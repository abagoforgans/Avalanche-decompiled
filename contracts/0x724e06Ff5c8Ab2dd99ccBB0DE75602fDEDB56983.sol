contract main {




// =====================  Runtime code  =====================


#
#  - sub_31d3fb12(?)
#  - sub_c8cd5990(?)
#  - sub_e996414b(?)
#
address owner;
mapping of uint8 stor1;
address WMATICAddress;
address sub_67491cb9Address;
address sub_5fdba4b7Address;
address feeReceiverAddress;
uint256 sub_fcb53d36;
mapping of uint8 stor7;
address CHI_ADDRESS;
uint256 sub_b38e50ee;
address sub_beaa26d7Address;
mapping of uint8 stor11;

function sub_40682152(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    return bool(stor1[arg1])
}

function WMATIC() payable {
    return WMATICAddress
}

function sub_5fdba4b7(?) payable {
    return sub_5fdba4b7Address
}

function sub_607dd6e4(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    return bool(stor11[arg1])
}

function sub_67491cb9(?) payable {
    return sub_67491cb9Address
}

function CHI_ADDRESS() payable {
    return CHI_ADDRESS
}

function owner() payable {
    return owner
}

function sub_b38e50ee(?) payable {
    return sub_b38e50ee
}

function feeReceiver() payable {
    return feeReceiverAddress
}

function sub_beaa26d7(?) payable {
    return sub_beaa26d7Address
}

function sub_fcb53d36(?) payable {
    return sub_fcb53d36
}

function _fallback() payable {
    revert
}

function renounceOwnership() payable {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    owner = 0
    emit OwnershipTransferred(owner, 0);
}

function setPrecision(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    sub_b38e50ee = arg1
}

function setWETH(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    WMATICAddress = arg1
}

function sub_9b2c0711(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    sub_beaa26d7Address = address(arg1)
}

function sub_36396a35(?) payable {
    require calldata.size - 4 >= 64
    require arg1 == address(arg1)
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    feeReceiverAddress = address(arg1)
    sub_fcb53d36 = arg2
}

function sub_5d7bab8f(?) payable {
    require calldata.size - 4 >= 64
    require arg1 == address(arg1)
    require arg2 == bool(arg2)
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    stor7[address(arg1)] = uint8(bool(arg2))
}

function sub_efc229fa(?) payable {
    require calldata.size - 4 >= 64
    require arg1 == address(arg1)
    require arg2 == bool(arg2)
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    stor11[address(arg1)] = uint8(bool(arg2))
}

function sub_4df3f50b(?) payable {
    require calldata.size - 4 >= 64
    require arg1 == address(arg1)
    require arg2 == address(arg2)
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    sub_67491cb9Address = address(arg1)
    sub_5fdba4b7Address = address(arg2)
}

function transferOwnership(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Ownable: new owner is the zero address'
    owner = arg1
    emit OwnershipTransferred(owner, arg1);
}

function balanceOf(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if not arg1:
        return eth.balance(this.address)
    require ext_code.size(arg1)
    staticcall arg1.0x70a08231 with:
            gas gas_remaining wei
           args this.address
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    return ext_call.return_data[0]
}

function sub_fd9ec6fe(?) payable {
    require calldata.size - 4 >= 64
    require cd[4] <= test266151307()
    require cd[4] + 35 < calldata.size
    require ('cd', 4).length <= test266151307()
    require cd[4] + (32 * ('cd', 4).length) + 36 <= calldata.size
    require cd[36] == bool(cd[36])
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    idx = 0
    while idx < ('cd', 4).length:
        require cd[((32 * idx) + cd[4] + 36)] == address(cd[((32 * idx) + cd[4] + 36)])
        mem[0] = address(cd[((32 * idx) + cd[4] + 36)])
        mem[32] = 11
        stor11[address(cd[((32 * idx) + cd[4] + 36)])] = uint8(bool(cd[36]))
        if idx == -1:
            revert with 'NH{q', 17
        idx = idx + 1
        continue 
}

function recover(address arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if stor1[address(arg1)]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    'TokenRecover#recover: Cannot recover tokens from the denylist'
    if not arg1:
        call owner with:
           value arg2 wei
             gas 2300 * is_zero(value) wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
    else:
        require ext_code.size(arg1)
        call arg1.0xa9059cbb with:
             gas gas_remaining wei
            args owner, arg2
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == bool(ext_call.return_data[0])
}

function elkCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require arg4.length >= 128
    require cd[(arg4 + 36)] == address(cd[(arg4 + 36)])
    require cd[(arg4 + 68)] <= test266151307()
    require arg4 + cd[(arg4 + 68)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 68)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 < 96 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(arg4 + cd[(arg4 + 68)] + 36)]
    require cd[(arg4 + 68)] + (32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 68)] + 68
    t = 128
    while idx < cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 100)] <= test266151307()
    require arg4 + cd[(arg4 + 100)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 100)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 < 97 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97] = cd[(arg4 + cd[(arg4 + 100)] + 36)]
    require cd[(arg4 + 100)] + (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 100)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129
    while idx < cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 132)] <= test266151307()
    require arg4 + cd[(arg4 + 132)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 132)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 < 98 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98] = cd[(arg4 + cd[(arg4 + 132)] + 36)]
    require cd[(arg4 + 132)] + (32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 132)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130
    while idx < cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 135] = _118
    require ext_code.size(address(cd[(arg4 + 36)]))
    call address(cd[(arg4 + 36)]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function apeCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require arg4.length >= 128
    require cd[(arg4 + 36)] == address(cd[(arg4 + 36)])
    require cd[(arg4 + 68)] <= test266151307()
    require arg4 + cd[(arg4 + 68)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 68)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 < 96 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(arg4 + cd[(arg4 + 68)] + 36)]
    require cd[(arg4 + 68)] + (32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 68)] + 68
    t = 128
    while idx < cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 100)] <= test266151307()
    require arg4 + cd[(arg4 + 100)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 100)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 < 97 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97] = cd[(arg4 + cd[(arg4 + 100)] + 36)]
    require cd[(arg4 + 100)] + (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 100)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129
    while idx < cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 132)] <= test266151307()
    require arg4 + cd[(arg4 + 132)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 132)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 < 98 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98] = cd[(arg4 + cd[(arg4 + 132)] + 36)]
    require cd[(arg4 + 132)] + (32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 132)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130
    while idx < cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 135] = _118
    require ext_code.size(address(cd[(arg4 + 36)]))
    call address(cd[(arg4 + 36)]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function joeCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require arg4.length >= 128
    require cd[(arg4 + 36)] == address(cd[(arg4 + 36)])
    require cd[(arg4 + 68)] <= test266151307()
    require arg4 + cd[(arg4 + 68)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 68)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 < 96 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(arg4 + cd[(arg4 + 68)] + 36)]
    require cd[(arg4 + 68)] + (32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 68)] + 68
    t = 128
    while idx < cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 100)] <= test266151307()
    require arg4 + cd[(arg4 + 100)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 100)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 < 97 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97] = cd[(arg4 + cd[(arg4 + 100)] + 36)]
    require cd[(arg4 + 100)] + (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 100)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129
    while idx < cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 132)] <= test266151307()
    require arg4 + cd[(arg4 + 132)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 132)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 < 98 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98] = cd[(arg4 + cd[(arg4 + 132)] + 36)]
    require cd[(arg4 + 132)] + (32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 132)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130
    while idx < cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 135] = _118
    require ext_code.size(address(cd[(arg4 + 36)]))
    call address(cd[(arg4 + 36)]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function PalmCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require arg4.length >= 128
    require cd[(arg4 + 36)] == address(cd[(arg4 + 36)])
    require cd[(arg4 + 68)] <= test266151307()
    require arg4 + cd[(arg4 + 68)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 68)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 < 96 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(arg4 + cd[(arg4 + 68)] + 36)]
    require cd[(arg4 + 68)] + (32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 68)] + 68
    t = 128
    while idx < cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 100)] <= test266151307()
    require arg4 + cd[(arg4 + 100)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 100)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 < 97 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97] = cd[(arg4 + cd[(arg4 + 100)] + 36)]
    require cd[(arg4 + 100)] + (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 100)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129
    while idx < cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 132)] <= test266151307()
    require arg4 + cd[(arg4 + 132)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 132)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 < 98 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98] = cd[(arg4 + cd[(arg4 + 132)] + 36)]
    require cd[(arg4 + 132)] + (32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 132)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130
    while idx < cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 135] = _118
    require ext_code.size(address(cd[(arg4 + 36)]))
    call address(cd[(arg4 + 36)]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function babyCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require arg4.length >= 128
    require cd[(arg4 + 36)] == address(cd[(arg4 + 36)])
    require cd[(arg4 + 68)] <= test266151307()
    require arg4 + cd[(arg4 + 68)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 68)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 < 96 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(arg4 + cd[(arg4 + 68)] + 36)]
    require cd[(arg4 + 68)] + (32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 68)] + 68
    t = 128
    while idx < cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 100)] <= test266151307()
    require arg4 + cd[(arg4 + 100)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 100)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 < 97 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97] = cd[(arg4 + cd[(arg4 + 100)] + 36)]
    require cd[(arg4 + 100)] + (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 100)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129
    while idx < cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 132)] <= test266151307()
    require arg4 + cd[(arg4 + 132)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 132)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 < 98 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98] = cd[(arg4 + cd[(arg4 + 132)] + 36)]
    require cd[(arg4 + 132)] + (32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 132)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130
    while idx < cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 135] = _118
    require ext_code.size(address(cd[(arg4 + 36)]))
    call address(cd[(arg4 + 36)]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function zeroCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require arg4.length >= 128
    require cd[(arg4 + 36)] == address(cd[(arg4 + 36)])
    require cd[(arg4 + 68)] <= test266151307()
    require arg4 + cd[(arg4 + 68)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 68)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 < 96 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(arg4 + cd[(arg4 + 68)] + 36)]
    require cd[(arg4 + 68)] + (32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 68)] + 68
    t = 128
    while idx < cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 100)] <= test266151307()
    require arg4 + cd[(arg4 + 100)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 100)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 < 97 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97] = cd[(arg4 + cd[(arg4 + 100)] + 36)]
    require cd[(arg4 + 100)] + (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 100)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129
    while idx < cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 132)] <= test266151307()
    require arg4 + cd[(arg4 + 132)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 132)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 < 98 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98] = cd[(arg4 + cd[(arg4 + 132)] + 36)]
    require cd[(arg4 + 132)] + (32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 132)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130
    while idx < cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 135] = _118
    require ext_code.size(address(cd[(arg4 + 36)]))
    call address(cd[(arg4 + 36)]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function bnEXCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require arg4.length >= 128
    require cd[(arg4 + 36)] == address(cd[(arg4 + 36)])
    require cd[(arg4 + 68)] <= test266151307()
    require arg4 + cd[(arg4 + 68)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 68)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 < 96 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(arg4 + cd[(arg4 + 68)] + 36)]
    require cd[(arg4 + 68)] + (32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 68)] + 68
    t = 128
    while idx < cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 100)] <= test266151307()
    require arg4 + cd[(arg4 + 100)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 100)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 < 97 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97] = cd[(arg4 + cd[(arg4 + 100)] + 36)]
    require cd[(arg4 + 100)] + (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 100)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129
    while idx < cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 132)] <= test266151307()
    require arg4 + cd[(arg4 + 132)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 132)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 < 98 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98] = cd[(arg4 + cd[(arg4 + 132)] + 36)]
    require cd[(arg4 + 132)] + (32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 132)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130
    while idx < cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 135] = _118
    require ext_code.size(address(cd[(arg4 + 36)]))
    call address(cd[(arg4 + 36)]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function cafeCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require arg4.length >= 128
    require cd[(arg4 + 36)] == address(cd[(arg4 + 36)])
    require cd[(arg4 + 68)] <= test266151307()
    require arg4 + cd[(arg4 + 68)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 68)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 < 96 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(arg4 + cd[(arg4 + 68)] + 36)]
    require cd[(arg4 + 68)] + (32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 68)] + 68
    t = 128
    while idx < cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 100)] <= test266151307()
    require arg4 + cd[(arg4 + 100)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 100)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 < 97 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97] = cd[(arg4 + cd[(arg4 + 100)] + 36)]
    require cd[(arg4 + 100)] + (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 100)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129
    while idx < cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 132)] <= test266151307()
    require arg4 + cd[(arg4 + 132)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 132)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 < 98 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98] = cd[(arg4 + cd[(arg4 + 132)] + 36)]
    require cd[(arg4 + 132)] + (32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 132)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130
    while idx < cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 135] = _118
    require ext_code.size(address(cd[(arg4 + 36)]))
    call address(cd[(arg4 + 36)]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function slimeCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require arg4.length >= 128
    require cd[(arg4 + 36)] == address(cd[(arg4 + 36)])
    require cd[(arg4 + 68)] <= test266151307()
    require arg4 + cd[(arg4 + 68)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 68)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 < 96 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(arg4 + cd[(arg4 + 68)] + 36)]
    require cd[(arg4 + 68)] + (32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 68)] + 68
    t = 128
    while idx < cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 100)] <= test266151307()
    require arg4 + cd[(arg4 + 100)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 100)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 < 97 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97] = cd[(arg4 + cd[(arg4 + 100)] + 36)]
    require cd[(arg4 + 100)] + (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 100)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129
    while idx < cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 132)] <= test266151307()
    require arg4 + cd[(arg4 + 132)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 132)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 < 98 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98] = cd[(arg4 + cd[(arg4 + 132)] + 36)]
    require cd[(arg4 + 132)] + (32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 132)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130
    while idx < cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 135] = _118
    require ext_code.size(address(cd[(arg4 + 36)]))
    call address(cd[(arg4 + 36)]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function oliveCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require arg4.length >= 128
    require cd[(arg4 + 36)] == address(cd[(arg4 + 36)])
    require cd[(arg4 + 68)] <= test266151307()
    require arg4 + cd[(arg4 + 68)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 68)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 < 96 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(arg4 + cd[(arg4 + 68)] + 36)]
    require cd[(arg4 + 68)] + (32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 68)] + 68
    t = 128
    while idx < cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 100)] <= test266151307()
    require arg4 + cd[(arg4 + 100)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 100)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 < 97 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97] = cd[(arg4 + cd[(arg4 + 100)] + 36)]
    require cd[(arg4 + 100)] + (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 100)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129
    while idx < cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 132)] <= test266151307()
    require arg4 + cd[(arg4 + 132)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 132)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 < 98 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98] = cd[(arg4 + cd[(arg4 + 132)] + 36)]
    require cd[(arg4 + 132)] + (32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 132)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130
    while idx < cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 135] = _118
    require ext_code.size(address(cd[(arg4 + 36)]))
    call address(cd[(arg4 + 36)]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function shibaCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require arg4.length >= 128
    require cd[(arg4 + 36)] == address(cd[(arg4 + 36)])
    require cd[(arg4 + 68)] <= test266151307()
    require arg4 + cd[(arg4 + 68)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 68)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 < 96 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(arg4 + cd[(arg4 + 68)] + 36)]
    require cd[(arg4 + 68)] + (32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 68)] + 68
    t = 128
    while idx < cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 100)] <= test266151307()
    require arg4 + cd[(arg4 + 100)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 100)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 < 97 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97] = cd[(arg4 + cd[(arg4 + 100)] + 36)]
    require cd[(arg4 + 100)] + (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 100)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129
    while idx < cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 132)] <= test266151307()
    require arg4 + cd[(arg4 + 132)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 132)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 < 98 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98] = cd[(arg4 + cd[(arg4 + 132)] + 36)]
    require cd[(arg4 + 132)] + (32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 132)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130
    while idx < cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 135] = _118
    require ext_code.size(address(cd[(arg4 + 36)]))
    call address(cd[(arg4 + 36)]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function lydiaCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require arg4.length >= 128
    require cd[(arg4 + 36)] == address(cd[(arg4 + 36)])
    require cd[(arg4 + 68)] <= test266151307()
    require arg4 + cd[(arg4 + 68)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 68)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 < 96 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(arg4 + cd[(arg4 + 68)] + 36)]
    require cd[(arg4 + 68)] + (32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 68)] + 68
    t = 128
    while idx < cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 100)] <= test266151307()
    require arg4 + cd[(arg4 + 100)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 100)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 < 97 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97] = cd[(arg4 + cd[(arg4 + 100)] + 36)]
    require cd[(arg4 + 100)] + (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 100)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129
    while idx < cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 132)] <= test266151307()
    require arg4 + cd[(arg4 + 132)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 132)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 < 98 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98] = cd[(arg4 + cd[(arg4 + 132)] + 36)]
    require cd[(arg4 + 132)] + (32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 132)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130
    while idx < cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 135] = _118
    require ext_code.size(address(cd[(arg4 + 36)]))
    call address(cd[(arg4 + 36)]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function canaryCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require arg4.length >= 128
    require cd[(arg4 + 36)] == address(cd[(arg4 + 36)])
    require cd[(arg4 + 68)] <= test266151307()
    require arg4 + cd[(arg4 + 68)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 68)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 < 96 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(arg4 + cd[(arg4 + 68)] + 36)]
    require cd[(arg4 + 68)] + (32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 68)] + 68
    t = 128
    while idx < cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 100)] <= test266151307()
    require arg4 + cd[(arg4 + 100)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 100)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 < 97 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97] = cd[(arg4 + cd[(arg4 + 100)] + 36)]
    require cd[(arg4 + 100)] + (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 100)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129
    while idx < cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 132)] <= test266151307()
    require arg4 + cd[(arg4 + 132)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 132)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 < 98 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98] = cd[(arg4 + cd[(arg4 + 132)] + 36)]
    require cd[(arg4 + 132)] + (32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 132)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130
    while idx < cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 135] = _118
    require ext_code.size(address(cd[(arg4 + 36)]))
    call address(cd[(arg4 + 36)]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function wardenCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require arg4.length >= 128
    require cd[(arg4 + 36)] == address(cd[(arg4 + 36)])
    require cd[(arg4 + 68)] <= test266151307()
    require arg4 + cd[(arg4 + 68)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 68)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 < 96 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(arg4 + cd[(arg4 + 68)] + 36)]
    require cd[(arg4 + 68)] + (32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 68)] + 68
    t = 128
    while idx < cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 100)] <= test266151307()
    require arg4 + cd[(arg4 + 100)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 100)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 < 97 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97] = cd[(arg4 + cd[(arg4 + 100)] + 36)]
    require cd[(arg4 + 100)] + (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 100)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129
    while idx < cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 132)] <= test266151307()
    require arg4 + cd[(arg4 + 132)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 132)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 < 98 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98] = cd[(arg4 + cd[(arg4 + 132)] + 36)]
    require cd[(arg4 + 132)] + (32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 132)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130
    while idx < cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 135] = _118
    require ext_code.size(address(cd[(arg4 + 36)]))
    call address(cd[(arg4 + 36)]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function BiswapCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require arg4.length >= 128
    require cd[(arg4 + 36)] == address(cd[(arg4 + 36)])
    require cd[(arg4 + 68)] <= test266151307()
    require arg4 + cd[(arg4 + 68)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 68)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 < 96 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(arg4 + cd[(arg4 + 68)] + 36)]
    require cd[(arg4 + 68)] + (32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 68)] + 68
    t = 128
    while idx < cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 100)] <= test266151307()
    require arg4 + cd[(arg4 + 100)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 100)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 < 97 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97] = cd[(arg4 + cd[(arg4 + 100)] + 36)]
    require cd[(arg4 + 100)] + (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 100)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129
    while idx < cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 132)] <= test266151307()
    require arg4 + cd[(arg4 + 132)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 132)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 < 98 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98] = cd[(arg4 + cd[(arg4 + 132)] + 36)]
    require cd[(arg4 + 132)] + (32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 132)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130
    while idx < cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 135] = _118
    require ext_code.size(address(cd[(arg4 + 36)]))
    call address(cd[(arg4 + 36)]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function swapV2Call(address arg1, uint256 arg2, uint256 arg3, bytes arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require arg4.length >= 128
    require cd[(arg4 + 36)] == address(cd[(arg4 + 36)])
    require cd[(arg4 + 68)] <= test266151307()
    require arg4 + cd[(arg4 + 68)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 68)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 < 96 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(arg4 + cd[(arg4 + 68)] + 36)]
    require cd[(arg4 + 68)] + (32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 68)] + 68
    t = 128
    while idx < cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 100)] <= test266151307()
    require arg4 + cd[(arg4 + 100)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 100)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 < 97 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97] = cd[(arg4 + cd[(arg4 + 100)] + 36)]
    require cd[(arg4 + 100)] + (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 100)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129
    while idx < cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 132)] <= test266151307()
    require arg4 + cd[(arg4 + 132)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 132)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 < 98 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98] = cd[(arg4 + cd[(arg4 + 132)] + 36)]
    require cd[(arg4 + 132)] + (32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 132)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130
    while idx < cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 135] = _118
    require ext_code.size(address(cd[(arg4 + 36)]))
    call address(cd[(arg4 + 36)]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function planetCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require arg4.length >= 128
    require cd[(arg4 + 36)] == address(cd[(arg4 + 36)])
    require cd[(arg4 + 68)] <= test266151307()
    require arg4 + cd[(arg4 + 68)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 68)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 < 96 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(arg4 + cd[(arg4 + 68)] + 36)]
    require cd[(arg4 + 68)] + (32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 68)] + 68
    t = 128
    while idx < cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 100)] <= test266151307()
    require arg4 + cd[(arg4 + 100)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 100)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 < 97 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97] = cd[(arg4 + cd[(arg4 + 100)] + 36)]
    require cd[(arg4 + 100)] + (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 100)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129
    while idx < cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 132)] <= test266151307()
    require arg4 + cd[(arg4 + 132)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 132)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 < 98 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98] = cd[(arg4 + cd[(arg4 + 132)] + 36)]
    require cd[(arg4 + 132)] + (32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 132)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130
    while idx < cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 135] = _118
    require ext_code.size(address(cd[(arg4 + 36)]))
    call address(cd[(arg4 + 36)]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function definixCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require arg4.length >= 128
    require cd[(arg4 + 36)] == address(cd[(arg4 + 36)])
    require cd[(arg4 + 68)] <= test266151307()
    require arg4 + cd[(arg4 + 68)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 68)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 < 96 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(arg4 + cd[(arg4 + 68)] + 36)]
    require cd[(arg4 + 68)] + (32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 68)] + 68
    t = 128
    while idx < cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 100)] <= test266151307()
    require arg4 + cd[(arg4 + 100)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 100)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 < 97 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97] = cd[(arg4 + cd[(arg4 + 100)] + 36)]
    require cd[(arg4 + 100)] + (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 100)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129
    while idx < cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 132)] <= test266151307()
    require arg4 + cd[(arg4 + 132)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 132)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 < 98 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98] = cd[(arg4 + cd[(arg4 + 132)] + 36)]
    require cd[(arg4 + 132)] + (32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 132)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130
    while idx < cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 135] = _118
    require ext_code.size(address(cd[(arg4 + 36)]))
    call address(cd[(arg4 + 36)]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function polyZapCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require arg4.length >= 128
    require cd[(arg4 + 36)] == address(cd[(arg4 + 36)])
    require cd[(arg4 + 68)] <= test266151307()
    require arg4 + cd[(arg4 + 68)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 68)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 < 96 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(arg4 + cd[(arg4 + 68)] + 36)]
    require cd[(arg4 + 68)] + (32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 68)] + 68
    t = 128
    while idx < cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 100)] <= test266151307()
    require arg4 + cd[(arg4 + 100)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 100)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 < 97 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97] = cd[(arg4 + cd[(arg4 + 100)] + 36)]
    require cd[(arg4 + 100)] + (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 100)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129
    while idx < cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 132)] <= test266151307()
    require arg4 + cd[(arg4 + 132)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 132)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 < 98 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98] = cd[(arg4 + cd[(arg4 + 132)] + 36)]
    require cd[(arg4 + 132)] + (32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 132)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130
    while idx < cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 135] = _118
    require ext_code.size(address(cd[(arg4 + 36)]))
    call address(cd[(arg4 + 36)]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function pantherCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require arg4.length >= 128
    require cd[(arg4 + 36)] == address(cd[(arg4 + 36)])
    require cd[(arg4 + 68)] <= test266151307()
    require arg4 + cd[(arg4 + 68)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 68)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 < 96 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(arg4 + cd[(arg4 + 68)] + 36)]
    require cd[(arg4 + 68)] + (32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 68)] + 68
    t = 128
    while idx < cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 100)] <= test266151307()
    require arg4 + cd[(arg4 + 100)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 100)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 < 97 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97] = cd[(arg4 + cd[(arg4 + 100)] + 36)]
    require cd[(arg4 + 100)] + (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 100)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129
    while idx < cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 132)] <= test266151307()
    require arg4 + cd[(arg4 + 132)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 132)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 < 98 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98] = cd[(arg4 + cd[(arg4 + 132)] + 36)]
    require cd[(arg4 + 132)] + (32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 132)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130
    while idx < cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 135] = _118
    require ext_code.size(address(cd[(arg4 + 36)]))
    call address(cd[(arg4 + 36)]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function polydexCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require arg4.length >= 128
    require cd[(arg4 + 36)] == address(cd[(arg4 + 36)])
    require cd[(arg4 + 68)] <= test266151307()
    require arg4 + cd[(arg4 + 68)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 68)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 < 96 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(arg4 + cd[(arg4 + 68)] + 36)]
    require cd[(arg4 + 68)] + (32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 68)] + 68
    t = 128
    while idx < cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 100)] <= test266151307()
    require arg4 + cd[(arg4 + 100)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 100)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 < 97 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97] = cd[(arg4 + cd[(arg4 + 100)] + 36)]
    require cd[(arg4 + 100)] + (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 100)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129
    while idx < cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 132)] <= test266151307()
    require arg4 + cd[(arg4 + 132)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 132)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 < 98 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98] = cd[(arg4 + cd[(arg4 + 132)] + 36)]
    require cd[(arg4 + 132)] + (32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 132)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130
    while idx < cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 135] = _118
    require ext_code.size(address(cd[(arg4 + 36)]))
    call address(cd[(arg4 + 36)]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function hswapV2Call(address arg1, uint256 arg2, uint256 arg3, bytes arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require arg4.length >= 128
    require cd[(arg4 + 36)] == address(cd[(arg4 + 36)])
    require cd[(arg4 + 68)] <= test266151307()
    require arg4 + cd[(arg4 + 68)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 68)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 < 96 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(arg4 + cd[(arg4 + 68)] + 36)]
    require cd[(arg4 + 68)] + (32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 68)] + 68
    t = 128
    while idx < cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 100)] <= test266151307()
    require arg4 + cd[(arg4 + 100)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 100)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 < 97 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97] = cd[(arg4 + cd[(arg4 + 100)] + 36)]
    require cd[(arg4 + 100)] + (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 100)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129
    while idx < cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 132)] <= test266151307()
    require arg4 + cd[(arg4 + 132)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 132)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 < 98 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98] = cd[(arg4 + cd[(arg4 + 132)] + 36)]
    require cd[(arg4 + 132)] + (32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 132)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130
    while idx < cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 135] = _118
    require ext_code.size(address(cd[(arg4 + 36)]))
    call address(cd[(arg4 + 36)]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function jetswapCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require arg4.length >= 128
    require cd[(arg4 + 36)] == address(cd[(arg4 + 36)])
    require cd[(arg4 + 68)] <= test266151307()
    require arg4 + cd[(arg4 + 68)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 68)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 < 96 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(arg4 + cd[(arg4 + 68)] + 36)]
    require cd[(arg4 + 68)] + (32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 68)] + 68
    t = 128
    while idx < cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 100)] <= test266151307()
    require arg4 + cd[(arg4 + 100)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 100)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 < 97 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97] = cd[(arg4 + cd[(arg4 + 100)] + 36)]
    require cd[(arg4 + 100)] + (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 100)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129
    while idx < cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 132)] <= test266151307()
    require arg4 + cd[(arg4 + 132)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 132)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 < 98 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98] = cd[(arg4 + cd[(arg4 + 132)] + 36)]
    require cd[(arg4 + 132)] + (32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 132)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130
    while idx < cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 135] = _118
    require ext_code.size(address(cd[(arg4 + 36)]))
    call address(cd[(arg4 + 36)]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function stableXCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require arg4.length >= 128
    require cd[(arg4 + 36)] == address(cd[(arg4 + 36)])
    require cd[(arg4 + 68)] <= test266151307()
    require arg4 + cd[(arg4 + 68)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 68)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 < 96 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(arg4 + cd[(arg4 + 68)] + 36)]
    require cd[(arg4 + 68)] + (32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 68)] + 68
    t = 128
    while idx < cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 100)] <= test266151307()
    require arg4 + cd[(arg4 + 100)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 100)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 < 97 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97] = cd[(arg4 + cd[(arg4 + 100)] + 36)]
    require cd[(arg4 + 100)] + (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 100)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129
    while idx < cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 132)] <= test266151307()
    require arg4 + cd[(arg4 + 132)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 132)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 < 98 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98] = cd[(arg4 + cd[(arg4 + 132)] + 36)]
    require cd[(arg4 + 132)] + (32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 132)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130
    while idx < cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 135] = _118
    require ext_code.size(address(cd[(arg4 + 36)]))
    call address(cd[(arg4 + 36)]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function BSCswapCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require arg4.length >= 128
    require cd[(arg4 + 36)] == address(cd[(arg4 + 36)])
    require cd[(arg4 + 68)] <= test266151307()
    require arg4 + cd[(arg4 + 68)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 68)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 < 96 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(arg4 + cd[(arg4 + 68)] + 36)]
    require cd[(arg4 + 68)] + (32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 68)] + 68
    t = 128
    while idx < cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 100)] <= test266151307()
    require arg4 + cd[(arg4 + 100)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 100)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 < 97 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97] = cd[(arg4 + cd[(arg4 + 100)] + 36)]
    require cd[(arg4 + 100)] + (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 100)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129
    while idx < cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 132)] <= test266151307()
    require arg4 + cd[(arg4 + 132)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 132)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 < 98 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98] = cd[(arg4 + cd[(arg4 + 132)] + 36)]
    require cd[(arg4 + 132)] + (32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 132)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130
    while idx < cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 135] = _118
    require ext_code.size(address(cd[(arg4 + 36)]))
    call address(cd[(arg4 + 36)]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function pancakeCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require arg4.length >= 128
    require cd[(arg4 + 36)] == address(cd[(arg4 + 36)])
    require cd[(arg4 + 68)] <= test266151307()
    require arg4 + cd[(arg4 + 68)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 68)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 < 96 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(arg4 + cd[(arg4 + 68)] + 36)]
    require cd[(arg4 + 68)] + (32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 68)] + 68
    t = 128
    while idx < cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 100)] <= test266151307()
    require arg4 + cd[(arg4 + 100)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 100)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 < 97 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97] = cd[(arg4 + cd[(arg4 + 100)] + 36)]
    require cd[(arg4 + 100)] + (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 100)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129
    while idx < cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 132)] <= test266151307()
    require arg4 + cd[(arg4 + 132)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 132)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 < 98 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98] = cd[(arg4 + cd[(arg4 + 132)] + 36)]
    require cd[(arg4 + 132)] + (32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 132)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130
    while idx < cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 135] = _118
    require ext_code.size(address(cd[(arg4 + 36)]))
    call address(cd[(arg4 + 36)]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function wakaSwapCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require arg4.length >= 128
    require cd[(arg4 + 36)] == address(cd[(arg4 + 36)])
    require cd[(arg4 + 68)] <= test266151307()
    require arg4 + cd[(arg4 + 68)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 68)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 < 96 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(arg4 + cd[(arg4 + 68)] + 36)]
    require cd[(arg4 + 68)] + (32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 68)] + 68
    t = 128
    while idx < cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 100)] <= test266151307()
    require arg4 + cd[(arg4 + 100)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 100)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 < 97 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97] = cd[(arg4 + cd[(arg4 + 100)] + 36)]
    require cd[(arg4 + 100)] + (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 100)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129
    while idx < cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 132)] <= test266151307()
    require arg4 + cd[(arg4 + 132)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 132)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 < 98 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98] = cd[(arg4 + cd[(arg4 + 132)] + 36)]
    require cd[(arg4 + 132)] + (32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 132)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130
    while idx < cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 135] = _118
    require ext_code.size(address(cd[(arg4 + 36)]))
    call address(cd[(arg4 + 36)]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function ballSwapCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require arg4.length >= 128
    require cd[(arg4 + 36)] == address(cd[(arg4 + 36)])
    require cd[(arg4 + 68)] <= test266151307()
    require arg4 + cd[(arg4 + 68)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 68)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 < 96 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(arg4 + cd[(arg4 + 68)] + 36)]
    require cd[(arg4 + 68)] + (32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 68)] + 68
    t = 128
    while idx < cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 100)] <= test266151307()
    require arg4 + cd[(arg4 + 100)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 100)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 < 97 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97] = cd[(arg4 + cd[(arg4 + 100)] + 36)]
    require cd[(arg4 + 100)] + (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 100)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129
    while idx < cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 132)] <= test266151307()
    require arg4 + cd[(arg4 + 132)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 132)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 < 98 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98] = cd[(arg4 + cd[(arg4 + 132)] + 36)]
    require cd[(arg4 + 132)] + (32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 132)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130
    while idx < cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 135] = _118
    require ext_code.size(address(cd[(arg4 + 36)]))
    call address(cd[(arg4 + 36)]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function infinityCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require arg4.length >= 128
    require cd[(arg4 + 36)] == address(cd[(arg4 + 36)])
    require cd[(arg4 + 68)] <= test266151307()
    require arg4 + cd[(arg4 + 68)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 68)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 < 96 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(arg4 + cd[(arg4 + 68)] + 36)]
    require cd[(arg4 + 68)] + (32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 68)] + 68
    t = 128
    while idx < cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 100)] <= test266151307()
    require arg4 + cd[(arg4 + 100)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 100)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 < 97 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97] = cd[(arg4 + cd[(arg4 + 100)] + 36)]
    require cd[(arg4 + 100)] + (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 100)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129
    while idx < cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 132)] <= test266151307()
    require arg4 + cd[(arg4 + 132)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 132)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 < 98 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98] = cd[(arg4 + cd[(arg4 + 132)] + 36)]
    require cd[(arg4 + 132)] + (32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 132)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130
    while idx < cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 135] = _118
    require ext_code.size(address(cd[(arg4 + 36)]))
    call address(cd[(arg4 + 36)]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function pinkswapCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require arg4.length >= 128
    require cd[(arg4 + 36)] == address(cd[(arg4 + 36)])
    require cd[(arg4 + 68)] <= test266151307()
    require arg4 + cd[(arg4 + 68)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 68)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 < 96 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(arg4 + cd[(arg4 + 68)] + 36)]
    require cd[(arg4 + 68)] + (32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 68)] + 68
    t = 128
    while idx < cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 100)] <= test266151307()
    require arg4 + cd[(arg4 + 100)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 100)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 < 97 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97] = cd[(arg4 + cd[(arg4 + 100)] + 36)]
    require cd[(arg4 + 100)] + (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 100)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129
    while idx < cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 132)] <= test266151307()
    require arg4 + cd[(arg4 + 132)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 132)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 < 98 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98] = cd[(arg4 + cd[(arg4 + 132)] + 36)]
    require cd[(arg4 + 132)] + (32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 132)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130
    while idx < cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 135] = _118
    require ext_code.size(address(cd[(arg4 + 36)]))
    call address(cd[(arg4 + 36)]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function coinswapCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require arg4.length >= 128
    require cd[(arg4 + 36)] == address(cd[(arg4 + 36)])
    require cd[(arg4 + 68)] <= test266151307()
    require arg4 + cd[(arg4 + 68)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 68)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 < 96 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(arg4 + cd[(arg4 + 68)] + 36)]
    require cd[(arg4 + 68)] + (32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 68)] + 68
    t = 128
    while idx < cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 100)] <= test266151307()
    require arg4 + cd[(arg4 + 100)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 100)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 < 97 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97] = cd[(arg4 + cd[(arg4 + 100)] + 36)]
    require cd[(arg4 + 100)] + (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 100)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129
    while idx < cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 132)] <= test266151307()
    require arg4 + cd[(arg4 + 132)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 132)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 < 98 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98] = cd[(arg4 + cd[(arg4 + 132)] + 36)]
    require cd[(arg4 + 132)] + (32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 132)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130
    while idx < cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 135] = _118
    require ext_code.size(address(cd[(arg4 + 36)]))
    call address(cd[(arg4 + 36)]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function baguetteCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require arg4.length >= 128
    require cd[(arg4 + 36)] == address(cd[(arg4 + 36)])
    require cd[(arg4 + 68)] <= test266151307()
    require arg4 + cd[(arg4 + 68)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 68)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 < 96 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(arg4 + cd[(arg4 + 68)] + 36)]
    require cd[(arg4 + 68)] + (32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 68)] + 68
    t = 128
    while idx < cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 100)] <= test266151307()
    require arg4 + cd[(arg4 + 100)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 100)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 < 97 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97] = cd[(arg4 + cd[(arg4 + 100)] + 36)]
    require cd[(arg4 + 100)] + (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 100)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129
    while idx < cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 132)] <= test266151307()
    require arg4 + cd[(arg4 + 132)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 132)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 < 98 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98] = cd[(arg4 + cd[(arg4 + 132)] + 36)]
    require cd[(arg4 + 132)] + (32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 132)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130
    while idx < cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 135] = _118
    require ext_code.size(address(cd[(arg4 + 36)]))
    call address(cd[(arg4 + 36)]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function ThugswapCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require arg4.length >= 128
    require cd[(arg4 + 36)] == address(cd[(arg4 + 36)])
    require cd[(arg4 + 68)] <= test266151307()
    require arg4 + cd[(arg4 + 68)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 68)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 < 96 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(arg4 + cd[(arg4 + 68)] + 36)]
    require cd[(arg4 + 68)] + (32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 68)] + 68
    t = 128
    while idx < cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 100)] <= test266151307()
    require arg4 + cd[(arg4 + 100)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 100)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 < 97 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97] = cd[(arg4 + cd[(arg4 + 100)] + 36)]
    require cd[(arg4 + 100)] + (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 100)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129
    while idx < cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 132)] <= test266151307()
    require arg4 + cd[(arg4 + 132)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 132)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 < 98 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98] = cd[(arg4 + cd[(arg4 + 132)] + 36)]
    require cd[(arg4 + 132)] + (32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 132)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130
    while idx < cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 135] = _118
    require ext_code.size(address(cd[(arg4 + 36)]))
    call address(cd[(arg4 + 36)]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function yetiswapCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require arg4.length >= 128
    require cd[(arg4 + 36)] == address(cd[(arg4 + 36)])
    require cd[(arg4 + 68)] <= test266151307()
    require arg4 + cd[(arg4 + 68)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 68)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 < 96 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(arg4 + cd[(arg4 + 68)] + 36)]
    require cd[(arg4 + 68)] + (32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 68)] + 68
    t = 128
    while idx < cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 100)] <= test266151307()
    require arg4 + cd[(arg4 + 100)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 100)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 < 97 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97] = cd[(arg4 + cd[(arg4 + 100)] + 36)]
    require cd[(arg4 + 100)] + (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 100)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129
    while idx < cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 132)] <= test266151307()
    require arg4 + cd[(arg4 + 132)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 132)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 < 98 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98] = cd[(arg4 + cd[(arg4 + 132)] + 36)]
    require cd[(arg4 + 132)] + (32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 132)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130
    while idx < cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 135] = _118
    require ext_code.size(address(cd[(arg4 + 36)]))
    call address(cd[(arg4 + 36)]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function pangolinCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require arg4.length >= 128
    require cd[(arg4 + 36)] == address(cd[(arg4 + 36)])
    require cd[(arg4 + 68)] <= test266151307()
    require arg4 + cd[(arg4 + 68)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 68)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 < 96 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(arg4 + cd[(arg4 + 68)] + 36)]
    require cd[(arg4 + 68)] + (32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 68)] + 68
    t = 128
    while idx < cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 100)] <= test266151307()
    require arg4 + cd[(arg4 + 100)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 100)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 < 97 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97] = cd[(arg4 + cd[(arg4 + 100)] + 36)]
    require cd[(arg4 + 100)] + (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 100)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129
    while idx < cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 132)] <= test266151307()
    require arg4 + cd[(arg4 + 132)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 132)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 < 98 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98] = cd[(arg4 + cd[(arg4 + 132)] + 36)]
    require cd[(arg4 + 132)] + (32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 132)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130
    while idx < cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 135] = _118
    require ext_code.size(address(cd[(arg4 + 36)]))
    call address(cd[(arg4 + 36)]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function uniswapV2Call(address arg1, uint256 arg2, uint256 arg3, bytes arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require arg4.length >= 128
    require cd[(arg4 + 36)] == address(cd[(arg4 + 36)])
    require cd[(arg4 + 68)] <= test266151307()
    require arg4 + cd[(arg4 + 68)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 68)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 < 96 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(arg4 + cd[(arg4 + 68)] + 36)]
    require cd[(arg4 + 68)] + (32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 68)] + 68
    t = 128
    while idx < cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 100)] <= test266151307()
    require arg4 + cd[(arg4 + 100)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 100)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 < 97 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97] = cd[(arg4 + cd[(arg4 + 100)] + 36)]
    require cd[(arg4 + 100)] + (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 100)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129
    while idx < cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 132)] <= test266151307()
    require arg4 + cd[(arg4 + 132)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 132)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 < 98 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98] = cd[(arg4 + cd[(arg4 + 132)] + 36)]
    require cd[(arg4 + 132)] + (32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 132)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130
    while idx < cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 135] = _118
    require ext_code.size(address(cd[(arg4 + 36)]))
    call address(cd[(arg4 + 36)]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function complusV2Call(address arg1, uint256 arg2, uint256 arg3, bytes arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require arg4.length >= 128
    require cd[(arg4 + 36)] == address(cd[(arg4 + 36)])
    require cd[(arg4 + 68)] <= test266151307()
    require arg4 + cd[(arg4 + 68)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 68)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 < 96 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(arg4 + cd[(arg4 + 68)] + 36)]
    require cd[(arg4 + 68)] + (32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 68)] + 68
    t = 128
    while idx < cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 100)] <= test266151307()
    require arg4 + cd[(arg4 + 100)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 100)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 < 97 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97] = cd[(arg4 + cd[(arg4 + 100)] + 36)]
    require cd[(arg4 + 100)] + (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 100)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129
    while idx < cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 132)] <= test266151307()
    require arg4 + cd[(arg4 + 132)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 132)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 < 98 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98] = cd[(arg4 + cd[(arg4 + 132)] + 36)]
    require cd[(arg4 + 132)] + (32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 132)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130
    while idx < cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 135] = _118
    require ext_code.size(address(cd[(arg4 + 36)]))
    call address(cd[(arg4 + 36)]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function waultSwapCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require arg4.length >= 128
    require cd[(arg4 + 36)] == address(cd[(arg4 + 36)])
    require cd[(arg4 + 68)] <= test266151307()
    require arg4 + cd[(arg4 + 68)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 68)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 < 96 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(arg4 + cd[(arg4 + 68)] + 36)]
    require cd[(arg4 + 68)] + (32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 68)] + 68
    t = 128
    while idx < cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 100)] <= test266151307()
    require arg4 + cd[(arg4 + 100)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 100)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 < 97 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97] = cd[(arg4 + cd[(arg4 + 100)] + 36)]
    require cd[(arg4 + 100)] + (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 100)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129
    while idx < cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 132)] <= test266151307()
    require arg4 + cd[(arg4 + 132)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 132)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 < 98 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98] = cd[(arg4 + cd[(arg4 + 132)] + 36)]
    require cd[(arg4 + 132)] + (32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 132)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130
    while idx < cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 135] = _118
    require ext_code.size(address(cd[(arg4 + 36)]))
    call address(cd[(arg4 + 36)]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function cheeseswapCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require arg4.length >= 128
    require cd[(arg4 + 36)] == address(cd[(arg4 + 36)])
    require cd[(arg4 + 68)] <= test266151307()
    require arg4 + cd[(arg4 + 68)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 68)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 < 96 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(arg4 + cd[(arg4 + 68)] + 36)]
    require cd[(arg4 + 68)] + (32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 68)] + 68
    t = 128
    while idx < cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 100)] <= test266151307()
    require arg4 + cd[(arg4 + 100)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 100)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 < 97 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97] = cd[(arg4 + cd[(arg4 + 100)] + 36)]
    require cd[(arg4 + 100)] + (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 100)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129
    while idx < cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 132)] <= test266151307()
    require arg4 + cd[(arg4 + 132)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 132)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 < 98 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98] = cd[(arg4 + cd[(arg4 + 132)] + 36)]
    require cd[(arg4 + 132)] + (32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 132)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130
    while idx < cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 135] = _118
    require ext_code.size(address(cd[(arg4 + 36)]))
    call address(cd[(arg4 + 36)]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function thunderSwapCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require arg4.length >= 128
    require cd[(arg4 + 36)] == address(cd[(arg4 + 36)])
    require cd[(arg4 + 68)] <= test266151307()
    require arg4 + cd[(arg4 + 68)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 68)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 < 96 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(arg4 + cd[(arg4 + 68)] + 36)]
    require cd[(arg4 + 68)] + (32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 68)] + 68
    t = 128
    while idx < cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 100)] <= test266151307()
    require arg4 + cd[(arg4 + 100)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 100)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 < 97 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97] = cd[(arg4 + cd[(arg4 + 100)] + 36)]
    require cd[(arg4 + 100)] + (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 100)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129
    while idx < cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 132)] <= test266151307()
    require arg4 + cd[(arg4 + 132)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 132)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 < 98 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98] = cd[(arg4 + cd[(arg4 + 132)] + 36)]
    require cd[(arg4 + 132)] + (32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 132)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130
    while idx < cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 135] = _118
    require ext_code.size(address(cd[(arg4 + 36)]))
    call address(cd[(arg4 + 36)]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function executeOperation(address arg1, uint256 arg2, uint256 arg3, bytes arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require arg4.length >= 128
    require cd[(arg4 + 36)] == address(cd[(arg4 + 36)])
    require cd[(arg4 + 68)] <= test266151307()
    require arg4 + cd[(arg4 + 68)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 68)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 < 96 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(arg4 + cd[(arg4 + 68)] + 36)]
    require cd[(arg4 + 68)] + (32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 68)] + 68
    t = 128
    while idx < cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 100)] <= test266151307()
    require arg4 + cd[(arg4 + 100)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 100)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 < 97 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97] = cd[(arg4 + cd[(arg4 + 100)] + 36)]
    require cd[(arg4 + 100)] + (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 100)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129
    while idx < cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 132)] <= test266151307()
    require arg4 + cd[(arg4 + 132)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 132)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 < 98 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98] = cd[(arg4 + cd[(arg4 + 132)] + 36)]
    require cd[(arg4 + 132)] + (32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 132)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130
    while idx < cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 135] = _118
    require ext_code.size(address(cd[(arg4 + 36)]))
    call address(cd[(arg4 + 36)]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_00d79885(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_042fb303(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_07833161(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_0a2d89cc(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_0cdf2eba(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_0e7c2d0e(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_10277583(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_1234e33d(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_13b977c1(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_14283669(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_1750699e(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_1a7f26cb(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_1b4dd2e9(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_1b9092b6(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_1c9f2b97(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_21aa670e(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_224adeb0(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_28cf0af5(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_29764754(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_29a9cf88(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_2d17cf05(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_2ec377e1(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_3026cc62(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_32c8680d(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_32f58371(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_3332bfd4(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_366c631d(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_39815037(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_3aa99232(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_3b1365d8(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_3cc9c6b4(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_3e606615(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_40c77747(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_40f19666(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_42b7240d(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_434d25ce(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_437f1ee4(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_44ddf7b1(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_45006522(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_477231ec(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_48639c9d(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_48c5b27e(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_4afa36ff(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_4c53de6e(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_4f4f2d9e(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_500a7449(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_5461e50a(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_54a6d612(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_5bb2ec07(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_5c0704f1(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_5c629f0f(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_5d6efb3a(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_5d792f1d(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_5d7d72db(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_5f4aa5a1(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_5fa45711(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_613c8e8d(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_61987d16(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_6615ae54(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_6658695a(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_68af5cd7(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_69823244(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_6b041fb2(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_6dca4cd4(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_709caa1e(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_783a23b3(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_78b94ae6(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_79af2fe8(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_7b4c0fc2(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_7b4c893e(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_801d49f8(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_806693a3(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_813029ee(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_8649b473(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_8652f2d5(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_87c26197(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_883ff740(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_8955316a(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_89d4e2f4(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_8c87d9b1(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_8d07fe0d(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_8d944b67(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_9182f77e(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_934eab2a(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_964fd153(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_966011ef(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_97af7734(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_97e49a26(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_9955d5b1(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_9b6dda6e(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_9bdb3b48(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_9d8811ae(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_9e4a159b(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_9fd6c0f6(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_a3c74e3b(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_a5716077(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_a5cc261d(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_a8ed3ae8(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_aa7f3901(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_ace1c26f(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_ae457fcd(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_b0552da0(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_b063200c(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_b7c1e2f3(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_b9103bf3(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_bae7418b(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_bb7cb3e9(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_bb872fac(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_c0b6d79f(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_c0dfa316(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_c0fc3ce6(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_c3be5772(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_ca1d2ce0(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_ca5623b9(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_cdc84872(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_cdcaf6a0(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_ce093dbc(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_ce6ff890(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_cf90dbbe(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_d053452f(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_d0b0466f(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_d400ab37(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_d6a665c3(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_d8366103(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_d9f7cd9e(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_db0aae9b(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_dbf4a368(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_defdf6ec(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_dfccb541(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_e20dbb6e(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_e3b4a0e3(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_e48ee111(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_e4d3ae86(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_eab1e72a(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_ed6c22ec(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_f05ffd30(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_f0cc0646(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_f17194aa(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_f27065b9(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_f50dd813(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_f760d0b8(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_f83eb0bb(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_f9265a4f(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_fc4d9749(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_fd5cc49d(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_fdb610cd(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_ffcd3013(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor11[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).0xa9059cbb with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_4523a995(?) payable {
    require calldata.size - 4 >= 32
    require cd[4] <= test266151307()
    require cd[4] + 35 < calldata.size
    require ('cd', 4).length <= test266151307()
    require cd[4] + (32 * ('cd', 4).length) + 36 <= calldata.size
    if ('cd', 4).length > test266151307():
        revert with 'NH{q', 65
    mem[96] = ('cd', 4).length
    if not ('cd', 4).length:
        if ('cd', 4).length > test266151307():
            revert with 'NH{q', 65
        mem[(32 * ('cd', 4).length) + 128] = ('cd', 4).length
        if not ('cd', 4).length:
            if ('cd', 4).length > test266151307():
                revert with 'NH{q', 65
            mem[(64 * ('cd', 4).length) + 160] = ('cd', 4).length
            mem[64] = (98 * ('cd', 4).length) + 192
            if not ('cd', 4).length:
                if 0 >= ('cd', 4).length:
                    revert with 'NH{q', 50
                idx = 0
                while idx < ('cd', 4).length:
                    if idx >= mem[96]:
                        revert with 'NH{q', 50
                    mem[(32 * idx) + 128] = address(cd[((32 * idx) + cd[4] + 36)])
                    if idx >= ('cd', 4).length:
                        revert with 'NH{q', 50
                    if idx >= mem[(32 * ('cd', 4).length) + 128]:
                        revert with 'NH{q', 50
                    mem[(32 * idx) + (32 * ('cd', 4).length) + 160] = 0
                    if idx >= ('cd', 4).length:
                        revert with 'NH{q', 50
                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                        revert with 'NH{q', 50
                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                mem[mem[64]] = 128
                _48 = mem[96]
                mem[mem[64] + 128] = mem[96]
                idx = 0
                s = 128
                t = mem[64] + 160
                while idx < _48:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[mem[64] + 32] = (32 * _48) + 160
                _128 = mem[(32 * ('cd', 4).length) + 128]
                mem[mem[64] + (32 * _48) + 160] = mem[(32 * ('cd', 4).length) + 128]
                mem[mem[64] + (32 * _48) + 192 len 32 * _128] = mem[(32 * ('cd', 4).length) + 160 len 32 * _128]
                mem[mem[64] + 64] = (32 * _48) + (32 * _128) + 192
                _176 = mem[(64 * ('cd', 4).length) + 160]
                mem[mem[64] + (32 * _48) + (32 * _128) + 192] = mem[(64 * ('cd', 4).length) + 160]
                mem[mem[64] + (32 * _48) + (32 * _128) + 224 len 32 * _176] = mem[(64 * ('cd', 4).length) + 192 len 32 * _176]
                mem[mem[64] + 96] = 1
                return 128, 
                       (32 * _48) + 160,
                       (32 * _48) + (32 * _128) + 192,
                       1,
                       mem[mem[64] + 128 len (32 * _48) + (32 * _128) + (32 * _176) + 96]
            mem[(64 * ('cd', 4).length) + 192 len 32 * ('cd', 4).length] = call.data[calldata.size len 32 * ('cd', 4).length]
            if 0 >= ('cd', 4).length:
                revert with 'NH{q', 50
            idx = 0
            while idx < ('cd', 4).length:
                if idx >= mem[96]:
                    revert with 'NH{q', 50
                mem[(32 * idx) + 128] = address(cd[((32 * idx) + cd[4] + 36)])
                if idx >= ('cd', 4).length:
                    revert with 'NH{q', 50
                if idx >= mem[(32 * ('cd', 4).length) + 128]:
                    revert with 'NH{q', 50
                mem[(32 * idx) + (32 * ('cd', 4).length) + 160] = 0
                if idx >= ('cd', 4).length:
                    revert with 'NH{q', 50
                if idx >= mem[(64 * ('cd', 4).length) + 160]:
                    revert with 'NH{q', 50
                mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0
                if idx == -1:
                    revert with 'NH{q', 17
                idx = idx + 1
                continue 
            mem[mem[64]] = 128
            _50 = mem[96]
            mem[mem[64] + 128] = mem[96]
            idx = 0
            s = 128
            t = mem[64] + 160
            while idx < _50:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[mem[64] + 32] = (32 * _50) + 160
            _129 = mem[(32 * ('cd', 4).length) + 128]
            mem[mem[64] + (32 * _50) + 160] = mem[(32 * ('cd', 4).length) + 128]
            mem[mem[64] + (32 * _50) + 192 len 32 * _129] = mem[(32 * ('cd', 4).length) + 160 len 32 * _129]
            mem[mem[64] + 64] = (32 * _50) + (32 * _129) + 192
            _177 = mem[(64 * ('cd', 4).length) + 160]
            mem[mem[64] + (32 * _50) + (32 * _129) + 192] = mem[(64 * ('cd', 4).length) + 160]
            mem[mem[64] + (32 * _50) + (32 * _129) + 224 len 32 * _177] = mem[(64 * ('cd', 4).length) + 192 len 32 * _177]
            mem[mem[64] + 96] = 1
            return 128, 
                   (32 * _50) + 160,
                   (32 * _50) + (32 * _129) + 192,
                   1,
                   mem[mem[64] + 128 len (32 * _50) + (32 * _129) + (32 * _177) + 96]
        mem[(32 * ('cd', 4).length) + 160 len 32 * ('cd', 4).length] = call.data[calldata.size len 32 * ('cd', 4).length]
        if ('cd', 4).length > test266151307():
            revert with 'NH{q', 65
        mem[(64 * ('cd', 4).length) + 160] = ('cd', 4).length
        mem[64] = (98 * ('cd', 4).length) + 192
        if not ('cd', 4).length:
            if 0 >= ('cd', 4).length:
                revert with 'NH{q', 50
            idx = 0
            while idx < ('cd', 4).length:
                if idx >= mem[96]:
                    revert with 'NH{q', 50
                mem[(32 * idx) + 128] = address(cd[((32 * idx) + cd[4] + 36)])
                if idx >= ('cd', 4).length:
                    revert with 'NH{q', 50
                if idx >= mem[(32 * ('cd', 4).length) + 128]:
                    revert with 'NH{q', 50
                mem[(32 * idx) + (32 * ('cd', 4).length) + 160] = 0
                if idx >= ('cd', 4).length:
                    revert with 'NH{q', 50
                if idx >= mem[(64 * ('cd', 4).length) + 160]:
                    revert with 'NH{q', 50
                mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0
                if idx == -1:
                    revert with 'NH{q', 17
                idx = idx + 1
                continue 
            mem[mem[64]] = 128
            _52 = mem[96]
            mem[mem[64] + 128] = mem[96]
            idx = 0
            s = 128
            t = mem[64] + 160
            while idx < _52:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[mem[64] + 32] = (32 * _52) + 160
            _130 = mem[(32 * ('cd', 4).length) + 128]
            mem[mem[64] + (32 * _52) + 160] = mem[(32 * ('cd', 4).length) + 128]
            mem[mem[64] + (32 * _52) + 192 len 32 * _130] = mem[(32 * ('cd', 4).length) + 160 len 32 * _130]
            mem[mem[64] + 64] = (32 * _52) + (32 * _130) + 192
            _178 = mem[(64 * ('cd', 4).length) + 160]
            mem[mem[64] + (32 * _52) + (32 * _130) + 192] = mem[(64 * ('cd', 4).length) + 160]
            mem[mem[64] + (32 * _52) + (32 * _130) + 224 len 32 * _178] = mem[(64 * ('cd', 4).length) + 192 len 32 * _178]
            mem[mem[64] + 96] = 1
            return 128, 
                   (32 * _52) + 160,
                   (32 * _52) + (32 * _130) + 192,
                   1,
                   mem[mem[64] + 128 len (32 * _52) + (32 * _130) + (32 * _178) + 96]
        mem[(64 * ('cd', 4).length) + 192 len 32 * ('cd', 4).length] = call.data[calldata.size len 32 * ('cd', 4).length]
        if 0 >= ('cd', 4).length:
            revert with 'NH{q', 50
        idx = 0
        while idx < ('cd', 4).length:
            if idx >= mem[96]:
                revert with 'NH{q', 50
            mem[(32 * idx) + 128] = address(cd[((32 * idx) + cd[4] + 36)])
            if idx >= ('cd', 4).length:
                revert with 'NH{q', 50
            if idx >= mem[(32 * ('cd', 4).length) + 128]:
                revert with 'NH{q', 50
            mem[(32 * idx) + (32 * ('cd', 4).length) + 160] = 0
            if idx >= ('cd', 4).length:
                revert with 'NH{q', 50
            if idx >= mem[(64 * ('cd', 4).length) + 160]:
                revert with 'NH{q', 50
            mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0
            if idx == -1:
                revert with 'NH{q', 17
            idx = idx + 1
            continue 
        mem[mem[64]] = 128
        _54 = mem[96]
        mem[mem[64] + 128] = mem[96]
        idx = 0
        s = 128
        t = mem[64] + 160
        while idx < _54:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        mem[mem[64] + 32] = (32 * _54) + 160
        _131 = mem[(32 * ('cd', 4).length) + 128]
        mem[mem[64] + (32 * _54) + 160] = mem[(32 * ('cd', 4).length) + 128]
        mem[mem[64] + (32 * _54) + 192 len 32 * _131] = mem[(32 * ('cd', 4).length) + 160 len 32 * _131]
        mem[mem[64] + 64] = (32 * _54) + (32 * _131) + 192
        _179 = mem[(64 * ('cd', 4).length) + 160]
        mem[mem[64] + (32 * _54) + (32 * _131) + 192] = mem[(64 * ('cd', 4).length) + 160]
        mem[mem[64] + (32 * _54) + (32 * _131) + 224 len 32 * _179] = mem[(64 * ('cd', 4).length) + 192 len 32 * _179]
        mem[mem[64] + 96] = 1
        return 128, 
               (32 * _54) + 160,
               (32 * _54) + (32 * _131) + 192,
               1,
               mem[mem[64] + 128 len (32 * _54) + (32 * _131) + (32 * _179) + 96]
    mem[128 len 32 * ('cd', 4).length] = call.data[calldata.size len 32 * ('cd', 4).length]
    if ('cd', 4).length > test266151307():
        revert with 'NH{q', 65
    mem[(32 * ('cd', 4).length) + 128] = ('cd', 4).length
    if not ('cd', 4).length:
        if ('cd', 4).length > test266151307():
            revert with 'NH{q', 65
        mem[(64 * ('cd', 4).length) + 160] = ('cd', 4).length
        mem[64] = (98 * ('cd', 4).length) + 192
        if not ('cd', 4).length:
            if 0 >= ('cd', 4).length:
                revert with 'NH{q', 50
            idx = 0
            while idx < ('cd', 4).length:
                if idx >= mem[96]:
                    revert with 'NH{q', 50
                mem[(32 * idx) + 128] = address(cd[((32 * idx) + cd[4] + 36)])
                if idx >= ('cd', 4).length:
                    revert with 'NH{q', 50
                if idx >= mem[(32 * ('cd', 4).length) + 128]:
                    revert with 'NH{q', 50
                mem[(32 * idx) + (32 * ('cd', 4).length) + 160] = 0
                if idx >= ('cd', 4).length:
                    revert with 'NH{q', 50
                if idx >= mem[(64 * ('cd', 4).length) + 160]:
                    revert with 'NH{q', 50
                mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0
                if idx == -1:
                    revert with 'NH{q', 17
                idx = idx + 1
                continue 
            mem[mem[64]] = 128
            _56 = mem[96]
            mem[mem[64] + 128] = mem[96]
            idx = 0
            s = 128
            t = mem[64] + 160
            while idx < _56:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[mem[64] + 32] = (32 * _56) + 160
            _132 = mem[(32 * ('cd', 4).length) + 128]
            mem[mem[64] + (32 * _56) + 160] = mem[(32 * ('cd', 4).length) + 128]
            mem[mem[64] + (32 * _56) + 192 len 32 * _132] = mem[(32 * ('cd', 4).length) + 160 len 32 * _132]
            mem[mem[64] + 64] = (32 * _56) + (32 * _132) + 192
            _180 = mem[(64 * ('cd', 4).length) + 160]
            mem[mem[64] + (32 * _56) + (32 * _132) + 192] = mem[(64 * ('cd', 4).length) + 160]
            mem[mem[64] + (32 * _56) + (32 * _132) + 224 len 32 * _180] = mem[(64 * ('cd', 4).length) + 192 len 32 * _180]
            mem[mem[64] + 96] = 1
            return 128, 
                   (32 * _56) + 160,
                   (32 * _56) + (32 * _132) + 192,
                   1,
                   mem[mem[64] + 128 len (32 * _56) + (32 * _132) + (32 * _180) + 96]
        mem[(64 * ('cd', 4).length) + 192 len 32 * ('cd', 4).length] = call.data[calldata.size len 32 * ('cd', 4).length]
        if 0 >= ('cd', 4).length:
            revert with 'NH{q', 50
        idx = 0
        while idx < ('cd', 4).length:
            if idx >= mem[96]:
                revert with 'NH{q', 50
            mem[(32 * idx) + 128] = address(cd[((32 * idx) + cd[4] + 36)])
            if idx >= ('cd', 4).length:
                revert with 'NH{q', 50
            if idx >= mem[(32 * ('cd', 4).length) + 128]:
                revert with 'NH{q', 50
            mem[(32 * idx) + (32 * ('cd', 4).length) + 160] = 0
            if idx >= ('cd', 4).length:
                revert with 'NH{q', 50
            if idx >= mem[(64 * ('cd', 4).length) + 160]:
                revert with 'NH{q', 50
            mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0
            if idx == -1:
                revert with 'NH{q', 17
            idx = idx + 1
            continue 
        mem[mem[64]] = 128
        _58 = mem[96]
        mem[mem[64] + 128] = mem[96]
        idx = 0
        s = 128
        t = mem[64] + 160
        while idx < _58:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        mem[mem[64] + 32] = (32 * _58) + 160
        _133 = mem[(32 * ('cd', 4).length) + 128]
        mem[mem[64] + (32 * _58) + 160] = mem[(32 * ('cd', 4).length) + 128]
        mem[mem[64] + (32 * _58) + 192 len 32 * _133] = mem[(32 * ('cd', 4).length) + 160 len 32 * _133]
        mem[mem[64] + 64] = (32 * _58) + (32 * _133) + 192
        _181 = mem[(64 * ('cd', 4).length) + 160]
        mem[mem[64] + (32 * _58) + (32 * _133) + 192] = mem[(64 * ('cd', 4).length) + 160]
        mem[mem[64] + (32 * _58) + (32 * _133) + 224 len 32 * _181] = mem[(64 * ('cd', 4).length) + 192 len 32 * _181]
        mem[mem[64] + 96] = 1
        return 128, 
               (32 * _58) + 160,
               (32 * _58) + (32 * _133) + 192,
               1,
               mem[mem[64] + 128 len (32 * _58) + (32 * _133) + (32 * _181) + 96]
    mem[(32 * ('cd', 4).length) + 160 len 32 * ('cd', 4).length] = call.data[calldata.size len 32 * ('cd', 4).length]
    if ('cd', 4).length > test266151307():
        revert with 'NH{q', 65
    mem[(64 * ('cd', 4).length) + 160] = ('cd', 4).length
    mem[64] = (98 * ('cd', 4).length) + 192
    if not ('cd', 4).length:
        if 0 >= ('cd', 4).length:
            revert with 'NH{q', 50
        idx = 0
        while idx < ('cd', 4).length:
            if idx >= mem[96]:
                revert with 'NH{q', 50
            mem[(32 * idx) + 128] = address(cd[((32 * idx) + cd[4] + 36)])
            if idx >= ('cd', 4).length:
                revert with 'NH{q', 50
            if idx >= mem[(32 * ('cd', 4).length) + 128]:
                revert with 'NH{q', 50
            mem[(32 * idx) + (32 * ('cd', 4).length) + 160] = 0
            if idx >= ('cd', 4).length:
                revert with 'NH{q', 50
            if idx >= mem[(64 * ('cd', 4).length) + 160]:
                revert with 'NH{q', 50
            mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0
            if idx == -1:
                revert with 'NH{q', 17
            idx = idx + 1
            continue 
        mem[mem[64]] = 128
        _60 = mem[96]
        mem[mem[64] + 128] = mem[96]
        idx = 0
        s = 128
        t = mem[64] + 160
        while idx < _60:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        mem[mem[64] + 32] = (32 * _60) + 160
        _134 = mem[(32 * ('cd', 4).length) + 128]
        mem[mem[64] + (32 * _60) + 160] = mem[(32 * ('cd', 4).length) + 128]
        mem[mem[64] + (32 * _60) + 192 len 32 * _134] = mem[(32 * ('cd', 4).length) + 160 len 32 * _134]
        mem[mem[64] + 64] = (32 * _60) + (32 * _134) + 192
        _182 = mem[(64 * ('cd', 4).length) + 160]
        mem[mem[64] + (32 * _60) + (32 * _134) + 192] = mem[(64 * ('cd', 4).length) + 160]
        mem[mem[64] + (32 * _60) + (32 * _134) + 224 len 32 * _182] = mem[(64 * ('cd', 4).length) + 192 len 32 * _182]
        mem[mem[64] + 96] = 1
        return 128, 
               (32 * _60) + 160,
               (32 * _60) + (32 * _134) + 192,
               1,
               mem[mem[64] + 128 len (32 * _60) + (32 * _134) + (32 * _182) + 96]
    mem[(64 * ('cd', 4).length) + 192 len 32 * ('cd', 4).length] = call.data[calldata.size len 32 * ('cd', 4).length]
    if 0 >= ('cd', 4).length:
        revert with 'NH{q', 50
    idx = 0
    while idx < ('cd', 4).length:
        if idx >= mem[96]:
            revert with 'NH{q', 50
        mem[(32 * idx) + 128] = address(cd[((32 * idx) + cd[4] + 36)])
        if idx >= ('cd', 4).length:
            revert with 'NH{q', 50
        if idx >= mem[(32 * ('cd', 4).length) + 128]:
            revert with 'NH{q', 50
        mem[(32 * idx) + (32 * ('cd', 4).length) + 160] = 0
        if idx >= ('cd', 4).length:
            revert with 'NH{q', 50
        if idx >= mem[(64 * ('cd', 4).length) + 160]:
            revert with 'NH{q', 50
        mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0
        if idx == -1:
            revert with 'NH{q', 17
        idx = idx + 1
        continue 
    mem[mem[64]] = 128
    _62 = mem[96]
    mem[mem[64] + 128] = mem[96]
    idx = 0
    s = 128
    t = mem[64] + 160
    while idx < _62:
        mem[t] = mem[s + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    mem[mem[64] + 32] = (32 * _62) + 160
    _135 = mem[(32 * ('cd', 4).length) + 128]
    mem[mem[64] + (32 * _62) + 160] = mem[(32 * ('cd', 4).length) + 128]
    mem[mem[64] + (32 * _62) + 192 len 32 * _135] = mem[(32 * ('cd', 4).length) + 160 len 32 * _135]
    mem[mem[64] + 64] = (32 * _62) + (32 * _135) + 192
    _183 = mem[(64 * ('cd', 4).length) + 160]
    mem[mem[64] + (32 * _62) + (32 * _135) + 192] = mem[(64 * ('cd', 4).length) + 160]
    mem[mem[64] + (32 * _62) + (32 * _135) + 224 len 32 * _183] = mem[(64 * ('cd', 4).length) + 192 len 32 * _183]
    mem[mem[64] + 96] = 1
    return 128, 
           (32 * _62) + 160,
           (32 * _62) + (32 * _135) + 192,
           1,
           mem[mem[64] + 128 len (32 * _62) + (32 * _135) + (32 * _183) + 96]
}

function sub_850b46c0(?) payable {
    mem[64] = 96
    require calldata.size - 4 >= 32
    require cd[4] <= test266151307()
    require cd[4] + 35 < calldata.size
    require ('cd', 4).length <= test266151307()
    require cd[4] + (32 * ('cd', 4).length) + 36 <= calldata.size
    idx = 0
    while idx < ('cd', 4).length:
        require cd[((32 * idx) + cd[4] + 36)] == address(cd[((32 * idx) + cd[4] + 36)])
        mem[mem[64] + 4] = this.address
        require ext_code.size(address(cd[((32 * idx) + cd[4] + 36)]))
        staticcall address(cd[((32 * idx) + cd[4] + 36)]).0x70a08231 with:
                gas gas_remaining wei
               args this.address
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _154 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _155 = mem[_154]
        if mem[_154]:
            if sub_fcb53d36 <= 0:
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(cd[((32 * idx) + cd[4] + 36)]))
                staticcall address(cd[((32 * idx) + cd[4] + 36)]).0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _161 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _163 = mem[_161]
                if mem[_161]:
                    mem[0] = address(cd[((32 * idx) + cd[4] + 36)])
                    mem[32] = 1
                    if stor1[address(cd[((32 * idx) + cd[4] + 36)])]:
                        revert with 0, 'TokenRecover#recover: Cannot recover tokens from the denylist'
                    if not address(cd[((32 * idx) + cd[4] + 36)]):
                        call owner with:
                           value _163 wei
                             gas 2300 * is_zero(value) wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                    else:
                        mem[mem[64] + 4] = owner
                        mem[mem[64] + 36] = _163
                        require ext_code.size(address(cd[((32 * idx) + cd[4] + 36)]))
                        call address(cd[((32 * idx) + cd[4] + 36)]).0xa9059cbb with:
                             gas gas_remaining wei
                            args owner, _163
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _185 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_185] == bool(mem[_185])
            else:
                mem[0] = address(cd[((32 * idx) + cd[4] + 36)])
                mem[32] = 7
                if not stor7[address(cd[((32 * idx) + cd[4] + 36)])]:
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(cd[((32 * idx) + cd[4] + 36)]))
                    staticcall address(cd[((32 * idx) + cd[4] + 36)]).0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _162 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _164 = mem[_162]
                    if mem[_162]:
                        mem[0] = address(cd[((32 * idx) + cd[4] + 36)])
                        mem[32] = 1
                        if stor1[address(cd[((32 * idx) + cd[4] + 36)])]:
                            revert with 0, 'TokenRecover#recover: Cannot recover tokens from the denylist'
                        if not address(cd[((32 * idx) + cd[4] + 36)]):
                            call owner with:
                               value _164 wei
                                 gas 2300 * is_zero(value) wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                        else:
                            mem[mem[64] + 4] = owner
                            mem[mem[64] + 36] = _164
                            require ext_code.size(address(cd[((32 * idx) + cd[4] + 36)]))
                            call address(cd[((32 * idx) + cd[4] + 36)]).0xa9059cbb with:
                                 gas gas_remaining wei
                                args owner, _164
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _186 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_186] == bool(mem[_186])
                else:
                    if _155 and sub_fcb53d36 > -1 / _155:
                        revert with 'NH{q', 17
                    if not _155 * sub_fcb53d36 / 1000:
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(cd[((32 * idx) + cd[4] + 36)]))
                        staticcall address(cd[((32 * idx) + cd[4] + 36)]).0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _181 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _187 = mem[_181]
                        if mem[_181]:
                            mem[0] = address(cd[((32 * idx) + cd[4] + 36)])
                            mem[32] = 1
                            if stor1[address(cd[((32 * idx) + cd[4] + 36)])]:
                                revert with 0, 'TokenRecover#recover: Cannot recover tokens from the denylist'
                            if not address(cd[((32 * idx) + cd[4] + 36)]):
                                call owner with:
                                   value _187 wei
                                     gas 2300 * is_zero(value) wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                            else:
                                mem[mem[64] + 4] = owner
                                mem[mem[64] + 36] = _187
                                require ext_code.size(address(cd[((32 * idx) + cd[4] + 36)]))
                                call address(cd[((32 * idx) + cd[4] + 36)]).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args owner, _187
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _208 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_208] == bool(mem[_208])
                    else:
                        if WMATICAddress == address(cd[((32 * idx) + cd[4] + 36)]):
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(cd[((32 * idx) + cd[4] + 36)]))
                            staticcall address(cd[((32 * idx) + cd[4] + 36)]).0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _188 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _192 = mem[_188]
                            if mem[_188]:
                                mem[0] = address(cd[((32 * idx) + cd[4] + 36)])
                                mem[32] = 1
                                if stor1[address(cd[((32 * idx) + cd[4] + 36)])]:
                                    revert with 0, 'TokenRecover#recover: Cannot recover tokens from the denylist'
                                if not address(cd[((32 * idx) + cd[4] + 36)]):
                                    call owner with:
                                       value _192 wei
                                         gas 2300 * is_zero(value) wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                else:
                                    mem[mem[64] + 4] = owner
                                    mem[mem[64] + 36] = _192
                                    require ext_code.size(address(cd[((32 * idx) + cd[4] + 36)]))
                                    call address(cd[((32 * idx) + cd[4] + 36)]).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args owner, _192
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _214 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_214] == bool(mem[_214])
                        else:
                            mem[mem[64] + 4] = address(cd[((32 * idx) + cd[4] + 36)])
                            mem[mem[64] + 36] = WMATICAddress
                            require ext_code.size(sub_67491cb9Address)
                            staticcall sub_67491cb9Address.getPair(address rg1, address rg2) with:
                                    gas gas_remaining wei
                                   args address(cd[((32 * idx) + cd[4] + 36)]), WMATICAddress
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _184 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_184] == mem[_184 + 12 len 20]
                            if not mem[_184 + 12 len 20]:
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(address(cd[((32 * idx) + cd[4] + 36)]))
                                staticcall address(cd[((32 * idx) + cd[4] + 36)]).0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _212 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _216 = mem[_212]
                                if mem[_212]:
                                    mem[0] = address(cd[((32 * idx) + cd[4] + 36)])
                                    mem[32] = 1
                                    if stor1[address(cd[((32 * idx) + cd[4] + 36)])]:
                                        revert with 0, 'TokenRecover#recover: Cannot recover tokens from the denylist'
                                    if not address(cd[((32 * idx) + cd[4] + 36)]):
                                        call owner with:
                                           value _216 wei
                                             gas 2300 * is_zero(value) wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                    else:
                                        mem[mem[64] + 4] = owner
                                        mem[mem[64] + 36] = _216
                                        require ext_code.size(address(cd[((32 * idx) + cd[4] + 36)]))
                                        call address(cd[((32 * idx) + cd[4] + 36)]).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args owner, _216
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _228 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_228] == bool(mem[_228])
                            else:
                                _201 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_201]:
                                    revert with 'NH{q', 50
                                mem[_201 + 32] = address(cd[((32 * idx) + cd[4] + 36)])
                                if 1 >= mem[_201]:
                                    revert with 'NH{q', 50
                                mem[_201 + 64] = WMATICAddress
                                mem[_201 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_201 + 100] = _155 * sub_fcb53d36 / 1000
                                mem[_201 + 132] = 64
                                mem[_201 + 164] = mem[_201]
                                s = 0
                                t = _201 + 32
                                u = _201 + 196
                                while s < mem[_201]:
                                    mem[u] = mem[t + 12 len 20]
                                    s = s + 1
                                    t = t + 32
                                    u = u + 32
                                    continue 
                                require ext_code.size(sub_5fdba4b7Address)
                                staticcall sub_5fdba4b7Address.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _201 + (32 * mem[_201]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _305 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _306 = mem[_305]
                                require mem[_305] <= test266151307()
                                require _305 + return_data.size > _305 + mem[_305] + 31
                                _307 = mem[_305 + mem[_305]]
                                if mem[_305 + mem[_305]] > test266151307():
                                    revert with 'NH{q', 65
                                if ceil32(32 * mem[_305 + mem[_305]]) + 1 < 0 or _305 + ceil32(return_data.size) + ceil32(32 * mem[_305 + mem[_305]]) + 1 > test266151307():
                                    revert with 'NH{q', 65
                                mem[64] = _305 + ceil32(return_data.size) + ceil32(32 * mem[_305 + mem[_305]]) + 1
                                mem[_305 + ceil32(return_data.size)] = _307
                                require _306 + (32 * _307) + 32 <= return_data.size
                                t = _305 + _306 + 32
                                u = _305 + ceil32(return_data.size) + 32
                                s = 0
                                while s < _307:
                                    mem[u] = mem[t]
                                    t = t + 32
                                    u = u + 32
                                    s = s + 1
                                    continue 
                                if 1 >= _307:
                                    revert with 'NH{q', 50
                                if mem[_305 + ceil32(return_data.size) + 64] <= 0:
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(address(cd[((32 * idx) + cd[4] + 36)]))
                                    staticcall address(cd[((32 * idx) + cd[4] + 36)]).0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _390 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _392 = mem[_390]
                                    if mem[_390]:
                                        mem[0] = address(cd[((32 * idx) + cd[4] + 36)])
                                        mem[32] = 1
                                        if stor1[address(cd[((32 * idx) + cd[4] + 36)])]:
                                            revert with 0, 'TokenRecover#recover: Cannot recover tokens from the denylist'
                                        if not address(cd[((32 * idx) + cd[4] + 36)]):
                                            call owner with:
                                               value _392 wei
                                                 gas 2300 * is_zero(value) wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                        else:
                                            mem[mem[64] + 4] = owner
                                            mem[mem[64] + 36] = _392
                                            require ext_code.size(address(cd[((32 * idx) + cd[4] + 36)]))
                                            call address(cd[((32 * idx) + cd[4] + 36)]).0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args owner, _392
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _407 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_407] == bool(mem[_407])
                                else:
                                    if 0 >= _307:
                                        revert with 'NH{q', 50
                                    _384 = mem[_305 + ceil32(return_data.size) + 32]
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = sub_5fdba4b7Address
                                    require ext_code.size(address(cd[((32 * idx) + cd[4] + 36)]))
                                    staticcall address(cd[((32 * idx) + cd[4] + 36)]).0xdd62ed3e with:
                                            gas gas_remaining wei
                                           args this.address, sub_5fdba4b7Address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _389 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_389] >= _384:
                                        if 1 >= _307:
                                            revert with 'NH{q', 50
                                        _396 = mem[_305 + ceil32(return_data.size) + 64]
                                        if 3600 > !block.timestamp:
                                            revert with 'NH{q', 17
                                        mem[mem[64]] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = _155 * sub_fcb53d36 / 1000
                                        mem[mem[64] + 36] = _396
                                        mem[mem[64] + 68] = 160
                                        _406 = mem[_201]
                                        mem[mem[64] + 164] = mem[_201]
                                        s = 0
                                        t = _201 + 32
                                        u = mem[64] + 196
                                        while s < _406:
                                            mem[u] = mem[t + 12 len 20]
                                            s = s + 1
                                            t = t + 32
                                            u = u + 32
                                            continue 
                                        mem[mem[64] + 100] = feeReceiverAddress
                                        mem[mem[64] + 132] = block.timestamp + 3600
                                        require ext_code.size(sub_5fdba4b7Address)
                                        call sub_5fdba4b7Address.swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args _155 * sub_fcb53d36 / 1000, _396, 160, feeReceiverAddress, block.timestamp + 3600, mem[mem[64] + 164 len (32 * _406) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _455 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _457 = mem[_455]
                                        require mem[_455] <= test266151307()
                                        require _455 + return_data.size > _455 + mem[_455] + 31
                                        _459 = mem[_455 + mem[_455]]
                                        if mem[_455 + mem[_455]] > test266151307():
                                            revert with 'NH{q', 65
                                        if ceil32(32 * mem[_455 + mem[_455]]) + 1 < 0 or _455 + ceil32(return_data.size) + ceil32(32 * mem[_455 + mem[_455]]) + 1 > test266151307():
                                            revert with 'NH{q', 65
                                        mem[64] = _455 + ceil32(return_data.size) + ceil32(32 * mem[_455 + mem[_455]]) + 1
                                        mem[_455 + ceil32(return_data.size)] = _459
                                        require _457 + (32 * _459) + 32 <= return_data.size
                                        t = _455 + _457 + 32
                                        u = _455 + ceil32(return_data.size) + 32
                                        s = 0
                                        while s < _459:
                                            mem[u] = mem[t]
                                            t = t + 32
                                            u = u + 32
                                            s = s + 1
                                            continue 
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(cd[((32 * idx) + cd[4] + 36)]))
                                        staticcall address(cd[((32 * idx) + cd[4] + 36)]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _495 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _497 = mem[_495]
                                        if mem[_495]:
                                            mem[0] = address(cd[((32 * idx) + cd[4] + 36)])
                                            mem[32] = 1
                                            if stor1[address(cd[((32 * idx) + cd[4] + 36)])]:
                                                revert with 0, 'TokenRecover#recover: Cannot recover tokens from the denylist'
                                            if not address(cd[((32 * idx) + cd[4] + 36)]):
                                                call owner with:
                                                   value _497 wei
                                                     gas 2300 * is_zero(value) wei
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                            else:
                                                mem[mem[64] + 4] = owner
                                                mem[mem[64] + 36] = _497
                                                require ext_code.size(address(cd[((32 * idx) + cd[4] + 36)]))
                                                call address(cd[((32 * idx) + cd[4] + 36)]).0xa9059cbb with:
                                                     gas gas_remaining wei
                                                    args owner, _497
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _511 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_511] == bool(mem[_511])
                                    else:
                                        mem[mem[64] + 4] = sub_5fdba4b7Address
                                        mem[mem[64] + 36] = -1
                                        require ext_code.size(address(cd[((32 * idx) + cd[4] + 36)]))
                                        call address(cd[((32 * idx) + cd[4] + 36)]).approve(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args sub_5fdba4b7Address, -1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _398 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_398] == bool(mem[_398])
                                        if 1 >= _307:
                                            revert with 'NH{q', 50
                                        _412 = mem[_305 + ceil32(return_data.size) + 64]
                                        if 3600 > !block.timestamp:
                                            revert with 'NH{q', 17
                                        mem[mem[64]] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = _155 * sub_fcb53d36 / 1000
                                        mem[mem[64] + 36] = _412
                                        mem[mem[64] + 68] = 160
                                        _416 = mem[_201]
                                        mem[mem[64] + 164] = mem[_201]
                                        s = 0
                                        t = _201 + 32
                                        u = mem[64] + 196
                                        while s < _416:
                                            mem[u] = mem[t + 12 len 20]
                                            s = s + 1
                                            t = t + 32
                                            u = u + 32
                                            continue 
                                        mem[mem[64] + 100] = feeReceiverAddress
                                        mem[mem[64] + 132] = block.timestamp + 3600
                                        require ext_code.size(sub_5fdba4b7Address)
                                        call sub_5fdba4b7Address.swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args _155 * sub_fcb53d36 / 1000, _412, 160, feeReceiverAddress, block.timestamp + 3600, mem[mem[64] + 164 len (32 * _416) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _456 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _458 = mem[_456]
                                        require mem[_456] <= test266151307()
                                        require _456 + return_data.size > _456 + mem[_456] + 31
                                        _460 = mem[_456 + mem[_456]]
                                        if mem[_456 + mem[_456]] > test266151307():
                                            revert with 'NH{q', 65
                                        if ceil32(32 * mem[_456 + mem[_456]]) + 1 < 0 or _456 + ceil32(return_data.size) + ceil32(32 * mem[_456 + mem[_456]]) + 1 > test266151307():
                                            revert with 'NH{q', 65
                                        mem[64] = _456 + ceil32(return_data.size) + ceil32(32 * mem[_456 + mem[_456]]) + 1
                                        mem[_456 + ceil32(return_data.size)] = _460
                                        require _458 + (32 * _460) + 32 <= return_data.size
                                        t = _456 + _458 + 32
                                        u = _456 + ceil32(return_data.size) + 32
                                        s = 0
                                        while s < _460:
                                            mem[u] = mem[t]
                                            t = t + 32
                                            u = u + 32
                                            s = s + 1
                                            continue 
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(cd[((32 * idx) + cd[4] + 36)]))
                                        staticcall address(cd[((32 * idx) + cd[4] + 36)]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _496 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _498 = mem[_496]
                                        if mem[_496]:
                                            mem[0] = address(cd[((32 * idx) + cd[4] + 36)])
                                            mem[32] = 1
                                            if stor1[address(cd[((32 * idx) + cd[4] + 36)])]:
                                                revert with 0, 'TokenRecover#recover: Cannot recover tokens from the denylist'
                                            if not address(cd[((32 * idx) + cd[4] + 36)]):
                                                call owner with:
                                                   value _498 wei
                                                     gas 2300 * is_zero(value) wei
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                            else:
                                                mem[mem[64] + 4] = owner
                                                mem[mem[64] + 36] = _498
                                                require ext_code.size(address(cd[((32 * idx) + cd[4] + 36)]))
                                                call address(cd[((32 * idx) + cd[4] + 36)]).0xa9059cbb with:
                                                     gas gas_remaining wei
                                                    args owner, _498
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _512 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_512] == bool(mem[_512])
        if idx == -1:
            revert with 'NH{q', 17
        idx = idx + 1
        continue 
}

function sub_e6ac556a(?) payable {
    require calldata.size - 4 >= 96
    require cd[4] <= test266151307()
    require cd[4] + 35 < calldata.size
    if ('cd', 4).length > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * ('cd', 4).length) + 97 < 96 or ceil32(32 * ('cd', 4).length) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = ('cd', 4).length
    require cd[4] + (32 * ('cd', 4).length) + 36 <= calldata.size
    idx = 0
    s = cd[4] + 36
    t = 128
    while idx < ('cd', 4).length:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[36] <= test266151307()
    require cd[36] + 35 < calldata.size
    if ('cd', 36).length > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * ('cd', 36).length) + 98 < 97 or ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * ('cd', 4).length) + 97] = ('cd', 36).length
    require cd[36] + (32 * ('cd', 36).length) + 36 <= calldata.size
    idx = 0
    s = cd[36] + 36
    t = ceil32(32 * ('cd', 4).length) + 129
    while idx < ('cd', 36).length:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[68] <= test266151307()
    require cd[68] + 35 < calldata.size
    if ('cd', 68).length > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * ('cd', 68).length) + 99 < 98 or ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98] = ('cd', 68).length
    require cd[68] + (32 * ('cd', 68).length) + 36 <= calldata.size
    idx = 0
    s = cd[68] + 36
    t = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130
    while idx < ('cd', 68).length:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if ('cd', 4).length < 1:
        revert with 'NH{q', 17
    if ('cd', 4).length - 1 >= ('cd', 4).length:
        revert with 'NH{q', 50
    _519 = mem[(32 * ('cd', 4).length - 1) + 128]
    if ('cd', 68).length < 1:
        revert with 'NH{q', 17
    if ('cd', 68).length - 1 >= ('cd', 68).length:
        revert with 'NH{q', 50
    require ext_code.size(mem[(32 * ('cd', 4).length - 1) + 140 len 20])
    if 0 == mem[(32 * ('cd', 68).length - 1) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130]:
        staticcall mem[(32 * ('cd', 4).length - 1) + 140 len 20].token1() with:
                gas gas_remaining wei
        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 99] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + ceil32(return_data.size) + 103] = this.address
        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + ceil32(return_data.size) + 135] = address(_519)
        require ext_code.size(address(ext_call.return_data[0]))
        staticcall address(ext_call.return_data[0]).0xdd62ed3e with:
                gas gas_remaining wei
               args this.address, address(_519)
        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + ceil32(return_data.size) + 99] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ext_call.return_data[0] >= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff:
            if ('cd', 68).length < 1:
                revert with 'NH{q', 17
            if ('cd', 68).length - 1 >= ('cd', 68).length:
                revert with 'NH{q', 50
            if ('cd', 36).length < 1:
                revert with 'NH{q', 17
            if ('cd', 36).length - 1 >= ('cd', 36).length:
                revert with 'NH{q', 50
            if mem[(32 * ('cd', 68).length - 1) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130] != 0:
                _559 = mem[(32 * ('cd', 36).length - 1) + ceil32(32 * ('cd', 4).length) + 129]
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 131] = address(ext_call.return_data[0])
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 163] = 128
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 259] = ('cd', 4).length
                idx = 0
                s = 128
                t = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 291
                while idx < ('cd', 4).length:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 195] = (32 * ('cd', 4).length) + 160
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + 291] = ('cd', 36).length
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + 323 len 32 * ('cd', 36).length] = mem[ceil32(32 * ('cd', 4).length) + 129 len 32 * ('cd', 36).length]
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 227] = (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 192
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 323] = ('cd', 68).length
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 355 len 32 * ('cd', 68).length] = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130 len 32 * ('cd', 68).length]
                var94001 = ('cd', 68).length
                var94002 = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 130
                var94007 = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 355
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 355] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 359] = _559
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 391] = 0
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 423] = this.address
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 455] = 128
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 487] = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 99]
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 519 len ceil32(mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 99])] = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 131 len ceil32(mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 99])]
                if ceil32(mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 99]) > mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 99]:
                    mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 99] + 519] = 0
                require ext_code.size(address(_519))
                call address(_519).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                     gas gas_remaining wei
                    args _559, 0, address(this.address), 128, mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 99], mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 519 len ceil32(mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 99])]
            else:
                _561 = mem[(32 * ('cd', 36).length - 1) + ceil32(32 * ('cd', 4).length) + 129]
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 131] = address(ext_call.return_data[0])
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 163] = 128
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 259] = ('cd', 4).length
                idx = 0
                s = 128
                t = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 291
                while idx < ('cd', 4).length:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 195] = (32 * ('cd', 4).length) + 160
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + 291] = ('cd', 36).length
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + 323 len 32 * ('cd', 36).length] = mem[ceil32(32 * ('cd', 4).length) + 129 len 32 * ('cd', 36).length]
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 227] = (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 192
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 323] = ('cd', 68).length
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 355 len 32 * ('cd', 68).length] = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130 len 32 * ('cd', 68).length]
                var94001 = ('cd', 68).length
                var94002 = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 130
                var94007 = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 355
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 355] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 359] = 0
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 391] = _561
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 423] = this.address
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 455] = 128
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 487] = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 99]
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 519 len ceil32(mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 99])] = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 131 len ceil32(mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 99])]
                if ceil32(mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 99]) > mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 99]:
                    mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 99] + 519] = 0
                require ext_code.size(address(_519))
                call address(_519).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                     gas gas_remaining wei
                    args 0, _561, address(this.address), 128, mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 99], mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 519 len ceil32(mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 99])]
        else:
            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 103] = address(_519)
            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 135] = -1
            require ext_code.size(address(ext_call.return_data[0]))
            call address(ext_call.return_data[0]).approve(address rg1, uint256 rg2) with:
                 gas gas_remaining wei
                args address(_519), -1
            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 99] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            if ('cd', 68).length < 1:
                revert with 'NH{q', 17
            if ('cd', 68).length - 1 >= ('cd', 68).length:
                revert with 'NH{q', 50
            if ('cd', 36).length < 1:
                revert with 'NH{q', 17
            if ('cd', 36).length - 1 >= ('cd', 36).length:
                revert with 'NH{q', 50
            if mem[(32 * ('cd', 68).length - 1) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130] != 0:
                _595 = mem[(32 * ('cd', 36).length - 1) + ceil32(32 * ('cd', 4).length) + 129]
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 131] = address(ext_call.return_data[0])
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 163] = 128
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 259] = ('cd', 4).length
                idx = 0
                s = 128
                t = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 291
                while idx < ('cd', 4).length:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 195] = (32 * ('cd', 4).length) + 160
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + 291] = ('cd', 36).length
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + 323 len 32 * ('cd', 36).length] = mem[ceil32(32 * ('cd', 4).length) + 129 len 32 * ('cd', 36).length]
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 227] = (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 192
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 323] = ('cd', 68).length
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 355 len 32 * ('cd', 68).length] = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130 len 32 * ('cd', 68).length]
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 355] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 359] = _595
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 391] = 0
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 423] = this.address
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 455] = 128
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 487] = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 99]
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 519 len ceil32(mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 99])] = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 131 len ceil32(mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 99])]
                if ceil32(mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 99]) > mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 99]:
                    mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 99] + 519] = 0
                require ext_code.size(address(_519))
                call address(_519).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                     gas gas_remaining wei
                    args _595, 0, address(this.address), 128, mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 99], mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 519 len ceil32(mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 99])]
            else:
                _597 = mem[(32 * ('cd', 36).length - 1) + ceil32(32 * ('cd', 4).length) + 129]
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 131] = address(ext_call.return_data[0])
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 163] = 128
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 259] = ('cd', 4).length
                idx = 0
                s = 128
                t = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 291
                while idx < ('cd', 4).length:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 195] = (32 * ('cd', 4).length) + 160
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + 291] = ('cd', 36).length
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + 323 len 32 * ('cd', 36).length] = mem[ceil32(32 * ('cd', 4).length) + 129 len 32 * ('cd', 36).length]
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 227] = (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 192
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 323] = ('cd', 68).length
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 355 len 32 * ('cd', 68).length] = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130 len 32 * ('cd', 68).length]
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 355] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 359] = 0
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 391] = _597
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 423] = this.address
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 455] = 128
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 487] = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 99]
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 519 len ceil32(mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 99])] = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 131 len ceil32(mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 99])]
                if ceil32(mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 99]) > mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 99]:
                    mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 99] + 519] = 0
                require ext_code.size(address(_519))
                call address(_519).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                     gas gas_remaining wei
                    args 0, _597, address(this.address), 128, mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 99], mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 519 len ceil32(mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 99])]
    else:
        staticcall mem[(32 * ('cd', 4).length - 1) + 140 len 20].token0() with:
                gas gas_remaining wei
        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 99] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + ceil32(return_data.size) + 103] = this.address
        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + ceil32(return_data.size) + 135] = address(_519)
        require ext_code.size(address(ext_call.return_data[0]))
        staticcall address(ext_call.return_data[0]).0xdd62ed3e with:
                gas gas_remaining wei
               args this.address, address(_519)
        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + ceil32(return_data.size) + 99] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ext_call.return_data[0] >= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff:
            if ('cd', 68).length < 1:
                revert with 'NH{q', 17
            if ('cd', 68).length - 1 >= ('cd', 68).length:
                revert with 'NH{q', 50
            if ('cd', 36).length < 1:
                revert with 'NH{q', 17
            if ('cd', 36).length - 1 >= ('cd', 36).length:
                revert with 'NH{q', 50
            if mem[(32 * ('cd', 68).length - 1) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130] != 0:
                _566 = mem[(32 * ('cd', 36).length - 1) + ceil32(32 * ('cd', 4).length) + 129]
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 131] = address(ext_call.return_data[0])
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 163] = 128
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 259] = ('cd', 4).length
                idx = 0
                s = 128
                t = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 291
                while idx < ('cd', 4).length:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 195] = (32 * ('cd', 4).length) + 160
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + 291] = ('cd', 36).length
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + 323 len 32 * ('cd', 36).length] = mem[ceil32(32 * ('cd', 4).length) + 129 len 32 * ('cd', 36).length]
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 227] = (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 192
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 323] = ('cd', 68).length
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 355 len 32 * ('cd', 68).length] = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130 len 32 * ('cd', 68).length]
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 355] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 359] = _566
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 391] = 0
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 423] = this.address
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 455] = 128
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 487] = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 99]
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 519 len ceil32(mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 99])] = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 131 len ceil32(mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 99])]
                if ceil32(mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 99]) > mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 99]:
                    mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 99] + 519] = 0
                require ext_code.size(address(_519))
                call address(_519).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                     gas gas_remaining wei
                    args _566, 0, address(this.address), 128, mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 99], mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 519 len ceil32(mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 99])]
            else:
                _568 = mem[(32 * ('cd', 36).length - 1) + ceil32(32 * ('cd', 4).length) + 129]
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 131] = address(ext_call.return_data[0])
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 163] = 128
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 259] = ('cd', 4).length
                idx = 0
                s = 128
                t = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 291
                while idx < ('cd', 4).length:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 195] = (32 * ('cd', 4).length) + 160
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + 291] = ('cd', 36).length
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + 323 len 32 * ('cd', 36).length] = mem[ceil32(32 * ('cd', 4).length) + 129 len 32 * ('cd', 36).length]
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 227] = (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 192
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 323] = ('cd', 68).length
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 355 len 32 * ('cd', 68).length] = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130 len 32 * ('cd', 68).length]
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 355] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 359] = 0
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 391] = _568
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 423] = this.address
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 455] = 128
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 487] = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 99]
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 519 len ceil32(mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 99])] = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 131 len ceil32(mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 99])]
                if ceil32(mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 99]) > mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 99]:
                    mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 99] + 519] = 0
                require ext_code.size(address(_519))
                call address(_519).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                     gas gas_remaining wei
                    args 0, _568, address(this.address), 128, mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 99], mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 519 len ceil32(mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 99])]
        else:
            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 103] = address(_519)
            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 135] = -1
            require ext_code.size(address(ext_call.return_data[0]))
            call address(ext_call.return_data[0]).approve(address rg1, uint256 rg2) with:
                 gas gas_remaining wei
                args address(_519), -1
            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 99] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            if ('cd', 68).length < 1:
                revert with 'NH{q', 17
            if ('cd', 68).length - 1 >= ('cd', 68).length:
                revert with 'NH{q', 50
            if ('cd', 36).length < 1:
                revert with 'NH{q', 17
            if ('cd', 36).length - 1 >= ('cd', 36).length:
                revert with 'NH{q', 50
            if mem[(32 * ('cd', 68).length - 1) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130] != 0:
                _605 = mem[(32 * ('cd', 36).length - 1) + ceil32(32 * ('cd', 4).length) + 129]
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 131] = address(ext_call.return_data[0])
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 163] = 128
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 259] = ('cd', 4).length
                idx = 0
                s = 128
                t = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 291
                while idx < ('cd', 4).length:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 195] = (32 * ('cd', 4).length) + 160
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + 291] = ('cd', 36).length
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + 323 len 32 * ('cd', 36).length] = mem[ceil32(32 * ('cd', 4).length) + 129 len 32 * ('cd', 36).length]
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 227] = (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 192
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 323] = ('cd', 68).length
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 355 len 32 * ('cd', 68).length] = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130 len 32 * ('cd', 68).length]
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 355] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 359] = _605
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 391] = 0
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 423] = this.address
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 455] = 128
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 487] = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 99]
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 519 len ceil32(mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 99])] = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 131 len ceil32(mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 99])]
                if ceil32(mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 99]) > mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 99]:
                    mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 99] + 519] = 0
                require ext_code.size(address(_519))
                call address(_519).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                     gas gas_remaining wei
                    args _605, 0, address(this.address), 128, mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 99], mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 519 len ceil32(mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 99])]
            else:
                _607 = mem[(32 * ('cd', 36).length - 1) + ceil32(32 * ('cd', 4).length) + 129]
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 131] = address(ext_call.return_data[0])
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 163] = 128
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 259] = ('cd', 4).length
                idx = 0
                s = 128
                t = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 291
                while idx < ('cd', 4).length:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 195] = (32 * ('cd', 4).length) + 160
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + 291] = ('cd', 36).length
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + 323 len 32 * ('cd', 36).length] = mem[ceil32(32 * ('cd', 4).length) + 129 len 32 * ('cd', 36).length]
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 227] = (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 192
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 323] = ('cd', 68).length
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 355 len 32 * ('cd', 68).length] = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130 len 32 * ('cd', 68).length]
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 355] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 359] = 0
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 391] = _607
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 423] = this.address
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 455] = 128
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 487] = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 99]
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 519 len ceil32(mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 99])] = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 131 len ceil32(mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 99])]
                if ceil32(mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 99]) > mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 99]:
                    mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 99] + 519] = 0
                require ext_code.size(address(_519))
                call address(_519).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                     gas gas_remaining wei
                    args 0, _607, address(this.address), 128, mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 99], mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 519 len ceil32(mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 99])]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}



}

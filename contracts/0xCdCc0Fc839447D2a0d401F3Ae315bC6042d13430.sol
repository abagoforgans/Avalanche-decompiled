contract main {




// =====================  Runtime code  =====================


#
#  - transferFrom(address arg1, address arg2, uint256 arg3)
#  - deliver(uint256 arg1)
#  - transfer(address arg1, uint256 arg2)
#
const name = 'SafeMoonAvax', 0

const decimals = 9

const symbol = 'SafeMoonA', 0


address owner;
address stor1;
uint256 unlockTime;
mapping of uint256 stor3;
mapping of uint256 stor4;
mapping of uint8 stor5;
mapping of uint8 stor6;
mapping of uint256 allowance;
mapping of uint8 stor8;
array of address stor9;
address _charityWalletAddress;
uint256 totalSupply;
uint256 stor12;
uint256 totalFees;
uint256 totalBurn;
uint256 _taxFee;
uint256 _liquidityFee;
uint256 _burnFee;
uint256 _maxTxAmount;
uint256 _numTokensSellToAddToLiquidity;
uint8 _swapAndLiquifyEnabled;
address _uniswapV2RouterAddress; offset 16
address _uniswapV2PairAddress;

function totalFees() {
    return totalFees
}

function totalSupply() {
    return totalSupply
}

function _taxFee() {
    return _taxFee
}

function totalBurn() {
    return totalBurn
}

function _charityWallet() {
    return _charityWalletAddress
}

function isExcludedFromFee(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return bool(stor5[address(arg1)])
}

function _uniswapV2Router() {
    return _uniswapV2RouterAddress
}

function getUnlockTime() {
    return unlockTime
}

function _liquidityFee() {
    return _liquidityFee
}

function _maxTxAmount() {
    return _maxTxAmount
}

function sub_8268a343(?) {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    return bool(stor8[arg1])
}

function isExcludedFromReward(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return bool(stor6[address(arg1)])
}

function owner() {
    return owner
}

function _uniswapV2Pair() {
    return _uniswapV2PairAddress
}

function _numTokensSellToAddToLiquidity() {
    return _numTokensSellToAddToLiquidity
}

function _burnFee() {
    return _burnFee
}

function _swapAndLiquifyEnabled() {
    return bool(_swapAndLiquifyEnabled)
}

function allowance(address arg1, address arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    return allowance[address(arg1)][address(arg2)]
}

function _fallback() payable {
    revert
}

function renounceOwnership() {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    emit OwnershipTransferred(owner, 0);
    owner = 0
}

function setTaxFeePercent(uint256 arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    _taxFee = arg1
}

function setBurnFeePercent(uint256 arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    _burnFee = arg1
}

function includeInFee(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    stor5[address(arg1)] = 0
}

function excludeFromFee(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    stor5[address(arg1)] = 1
}

function setLiquidityFeePercent(uint256 arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    _liquidityFee = arg1
}

function setUniswapPair(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    _uniswapV2PairAddress = arg1
}

function setUniswapRouter(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    _uniswapV2RouterAddress = arg1
}

function setIsExcludedFromSwapAndLiquify(address arg1, bool arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    stor8[address(arg1)] = uint8(arg2)
}

function setSwapAndLiquifyEnabled(bool arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    _swapAndLiquifyEnabled = uint8(arg1)
    emit SwapAndLiquifyEnabledUpdated(arg1);
}

function unlock() {
    if stor1 != msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'You don't have permission to unlock'
    if block.timestamp <= unlockTime:
        revert with 0, 'Contract is still locked'
    emit OwnershipTransferred(owner, stor1);
    owner = stor1
}

function lock(uint256 arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    stor1 = owner
    owner = 0
    if block.timestamp > -arg1 - 1:
        revert with 'NH{q', 17
    unlockTime = block.timestamp + arg1
    emit OwnershipTransferred(owner, 0);
}

function transferOwnership(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Ownable: new owner is the zero address'
    emit OwnershipTransferred(owner, arg1);
    owner = arg1
}

function approve(address arg1, uint256 arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    if not msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: approve from the zero address'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: approve to the zero address'
    allowance[address(msg.sender)][address(arg1)] = arg2
    emit Approval(arg2, msg.sender, arg1);
    return 1
}

function setMaxTxPercent(uint256 arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not totalSupply:
        _maxTxAmount = 0
    else:
        if totalSupply and arg1 > -1 / totalSupply:
            revert with 'NH{q', 17
        if not totalSupply:
            revert with 'NH{q', 18
        if totalSupply * arg1 / totalSupply != arg1:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
        _maxTxAmount = totalSupply * arg1 / 100
}

function setMinLiquidityPercent(uint256 arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not totalSupply:
        _numTokensSellToAddToLiquidity = 0
    else:
        if totalSupply and arg1 > -1 / totalSupply:
            revert with 'NH{q', 17
        if not totalSupply:
            revert with 'NH{q', 18
        if totalSupply * arg1 / totalSupply != arg1:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
        _numTokensSellToAddToLiquidity = totalSupply * arg1 / 1000
}

function decreaseAllowance(address arg1, uint256 arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    if arg2 > allowance[address(msg.sender)][address(arg1)]:
        revert with 0, 32, 37, 0x6542455032303a2064656372656173656420616c6c6f77616e63652062656c6f77207a6572, mem[165 len 27] >> 40, 0
    if allowance[address(msg.sender)][address(arg1)] < arg2:
        revert with 'NH{q', 17
    if not msg.sender:
        revert with 0, 'BEP20: approve from the zero address'
    if not arg1:
        revert with 0, 'BEP20: approve to the zero address'
    allowance[address(msg.sender)][address(arg1)] -= arg2
    emit Approval((allowance[address(msg.sender)][address(arg1)] - arg2), msg.sender, arg1);
    return 1
}

function increaseAllowance(address arg1, uint256 arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    if allowance[address(msg.sender)][address(arg1)] > -arg2 - 1:
        revert with 'NH{q', 17
    if allowance[address(msg.sender)][address(arg1)] + arg2 < allowance[address(msg.sender)][address(arg1)]:
        revert with 0, 'SafeMath: addition overflow'
    if not msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: approve from the zero address'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: approve to the zero address'
    allowance[address(msg.sender)][address(arg1)] += arg2
    emit Approval((allowance[address(msg.sender)][address(arg1)] + arg2), msg.sender, arg1);
    return 1
}

function includeInReward(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not stor6[address(arg1)]:
        revert with 0, 'Account is already excluded'
    idx = 0
    while idx < stor9.length:
        mem[0] = 9
        if stor9[idx] != arg1:
            if idx == -1:
                revert with 'NH{q', 17
            idx = idx + 1
            continue 
        if stor9.length < 1:
            revert with 'NH{q', 17
        if stor9.length - 1 >= stor9.length:
            revert with 'NH{q', 50
        if idx >= stor9.length:
            revert with 'NH{q', 50
        stor9[idx] = stor9[stor9.length]
        stor4[address(arg1)] = 0
        stor6[address(arg1)] = 0
        if not stor9.length:
            revert with 'NH{q', 49
        stor9[stor9.length] = 0
        stor9.length--
}

function tokenFromReflection(uint256 arg1) payable {
    mem[64] = 96
    require not msg.value
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if arg1 > stor12:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Amount must be less than total reflections'
    idx = 0
    s = totalSupply
    t = stor12
    while idx < stor9.length:
        mem[0] = stor9[idx]
        mem[32] = 3
        if stor3[stor9[idx]] > t:
            _92 = mem[64]
            mem[64] = mem[64] + 64
            mem[_92] = 26
            mem[_92 + 32] = 'SafeMath: division by zero'
            if totalSupply <= 0:
                _96 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_96 + idx + 68] = mem[_92 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_96 + 94] = 0
                revert with memory
                  from mem[64]
                   len _96 + -mem[64] + 100
            if not totalSupply:
                revert with 'NH{q', 18
            _112 = mem[64]
            mem[64] = mem[64] + 64
            mem[_112] = 26
            mem[_112 + 32] = 'SafeMath: division by zero'
            if stor12 / totalSupply > 0:
                if not stor12 / totalSupply:
                    revert with 'NH{q', 18
                return (arg1 / stor12 / totalSupply)
            _119 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[_119 + idx + 68] = mem[_112 + idx + 32]
                idx = idx + 32
                continue 
            mem[_119 + 94] = 0
            revert with memory
              from mem[64]
               len _119 + -mem[64] + 100
        if idx >= stor9.length:
            revert with 'NH{q', 50
        mem[0] = stor9[idx]
        mem[32] = 4
        if stor4[stor9[idx]] > s:
            _97 = mem[64]
            mem[64] = mem[64] + 64
            mem[_97] = 26
            mem[_97 + 32] = 'SafeMath: division by zero'
            if totalSupply <= 0:
                _99 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_99 + idx + 68] = mem[_97 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_99 + 94] = 0
                revert with memory
                  from mem[64]
                   len _99 + -mem[64] + 100
            if not totalSupply:
                revert with 'NH{q', 18
            _120 = mem[64]
            mem[64] = mem[64] + 64
            mem[_120] = 26
            mem[_120 + 32] = 'SafeMath: division by zero'
            if stor12 / totalSupply > 0:
                if not stor12 / totalSupply:
                    revert with 'NH{q', 18
                return (arg1 / stor12 / totalSupply)
            _123 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[_123 + idx + 68] = mem[_120 + idx + 32]
                idx = idx + 32
                continue 
            mem[_123 + 94] = 0
            revert with memory
              from mem[64]
               len _123 + -mem[64] + 100
        if idx >= stor9.length:
            revert with 'NH{q', 50
        mem[0] = stor9[idx]
        mem[32] = 3
        _95 = mem[64]
        mem[64] = mem[64] + 64
        mem[_95] = 30
        mem[_95 + 32] = 'SafeMath: subtraction overflow'
        if stor3[stor9[idx]] > t:
            _98 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[_98 + idx + 68] = mem[_95 + idx + 32]
                idx = idx + 32
                continue 
            mem[_98 + 98] = 0
            revert with memory
              from mem[64]
               len _98 + -mem[64] + 100
        if t < stor3[stor9[idx]]:
            revert with 'NH{q', 17
        if idx >= stor9.length:
            revert with 'NH{q', 50
        mem[0] = stor9[idx]
        mem[32] = 4
        _116 = mem[64]
        mem[64] = mem[64] + 64
        mem[_116] = 30
        mem[_116 + 32] = 'SafeMath: subtraction overflow'
        if stor4[stor9[idx]] <= s:
            if s < stor4[stor9[idx]]:
                revert with 'NH{q', 17
            if idx == -1:
                revert with 'NH{q', 17
            idx = idx + 1
            s = s - stor4[stor9[idx]]
            t = t - stor3[stor9[idx]]
            continue 
        _121 = mem[64]
        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 32
        mem[mem[64] + 36] = 30
        idx = 0
        while idx < 30:
            mem[_121 + idx + 68] = mem[_116 + idx + 32]
            idx = idx + 32
            continue 
        mem[_121 + 98] = 0
        revert with memory
          from mem[64]
           len _121 + -mem[64] + 100
    if totalSupply <= 0:
        revert with 0, 'SafeMath: division by zero', 0
    if not totalSupply:
        revert with 'NH{q', 18
    if t >= stor12 / totalSupply:
        if s <= 0:
            revert with 0, 'SafeMath: division by zero', 0
        if not s:
            revert with 'NH{q', 18
        if t / s <= 0:
            revert with 0, 'SafeMath: division by zero', 0
        if not t / s:
            revert with 'NH{q', 18
        return (arg1 / t / s)
    if totalSupply <= 0:
        revert with 0, 'SafeMath: division by zero', 0
    if not totalSupply:
        revert with 'NH{q', 18
    if stor12 / totalSupply <= 0:
        revert with 0, 'SafeMath: division by zero', 0
    if not stor12 / totalSupply:
        revert with 'NH{q', 18
    return (arg1 / stor12 / totalSupply)
}

function balanceOf(address arg1) payable {
    mem[64] = 96
    require not msg.value
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if stor6[address(arg1)]:
        return stor4[address(arg1)]
    mem[0] = arg1
    mem[32] = 3
    if stor3[address(arg1)] > stor12:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Amount must be less than total reflections'
    idx = 0
    s = totalSupply
    t = stor12
    while idx < stor9.length:
        mem[0] = stor9[idx]
        mem[32] = 3
        if stor3[stor9[idx]] > t:
            _97 = mem[64]
            mem[64] = mem[64] + 64
            mem[_97] = 26
            mem[_97 + 32] = 'SafeMath: division by zero'
            if totalSupply <= 0:
                _101 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_101 + idx + 68] = mem[_97 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_101 + 94] = 0
                revert with memory
                  from mem[64]
                   len _101 + -mem[64] + 100
            if not totalSupply:
                revert with 'NH{q', 18
            _117 = mem[64]
            mem[64] = mem[64] + 64
            mem[_117] = 26
            mem[_117 + 32] = 'SafeMath: division by zero'
            if stor12 / totalSupply > 0:
                if not stor12 / totalSupply:
                    revert with 'NH{q', 18
                return (stor3[address(arg1)] / stor12 / totalSupply)
            _124 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[_124 + idx + 68] = mem[_117 + idx + 32]
                idx = idx + 32
                continue 
            mem[_124 + 94] = 0
            revert with memory
              from mem[64]
               len _124 + -mem[64] + 100
        if idx >= stor9.length:
            revert with 'NH{q', 50
        mem[0] = stor9[idx]
        mem[32] = 4
        if stor4[stor9[idx]] > s:
            _102 = mem[64]
            mem[64] = mem[64] + 64
            mem[_102] = 26
            mem[_102 + 32] = 'SafeMath: division by zero'
            if totalSupply <= 0:
                _104 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_104 + idx + 68] = mem[_102 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_104 + 94] = 0
                revert with memory
                  from mem[64]
                   len _104 + -mem[64] + 100
            if not totalSupply:
                revert with 'NH{q', 18
            _125 = mem[64]
            mem[64] = mem[64] + 64
            mem[_125] = 26
            mem[_125 + 32] = 'SafeMath: division by zero'
            if stor12 / totalSupply > 0:
                if not stor12 / totalSupply:
                    revert with 'NH{q', 18
                return (stor3[address(arg1)] / stor12 / totalSupply)
            _128 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[_128 + idx + 68] = mem[_125 + idx + 32]
                idx = idx + 32
                continue 
            mem[_128 + 94] = 0
            revert with memory
              from mem[64]
               len _128 + -mem[64] + 100
        if idx >= stor9.length:
            revert with 'NH{q', 50
        mem[0] = stor9[idx]
        mem[32] = 3
        _100 = mem[64]
        mem[64] = mem[64] + 64
        mem[_100] = 30
        mem[_100 + 32] = 'SafeMath: subtraction overflow'
        if stor3[stor9[idx]] > t:
            _103 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[_103 + idx + 68] = mem[_100 + idx + 32]
                idx = idx + 32
                continue 
            mem[_103 + 98] = 0
            revert with memory
              from mem[64]
               len _103 + -mem[64] + 100
        if t < stor3[stor9[idx]]:
            revert with 'NH{q', 17
        if idx >= stor9.length:
            revert with 'NH{q', 50
        mem[0] = stor9[idx]
        mem[32] = 4
        _121 = mem[64]
        mem[64] = mem[64] + 64
        mem[_121] = 30
        mem[_121 + 32] = 'SafeMath: subtraction overflow'
        if stor4[stor9[idx]] <= s:
            if s < stor4[stor9[idx]]:
                revert with 'NH{q', 17
            if idx == -1:
                revert with 'NH{q', 17
            idx = idx + 1
            s = s - stor4[stor9[idx]]
            t = t - stor3[stor9[idx]]
            continue 
        _126 = mem[64]
        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 32
        mem[mem[64] + 36] = 30
        idx = 0
        while idx < 30:
            mem[_126 + idx + 68] = mem[_121 + idx + 32]
            idx = idx + 32
            continue 
        mem[_126 + 98] = 0
        revert with memory
          from mem[64]
           len _126 + -mem[64] + 100
    if totalSupply <= 0:
        revert with 0, 'SafeMath: division by zero', 0
    if not totalSupply:
        revert with 'NH{q', 18
    if t >= stor12 / totalSupply:
        if s <= 0:
            revert with 0, 'SafeMath: division by zero', 0
        if not s:
            revert with 'NH{q', 18
        if t / s <= 0:
            revert with 0, 'SafeMath: division by zero', 0
        if not t / s:
            revert with 'NH{q', 18
        return (stor3[address(arg1)] / t / s)
    if totalSupply <= 0:
        revert with 0, 'SafeMath: division by zero', 0
    if not totalSupply:
        revert with 'NH{q', 18
    if stor12 / totalSupply <= 0:
        revert with 0, 'SafeMath: division by zero', 0
    if not stor12 / totalSupply:
        revert with 'NH{q', 18
    return (stor3[address(arg1)] / stor12 / totalSupply)
}

function excludeFromReward(address arg1) payable {
    mem[64] = 96
    require not msg.value
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if stor6[address(arg1)]:
        revert with 0, 'Account is already excluded'
    if stor3[address(arg1)] > 0:
        mem[0] = arg1
        mem[32] = 3
        if stor3[address(arg1)] > stor12:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Amount must be less than total reflections'
        idx = 0
        s = totalSupply
        t = stor12
        while idx < stor9.length:
            mem[0] = stor9[idx]
            mem[32] = 3
            if stor3[stor9[idx]] > t:
                _105 = mem[64]
                mem[64] = mem[64] + 64
                mem[_105] = 26
                mem[_105 + 32] = 'SafeMath: division by zero'
                if totalSupply <= 0:
                    _109 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_109 + idx + 68] = mem[_105 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_109 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _109 + -mem[64] + 100
                if not totalSupply:
                    revert with 'NH{q', 18
                _125 = mem[64]
                mem[64] = mem[64] + 64
                mem[_125] = 26
                mem[_125 + 32] = 'SafeMath: division by zero'
                if stor12 / totalSupply > 0:
                    if not stor12 / totalSupply:
                        revert with 'NH{q', 18
                    stor4[address(arg1)] = stor3[address(arg1)] / stor12 / totalSupply
                    stor6[address(arg1)] = 1
                    stor9.length++
                    stor9[stor9.length] = arg1
                _132 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_132 + idx + 68] = mem[_125 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_132 + 94] = 0
                revert with memory
                  from mem[64]
                   len _132 + -mem[64] + 100
            if idx >= stor9.length:
                revert with 'NH{q', 50
            mem[0] = stor9[idx]
            mem[32] = 4
            if stor4[stor9[idx]] > s:
                _110 = mem[64]
                mem[64] = mem[64] + 64
                mem[_110] = 26
                mem[_110 + 32] = 'SafeMath: division by zero'
                if totalSupply <= 0:
                    _112 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_112 + idx + 68] = mem[_110 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_112 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _112 + -mem[64] + 100
                if not totalSupply:
                    revert with 'NH{q', 18
                _133 = mem[64]
                mem[64] = mem[64] + 64
                mem[_133] = 26
                mem[_133 + 32] = 'SafeMath: division by zero'
                if stor12 / totalSupply > 0:
                    if not stor12 / totalSupply:
                        revert with 'NH{q', 18
                    stor4[address(arg1)] = stor3[address(arg1)] / stor12 / totalSupply
                    stor6[address(arg1)] = 1
                    stor9.length++
                    stor9[stor9.length] = arg1
                _136 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_136 + idx + 68] = mem[_133 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_136 + 94] = 0
                revert with memory
                  from mem[64]
                   len _136 + -mem[64] + 100
            if idx >= stor9.length:
                revert with 'NH{q', 50
            mem[0] = stor9[idx]
            mem[32] = 3
            _108 = mem[64]
            mem[64] = mem[64] + 64
            mem[_108] = 30
            mem[_108 + 32] = 'SafeMath: subtraction overflow'
            if stor3[stor9[idx]] > t:
                _111 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_111 + idx + 68] = mem[_108 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_111 + 98] = 0
                revert with memory
                  from mem[64]
                   len _111 + -mem[64] + 100
            if t < stor3[stor9[idx]]:
                revert with 'NH{q', 17
            if idx >= stor9.length:
                revert with 'NH{q', 50
            mem[0] = stor9[idx]
            mem[32] = 4
            _129 = mem[64]
            mem[64] = mem[64] + 64
            mem[_129] = 30
            mem[_129 + 32] = 'SafeMath: subtraction overflow'
            if stor4[stor9[idx]] <= s:
                if s < stor4[stor9[idx]]:
                    revert with 'NH{q', 17
                if idx == -1:
                    revert with 'NH{q', 17
                idx = idx + 1
                s = s - stor4[stor9[idx]]
                t = t - stor3[stor9[idx]]
                continue 
            _134 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[_134 + idx + 68] = mem[_129 + idx + 32]
                idx = idx + 32
                continue 
            mem[_134 + 98] = 0
            revert with memory
              from mem[64]
               len _134 + -mem[64] + 100
        if totalSupply <= 0:
            revert with 0, 'SafeMath: division by zero', 0
        if not totalSupply:
            revert with 'NH{q', 18
        if t >= stor12 / totalSupply:
            if s <= 0:
                revert with 0, 'SafeMath: division by zero', 0
            if not s:
                revert with 'NH{q', 18
            if t / s <= 0:
                revert with 0, 'SafeMath: division by zero', 0
            if not t / s:
                revert with 'NH{q', 18
            stor4[address(arg1)] = stor3[address(arg1)] / t / s
        else:
            if totalSupply <= 0:
                revert with 0, 'SafeMath: division by zero', 0
            if not totalSupply:
                revert with 'NH{q', 18
            if stor12 / totalSupply <= 0:
                revert with 0, 'SafeMath: division by zero', 0
            if not stor12 / totalSupply:
                revert with 'NH{q', 18
            stor4[address(arg1)] = stor3[address(arg1)] / stor12 / totalSupply
    stor6[address(arg1)] = 1
    stor9.length++
    stor9[stor9.length] = arg1
}

function reflectionFromToken(uint256 arg1, bool arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    if arg1 > totalSupply:
        revert with 0, 'Amount must be less than supply'
    if arg2:
        if not arg1:
            mem[96] = 26
            mem[128] = 'SafeMath: division by zero'
            if not arg1:
                mem[160] = 26
                mem[192] = 'SafeMath: division by zero'
                if not arg1:
                    mem[224] = 26
                    mem[256] = 'SafeMath: division by zero'
                    mem[288] = 30
                    mem[320] = 'SafeMath: subtraction overflow'
                    if 0 > arg1:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 < 0:
                        revert with 'NH{q', 17
                    mem[352] = 30
                    mem[384] = 'SafeMath: subtraction overflow'
                    if 0 > arg1:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 < 0:
                        revert with 'NH{q', 17
                    mem[64] = 480
                    mem[416] = 30
                    mem[448] = 'SafeMath: subtraction overflow'
                    if 0 > arg1:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 < 0:
                        revert with 'NH{q', 17
                    idx = 0
                    s = totalSupply
                    t = stor12
                    while idx < stor9.length:
                        mem[0] = stor9[idx]
                        mem[32] = 3
                        if stor3[stor9[idx]] > t:
                            _2285 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2285] = 26
                            mem[_2285 + 32] = 'SafeMath: division by zero'
                            if totalSupply <= 0:
                                _2425 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_2425 + idx + 68] = mem[_2285 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2425 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _2425 + -mem[64] + 100
                            if not totalSupply:
                                revert with 'NH{q', 18
                            if not arg1:
                                return 0
                            if arg1 and stor12 / totalSupply > -1 / arg1:
                                revert with 'NH{q', 17
                            if not arg1:
                                revert with 'NH{q', 18
                            if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _3326 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3326] = 30
                            mem[_3326 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor12 / totalSupply:
                                _3385 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_3385 + idx + 68] = mem[_3326 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3385 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _3385 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _3874 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3874] = 30
                            mem[_3874 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor12 / totalSupply:
                                _4009 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_4009 + idx + 68] = mem[_3874 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4009 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _4009 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _4914 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4914] = 30
                            mem[_4914 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor12 / totalSupply:
                                if arg1 * stor12 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                return (arg1 * stor12 / totalSupply)
                            _5157 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_5157 + idx + 68] = mem[_4914 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5157 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5157 + -mem[64] + 100
                        if idx >= stor9.length:
                            revert with 'NH{q', 50
                        mem[0] = stor9[idx]
                        mem[32] = 4
                        if stor4[stor9[idx]] <= s:
                            if idx >= stor9.length:
                                revert with 'NH{q', 50
                            mem[0] = stor9[idx]
                            mem[32] = 3
                            _2375 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2375] = 30
                            mem[_2375 + 32] = 'SafeMath: subtraction overflow'
                            if stor3[stor9[idx]] > t:
                                _2450 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_2450 + idx + 68] = mem[_2375 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2450 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _2450 + -mem[64] + 100
                            if t < stor3[stor9[idx]]:
                                revert with 'NH{q', 17
                            if idx >= stor9.length:
                                revert with 'NH{q', 50
                            mem[0] = stor9[idx]
                            mem[32] = 4
                            _2722 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2722] = 30
                            mem[_2722 + 32] = 'SafeMath: subtraction overflow'
                            if stor4[stor9[idx]] <= s:
                                if s < stor4[stor9[idx]]:
                                    revert with 'NH{q', 17
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                s = s - stor4[stor9[idx]]
                                t = t - stor3[stor9[idx]]
                                continue 
                            _2770 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_2770 + idx + 68] = mem[_2722 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2770 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _2770 + -mem[64] + 100
                        _2426 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2426] = 26
                        mem[_2426 + 32] = 'SafeMath: division by zero'
                        if totalSupply <= 0:
                            _2466 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2466 + idx + 68] = mem[_2426 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2466 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2466 + -mem[64] + 100
                        if not totalSupply:
                            revert with 'NH{q', 18
                        if not arg1:
                            return 0
                        if arg1 and stor12 / totalSupply > -1 / arg1:
                            revert with 'NH{q', 17
                        if not arg1:
                            revert with 'NH{q', 18
                        if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _3386 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3386] = 30
                        mem[_3386 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _3490 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_3490 + idx + 68] = mem[_3386 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3490 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _3490 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _4010 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4010] = 30
                        mem[_4010 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _4188 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_4188 + idx + 68] = mem[_4010 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_4188 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _4188 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _5158 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5158] = 30
                        mem[_5158 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= arg1 * stor12 / totalSupply:
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 'NH{q', 17
                            return (arg1 * stor12 / totalSupply)
                        _5508 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_5508 + idx + 68] = mem[_5158 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_5508 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _5508 + -mem[64] + 100
                    if totalSupply <= 0:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not totalSupply:
                        revert with 'NH{q', 18
                    if t >= stor12 / totalSupply:
                        if s <= 0:
                            revert with 0, 'SafeMath: division by zero', 0
                        if not s:
                            revert with 'NH{q', 18
                        if not arg1:
                            return 0
                        if arg1 and t / s > -1 / arg1:
                            revert with 'NH{q', 17
                        if not arg1:
                            revert with 'NH{q', 18
                        if arg1 * t / s / arg1 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 'NH{q', 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 'NH{q', 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 'NH{q', 17
                        return (arg1 * t / s)
                    if totalSupply <= 0:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not totalSupply:
                        revert with 'NH{q', 18
                    if not arg1:
                        return 0
                    if arg1 and stor12 / totalSupply > -1 / arg1:
                        revert with 'NH{q', 17
                    if not arg1:
                        revert with 'NH{q', 18
                    if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 'NH{q', 17
                    if 0 > arg1 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 'NH{q', 17
                    if 0 > arg1 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 'NH{q', 17
                    return (arg1 * stor12 / totalSupply)
                if arg1 and _burnFee > -1 / arg1:
                    revert with 'NH{q', 17
                if not arg1:
                    revert with 'NH{q', 18
                if arg1 * _burnFee / arg1 != _burnFee:
                    revert with 0, 'SafeMath: multiplication overflow'
                mem[224] = 26
                mem[256] = 'SafeMath: division by zero'
                mem[288] = 30
                mem[320] = 'SafeMath: subtraction overflow'
                if 0 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < 0:
                    revert with 'NH{q', 17
                mem[352] = 30
                mem[384] = 'SafeMath: subtraction overflow'
                if 0 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < 0:
                    revert with 'NH{q', 17
                mem[64] = 480
                mem[416] = 30
                mem[448] = 'SafeMath: subtraction overflow'
                if arg1 * _burnFee / 10000 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < arg1 * _burnFee / 10000:
                    revert with 'NH{q', 17
                idx = 0
                s = totalSupply
                t = stor12
                while idx < stor9.length:
                    mem[0] = stor9[idx]
                    mem[32] = 3
                    if stor3[stor9[idx]] > t:
                        _2278 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2278] = 26
                        mem[_2278 + 32] = 'SafeMath: division by zero'
                        if totalSupply <= 0:
                            _2423 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2423 + idx + 68] = mem[_2278 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2423 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2423 + -mem[64] + 100
                        if not totalSupply:
                            revert with 'NH{q', 18
                        if not arg1:
                            if not arg1 * _burnFee / 10000:
                                return 0
                            if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                                revert with 'NH{q', 17
                            if not arg1 * _burnFee / 10000:
                                revert with 'NH{q', 18
                            if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _3325 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3325] = 30
                            mem[_3325 + 32] = 'SafeMath: subtraction overflow'
                            _3871 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3871] = 30
                            mem[_3871 + 32] = 'SafeMath: subtraction overflow'
                            _4911 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4911] = 30
                            mem[_4911 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _burnFee / 10000 * stor12 / totalSupply <= 0:
                                if 0 < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                                    revert with 'NH{q', 17
                                return (-1 * arg1 * _burnFee / 10000 * stor12 / totalSupply)
                            _5154 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_5154 + idx + 68] = mem[_4911 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5154 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5154 + -mem[64] + 100
                        if arg1 and stor12 / totalSupply > -1 / arg1:
                            revert with 'NH{q', 17
                        if not arg1:
                            revert with 'NH{q', 18
                        if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _burnFee / 10000:
                            _3324 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3324] = 30
                            mem[_3324 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor12 / totalSupply:
                                _3382 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_3382 + idx + 68] = mem[_3324 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3382 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _3382 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _3870 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3870] = 30
                            mem[_3870 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor12 / totalSupply:
                                _4005 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_4005 + idx + 68] = mem[_3870 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4005 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _4005 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _4910 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4910] = 30
                            mem[_4910 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor12 / totalSupply:
                                if arg1 * stor12 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                return (arg1 * stor12 / totalSupply)
                            _5153 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_5153 + idx + 68] = mem[_4910 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5153 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5153 + -mem[64] + 100
                        if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                            revert with 'NH{q', 17
                        if not arg1 * _burnFee / 10000:
                            revert with 'NH{q', 18
                        if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _4114 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4114] = 30
                        mem[_4114 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _4267 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_4267 + idx + 68] = mem[_4114 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_4267 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _4267 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _5333 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5333] = 30
                        mem[_5333 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _5645 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_5645 + idx + 68] = mem[_5333 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5645 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5645 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _7046 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_7046] = 30
                        mem[_7046 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _burnFee / 10000 * stor12 / totalSupply <= arg1 * stor12 / totalSupply:
                            if arg1 * stor12 / totalSupply < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                                revert with 'NH{q', 17
                            return ((arg1 * stor12 / totalSupply) - (arg1 * _burnFee / 10000 * stor12 / totalSupply))
                        _7425 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_7425 + idx + 68] = mem[_7046 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_7425 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _7425 + -mem[64] + 100
                    if idx >= stor9.length:
                        revert with 'NH{q', 50
                    mem[0] = stor9[idx]
                    mem[32] = 4
                    if stor4[stor9[idx]] <= s:
                        if idx >= stor9.length:
                            revert with 'NH{q', 50
                        mem[0] = stor9[idx]
                        mem[32] = 3
                        _2371 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2371] = 30
                        mem[_2371 + 32] = 'SafeMath: subtraction overflow'
                        if stor3[stor9[idx]] > t:
                            _2449 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_2449 + idx + 68] = mem[_2371 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2449 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _2449 + -mem[64] + 100
                        if t < stor3[stor9[idx]]:
                            revert with 'NH{q', 17
                        if idx >= stor9.length:
                            revert with 'NH{q', 50
                        mem[0] = stor9[idx]
                        mem[32] = 4
                        _2721 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2721] = 30
                        mem[_2721 + 32] = 'SafeMath: subtraction overflow'
                        if stor4[stor9[idx]] <= s:
                            if s < stor4[stor9[idx]]:
                                revert with 'NH{q', 17
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            s = s - stor4[stor9[idx]]
                            t = t - stor3[stor9[idx]]
                            continue 
                        _2769 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_2769 + idx + 68] = mem[_2721 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2769 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _2769 + -mem[64] + 100
                    _2424 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2424] = 26
                    mem[_2424 + 32] = 'SafeMath: division by zero'
                    if totalSupply <= 0:
                        _2465 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2465 + idx + 68] = mem[_2424 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2465 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2465 + -mem[64] + 100
                    if not totalSupply:
                        revert with 'NH{q', 18
                    if not arg1:
                        if not arg1 * _burnFee / 10000:
                            return 0
                        if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                            revert with 'NH{q', 17
                        if not arg1 * _burnFee / 10000:
                            revert with 'NH{q', 18
                        if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _3384 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3384] = 30
                        mem[_3384 + 32] = 'SafeMath: subtraction overflow'
                        _4008 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4008] = 30
                        mem[_4008 + 32] = 'SafeMath: subtraction overflow'
                        _5156 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5156] = 30
                        mem[_5156 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _burnFee / 10000 * stor12 / totalSupply <= 0:
                            if 0 < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                                revert with 'NH{q', 17
                            return (-1 * arg1 * _burnFee / 10000 * stor12 / totalSupply)
                        _5505 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_5505 + idx + 68] = mem[_5156 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_5505 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _5505 + -mem[64] + 100
                    if arg1 and stor12 / totalSupply > -1 / arg1:
                        revert with 'NH{q', 17
                    if not arg1:
                        revert with 'NH{q', 18
                    if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _burnFee / 10000:
                        _3383 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3383] = 30
                        mem[_3383 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _3489 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_3489 + idx + 68] = mem[_3383 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3489 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _3489 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _4007 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4007] = 30
                        mem[_4007 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _4187 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_4187 + idx + 68] = mem[_4007 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_4187 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _4187 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _5155 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5155] = 30
                        mem[_5155 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= arg1 * stor12 / totalSupply:
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 'NH{q', 17
                            return (arg1 * stor12 / totalSupply)
                        _5504 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_5504 + idx + 68] = mem[_5155 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_5504 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _5504 + -mem[64] + 100
                    if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                        revert with 'NH{q', 17
                    if not arg1 * _burnFee / 10000:
                        revert with 'NH{q', 18
                    if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _4270 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4270] = 30
                    mem[_4270 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor12 / totalSupply:
                        _4448 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_4448 + idx + 68] = mem[_4270 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4448 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _4448 + -mem[64] + 100
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 'NH{q', 17
                    _5650 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5650] = 30
                    mem[_5650 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor12 / totalSupply:
                        _5937 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_5937 + idx + 68] = mem[_5650 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_5937 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _5937 + -mem[64] + 100
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 'NH{q', 17
                    _7428 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_7428] = 30
                    mem[_7428 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _burnFee / 10000 * stor12 / totalSupply <= arg1 * stor12 / totalSupply:
                        if arg1 * stor12 / totalSupply < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                            revert with 'NH{q', 17
                        return ((arg1 * stor12 / totalSupply) - (arg1 * _burnFee / 10000 * stor12 / totalSupply))
                    _7790 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_7790 + idx + 68] = mem[_7428 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_7790 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _7790 + -mem[64] + 100
                if totalSupply <= 0:
                    revert with 0, 'SafeMath: division by zero', 0
                if not totalSupply:
                    revert with 'NH{q', 18
                if t >= stor12 / totalSupply:
                    if s <= 0:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not s:
                        revert with 'NH{q', 18
                    if not arg1:
                        if not arg1 * _burnFee / 10000:
                            return 0
                        if arg1 * _burnFee / 10000 and t / s > -1 / arg1 * _burnFee / 10000:
                            revert with 'NH{q', 17
                        if not arg1 * _burnFee / 10000:
                            revert with 'NH{q', 18
                        if arg1 * _burnFee / 10000 * t / s / arg1 * _burnFee / 10000 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * _burnFee / 10000 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _burnFee / 10000 * t / s:
                            revert with 'NH{q', 17
                        return (-1 * arg1 * _burnFee / 10000 * t / s)
                    if arg1 and t / s > -1 / arg1:
                        revert with 'NH{q', 17
                    if not arg1:
                        revert with 'NH{q', 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _burnFee / 10000:
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 'NH{q', 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 'NH{q', 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 'NH{q', 17
                        return (arg1 * t / s)
                    if arg1 * _burnFee / 10000 and t / s > -1 / arg1 * _burnFee / 10000:
                        revert with 'NH{q', 17
                    if not arg1 * _burnFee / 10000:
                        revert with 'NH{q', 18
                    if arg1 * _burnFee / 10000 * t / s / arg1 * _burnFee / 10000 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 'NH{q', 17
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 'NH{q', 17
                    if arg1 * _burnFee / 10000 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * _burnFee / 10000 * t / s:
                        revert with 'NH{q', 17
                    return ((arg1 * t / s) - (arg1 * _burnFee / 10000 * t / s))
                if totalSupply <= 0:
                    revert with 0, 'SafeMath: division by zero', 0
                if not totalSupply:
                    revert with 'NH{q', 18
                if not arg1:
                    if not arg1 * _burnFee / 10000:
                        return 0
                    if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                        revert with 'NH{q', 17
                    if not arg1 * _burnFee / 10000:
                        revert with 'NH{q', 18
                    if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * _burnFee / 10000 * stor12 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                        revert with 'NH{q', 17
                    return (-1 * arg1 * _burnFee / 10000 * stor12 / totalSupply)
                if arg1 and stor12 / totalSupply > -1 / arg1:
                    revert with 'NH{q', 17
                if not arg1:
                    revert with 'NH{q', 18
                if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _burnFee / 10000:
                    if 0 > arg1 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 'NH{q', 17
                    if 0 > arg1 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 'NH{q', 17
                    if 0 > arg1 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 'NH{q', 17
                    return (arg1 * stor12 / totalSupply)
                if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                    revert with 'NH{q', 17
                if not arg1 * _burnFee / 10000:
                    revert with 'NH{q', 18
                if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 > arg1 * stor12 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor12 / totalSupply < 0:
                    revert with 'NH{q', 17
                if 0 > arg1 * stor12 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor12 / totalSupply < 0:
                    revert with 'NH{q', 17
                if arg1 * _burnFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor12 / totalSupply < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                    revert with 'NH{q', 17
                return ((arg1 * stor12 / totalSupply) - (arg1 * _burnFee / 10000 * stor12 / totalSupply))
            if arg1 and _liquidityFee > -1 / arg1:
                revert with 'NH{q', 17
            if not arg1:
                revert with 'NH{q', 18
            if arg1 * _liquidityFee / arg1 != _liquidityFee:
                revert with 0, 'SafeMath: multiplication overflow'
            mem[160] = 26
            mem[192] = 'SafeMath: division by zero'
            if not arg1:
                mem[224] = 26
                mem[256] = 'SafeMath: division by zero'
                mem[288] = 30
                mem[320] = 'SafeMath: subtraction overflow'
                if 0 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < 0:
                    revert with 'NH{q', 17
                mem[352] = 30
                mem[384] = 'SafeMath: subtraction overflow'
                if arg1 * _liquidityFee / 10000 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < arg1 * _liquidityFee / 10000:
                    revert with 'NH{q', 17
                mem[64] = 480
                mem[416] = 30
                mem[448] = 'SafeMath: subtraction overflow'
                if 0 > arg1 - (arg1 * _liquidityFee / 10000):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * _liquidityFee / 10000) < 0:
                    revert with 'NH{q', 17
                idx = 0
                s = totalSupply
                t = stor12
                while idx < stor9.length:
                    mem[0] = stor9[idx]
                    mem[32] = 3
                    if stor3[stor9[idx]] > t:
                        _2271 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2271] = 26
                        mem[_2271 + 32] = 'SafeMath: division by zero'
                        if totalSupply <= 0:
                            _2421 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2421 + idx + 68] = mem[_2271 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2421 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2421 + -mem[64] + 100
                        if not totalSupply:
                            revert with 'NH{q', 18
                        if not arg1:
                            if not arg1 * _liquidityFee / 10000:
                                return 0
                            if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                                revert with 'NH{q', 17
                            if not arg1 * _liquidityFee / 10000:
                                revert with 'NH{q', 18
                            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _3323 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3323] = 30
                            mem[_3323 + 32] = 'SafeMath: subtraction overflow'
                            _3866 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3866] = 30
                            mem[_3866 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > 0:
                                _4002 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_4002 + idx + 68] = mem[_3866 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4002 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _4002 + -mem[64] + 100
                            if 0 < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                revert with 'NH{q', 17
                            _4907 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4907] = 30
                            mem[_4907 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                if -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                return (-1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply)
                            _5149 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_5149 + idx + 68] = mem[_4907 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5149 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5149 + -mem[64] + 100
                        if arg1 and stor12 / totalSupply > -1 / arg1:
                            revert with 'NH{q', 17
                        if not arg1:
                            revert with 'NH{q', 18
                        if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _liquidityFee / 10000:
                            _3322 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3322] = 30
                            mem[_3322 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor12 / totalSupply:
                                _3379 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_3379 + idx + 68] = mem[_3322 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3379 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _3379 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _3865 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3865] = 30
                            mem[_3865 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor12 / totalSupply:
                                _4001 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_4001 + idx + 68] = mem[_3865 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4001 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _4001 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _4906 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4906] = 30
                            mem[_4906 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor12 / totalSupply:
                                if arg1 * stor12 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                return (arg1 * stor12 / totalSupply)
                            _5148 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_5148 + idx + 68] = mem[_4906 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5148 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5148 + -mem[64] + 100
                        if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                            revert with 'NH{q', 17
                        if not arg1 * _liquidityFee / 10000:
                            revert with 'NH{q', 18
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _4109 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4109] = 30
                        mem[_4109 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _4262 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_4262 + idx + 68] = mem[_4109 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_4262 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _4262 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _5326 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5326] = 30
                        mem[_5326 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                            _5638 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_5638 + idx + 68] = mem[_5326 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5638 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5638 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                            revert with 'NH{q', 17
                        _7035 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_7035] = 30
                        mem[_7035 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                            if (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                                revert with 'NH{q', 17
                            return ((arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply))
                        _7421 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_7421 + idx + 68] = mem[_7035 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_7421 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _7421 + -mem[64] + 100
                    if idx >= stor9.length:
                        revert with 'NH{q', 50
                    mem[0] = stor9[idx]
                    mem[32] = 4
                    if stor4[stor9[idx]] <= s:
                        if idx >= stor9.length:
                            revert with 'NH{q', 50
                        mem[0] = stor9[idx]
                        mem[32] = 3
                        _2367 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2367] = 30
                        mem[_2367 + 32] = 'SafeMath: subtraction overflow'
                        if stor3[stor9[idx]] > t:
                            _2448 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_2448 + idx + 68] = mem[_2367 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2448 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _2448 + -mem[64] + 100
                        if t < stor3[stor9[idx]]:
                            revert with 'NH{q', 17
                        if idx >= stor9.length:
                            revert with 'NH{q', 50
                        mem[0] = stor9[idx]
                        mem[32] = 4
                        _2720 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2720] = 30
                        mem[_2720 + 32] = 'SafeMath: subtraction overflow'
                        if stor4[stor9[idx]] <= s:
                            if s < stor4[stor9[idx]]:
                                revert with 'NH{q', 17
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            s = s - stor4[stor9[idx]]
                            t = t - stor3[stor9[idx]]
                            continue 
                        _2768 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_2768 + idx + 68] = mem[_2720 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2768 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _2768 + -mem[64] + 100
                    _2422 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2422] = 26
                    mem[_2422 + 32] = 'SafeMath: division by zero'
                    if totalSupply <= 0:
                        _2464 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2464 + idx + 68] = mem[_2422 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2464 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2464 + -mem[64] + 100
                    if not totalSupply:
                        revert with 'NH{q', 18
                    if not arg1:
                        if not arg1 * _liquidityFee / 10000:
                            return 0
                        if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                            revert with 'NH{q', 17
                        if not arg1 * _liquidityFee / 10000:
                            revert with 'NH{q', 18
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _3381 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3381] = 30
                        mem[_3381 + 32] = 'SafeMath: subtraction overflow'
                        _4004 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4004] = 30
                        mem[_4004 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > 0:
                            _4186 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_4186 + idx + 68] = mem[_4004 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_4186 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _4186 + -mem[64] + 100
                        if 0 < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                            revert with 'NH{q', 17
                        _5151 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5151] = 30
                        mem[_5151 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                            if -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply < 0:
                                revert with 'NH{q', 17
                            return (-1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply)
                        _5500 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_5500 + idx + 68] = mem[_5151 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_5500 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _5500 + -mem[64] + 100
                    if arg1 and stor12 / totalSupply > -1 / arg1:
                        revert with 'NH{q', 17
                    if not arg1:
                        revert with 'NH{q', 18
                    if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _liquidityFee / 10000:
                        _3380 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3380] = 30
                        mem[_3380 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _3488 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_3488 + idx + 68] = mem[_3380 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3488 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _3488 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _4003 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4003] = 30
                        mem[_4003 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _4185 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_4185 + idx + 68] = mem[_4003 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_4185 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _4185 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _5150 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5150] = 30
                        mem[_5150 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= arg1 * stor12 / totalSupply:
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 'NH{q', 17
                            return (arg1 * stor12 / totalSupply)
                        _5499 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_5499 + idx + 68] = mem[_5150 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_5499 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _5499 + -mem[64] + 100
                    if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                        revert with 'NH{q', 17
                    if not arg1 * _liquidityFee / 10000:
                        revert with 'NH{q', 18
                    if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _4266 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4266] = 30
                    mem[_4266 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor12 / totalSupply:
                        _4442 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_4442 + idx + 68] = mem[_4266 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4442 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _4442 + -mem[64] + 100
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 'NH{q', 17
                    _5644 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5644] = 30
                    mem[_5644 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                        _5931 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_5931 + idx + 68] = mem[_5644 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_5931 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _5931 + -mem[64] + 100
                    if arg1 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                        revert with 'NH{q', 17
                    _7424 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_7424] = 30
                    mem[_7424 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                        if (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                            revert with 'NH{q', 17
                        return ((arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply))
                    _7785 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_7785 + idx + 68] = mem[_7424 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_7785 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _7785 + -mem[64] + 100
                if totalSupply <= 0:
                    revert with 0, 'SafeMath: division by zero', 0
                if not totalSupply:
                    revert with 'NH{q', 18
                if t >= stor12 / totalSupply:
                    if s <= 0:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not s:
                        revert with 'NH{q', 18
                    if not arg1:
                        if not arg1 * _liquidityFee / 10000:
                            return 0
                        if arg1 * _liquidityFee / 10000 and t / s > -1 / arg1 * _liquidityFee / 10000:
                            revert with 'NH{q', 17
                        if not arg1 * _liquidityFee / 10000:
                            revert with 'NH{q', 18
                        if arg1 * _liquidityFee / 10000 * t / s / arg1 * _liquidityFee / 10000 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * _liquidityFee / 10000 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _liquidityFee / 10000 * t / s:
                            revert with 'NH{q', 17
                        if 0 > -1 * arg1 * _liquidityFee / 10000 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _liquidityFee / 10000 * t / s < 0:
                            revert with 'NH{q', 17
                        return (-1 * arg1 * _liquidityFee / 10000 * t / s)
                    if arg1 and t / s > -1 / arg1:
                        revert with 'NH{q', 17
                    if not arg1:
                        revert with 'NH{q', 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _liquidityFee / 10000:
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 'NH{q', 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 'NH{q', 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 'NH{q', 17
                        return (arg1 * t / s)
                    if arg1 * _liquidityFee / 10000 and t / s > -1 / arg1 * _liquidityFee / 10000:
                        revert with 'NH{q', 17
                    if not arg1 * _liquidityFee / 10000:
                        revert with 'NH{q', 18
                    if arg1 * _liquidityFee / 10000 * t / s / arg1 * _liquidityFee / 10000 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 'NH{q', 17
                    if arg1 * _liquidityFee / 10000 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * _liquidityFee / 10000 * t / s:
                        revert with 'NH{q', 17
                    if 0 > (arg1 * t / s) - (arg1 * _liquidityFee / 10000 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * _liquidityFee / 10000 * t / s) < 0:
                        revert with 'NH{q', 17
                    return ((arg1 * t / s) - (arg1 * _liquidityFee / 10000 * t / s))
                if totalSupply <= 0:
                    revert with 0, 'SafeMath: division by zero', 0
                if not totalSupply:
                    revert with 'NH{q', 18
                if not arg1:
                    if not arg1 * _liquidityFee / 10000:
                        return 0
                    if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                        revert with 'NH{q', 17
                    if not arg1 * _liquidityFee / 10000:
                        revert with 'NH{q', 18
                    if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                        revert with 'NH{q', 17
                    if 0 > -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply < 0:
                        revert with 'NH{q', 17
                    return (-1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply)
                if arg1 and stor12 / totalSupply > -1 / arg1:
                    revert with 'NH{q', 17
                if not arg1:
                    revert with 'NH{q', 18
                if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _liquidityFee / 10000:
                    if 0 > arg1 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 'NH{q', 17
                    if 0 > arg1 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 'NH{q', 17
                    if 0 > arg1 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 'NH{q', 17
                    return (arg1 * stor12 / totalSupply)
                if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                    revert with 'NH{q', 17
                if not arg1 * _liquidityFee / 10000:
                    revert with 'NH{q', 18
                if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 > arg1 * stor12 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor12 / totalSupply < 0:
                    revert with 'NH{q', 17
                if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                    revert with 'NH{q', 17
                if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                    revert with 'NH{q', 17
                return ((arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply))
            if arg1 and _burnFee > -1 / arg1:
                revert with 'NH{q', 17
            if not arg1:
                revert with 'NH{q', 18
            if arg1 * _burnFee / arg1 != _burnFee:
                revert with 0, 'SafeMath: multiplication overflow'
            mem[224] = 26
            mem[256] = 'SafeMath: division by zero'
            mem[288] = 30
            mem[320] = 'SafeMath: subtraction overflow'
            if 0 > arg1:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 < 0:
                revert with 'NH{q', 17
            mem[352] = 30
            mem[384] = 'SafeMath: subtraction overflow'
            if arg1 * _liquidityFee / 10000 > arg1:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 < arg1 * _liquidityFee / 10000:
                revert with 'NH{q', 17
            mem[64] = 480
            mem[416] = 30
            mem[448] = 'SafeMath: subtraction overflow'
            if arg1 * _burnFee / 10000 > arg1 - (arg1 * _liquidityFee / 10000):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 - (arg1 * _liquidityFee / 10000) < arg1 * _burnFee / 10000:
                revert with 'NH{q', 17
            idx = 0
            s = totalSupply
            t = stor12
            while idx < stor9.length:
                mem[0] = stor9[idx]
                mem[32] = 3
                if stor3[stor9[idx]] > t:
                    _2264 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2264] = 26
                    mem[_2264 + 32] = 'SafeMath: division by zero'
                    if totalSupply <= 0:
                        _2419 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2419 + idx + 68] = mem[_2264 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2419 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2419 + -mem[64] + 100
                    if not totalSupply:
                        revert with 'NH{q', 18
                    if not arg1:
                        if not arg1 * _liquidityFee / 10000:
                            if not arg1 * _burnFee / 10000:
                                return 0
                            if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                                revert with 'NH{q', 17
                            if not arg1 * _burnFee / 10000:
                                revert with 'NH{q', 18
                            if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _3321 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3321] = 30
                            mem[_3321 + 32] = 'SafeMath: subtraction overflow'
                            _3862 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3862] = 30
                            mem[_3862 + 32] = 'SafeMath: subtraction overflow'
                            _4901 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4901] = 30
                            mem[_4901 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _burnFee / 10000 * stor12 / totalSupply <= 0:
                                if 0 < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                                    revert with 'NH{q', 17
                                return (-1 * arg1 * _burnFee / 10000 * stor12 / totalSupply)
                            _5141 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_5141 + idx + 68] = mem[_4901 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5141 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5141 + -mem[64] + 100
                        if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                            revert with 'NH{q', 17
                        if not arg1 * _liquidityFee / 10000:
                            revert with 'NH{q', 18
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _burnFee / 10000:
                            _3320 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3320] = 30
                            mem[_3320 + 32] = 'SafeMath: subtraction overflow'
                            _3861 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3861] = 30
                            mem[_3861 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > 0:
                                _3995 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_3995 + idx + 68] = mem[_3861 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3995 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _3995 + -mem[64] + 100
                            if 0 < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                revert with 'NH{q', 17
                            _4900 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4900] = 30
                            mem[_4900 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                if -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                return (-1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply)
                            _5140 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_5140 + idx + 68] = mem[_4900 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5140 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5140 + -mem[64] + 100
                        if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                            revert with 'NH{q', 17
                        if not arg1 * _burnFee / 10000:
                            revert with 'NH{q', 18
                        if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _4106 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4106] = 30
                        mem[_4106 + 32] = 'SafeMath: subtraction overflow'
                        _5317 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5317] = 30
                        mem[_5317 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > 0:
                            _5629 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_5629 + idx + 68] = mem[_5317 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5629 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5629 + -mem[64] + 100
                        if 0 < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                            revert with 'NH{q', 17
                        _7022 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_7022] = 30
                        mem[_7022 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _burnFee / 10000 * stor12 / totalSupply <= -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                            if -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                                revert with 'NH{q', 17
                            return ((-1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply) - (arg1 * _burnFee / 10000 * stor12 / totalSupply))
                        _7415 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_7415 + idx + 68] = mem[_7022 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_7415 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _7415 + -mem[64] + 100
                    if arg1 and stor12 / totalSupply > -1 / arg1:
                        revert with 'NH{q', 17
                    if not arg1:
                        revert with 'NH{q', 18
                    if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _liquidityFee / 10000:
                        if not arg1 * _burnFee / 10000:
                            _3319 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3319] = 30
                            mem[_3319 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor12 / totalSupply:
                                _3375 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_3375 + idx + 68] = mem[_3319 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3375 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _3375 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _3859 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3859] = 30
                            mem[_3859 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor12 / totalSupply:
                                _3994 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_3994 + idx + 68] = mem[_3859 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3994 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _3994 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _4899 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4899] = 30
                            mem[_4899 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor12 / totalSupply:
                                if arg1 * stor12 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                return (arg1 * stor12 / totalSupply)
                            _5139 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_5139 + idx + 68] = mem[_4899 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5139 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5139 + -mem[64] + 100
                        if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                            revert with 'NH{q', 17
                        if not arg1 * _burnFee / 10000:
                            revert with 'NH{q', 18
                        if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _4105 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4105] = 30
                        mem[_4105 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _4255 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_4255 + idx + 68] = mem[_4105 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_4255 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _4255 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _5316 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5316] = 30
                        mem[_5316 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _5626 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_5626 + idx + 68] = mem[_5316 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5626 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5626 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _7021 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_7021] = 30
                        mem[_7021 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _burnFee / 10000 * stor12 / totalSupply <= arg1 * stor12 / totalSupply:
                            if arg1 * stor12 / totalSupply < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                                revert with 'NH{q', 17
                            return ((arg1 * stor12 / totalSupply) - (arg1 * _burnFee / 10000 * stor12 / totalSupply))
                        _7413 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_7413 + idx + 68] = mem[_7021 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_7413 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _7413 + -mem[64] + 100
                    if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                        revert with 'NH{q', 17
                    if not arg1 * _liquidityFee / 10000:
                        revert with 'NH{q', 18
                    if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _burnFee / 10000:
                        _4104 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4104] = 30
                        mem[_4104 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _4254 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_4254 + idx + 68] = mem[_4104 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_4254 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _4254 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _5315 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5315] = 30
                        mem[_5315 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                            _5625 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_5625 + idx + 68] = mem[_5315 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5625 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5625 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                            revert with 'NH{q', 17
                        _7020 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_7020] = 30
                        mem[_7020 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                            if (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                                revert with 'NH{q', 17
                            return ((arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply))
                        _7412 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_7412 + idx + 68] = mem[_7020 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_7412 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _7412 + -mem[64] + 100
                    if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                        revert with 'NH{q', 17
                    if not arg1 * _burnFee / 10000:
                        revert with 'NH{q', 18
                    if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _5797 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5797] = 30
                    mem[_5797 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor12 / totalSupply:
                        _6056 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_6056 + idx + 68] = mem[_5797 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_6056 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _6056 + -mem[64] + 100
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 'NH{q', 17
                    _7590 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_7590] = 30
                    mem[_7590 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                        _7934 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_7934 + idx + 68] = mem[_7590 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_7934 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _7934 + -mem[64] + 100
                    if arg1 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                        revert with 'NH{q', 17
                    _9231 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9231] = 30
                    mem[_9231 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _burnFee / 10000 * stor12 / totalSupply <= (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                        if (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                            revert with 'NH{q', 17
                        return ((arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) - (arg1 * _burnFee / 10000 * stor12 / totalSupply))
                    _9535 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_9535 + idx + 68] = mem[_9231 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_9535 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _9535 + -mem[64] + 100
                if idx >= stor9.length:
                    revert with 'NH{q', 50
                mem[0] = stor9[idx]
                mem[32] = 4
                if stor4[stor9[idx]] <= s:
                    if idx >= stor9.length:
                        revert with 'NH{q', 50
                    mem[0] = stor9[idx]
                    mem[32] = 3
                    _2363 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2363] = 30
                    mem[_2363 + 32] = 'SafeMath: subtraction overflow'
                    if stor3[stor9[idx]] > t:
                        _2447 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_2447 + idx + 68] = mem[_2363 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2447 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _2447 + -mem[64] + 100
                    if t < stor3[stor9[idx]]:
                        revert with 'NH{q', 17
                    if idx >= stor9.length:
                        revert with 'NH{q', 50
                    mem[0] = stor9[idx]
                    mem[32] = 4
                    _2719 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2719] = 30
                    mem[_2719 + 32] = 'SafeMath: subtraction overflow'
                    if stor4[stor9[idx]] <= s:
                        if s < stor4[stor9[idx]]:
                            revert with 'NH{q', 17
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        s = s - stor4[stor9[idx]]
                        t = t - stor3[stor9[idx]]
                        continue 
                    _2767 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_2767 + idx + 68] = mem[_2719 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2767 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _2767 + -mem[64] + 100
                _2420 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2420] = 26
                mem[_2420 + 32] = 'SafeMath: division by zero'
                if totalSupply <= 0:
                    _2463 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2463 + idx + 68] = mem[_2420 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2463 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2463 + -mem[64] + 100
                if not totalSupply:
                    revert with 'NH{q', 18
                if not arg1:
                    if not arg1 * _liquidityFee / 10000:
                        if not arg1 * _burnFee / 10000:
                            return 0
                        if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                            revert with 'NH{q', 17
                        if not arg1 * _burnFee / 10000:
                            revert with 'NH{q', 18
                        if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _3378 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3378] = 30
                        mem[_3378 + 32] = 'SafeMath: subtraction overflow'
                        _4000 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4000] = 30
                        mem[_4000 + 32] = 'SafeMath: subtraction overflow'
                        _5144 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5144] = 30
                        mem[_5144 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _burnFee / 10000 * stor12 / totalSupply <= 0:
                            if 0 < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                                revert with 'NH{q', 17
                            return (-1 * arg1 * _burnFee / 10000 * stor12 / totalSupply)
                        _5495 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_5495 + idx + 68] = mem[_5144 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_5495 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _5495 + -mem[64] + 100
                    if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                        revert with 'NH{q', 17
                    if not arg1 * _liquidityFee / 10000:
                        revert with 'NH{q', 18
                    if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _burnFee / 10000:
                        _3377 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3377] = 30
                        mem[_3377 + 32] = 'SafeMath: subtraction overflow'
                        _3999 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3999] = 30
                        mem[_3999 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > 0:
                            _4183 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_4183 + idx + 68] = mem[_3999 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_4183 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _4183 + -mem[64] + 100
                        if 0 < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                            revert with 'NH{q', 17
                        _5143 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5143] = 30
                        mem[_5143 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                            if -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply < 0:
                                revert with 'NH{q', 17
                            return (-1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply)
                        _5494 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_5494 + idx + 68] = mem[_5143 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_5494 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _5494 + -mem[64] + 100
                    if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                        revert with 'NH{q', 17
                    if not arg1 * _burnFee / 10000:
                        revert with 'NH{q', 18
                    if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _4261 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4261] = 30
                    mem[_4261 + 32] = 'SafeMath: subtraction overflow'
                    _5637 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5637] = 30
                    mem[_5637 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > 0:
                        _5926 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_5926 + idx + 68] = mem[_5637 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_5926 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _5926 + -mem[64] + 100
                    if 0 < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                        revert with 'NH{q', 17
                    _7420 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_7420] = 30
                    mem[_7420 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _burnFee / 10000 * stor12 / totalSupply <= -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                        if -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                            revert with 'NH{q', 17
                        return ((-1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply) - (arg1 * _burnFee / 10000 * stor12 / totalSupply))
                    _7780 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_7780 + idx + 68] = mem[_7420 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_7780 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _7780 + -mem[64] + 100
                if arg1 and stor12 / totalSupply > -1 / arg1:
                    revert with 'NH{q', 17
                if not arg1:
                    revert with 'NH{q', 18
                if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _liquidityFee / 10000:
                    if not arg1 * _burnFee / 10000:
                        _3376 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3376] = 30
                        mem[_3376 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _3487 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_3487 + idx + 68] = mem[_3376 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3487 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _3487 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _3997 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3997] = 30
                        mem[_3997 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _4182 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_4182 + idx + 68] = mem[_3997 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_4182 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _4182 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _5142 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5142] = 30
                        mem[_5142 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= arg1 * stor12 / totalSupply:
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 'NH{q', 17
                            return (arg1 * stor12 / totalSupply)
                        _5493 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_5493 + idx + 68] = mem[_5142 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_5493 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _5493 + -mem[64] + 100
                    if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                        revert with 'NH{q', 17
                    if not arg1 * _burnFee / 10000:
                        revert with 'NH{q', 18
                    if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _4260 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4260] = 30
                    mem[_4260 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor12 / totalSupply:
                        _4436 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_4436 + idx + 68] = mem[_4260 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4436 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _4436 + -mem[64] + 100
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 'NH{q', 17
                    _5636 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5636] = 30
                    mem[_5636 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor12 / totalSupply:
                        _5923 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_5923 + idx + 68] = mem[_5636 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_5923 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _5923 + -mem[64] + 100
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 'NH{q', 17
                    _7419 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_7419] = 30
                    mem[_7419 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _burnFee / 10000 * stor12 / totalSupply <= arg1 * stor12 / totalSupply:
                        if arg1 * stor12 / totalSupply < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                            revert with 'NH{q', 17
                        return ((arg1 * stor12 / totalSupply) - (arg1 * _burnFee / 10000 * stor12 / totalSupply))
                    _7778 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_7778 + idx + 68] = mem[_7419 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_7778 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _7778 + -mem[64] + 100
                if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                    revert with 'NH{q', 17
                if not arg1 * _liquidityFee / 10000:
                    revert with 'NH{q', 18
                if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _burnFee / 10000:
                    _4259 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4259] = 30
                    mem[_4259 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor12 / totalSupply:
                        _4435 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_4435 + idx + 68] = mem[_4259 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4435 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _4435 + -mem[64] + 100
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 'NH{q', 17
                    _5635 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5635] = 30
                    mem[_5635 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                        _5922 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_5922 + idx + 68] = mem[_5635 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_5922 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _5922 + -mem[64] + 100
                    if arg1 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                        revert with 'NH{q', 17
                    _7418 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_7418] = 30
                    mem[_7418 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                        if (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                            revert with 'NH{q', 17
                        return ((arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply))
                    _7777 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_7777 + idx + 68] = mem[_7418 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_7777 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _7777 + -mem[64] + 100
                if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                    revert with 'NH{q', 17
                if not arg1 * _burnFee / 10000:
                    revert with 'NH{q', 18
                if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                _6062 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6062] = 30
                mem[_6062 + 32] = 'SafeMath: subtraction overflow'
                if 0 > arg1 * stor12 / totalSupply:
                    _6338 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_6338 + idx + 68] = mem[_6062 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_6338 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _6338 + -mem[64] + 100
                if arg1 * stor12 / totalSupply < 0:
                    revert with 'NH{q', 17
                _7944 = mem[64]
                mem[64] = mem[64] + 64
                mem[_7944] = 30
                mem[_7944 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                    _8263 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_8263 + idx + 68] = mem[_7944 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_8263 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _8263 + -mem[64] + 100
                if arg1 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                    revert with 'NH{q', 17
                _9539 = mem[64]
                mem[64] = mem[64] + 64
                mem[_9539] = 30
                mem[_9539 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _burnFee / 10000 * stor12 / totalSupply <= (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                    if (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                        revert with 'NH{q', 17
                    return ((arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) - (arg1 * _burnFee / 10000 * stor12 / totalSupply))
                _9707 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_9707 + idx + 68] = mem[_9539 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_9707 + 98] = 0
                revert with memory
                  from mem[64]
                   len _9707 + -mem[64] + 100
            if totalSupply <= 0:
                revert with 0, 'SafeMath: division by zero', 0
            if not totalSupply:
                revert with 'NH{q', 18
            if t >= stor12 / totalSupply:
                if s <= 0:
                    revert with 0, 'SafeMath: division by zero', 0
                if not s:
                    revert with 'NH{q', 18
                if not arg1:
                    if not arg1 * _liquidityFee / 10000:
                        if not arg1 * _burnFee / 10000:
                            return 0
                        if arg1 * _burnFee / 10000 and t / s > -1 / arg1 * _burnFee / 10000:
                            revert with 'NH{q', 17
                        if not arg1 * _burnFee / 10000:
                            revert with 'NH{q', 18
                        if arg1 * _burnFee / 10000 * t / s / arg1 * _burnFee / 10000 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * _burnFee / 10000 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _burnFee / 10000 * t / s:
                            revert with 'NH{q', 17
                        return (-1 * arg1 * _burnFee / 10000 * t / s)
                    if arg1 * _liquidityFee / 10000 and t / s > -1 / arg1 * _liquidityFee / 10000:
                        revert with 'NH{q', 17
                    if not arg1 * _liquidityFee / 10000:
                        revert with 'NH{q', 18
                    if arg1 * _liquidityFee / 10000 * t / s / arg1 * _liquidityFee / 10000 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _burnFee / 10000:
                        if arg1 * _liquidityFee / 10000 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _liquidityFee / 10000 * t / s:
                            revert with 'NH{q', 17
                        if 0 > -1 * arg1 * _liquidityFee / 10000 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _liquidityFee / 10000 * t / s < 0:
                            revert with 'NH{q', 17
                        return (-1 * arg1 * _liquidityFee / 10000 * t / s)
                    if arg1 * _burnFee / 10000 and t / s > -1 / arg1 * _burnFee / 10000:
                        revert with 'NH{q', 17
                    if not arg1 * _burnFee / 10000:
                        revert with 'NH{q', 18
                    if arg1 * _burnFee / 10000 * t / s / arg1 * _burnFee / 10000 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * _liquidityFee / 10000 * t / s > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _liquidityFee / 10000 * t / s:
                        revert with 'NH{q', 17
                    if arg1 * _burnFee / 10000 * t / s > -1 * arg1 * _liquidityFee / 10000 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _liquidityFee / 10000 * t / s < arg1 * _burnFee / 10000 * t / s:
                        revert with 'NH{q', 17
                    return ((-1 * arg1 * _liquidityFee / 10000 * t / s) - (arg1 * _burnFee / 10000 * t / s))
                if arg1 and t / s > -1 / arg1:
                    revert with 'NH{q', 17
                if not arg1:
                    revert with 'NH{q', 18
                if arg1 * t / s / arg1 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _liquidityFee / 10000:
                    if not arg1 * _burnFee / 10000:
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 'NH{q', 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 'NH{q', 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 'NH{q', 17
                        return (arg1 * t / s)
                    if arg1 * _burnFee / 10000 and t / s > -1 / arg1 * _burnFee / 10000:
                        revert with 'NH{q', 17
                    if not arg1 * _burnFee / 10000:
                        revert with 'NH{q', 18
                    if arg1 * _burnFee / 10000 * t / s / arg1 * _burnFee / 10000 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 'NH{q', 17
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 'NH{q', 17
                    if arg1 * _burnFee / 10000 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * _burnFee / 10000 * t / s:
                        revert with 'NH{q', 17
                    return ((arg1 * t / s) - (arg1 * _burnFee / 10000 * t / s))
                if arg1 * _liquidityFee / 10000 and t / s > -1 / arg1 * _liquidityFee / 10000:
                    revert with 'NH{q', 17
                if not arg1 * _liquidityFee / 10000:
                    revert with 'NH{q', 18
                if arg1 * _liquidityFee / 10000 * t / s / arg1 * _liquidityFee / 10000 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _burnFee / 10000:
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 'NH{q', 17
                    if arg1 * _liquidityFee / 10000 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * _liquidityFee / 10000 * t / s:
                        revert with 'NH{q', 17
                    if 0 > (arg1 * t / s) - (arg1 * _liquidityFee / 10000 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * _liquidityFee / 10000 * t / s) < 0:
                        revert with 'NH{q', 17
                    return ((arg1 * t / s) - (arg1 * _liquidityFee / 10000 * t / s))
                if arg1 * _burnFee / 10000 and t / s > -1 / arg1 * _burnFee / 10000:
                    revert with 'NH{q', 17
                if not arg1 * _burnFee / 10000:
                    revert with 'NH{q', 18
                if arg1 * _burnFee / 10000 * t / s / arg1 * _burnFee / 10000 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < 0:
                    revert with 'NH{q', 17
                if arg1 * _liquidityFee / 10000 * t / s > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < arg1 * _liquidityFee / 10000 * t / s:
                    revert with 'NH{q', 17
                if arg1 * _burnFee / 10000 * t / s > (arg1 * t / s) - (arg1 * _liquidityFee / 10000 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * _liquidityFee / 10000 * t / s) < arg1 * _burnFee / 10000 * t / s:
                    revert with 'NH{q', 17
                return ((arg1 * t / s) - (arg1 * _liquidityFee / 10000 * t / s) - (arg1 * _burnFee / 10000 * t / s))
            if totalSupply <= 0:
                revert with 0, 'SafeMath: division by zero', 0
            if not totalSupply:
                revert with 'NH{q', 18
            if not arg1:
                if not arg1 * _liquidityFee / 10000:
                    if not arg1 * _burnFee / 10000:
                        return 0
                    if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                        revert with 'NH{q', 17
                    if not arg1 * _burnFee / 10000:
                        revert with 'NH{q', 18
                    if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * _burnFee / 10000 * stor12 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                        revert with 'NH{q', 17
                    return (-1 * arg1 * _burnFee / 10000 * stor12 / totalSupply)
                if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                    revert with 'NH{q', 17
                if not arg1 * _liquidityFee / 10000:
                    revert with 'NH{q', 18
                if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _burnFee / 10000:
                    if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                        revert with 'NH{q', 17
                    if 0 > -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply < 0:
                        revert with 'NH{q', 17
                    return (-1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply)
                if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                    revert with 'NH{q', 17
                if not arg1 * _burnFee / 10000:
                    revert with 'NH{q', 18
                if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > 0:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if 0 < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                    revert with 'NH{q', 17
                if arg1 * _burnFee / 10000 * stor12 / totalSupply > -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                    revert with 'NH{q', 17
                return ((-1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply) - (arg1 * _burnFee / 10000 * stor12 / totalSupply))
            if arg1 and stor12 / totalSupply > -1 / arg1:
                revert with 'NH{q', 17
            if not arg1:
                revert with 'NH{q', 18
            if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * _liquidityFee / 10000:
                if not arg1 * _burnFee / 10000:
                    if 0 > arg1 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 'NH{q', 17
                    if 0 > arg1 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 'NH{q', 17
                    if 0 > arg1 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 'NH{q', 17
                    return (arg1 * stor12 / totalSupply)
                if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                    revert with 'NH{q', 17
                if not arg1 * _burnFee / 10000:
                    revert with 'NH{q', 18
                if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 > arg1 * stor12 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor12 / totalSupply < 0:
                    revert with 'NH{q', 17
                if 0 > arg1 * stor12 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor12 / totalSupply < 0:
                    revert with 'NH{q', 17
                if arg1 * _burnFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor12 / totalSupply < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                    revert with 'NH{q', 17
                return ((arg1 * stor12 / totalSupply) - (arg1 * _burnFee / 10000 * stor12 / totalSupply))
            if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                revert with 'NH{q', 17
            if not arg1 * _liquidityFee / 10000:
                revert with 'NH{q', 18
            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * _burnFee / 10000:
                if 0 > arg1 * stor12 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor12 / totalSupply < 0:
                    revert with 'NH{q', 17
                if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                    revert with 'NH{q', 17
                if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                    revert with 'NH{q', 17
                return ((arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply))
            if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                revert with 'NH{q', 17
            if not arg1 * _burnFee / 10000:
                revert with 'NH{q', 18
            if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if 0 > arg1 * stor12 / totalSupply:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * stor12 / totalSupply < 0:
                revert with 'NH{q', 17
            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                revert with 'NH{q', 17
            if arg1 * _burnFee / 10000 * stor12 / totalSupply > (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                revert with 'NH{q', 17
            return ((arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) - (arg1 * _burnFee / 10000 * stor12 / totalSupply))
        if arg1 and _taxFee > -1 / arg1:
            revert with 'NH{q', 17
        if not arg1:
            revert with 'NH{q', 18
        if arg1 * _taxFee / arg1 != _taxFee:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
        mem[96] = 26
        mem[128] = 'SafeMath: division by zero'
        if not arg1:
            mem[160] = 26
            mem[192] = 'SafeMath: division by zero'
            if not arg1:
                mem[224] = 26
                mem[256] = 'SafeMath: division by zero'
                mem[288] = 30
                mem[320] = 'SafeMath: subtraction overflow'
                if arg1 * _taxFee / 10000 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < arg1 * _taxFee / 10000:
                    revert with 'NH{q', 17
                mem[352] = 30
                mem[384] = 'SafeMath: subtraction overflow'
                if 0 > arg1 - (arg1 * _taxFee / 10000):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * _taxFee / 10000) < 0:
                    revert with 'NH{q', 17
                mem[64] = 480
                mem[416] = 30
                mem[448] = 'SafeMath: subtraction overflow'
                if 0 > arg1 - (arg1 * _taxFee / 10000):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * _taxFee / 10000) < 0:
                    revert with 'NH{q', 17
                idx = 0
                s = totalSupply
                t = stor12
                while idx < stor9.length:
                    mem[0] = stor9[idx]
                    mem[32] = 3
                    if stor3[stor9[idx]] > t:
                        _2257 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2257] = 26
                        mem[_2257 + 32] = 'SafeMath: division by zero'
                        if totalSupply <= 0:
                            _2417 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2417 + idx + 68] = mem[_2257 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2417 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2417 + -mem[64] + 100
                        if not totalSupply:
                            revert with 'NH{q', 18
                        if not arg1:
                            if not arg1 * _taxFee / 10000:
                                return 0
                            if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                                revert with 'NH{q', 17
                            if not arg1 * _taxFee / 10000:
                                revert with 'NH{q', 18
                            if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _3318 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3318] = 30
                            mem[_3318 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                                _3372 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_3372 + idx + 68] = mem[_3318 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3372 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _3372 + -mem[64] + 100
                            if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                revert with 'NH{q', 17
                            _3855 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3855] = 30
                            mem[_3855 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                _3990 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_3990 + idx + 68] = mem[_3855 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3990 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _3990 + -mem[64] + 100
                            if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _4894 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4894] = 30
                            mem[_4894 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                return (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply)
                            _5132 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_5132 + idx + 68] = mem[_4894 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5132 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5132 + -mem[64] + 100
                        if arg1 and stor12 / totalSupply > -1 / arg1:
                            revert with 'NH{q', 17
                        if not arg1:
                            revert with 'NH{q', 18
                        if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _taxFee / 10000:
                            _3317 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3317] = 30
                            mem[_3317 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor12 / totalSupply:
                                _3371 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_3371 + idx + 68] = mem[_3317 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3371 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _3371 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _3854 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3854] = 30
                            mem[_3854 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor12 / totalSupply:
                                _3989 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_3989 + idx + 68] = mem[_3854 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3989 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _3989 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _4893 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4893] = 30
                            mem[_4893 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor12 / totalSupply:
                                if arg1 * stor12 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                return (arg1 * stor12 / totalSupply)
                            _5131 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_5131 + idx + 68] = mem[_4893 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5131 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5131 + -mem[64] + 100
                        if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                            revert with 'NH{q', 17
                        if not arg1 * _taxFee / 10000:
                            revert with 'NH{q', 18
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _4099 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4099] = 30
                        mem[_4099 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                            _4248 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_4248 + idx + 68] = mem[_4099 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_4248 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _4248 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            revert with 'NH{q', 17
                        _5303 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5303] = 30
                        mem[_5303 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                            _5618 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_5618 + idx + 68] = mem[_5303 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5618 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5618 + -mem[64] + 100
                        if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                            revert with 'NH{q', 17
                        _7001 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_7001] = 30
                        mem[_7001 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                            if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                                revert with 'NH{q', 17
                            return ((arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply))
                        _7407 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_7407 + idx + 68] = mem[_7001 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_7407 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _7407 + -mem[64] + 100
                    if idx >= stor9.length:
                        revert with 'NH{q', 50
                    mem[0] = stor9[idx]
                    mem[32] = 4
                    if stor4[stor9[idx]] <= s:
                        if idx >= stor9.length:
                            revert with 'NH{q', 50
                        mem[0] = stor9[idx]
                        mem[32] = 3
                        _2359 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2359] = 30
                        mem[_2359 + 32] = 'SafeMath: subtraction overflow'
                        if stor3[stor9[idx]] > t:
                            _2446 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_2446 + idx + 68] = mem[_2359 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2446 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _2446 + -mem[64] + 100
                        if t < stor3[stor9[idx]]:
                            revert with 'NH{q', 17
                        if idx >= stor9.length:
                            revert with 'NH{q', 50
                        mem[0] = stor9[idx]
                        mem[32] = 4
                        _2718 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2718] = 30
                        mem[_2718 + 32] = 'SafeMath: subtraction overflow'
                        if stor4[stor9[idx]] <= s:
                            if s < stor4[stor9[idx]]:
                                revert with 'NH{q', 17
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            s = s - stor4[stor9[idx]]
                            t = t - stor3[stor9[idx]]
                            continue 
                        _2766 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_2766 + idx + 68] = mem[_2718 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2766 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _2766 + -mem[64] + 100
                    _2418 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2418] = 26
                    mem[_2418 + 32] = 'SafeMath: division by zero'
                    if totalSupply <= 0:
                        _2462 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2462 + idx + 68] = mem[_2418 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2462 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2462 + -mem[64] + 100
                    if not totalSupply:
                        revert with 'NH{q', 18
                    if not arg1:
                        if not arg1 * _taxFee / 10000:
                            return 0
                        if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                            revert with 'NH{q', 17
                        if not arg1 * _taxFee / 10000:
                            revert with 'NH{q', 18
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _3374 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3374] = 30
                        mem[_3374 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                            _3486 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_3486 + idx + 68] = mem[_3374 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3486 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _3486 + -mem[64] + 100
                        if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            revert with 'NH{q', 17
                        _3993 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3993] = 30
                        mem[_3993 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            _4180 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_4180 + idx + 68] = mem[_3993 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_4180 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _4180 + -mem[64] + 100
                        if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _5134 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5134] = 30
                        mem[_5134 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                                revert with 'NH{q', 17
                            return (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply)
                        _5488 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_5488 + idx + 68] = mem[_5134 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_5488 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _5488 + -mem[64] + 100
                    if arg1 and stor12 / totalSupply > -1 / arg1:
                        revert with 'NH{q', 17
                    if not arg1:
                        revert with 'NH{q', 18
                    if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _taxFee / 10000:
                        _3373 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3373] = 30
                        mem[_3373 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _3485 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_3485 + idx + 68] = mem[_3373 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3485 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _3485 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _3992 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3992] = 30
                        mem[_3992 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _4179 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_4179 + idx + 68] = mem[_3992 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_4179 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _4179 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _5133 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5133] = 30
                        mem[_5133 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= arg1 * stor12 / totalSupply:
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 'NH{q', 17
                            return (arg1 * stor12 / totalSupply)
                        _5487 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_5487 + idx + 68] = mem[_5133 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_5487 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _5487 + -mem[64] + 100
                    if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                        revert with 'NH{q', 17
                    if not arg1 * _taxFee / 10000:
                        revert with 'NH{q', 18
                    if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _4253 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4253] = 30
                    mem[_4253 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                        _4428 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_4428 + idx + 68] = mem[_4253 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4428 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _4428 + -mem[64] + 100
                    if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                        revert with 'NH{q', 17
                    _5624 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5624] = 30
                    mem[_5624 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                        _5916 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_5916 + idx + 68] = mem[_5624 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_5916 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _5916 + -mem[64] + 100
                    if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                        revert with 'NH{q', 17
                    _7410 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_7410] = 30
                    mem[_7410 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                        if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                            revert with 'NH{q', 17
                        return ((arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply))
                    _7769 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_7769 + idx + 68] = mem[_7410 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_7769 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _7769 + -mem[64] + 100
                if totalSupply <= 0:
                    revert with 0, 'SafeMath: division by zero', 0
                if not totalSupply:
                    revert with 'NH{q', 18
                if t >= stor12 / totalSupply:
                    if s <= 0:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not s:
                        revert with 'NH{q', 18
                    if not arg1:
                        if not arg1 * _taxFee / 10000:
                            return 0
                        if arg1 * _taxFee / 10000 and t / s > -1 / arg1 * _taxFee / 10000:
                            revert with 'NH{q', 17
                        if not arg1 * _taxFee / 10000:
                            revert with 'NH{q', 18
                        if arg1 * _taxFee / 10000 * t / s / arg1 * _taxFee / 10000 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * _taxFee / 10000 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _taxFee / 10000 * t / s:
                            revert with 'NH{q', 17
                        if 0 > -1 * arg1 * _taxFee / 10000 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _taxFee / 10000 * t / s < 0:
                            revert with 'NH{q', 17
                        if 0 > -1 * arg1 * _taxFee / 10000 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _taxFee / 10000 * t / s < 0:
                            revert with 'NH{q', 17
                        return (-1 * arg1 * _taxFee / 10000 * t / s)
                    if arg1 and t / s > -1 / arg1:
                        revert with 'NH{q', 17
                    if not arg1:
                        revert with 'NH{q', 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _taxFee / 10000:
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 'NH{q', 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 'NH{q', 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 'NH{q', 17
                        return (arg1 * t / s)
                    if arg1 * _taxFee / 10000 and t / s > -1 / arg1 * _taxFee / 10000:
                        revert with 'NH{q', 17
                    if not arg1 * _taxFee / 10000:
                        revert with 'NH{q', 18
                    if arg1 * _taxFee / 10000 * t / s / arg1 * _taxFee / 10000 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * _taxFee / 10000 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * _taxFee / 10000 * t / s:
                        revert with 'NH{q', 17
                    if 0 > (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) < 0:
                        revert with 'NH{q', 17
                    if 0 > (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) < 0:
                        revert with 'NH{q', 17
                    return ((arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s))
                if totalSupply <= 0:
                    revert with 0, 'SafeMath: division by zero', 0
                if not totalSupply:
                    revert with 'NH{q', 18
                if not arg1:
                    if not arg1 * _taxFee / 10000:
                        return 0
                    if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                        revert with 'NH{q', 17
                    if not arg1 * _taxFee / 10000:
                        revert with 'NH{q', 18
                    if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                        revert with 'NH{q', 17
                    if 0 > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                        revert with 'NH{q', 17
                    if 0 > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                        revert with 'NH{q', 17
                    return (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply)
                if arg1 and stor12 / totalSupply > -1 / arg1:
                    revert with 'NH{q', 17
                if not arg1:
                    revert with 'NH{q', 18
                if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _taxFee / 10000:
                    if 0 > arg1 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 'NH{q', 17
                    if 0 > arg1 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 'NH{q', 17
                    if 0 > arg1 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 'NH{q', 17
                    return (arg1 * stor12 / totalSupply)
                if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                    revert with 'NH{q', 17
                if not arg1 * _taxFee / 10000:
                    revert with 'NH{q', 18
                if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                    revert with 'NH{q', 17
                if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                    revert with 'NH{q', 17
                if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                    revert with 'NH{q', 17
                return ((arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply))
            if arg1 and _burnFee > -1 / arg1:
                revert with 'NH{q', 17
            if not arg1:
                revert with 'NH{q', 18
            if arg1 * _burnFee / arg1 != _burnFee:
                revert with 0, 'SafeMath: multiplication overflow'
            mem[224] = 26
            mem[256] = 'SafeMath: division by zero'
            mem[288] = 30
            mem[320] = 'SafeMath: subtraction overflow'
            if arg1 * _taxFee / 10000 > arg1:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 < arg1 * _taxFee / 10000:
                revert with 'NH{q', 17
            mem[352] = 30
            mem[384] = 'SafeMath: subtraction overflow'
            if 0 > arg1 - (arg1 * _taxFee / 10000):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 - (arg1 * _taxFee / 10000) < 0:
                revert with 'NH{q', 17
            mem[64] = 480
            mem[416] = 30
            mem[448] = 'SafeMath: subtraction overflow'
            if arg1 * _burnFee / 10000 > arg1 - (arg1 * _taxFee / 10000):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 - (arg1 * _taxFee / 10000) < arg1 * _burnFee / 10000:
                revert with 'NH{q', 17
            idx = 0
            s = totalSupply
            t = stor12
            while idx < stor9.length:
                mem[0] = stor9[idx]
                mem[32] = 3
                if stor3[stor9[idx]] > t:
                    _2250 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2250] = 26
                    mem[_2250 + 32] = 'SafeMath: division by zero'
                    if totalSupply <= 0:
                        _2415 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2415 + idx + 68] = mem[_2250 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2415 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2415 + -mem[64] + 100
                    if not totalSupply:
                        revert with 'NH{q', 18
                    if not arg1:
                        if not arg1 * _taxFee / 10000:
                            if not arg1 * _burnFee / 10000:
                                return 0
                            if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                                revert with 'NH{q', 17
                            if not arg1 * _burnFee / 10000:
                                revert with 'NH{q', 18
                            if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _3316 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3316] = 30
                            mem[_3316 + 32] = 'SafeMath: subtraction overflow'
                            _3848 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3848] = 30
                            mem[_3848 + 32] = 'SafeMath: subtraction overflow'
                            _4888 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4888] = 30
                            mem[_4888 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _burnFee / 10000 * stor12 / totalSupply <= 0:
                                if 0 < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                                    revert with 'NH{q', 17
                                return (-1 * arg1 * _burnFee / 10000 * stor12 / totalSupply)
                            _5126 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_5126 + idx + 68] = mem[_4888 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5126 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5126 + -mem[64] + 100
                        if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                            revert with 'NH{q', 17
                        if not arg1 * _taxFee / 10000:
                            revert with 'NH{q', 18
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _burnFee / 10000:
                            _3315 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3315] = 30
                            mem[_3315 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                                _3367 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_3367 + idx + 68] = mem[_3315 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3367 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _3367 + -mem[64] + 100
                            if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                revert with 'NH{q', 17
                            _3847 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3847] = 30
                            mem[_3847 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                _3980 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_3980 + idx + 68] = mem[_3847 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3980 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _3980 + -mem[64] + 100
                            if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _4887 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4887] = 30
                            mem[_4887 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                return (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply)
                            _5125 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_5125 + idx + 68] = mem[_4887 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5125 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5125 + -mem[64] + 100
                        if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                            revert with 'NH{q', 17
                        if not arg1 * _burnFee / 10000:
                            revert with 'NH{q', 18
                        if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _4094 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4094] = 30
                        mem[_4094 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                            _4242 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_4242 + idx + 68] = mem[_4094 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_4242 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _4242 + -mem[64] + 100
                        if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            revert with 'NH{q', 17
                        _5292 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5292] = 30
                        mem[_5292 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            _5609 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_5609 + idx + 68] = mem[_5292 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5609 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5609 + -mem[64] + 100
                        if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _6988 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6988] = 30
                        mem[_6988 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _burnFee / 10000 * stor12 / totalSupply <= -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                                revert with 'NH{q', 17
                            return ((-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _burnFee / 10000 * stor12 / totalSupply))
                        _7401 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_7401 + idx + 68] = mem[_6988 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_7401 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _7401 + -mem[64] + 100
                    if arg1 and stor12 / totalSupply > -1 / arg1:
                        revert with 'NH{q', 17
                    if not arg1:
                        revert with 'NH{q', 18
                    if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _taxFee / 10000:
                        if not arg1 * _burnFee / 10000:
                            _3314 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3314] = 30
                            mem[_3314 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor12 / totalSupply:
                                _3366 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_3366 + idx + 68] = mem[_3314 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3366 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _3366 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _3845 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3845] = 30
                            mem[_3845 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor12 / totalSupply:
                                _3979 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_3979 + idx + 68] = mem[_3845 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3979 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _3979 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _4886 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4886] = 30
                            mem[_4886 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor12 / totalSupply:
                                if arg1 * stor12 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                return (arg1 * stor12 / totalSupply)
                            _5123 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_5123 + idx + 68] = mem[_4886 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5123 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5123 + -mem[64] + 100
                        if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                            revert with 'NH{q', 17
                        if not arg1 * _burnFee / 10000:
                            revert with 'NH{q', 18
                        if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _4093 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4093] = 30
                        mem[_4093 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _4239 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_4239 + idx + 68] = mem[_4093 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_4239 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _4239 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _5291 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5291] = 30
                        mem[_5291 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _5606 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_5606 + idx + 68] = mem[_5291 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5606 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5606 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _6987 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6987] = 30
                        mem[_6987 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _burnFee / 10000 * stor12 / totalSupply <= arg1 * stor12 / totalSupply:
                            if arg1 * stor12 / totalSupply < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                                revert with 'NH{q', 17
                            return ((arg1 * stor12 / totalSupply) - (arg1 * _burnFee / 10000 * stor12 / totalSupply))
                        _7399 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_7399 + idx + 68] = mem[_6987 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_7399 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _7399 + -mem[64] + 100
                    if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                        revert with 'NH{q', 17
                    if not arg1 * _taxFee / 10000:
                        revert with 'NH{q', 18
                    if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _burnFee / 10000:
                        _4092 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4092] = 30
                        mem[_4092 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                            _4238 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_4238 + idx + 68] = mem[_4092 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_4238 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _4238 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            revert with 'NH{q', 17
                        _5290 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5290] = 30
                        mem[_5290 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                            _5605 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_5605 + idx + 68] = mem[_5290 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5605 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5605 + -mem[64] + 100
                        if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                            revert with 'NH{q', 17
                        _6986 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6986] = 30
                        mem[_6986 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                            if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                                revert with 'NH{q', 17
                            return ((arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply))
                        _7398 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_7398 + idx + 68] = mem[_6986 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_7398 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _7398 + -mem[64] + 100
                    if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                        revert with 'NH{q', 17
                    if not arg1 * _burnFee / 10000:
                        revert with 'NH{q', 18
                    if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _5782 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5782] = 30
                    mem[_5782 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                        _6042 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_6042 + idx + 68] = mem[_5782 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_6042 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _6042 + -mem[64] + 100
                    if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                        revert with 'NH{q', 17
                    _7568 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_7568] = 30
                    mem[_7568 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                        _7914 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_7914 + idx + 68] = mem[_7568 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_7914 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _7914 + -mem[64] + 100
                    if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                        revert with 'NH{q', 17
                    _9202 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9202] = 30
                    mem[_9202 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _burnFee / 10000 * stor12 / totalSupply <= (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                        if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                            revert with 'NH{q', 17
                        return ((arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _burnFee / 10000 * stor12 / totalSupply))
                    _9529 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_9529 + idx + 68] = mem[_9202 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_9529 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _9529 + -mem[64] + 100
                if idx >= stor9.length:
                    revert with 'NH{q', 50
                mem[0] = stor9[idx]
                mem[32] = 4
                if stor4[stor9[idx]] <= s:
                    if idx >= stor9.length:
                        revert with 'NH{q', 50
                    mem[0] = stor9[idx]
                    mem[32] = 3
                    _2355 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2355] = 30
                    mem[_2355 + 32] = 'SafeMath: subtraction overflow'
                    if stor3[stor9[idx]] > t:
                        _2445 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_2445 + idx + 68] = mem[_2355 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2445 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _2445 + -mem[64] + 100
                    if t < stor3[stor9[idx]]:
                        revert with 'NH{q', 17
                    if idx >= stor9.length:
                        revert with 'NH{q', 50
                    mem[0] = stor9[idx]
                    mem[32] = 4
                    _2717 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2717] = 30
                    mem[_2717 + 32] = 'SafeMath: subtraction overflow'
                    if stor4[stor9[idx]] <= s:
                        if s < stor4[stor9[idx]]:
                            revert with 'NH{q', 17
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        s = s - stor4[stor9[idx]]
                        t = t - stor3[stor9[idx]]
                        continue 
                    _2765 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_2765 + idx + 68] = mem[_2717 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2765 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _2765 + -mem[64] + 100
                _2416 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2416] = 26
                mem[_2416 + 32] = 'SafeMath: division by zero'
                if totalSupply <= 0:
                    _2461 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2461 + idx + 68] = mem[_2416 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2461 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2461 + -mem[64] + 100
                if not totalSupply:
                    revert with 'NH{q', 18
                if not arg1:
                    if not arg1 * _taxFee / 10000:
                        if not arg1 * _burnFee / 10000:
                            return 0
                        if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                            revert with 'NH{q', 17
                        if not arg1 * _burnFee / 10000:
                            revert with 'NH{q', 18
                        if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _3370 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3370] = 30
                        mem[_3370 + 32] = 'SafeMath: subtraction overflow'
                        _3986 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3986] = 30
                        mem[_3986 + 32] = 'SafeMath: subtraction overflow'
                        _5129 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5129] = 30
                        mem[_5129 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _burnFee / 10000 * stor12 / totalSupply <= 0:
                            if 0 < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                                revert with 'NH{q', 17
                            return (-1 * arg1 * _burnFee / 10000 * stor12 / totalSupply)
                        _5481 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_5481 + idx + 68] = mem[_5129 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_5481 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _5481 + -mem[64] + 100
                    if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                        revert with 'NH{q', 17
                    if not arg1 * _taxFee / 10000:
                        revert with 'NH{q', 18
                    if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _burnFee / 10000:
                        _3369 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3369] = 30
                        mem[_3369 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                            _3483 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_3483 + idx + 68] = mem[_3369 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3483 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _3483 + -mem[64] + 100
                        if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            revert with 'NH{q', 17
                        _3985 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3985] = 30
                        mem[_3985 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            _4178 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_4178 + idx + 68] = mem[_3985 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_4178 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _4178 + -mem[64] + 100
                        if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _5128 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5128] = 30
                        mem[_5128 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                                revert with 'NH{q', 17
                            return (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply)
                        _5480 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_5480 + idx + 68] = mem[_5128 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_5480 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _5480 + -mem[64] + 100
                    if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                        revert with 'NH{q', 17
                    if not arg1 * _burnFee / 10000:
                        revert with 'NH{q', 18
                    if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _4247 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4247] = 30
                    mem[_4247 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                        _4423 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_4423 + idx + 68] = mem[_4247 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4423 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _4423 + -mem[64] + 100
                    if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                        revert with 'NH{q', 17
                    _5617 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5617] = 30
                    mem[_5617 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                        _5911 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_5911 + idx + 68] = mem[_5617 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_5911 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _5911 + -mem[64] + 100
                    if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                        revert with 'NH{q', 17
                    _7406 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_7406] = 30
                    mem[_7406 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _burnFee / 10000 * stor12 / totalSupply <= -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                        if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                            revert with 'NH{q', 17
                        return ((-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _burnFee / 10000 * stor12 / totalSupply))
                    _7764 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_7764 + idx + 68] = mem[_7406 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_7764 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _7764 + -mem[64] + 100
                if arg1 and stor12 / totalSupply > -1 / arg1:
                    revert with 'NH{q', 17
                if not arg1:
                    revert with 'NH{q', 18
                if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _taxFee / 10000:
                    if not arg1 * _burnFee / 10000:
                        _3368 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3368] = 30
                        mem[_3368 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _3482 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_3482 + idx + 68] = mem[_3368 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3482 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _3482 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _3983 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3983] = 30
                        mem[_3983 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _4177 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_4177 + idx + 68] = mem[_3983 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_4177 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _4177 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _5127 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5127] = 30
                        mem[_5127 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= arg1 * stor12 / totalSupply:
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 'NH{q', 17
                            return (arg1 * stor12 / totalSupply)
                        _5478 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_5478 + idx + 68] = mem[_5127 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_5478 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _5478 + -mem[64] + 100
                    if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                        revert with 'NH{q', 17
                    if not arg1 * _burnFee / 10000:
                        revert with 'NH{q', 18
                    if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _4246 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4246] = 30
                    mem[_4246 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor12 / totalSupply:
                        _4420 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_4420 + idx + 68] = mem[_4246 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4420 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _4420 + -mem[64] + 100
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 'NH{q', 17
                    _5616 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5616] = 30
                    mem[_5616 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor12 / totalSupply:
                        _5908 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_5908 + idx + 68] = mem[_5616 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_5908 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _5908 + -mem[64] + 100
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 'NH{q', 17
                    _7405 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_7405] = 30
                    mem[_7405 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _burnFee / 10000 * stor12 / totalSupply <= arg1 * stor12 / totalSupply:
                        if arg1 * stor12 / totalSupply < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                            revert with 'NH{q', 17
                        return ((arg1 * stor12 / totalSupply) - (arg1 * _burnFee / 10000 * stor12 / totalSupply))
                    _7762 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_7762 + idx + 68] = mem[_7405 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_7762 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _7762 + -mem[64] + 100
                if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                    revert with 'NH{q', 17
                if not arg1 * _taxFee / 10000:
                    revert with 'NH{q', 18
                if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _burnFee / 10000:
                    _4245 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4245] = 30
                    mem[_4245 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                        _4419 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_4419 + idx + 68] = mem[_4245 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4419 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _4419 + -mem[64] + 100
                    if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                        revert with 'NH{q', 17
                    _5615 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5615] = 30
                    mem[_5615 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                        _5907 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_5907 + idx + 68] = mem[_5615 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_5907 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _5907 + -mem[64] + 100
                    if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                        revert with 'NH{q', 17
                    _7404 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_7404] = 30
                    mem[_7404 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                        if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                            revert with 'NH{q', 17
                        return ((arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply))
                    _7761 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_7761 + idx + 68] = mem[_7404 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_7761 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _7761 + -mem[64] + 100
                if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                    revert with 'NH{q', 17
                if not arg1 * _burnFee / 10000:
                    revert with 'NH{q', 18
                if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                _6049 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6049] = 30
                mem[_6049 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                    _6319 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_6319 + idx + 68] = mem[_6049 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_6319 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _6319 + -mem[64] + 100
                if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                    revert with 'NH{q', 17
                _7924 = mem[64]
                mem[64] = mem[64] + 64
                mem[_7924] = 30
                mem[_7924 + 32] = 'SafeMath: subtraction overflow'
                if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                    _8249 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_8249 + idx + 68] = mem[_7924 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_8249 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _8249 + -mem[64] + 100
                if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                    revert with 'NH{q', 17
                _9533 = mem[64]
                mem[64] = mem[64] + 64
                mem[_9533] = 30
                mem[_9533 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _burnFee / 10000 * stor12 / totalSupply <= (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                    if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                        revert with 'NH{q', 17
                    return ((arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _burnFee / 10000 * stor12 / totalSupply))
                _9700 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_9700 + idx + 68] = mem[_9533 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_9700 + 98] = 0
                revert with memory
                  from mem[64]
                   len _9700 + -mem[64] + 100
            if totalSupply <= 0:
                revert with 0, 'SafeMath: division by zero', 0
            if not totalSupply:
                revert with 'NH{q', 18
            if t >= stor12 / totalSupply:
                if s <= 0:
                    revert with 0, 'SafeMath: division by zero', 0
                if not s:
                    revert with 'NH{q', 18
                if not arg1:
                    if not arg1 * _taxFee / 10000:
                        if not arg1 * _burnFee / 10000:
                            return 0
                        if arg1 * _burnFee / 10000 and t / s > -1 / arg1 * _burnFee / 10000:
                            revert with 'NH{q', 17
                        if not arg1 * _burnFee / 10000:
                            revert with 'NH{q', 18
                        if arg1 * _burnFee / 10000 * t / s / arg1 * _burnFee / 10000 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * _burnFee / 10000 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _burnFee / 10000 * t / s:
                            revert with 'NH{q', 17
                        return (-1 * arg1 * _burnFee / 10000 * t / s)
                    if arg1 * _taxFee / 10000 and t / s > -1 / arg1 * _taxFee / 10000:
                        revert with 'NH{q', 17
                    if not arg1 * _taxFee / 10000:
                        revert with 'NH{q', 18
                    if arg1 * _taxFee / 10000 * t / s / arg1 * _taxFee / 10000 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _burnFee / 10000:
                        if arg1 * _taxFee / 10000 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _taxFee / 10000 * t / s:
                            revert with 'NH{q', 17
                        if 0 > -1 * arg1 * _taxFee / 10000 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _taxFee / 10000 * t / s < 0:
                            revert with 'NH{q', 17
                        if 0 > -1 * arg1 * _taxFee / 10000 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _taxFee / 10000 * t / s < 0:
                            revert with 'NH{q', 17
                        return (-1 * arg1 * _taxFee / 10000 * t / s)
                    if arg1 * _burnFee / 10000 and t / s > -1 / arg1 * _burnFee / 10000:
                        revert with 'NH{q', 17
                    if not arg1 * _burnFee / 10000:
                        revert with 'NH{q', 18
                    if arg1 * _burnFee / 10000 * t / s / arg1 * _burnFee / 10000 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * _taxFee / 10000 * t / s > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _taxFee / 10000 * t / s:
                        revert with 'NH{q', 17
                    if 0 > -1 * arg1 * _taxFee / 10000 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _taxFee / 10000 * t / s < 0:
                        revert with 'NH{q', 17
                    if arg1 * _burnFee / 10000 * t / s > -1 * arg1 * _taxFee / 10000 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _taxFee / 10000 * t / s < arg1 * _burnFee / 10000 * t / s:
                        revert with 'NH{q', 17
                    return ((-1 * arg1 * _taxFee / 10000 * t / s) - (arg1 * _burnFee / 10000 * t / s))
                if arg1 and t / s > -1 / arg1:
                    revert with 'NH{q', 17
                if not arg1:
                    revert with 'NH{q', 18
                if arg1 * t / s / arg1 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _taxFee / 10000:
                    if not arg1 * _burnFee / 10000:
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 'NH{q', 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 'NH{q', 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 'NH{q', 17
                        return (arg1 * t / s)
                    if arg1 * _burnFee / 10000 and t / s > -1 / arg1 * _burnFee / 10000:
                        revert with 'NH{q', 17
                    if not arg1 * _burnFee / 10000:
                        revert with 'NH{q', 18
                    if arg1 * _burnFee / 10000 * t / s / arg1 * _burnFee / 10000 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 'NH{q', 17
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 'NH{q', 17
                    if arg1 * _burnFee / 10000 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * _burnFee / 10000 * t / s:
                        revert with 'NH{q', 17
                    return ((arg1 * t / s) - (arg1 * _burnFee / 10000 * t / s))
                if arg1 * _taxFee / 10000 and t / s > -1 / arg1 * _taxFee / 10000:
                    revert with 'NH{q', 17
                if not arg1 * _taxFee / 10000:
                    revert with 'NH{q', 18
                if arg1 * _taxFee / 10000 * t / s / arg1 * _taxFee / 10000 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _burnFee / 10000:
                    if arg1 * _taxFee / 10000 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * _taxFee / 10000 * t / s:
                        revert with 'NH{q', 17
                    if 0 > (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) < 0:
                        revert with 'NH{q', 17
                    if 0 > (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) < 0:
                        revert with 'NH{q', 17
                    return ((arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s))
                if arg1 * _burnFee / 10000 and t / s > -1 / arg1 * _burnFee / 10000:
                    revert with 'NH{q', 17
                if not arg1 * _burnFee / 10000:
                    revert with 'NH{q', 18
                if arg1 * _burnFee / 10000 * t / s / arg1 * _burnFee / 10000 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * _taxFee / 10000 * t / s > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < arg1 * _taxFee / 10000 * t / s:
                    revert with 'NH{q', 17
                if 0 > (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) < 0:
                    revert with 'NH{q', 17
                if arg1 * _burnFee / 10000 * t / s > (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) < arg1 * _burnFee / 10000 * t / s:
                    revert with 'NH{q', 17
                return ((arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) - (arg1 * _burnFee / 10000 * t / s))
            if totalSupply <= 0:
                revert with 0, 'SafeMath: division by zero', 0
            if not totalSupply:
                revert with 'NH{q', 18
            if not arg1:
                if not arg1 * _taxFee / 10000:
                    if not arg1 * _burnFee / 10000:
                        return 0
                    if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                        revert with 'NH{q', 17
                    if not arg1 * _burnFee / 10000:
                        revert with 'NH{q', 18
                    if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * _burnFee / 10000 * stor12 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                        revert with 'NH{q', 17
                    return (-1 * arg1 * _burnFee / 10000 * stor12 / totalSupply)
                if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                    revert with 'NH{q', 17
                if not arg1 * _taxFee / 10000:
                    revert with 'NH{q', 18
                if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _burnFee / 10000:
                    if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                        revert with 'NH{q', 17
                    if 0 > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                        revert with 'NH{q', 17
                    if 0 > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                        revert with 'NH{q', 17
                    return (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply)
                if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                    revert with 'NH{q', 17
                if not arg1 * _burnFee / 10000:
                    revert with 'NH{q', 18
                if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                    revert with 'NH{q', 17
                if 0 > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                    revert with 'NH{q', 17
                if arg1 * _burnFee / 10000 * stor12 / totalSupply > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                    revert with 'NH{q', 17
                return ((-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _burnFee / 10000 * stor12 / totalSupply))
            if arg1 and stor12 / totalSupply > -1 / arg1:
                revert with 'NH{q', 17
            if not arg1:
                revert with 'NH{q', 18
            if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * _taxFee / 10000:
                if not arg1 * _burnFee / 10000:
                    if 0 > arg1 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 'NH{q', 17
                    if 0 > arg1 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 'NH{q', 17
                    if 0 > arg1 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 'NH{q', 17
                    return (arg1 * stor12 / totalSupply)
                if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                    revert with 'NH{q', 17
                if not arg1 * _burnFee / 10000:
                    revert with 'NH{q', 18
                if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 > arg1 * stor12 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor12 / totalSupply < 0:
                    revert with 'NH{q', 17
                if 0 > arg1 * stor12 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor12 / totalSupply < 0:
                    revert with 'NH{q', 17
                if arg1 * _burnFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor12 / totalSupply < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                    revert with 'NH{q', 17
                return ((arg1 * stor12 / totalSupply) - (arg1 * _burnFee / 10000 * stor12 / totalSupply))
            if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                revert with 'NH{q', 17
            if not arg1 * _taxFee / 10000:
                revert with 'NH{q', 18
            if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * _burnFee / 10000:
                if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                    revert with 'NH{q', 17
                if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                    revert with 'NH{q', 17
                if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                    revert with 'NH{q', 17
                return ((arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply))
            if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                revert with 'NH{q', 17
            if not arg1 * _burnFee / 10000:
                revert with 'NH{q', 18
            if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                revert with 'NH{q', 17
            if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                revert with 'NH{q', 17
            if arg1 * _burnFee / 10000 * stor12 / totalSupply > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                revert with 'NH{q', 17
            return ((arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _burnFee / 10000 * stor12 / totalSupply))
        if arg1 and _liquidityFee > -1 / arg1:
            revert with 'NH{q', 17
        if not arg1:
            revert with 'NH{q', 18
        if arg1 * _liquidityFee / arg1 != _liquidityFee:
            revert with 0, 'SafeMath: multiplication overflow'
        mem[160] = 26
        mem[192] = 'SafeMath: division by zero'
        if not arg1:
            mem[224] = 26
            mem[256] = 'SafeMath: division by zero'
            mem[288] = 30
            mem[320] = 'SafeMath: subtraction overflow'
            if arg1 * _taxFee / 10000 > arg1:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 < arg1 * _taxFee / 10000:
                revert with 'NH{q', 17
            mem[352] = 30
            mem[384] = 'SafeMath: subtraction overflow'
            if arg1 * _liquidityFee / 10000 > arg1 - (arg1 * _taxFee / 10000):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 - (arg1 * _taxFee / 10000) < arg1 * _liquidityFee / 10000:
                revert with 'NH{q', 17
            mem[64] = 480
            mem[416] = 30
            mem[448] = 'SafeMath: subtraction overflow'
            if 0 > arg1 - (arg1 * _taxFee / 10000) - (arg1 * _liquidityFee / 10000):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 - (arg1 * _taxFee / 10000) - (arg1 * _liquidityFee / 10000) < 0:
                revert with 'NH{q', 17
            idx = 0
            s = totalSupply
            t = stor12
            while idx < stor9.length:
                mem[0] = stor9[idx]
                mem[32] = 3
                if stor3[stor9[idx]] > t:
                    _2243 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2243] = 26
                    mem[_2243 + 32] = 'SafeMath: division by zero'
                    if totalSupply <= 0:
                        _2413 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2413 + idx + 68] = mem[_2243 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2413 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2413 + -mem[64] + 100
                    if not totalSupply:
                        revert with 'NH{q', 18
                    if not arg1:
                        if not arg1 * _taxFee / 10000:
                            if not arg1 * _liquidityFee / 10000:
                                return 0
                            if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                                revert with 'NH{q', 17
                            if not arg1 * _liquidityFee / 10000:
                                revert with 'NH{q', 18
                            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _3313 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3313] = 30
                            mem[_3313 + 32] = 'SafeMath: subtraction overflow'
                            _3838 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3838] = 30
                            mem[_3838 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > 0:
                                _3972 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_3972 + idx + 68] = mem[_3838 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3972 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _3972 + -mem[64] + 100
                            if 0 < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                revert with 'NH{q', 17
                            _4881 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4881] = 30
                            mem[_4881 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                if -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                return (-1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply)
                            _5117 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_5117 + idx + 68] = mem[_4881 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5117 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5117 + -mem[64] + 100
                        if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                            revert with 'NH{q', 17
                        if not arg1 * _taxFee / 10000:
                            revert with 'NH{q', 18
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _liquidityFee / 10000:
                            _3312 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3312] = 30
                            mem[_3312 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                                _3362 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_3362 + idx + 68] = mem[_3312 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3362 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _3362 + -mem[64] + 100
                            if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                revert with 'NH{q', 17
                            _3837 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3837] = 30
                            mem[_3837 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                _3971 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_3971 + idx + 68] = mem[_3837 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3971 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _3971 + -mem[64] + 100
                            if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _4880 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4880] = 30
                            mem[_4880 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                return (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply)
                            _5116 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_5116 + idx + 68] = mem[_4880 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5116 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5116 + -mem[64] + 100
                        if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                            revert with 'NH{q', 17
                        if not arg1 * _liquidityFee / 10000:
                            revert with 'NH{q', 18
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _4085 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4085] = 30
                        mem[_4085 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                            _4231 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_4231 + idx + 68] = mem[_4085 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_4231 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _4231 + -mem[64] + 100
                        if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            revert with 'NH{q', 17
                        _5274 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5274] = 30
                        mem[_5274 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            _5596 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_5596 + idx + 68] = mem[_5274 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5596 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5596 + -mem[64] + 100
                        if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                            revert with 'NH{q', 17
                        _6967 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6967] = 30
                        mem[_6967 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                            if (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                                revert with 'NH{q', 17
                            return ((-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply))
                        _7391 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_7391 + idx + 68] = mem[_6967 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_7391 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _7391 + -mem[64] + 100
                    if arg1 and stor12 / totalSupply > -1 / arg1:
                        revert with 'NH{q', 17
                    if not arg1:
                        revert with 'NH{q', 18
                    if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _taxFee / 10000:
                        if not arg1 * _liquidityFee / 10000:
                            _3311 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3311] = 30
                            mem[_3311 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor12 / totalSupply:
                                _3361 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_3361 + idx + 68] = mem[_3311 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3361 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _3361 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _3836 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3836] = 30
                            mem[_3836 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor12 / totalSupply:
                                _3970 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_3970 + idx + 68] = mem[_3836 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3970 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _3970 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _4879 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4879] = 30
                            mem[_4879 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor12 / totalSupply:
                                if arg1 * stor12 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                return (arg1 * stor12 / totalSupply)
                            _5114 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_5114 + idx + 68] = mem[_4879 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5114 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5114 + -mem[64] + 100
                        if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                            revert with 'NH{q', 17
                        if not arg1 * _liquidityFee / 10000:
                            revert with 'NH{q', 18
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _4084 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4084] = 30
                        mem[_4084 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _4228 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_4228 + idx + 68] = mem[_4084 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_4228 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _4228 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _5273 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5273] = 30
                        mem[_5273 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                            _5593 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_5593 + idx + 68] = mem[_5273 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5593 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5593 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                            revert with 'NH{q', 17
                        _6966 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6966] = 30
                        mem[_6966 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                            if (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                                revert with 'NH{q', 17
                            return ((arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply))
                        _7389 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_7389 + idx + 68] = mem[_6966 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_7389 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _7389 + -mem[64] + 100
                    if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                        revert with 'NH{q', 17
                    if not arg1 * _taxFee / 10000:
                        revert with 'NH{q', 18
                    if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _liquidityFee / 10000:
                        _4083 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4083] = 30
                        mem[_4083 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                            _4227 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_4227 + idx + 68] = mem[_4083 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_4227 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _4227 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            revert with 'NH{q', 17
                        _5272 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5272] = 30
                        mem[_5272 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                            _5592 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_5592 + idx + 68] = mem[_5272 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5592 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5592 + -mem[64] + 100
                        if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                            revert with 'NH{q', 17
                        _6965 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6965] = 30
                        mem[_6965 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                            if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                                revert with 'NH{q', 17
                            return ((arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply))
                        _7388 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_7388 + idx + 68] = mem[_6965 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_7388 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _7388 + -mem[64] + 100
                    if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                        revert with 'NH{q', 17
                    if not arg1 * _liquidityFee / 10000:
                        revert with 'NH{q', 18
                    if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _5768 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5768] = 30
                    mem[_5768 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                        _6031 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_6031 + idx + 68] = mem[_5768 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_6031 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _6031 + -mem[64] + 100
                    if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                        revert with 'NH{q', 17
                    _7550 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_7550] = 30
                    mem[_7550 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                        _7900 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_7900 + idx + 68] = mem[_7550 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_7900 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _7900 + -mem[64] + 100
                    if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                        revert with 'NH{q', 17
                    _9181 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9181] = 30
                    mem[_9181 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                        if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                            revert with 'NH{q', 17
                        return ((arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply))
                    _9524 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_9524 + idx + 68] = mem[_9181 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_9524 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _9524 + -mem[64] + 100
                if idx >= stor9.length:
                    revert with 'NH{q', 50
                mem[0] = stor9[idx]
                mem[32] = 4
                if stor4[stor9[idx]] <= s:
                    if idx >= stor9.length:
                        revert with 'NH{q', 50
                    mem[0] = stor9[idx]
                    mem[32] = 3
                    _2351 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2351] = 30
                    mem[_2351 + 32] = 'SafeMath: subtraction overflow'
                    if stor3[stor9[idx]] > t:
                        _2444 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_2444 + idx + 68] = mem[_2351 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2444 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _2444 + -mem[64] + 100
                    if t < stor3[stor9[idx]]:
                        revert with 'NH{q', 17
                    if idx >= stor9.length:
                        revert with 'NH{q', 50
                    mem[0] = stor9[idx]
                    mem[32] = 4
                    _2716 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2716] = 30
                    mem[_2716 + 32] = 'SafeMath: subtraction overflow'
                    if stor4[stor9[idx]] <= s:
                        if s < stor4[stor9[idx]]:
                            revert with 'NH{q', 17
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        s = s - stor4[stor9[idx]]
                        t = t - stor3[stor9[idx]]
                        continue 
                    _2764 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_2764 + idx + 68] = mem[_2716 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2764 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _2764 + -mem[64] + 100
                _2414 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2414] = 26
                mem[_2414 + 32] = 'SafeMath: division by zero'
                if totalSupply <= 0:
                    _2460 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2460 + idx + 68] = mem[_2414 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2460 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2460 + -mem[64] + 100
                if not totalSupply:
                    revert with 'NH{q', 18
                if not arg1:
                    if not arg1 * _taxFee / 10000:
                        if not arg1 * _liquidityFee / 10000:
                            return 0
                        if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                            revert with 'NH{q', 17
                        if not arg1 * _liquidityFee / 10000:
                            revert with 'NH{q', 18
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _3365 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3365] = 30
                        mem[_3365 + 32] = 'SafeMath: subtraction overflow'
                        _3976 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3976] = 30
                        mem[_3976 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > 0:
                            _4176 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_4176 + idx + 68] = mem[_3976 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_4176 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _4176 + -mem[64] + 100
                        if 0 < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                            revert with 'NH{q', 17
                        _5120 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5120] = 30
                        mem[_5120 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                            if -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply < 0:
                                revert with 'NH{q', 17
                            return (-1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply)
                        _5471 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_5471 + idx + 68] = mem[_5120 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_5471 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _5471 + -mem[64] + 100
                    if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                        revert with 'NH{q', 17
                    if not arg1 * _taxFee / 10000:
                        revert with 'NH{q', 18
                    if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _liquidityFee / 10000:
                        _3364 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3364] = 30
                        mem[_3364 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                            _3480 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_3480 + idx + 68] = mem[_3364 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3480 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _3480 + -mem[64] + 100
                        if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            revert with 'NH{q', 17
                        _3975 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3975] = 30
                        mem[_3975 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            _4175 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_4175 + idx + 68] = mem[_3975 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_4175 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _4175 + -mem[64] + 100
                        if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _5119 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5119] = 30
                        mem[_5119 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                                revert with 'NH{q', 17
                            return (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply)
                        _5470 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_5470 + idx + 68] = mem[_5119 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_5470 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _5470 + -mem[64] + 100
                    if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                        revert with 'NH{q', 17
                    if not arg1 * _liquidityFee / 10000:
                        revert with 'NH{q', 18
                    if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _4237 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4237] = 30
                    mem[_4237 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                        _4413 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_4413 + idx + 68] = mem[_4237 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4413 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _4413 + -mem[64] + 100
                    if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                        revert with 'NH{q', 17
                    _5604 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5604] = 30
                    mem[_5604 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                        _5901 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_5901 + idx + 68] = mem[_5604 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_5901 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _5901 + -mem[64] + 100
                    if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                        revert with 'NH{q', 17
                    _7396 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_7396] = 30
                    mem[_7396 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                        if (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                            revert with 'NH{q', 17
                        return ((-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply))
                    _7751 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_7751 + idx + 68] = mem[_7396 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_7751 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _7751 + -mem[64] + 100
                if arg1 and stor12 / totalSupply > -1 / arg1:
                    revert with 'NH{q', 17
                if not arg1:
                    revert with 'NH{q', 18
                if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _taxFee / 10000:
                    if not arg1 * _liquidityFee / 10000:
                        _3363 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3363] = 30
                        mem[_3363 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _3479 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_3479 + idx + 68] = mem[_3363 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3479 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _3479 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _3974 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3974] = 30
                        mem[_3974 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _4174 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_4174 + idx + 68] = mem[_3974 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_4174 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _4174 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _5118 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5118] = 30
                        mem[_5118 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= arg1 * stor12 / totalSupply:
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 'NH{q', 17
                            return (arg1 * stor12 / totalSupply)
                        _5468 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_5468 + idx + 68] = mem[_5118 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_5468 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _5468 + -mem[64] + 100
                    if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                        revert with 'NH{q', 17
                    if not arg1 * _liquidityFee / 10000:
                        revert with 'NH{q', 18
                    if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _4236 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4236] = 30
                    mem[_4236 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor12 / totalSupply:
                        _4410 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_4410 + idx + 68] = mem[_4236 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4410 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _4410 + -mem[64] + 100
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 'NH{q', 17
                    _5603 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5603] = 30
                    mem[_5603 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                        _5898 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_5898 + idx + 68] = mem[_5603 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_5898 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _5898 + -mem[64] + 100
                    if arg1 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                        revert with 'NH{q', 17
                    _7395 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_7395] = 30
                    mem[_7395 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                        if (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                            revert with 'NH{q', 17
                        return ((arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply))
                    _7749 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_7749 + idx + 68] = mem[_7395 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_7749 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _7749 + -mem[64] + 100
                if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                    revert with 'NH{q', 17
                if not arg1 * _taxFee / 10000:
                    revert with 'NH{q', 18
                if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _liquidityFee / 10000:
                    _4235 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4235] = 30
                    mem[_4235 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                        _4409 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_4409 + idx + 68] = mem[_4235 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4409 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _4409 + -mem[64] + 100
                    if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                        revert with 'NH{q', 17
                    _5602 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5602] = 30
                    mem[_5602 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                        _5897 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_5897 + idx + 68] = mem[_5602 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_5897 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _5897 + -mem[64] + 100
                    if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                        revert with 'NH{q', 17
                    _7394 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_7394] = 30
                    mem[_7394 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                        if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                            revert with 'NH{q', 17
                        return ((arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply))
                    _7748 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_7748 + idx + 68] = mem[_7394 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_7748 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _7748 + -mem[64] + 100
                if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                    revert with 'NH{q', 17
                if not arg1 * _liquidityFee / 10000:
                    revert with 'NH{q', 18
                if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                _6038 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6038] = 30
                mem[_6038 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                    _6306 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_6306 + idx + 68] = mem[_6038 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_6306 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _6306 + -mem[64] + 100
                if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                    revert with 'NH{q', 17
                _7910 = mem[64]
                mem[64] = mem[64] + 64
                mem[_7910] = 30
                mem[_7910 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                    _8239 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_8239 + idx + 68] = mem[_7910 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_8239 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _8239 + -mem[64] + 100
                if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                    revert with 'NH{q', 17
                _9528 = mem[64]
                mem[64] = mem[64] + 64
                mem[_9528] = 30
                mem[_9528 + 32] = 'SafeMath: subtraction overflow'
                if 0 <= (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                    if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                        revert with 'NH{q', 17
                    return ((arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply))
                _9694 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_9694 + idx + 68] = mem[_9528 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_9694 + 98] = 0
                revert with memory
                  from mem[64]
                   len _9694 + -mem[64] + 100
            if totalSupply <= 0:
                revert with 0, 'SafeMath: division by zero', 0
            if not totalSupply:
                revert with 'NH{q', 18
            if t >= stor12 / totalSupply:
                if s <= 0:
                    revert with 0, 'SafeMath: division by zero', 0
                if not s:
                    revert with 'NH{q', 18
                if not arg1:
                    if not arg1 * _taxFee / 10000:
                        if not arg1 * _liquidityFee / 10000:
                            return 0
                        if arg1 * _liquidityFee / 10000 and t / s > -1 / arg1 * _liquidityFee / 10000:
                            revert with 'NH{q', 17
                        if not arg1 * _liquidityFee / 10000:
                            revert with 'NH{q', 18
                        if arg1 * _liquidityFee / 10000 * t / s / arg1 * _liquidityFee / 10000 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * _liquidityFee / 10000 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _liquidityFee / 10000 * t / s:
                            revert with 'NH{q', 17
                        if 0 > -1 * arg1 * _liquidityFee / 10000 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _liquidityFee / 10000 * t / s < 0:
                            revert with 'NH{q', 17
                        return (-1 * arg1 * _liquidityFee / 10000 * t / s)
                    if arg1 * _taxFee / 10000 and t / s > -1 / arg1 * _taxFee / 10000:
                        revert with 'NH{q', 17
                    if not arg1 * _taxFee / 10000:
                        revert with 'NH{q', 18
                    if arg1 * _taxFee / 10000 * t / s / arg1 * _taxFee / 10000 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _liquidityFee / 10000:
                        if arg1 * _taxFee / 10000 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _taxFee / 10000 * t / s:
                            revert with 'NH{q', 17
                        if 0 > -1 * arg1 * _taxFee / 10000 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _taxFee / 10000 * t / s < 0:
                            revert with 'NH{q', 17
                        if 0 > -1 * arg1 * _taxFee / 10000 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _taxFee / 10000 * t / s < 0:
                            revert with 'NH{q', 17
                        return (-1 * arg1 * _taxFee / 10000 * t / s)
                    if arg1 * _liquidityFee / 10000 and t / s > -1 / arg1 * _liquidityFee / 10000:
                        revert with 'NH{q', 17
                    if not arg1 * _liquidityFee / 10000:
                        revert with 'NH{q', 18
                    if arg1 * _liquidityFee / 10000 * t / s / arg1 * _liquidityFee / 10000 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * _taxFee / 10000 * t / s > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _taxFee / 10000 * t / s:
                        revert with 'NH{q', 17
                    if arg1 * _liquidityFee / 10000 * t / s > -1 * arg1 * _taxFee / 10000 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _taxFee / 10000 * t / s < arg1 * _liquidityFee / 10000 * t / s:
                        revert with 'NH{q', 17
                    if 0 > (-1 * arg1 * _taxFee / 10000 * t / s) - (arg1 * _liquidityFee / 10000 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (-1 * arg1 * _taxFee / 10000 * t / s) - (arg1 * _liquidityFee / 10000 * t / s) < 0:
                        revert with 'NH{q', 17
                    return ((-1 * arg1 * _taxFee / 10000 * t / s) - (arg1 * _liquidityFee / 10000 * t / s))
                if arg1 and t / s > -1 / arg1:
                    revert with 'NH{q', 17
                if not arg1:
                    revert with 'NH{q', 18
                if arg1 * t / s / arg1 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _taxFee / 10000:
                    if not arg1 * _liquidityFee / 10000:
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 'NH{q', 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 'NH{q', 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 'NH{q', 17
                        return (arg1 * t / s)
                    if arg1 * _liquidityFee / 10000 and t / s > -1 / arg1 * _liquidityFee / 10000:
                        revert with 'NH{q', 17
                    if not arg1 * _liquidityFee / 10000:
                        revert with 'NH{q', 18
                    if arg1 * _liquidityFee / 10000 * t / s / arg1 * _liquidityFee / 10000 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 'NH{q', 17
                    if arg1 * _liquidityFee / 10000 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * _liquidityFee / 10000 * t / s:
                        revert with 'NH{q', 17
                    if 0 > (arg1 * t / s) - (arg1 * _liquidityFee / 10000 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * _liquidityFee / 10000 * t / s) < 0:
                        revert with 'NH{q', 17
                    return ((arg1 * t / s) - (arg1 * _liquidityFee / 10000 * t / s))
                if arg1 * _taxFee / 10000 and t / s > -1 / arg1 * _taxFee / 10000:
                    revert with 'NH{q', 17
                if not arg1 * _taxFee / 10000:
                    revert with 'NH{q', 18
                if arg1 * _taxFee / 10000 * t / s / arg1 * _taxFee / 10000 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _liquidityFee / 10000:
                    if arg1 * _taxFee / 10000 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * _taxFee / 10000 * t / s:
                        revert with 'NH{q', 17
                    if 0 > (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) < 0:
                        revert with 'NH{q', 17
                    if 0 > (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) < 0:
                        revert with 'NH{q', 17
                    return ((arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s))
                if arg1 * _liquidityFee / 10000 and t / s > -1 / arg1 * _liquidityFee / 10000:
                    revert with 'NH{q', 17
                if not arg1 * _liquidityFee / 10000:
                    revert with 'NH{q', 18
                if arg1 * _liquidityFee / 10000 * t / s / arg1 * _liquidityFee / 10000 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * _taxFee / 10000 * t / s > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < arg1 * _taxFee / 10000 * t / s:
                    revert with 'NH{q', 17
                if arg1 * _liquidityFee / 10000 * t / s > (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) < arg1 * _liquidityFee / 10000 * t / s:
                    revert with 'NH{q', 17
                if 0 > (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) - (arg1 * _liquidityFee / 10000 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) - (arg1 * _liquidityFee / 10000 * t / s) < 0:
                    revert with 'NH{q', 17
                return ((arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) - (arg1 * _liquidityFee / 10000 * t / s))
            if totalSupply <= 0:
                revert with 0, 'SafeMath: division by zero', 0
            if not totalSupply:
                revert with 'NH{q', 18
            if not arg1:
                if not arg1 * _taxFee / 10000:
                    if not arg1 * _liquidityFee / 10000:
                        return 0
                    if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                        revert with 'NH{q', 17
                    if not arg1 * _liquidityFee / 10000:
                        revert with 'NH{q', 18
                    if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                        revert with 'NH{q', 17
                    if 0 > -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply < 0:
                        revert with 'NH{q', 17
                    return (-1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply)
                if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                    revert with 'NH{q', 17
                if not arg1 * _taxFee / 10000:
                    revert with 'NH{q', 18
                if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _liquidityFee / 10000:
                    if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                        revert with 'NH{q', 17
                    if 0 > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                        revert with 'NH{q', 17
                    if 0 > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                        revert with 'NH{q', 17
                    return (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply)
                if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                    revert with 'NH{q', 17
                if not arg1 * _liquidityFee / 10000:
                    revert with 'NH{q', 18
                if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                    revert with 'NH{q', 17
                if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                    revert with 'NH{q', 17
                if 0 > (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                    revert with 'NH{q', 17
                return ((-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply))
            if arg1 and stor12 / totalSupply > -1 / arg1:
                revert with 'NH{q', 17
            if not arg1:
                revert with 'NH{q', 18
            if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * _taxFee / 10000:
                if not arg1 * _liquidityFee / 10000:
                    if 0 > arg1 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 'NH{q', 17
                    if 0 > arg1 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 'NH{q', 17
                    if 0 > arg1 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 'NH{q', 17
                    return (arg1 * stor12 / totalSupply)
                if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                    revert with 'NH{q', 17
                if not arg1 * _liquidityFee / 10000:
                    revert with 'NH{q', 18
                if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 > arg1 * stor12 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor12 / totalSupply < 0:
                    revert with 'NH{q', 17
                if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                    revert with 'NH{q', 17
                if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                    revert with 'NH{q', 17
                return ((arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply))
            if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                revert with 'NH{q', 17
            if not arg1 * _taxFee / 10000:
                revert with 'NH{q', 18
            if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * _liquidityFee / 10000:
                if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                    revert with 'NH{q', 17
                if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                    revert with 'NH{q', 17
                if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                    revert with 'NH{q', 17
                return ((arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply))
            if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                revert with 'NH{q', 17
            if not arg1 * _liquidityFee / 10000:
                revert with 'NH{q', 18
            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                revert with 'NH{q', 17
            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                revert with 'NH{q', 17
            if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                revert with 'NH{q', 17
            return ((arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply))
        if arg1 and _burnFee > -1 / arg1:
            revert with 'NH{q', 17
        if not arg1:
            revert with 'NH{q', 18
        if arg1 * _burnFee / arg1 != _burnFee:
            revert with 0, 'SafeMath: multiplication overflow'
        mem[224] = 26
        mem[256] = 'SafeMath: division by zero'
        mem[288] = 30
        mem[320] = 'SafeMath: subtraction overflow'
        if arg1 * _taxFee / 10000 > arg1:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if arg1 < arg1 * _taxFee / 10000:
            revert with 'NH{q', 17
        mem[352] = 30
        mem[384] = 'SafeMath: subtraction overflow'
        if arg1 * _liquidityFee / 10000 > arg1 - (arg1 * _taxFee / 10000):
            revert with 0, 'SafeMath: subtraction overflow', 0
        if arg1 - (arg1 * _taxFee / 10000) < arg1 * _liquidityFee / 10000:
            revert with 'NH{q', 17
        mem[64] = 480
        mem[416] = 30
        mem[448] = 'SafeMath: subtraction overflow'
        if arg1 * _burnFee / 10000 > arg1 - (arg1 * _taxFee / 10000) - (arg1 * _liquidityFee / 10000):
            revert with 0, 'SafeMath: subtraction overflow', 0
        if arg1 - (arg1 * _taxFee / 10000) - (arg1 * _liquidityFee / 10000) < arg1 * _burnFee / 10000:
            revert with 'NH{q', 17
        idx = 0
        s = totalSupply
        t = stor12
        while idx < stor9.length:
            mem[0] = stor9[idx]
            mem[32] = 3
            if stor3[stor9[idx]] > t:
                _2236 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2236] = 26
                mem[_2236 + 32] = 'SafeMath: division by zero'
                if totalSupply <= 0:
                    _2411 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2411 + idx + 68] = mem[_2236 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2411 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2411 + -mem[64] + 100
                if not totalSupply:
                    revert with 'NH{q', 18
                if not arg1:
                    if not arg1 * _taxFee / 10000:
                        if not arg1 * _liquidityFee / 10000:
                            if not arg1 * _burnFee / 10000:
                                return 0
                            if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                                revert with 'NH{q', 17
                            if not arg1 * _burnFee / 10000:
                                revert with 'NH{q', 18
                            if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _3310 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3310] = 30
                            mem[_3310 + 32] = 'SafeMath: subtraction overflow'
                            _3830 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3830] = 30
                            mem[_3830 + 32] = 'SafeMath: subtraction overflow'
                            _4872 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4872] = 30
                            mem[_4872 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _burnFee / 10000 * stor12 / totalSupply <= 0:
                                if 0 < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                                    revert with 'NH{q', 17
                                return (-1 * arg1 * _burnFee / 10000 * stor12 / totalSupply)
                            _5103 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_5103 + idx + 68] = mem[_4872 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5103 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5103 + -mem[64] + 100
                        if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                            revert with 'NH{q', 17
                        if not arg1 * _liquidityFee / 10000:
                            revert with 'NH{q', 18
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _burnFee / 10000:
                            _3309 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3309] = 30
                            mem[_3309 + 32] = 'SafeMath: subtraction overflow'
                            _3829 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3829] = 30
                            mem[_3829 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > 0:
                                _3959 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_3959 + idx + 68] = mem[_3829 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3959 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _3959 + -mem[64] + 100
                            if 0 < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                revert with 'NH{q', 17
                            _4871 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4871] = 30
                            mem[_4871 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                if -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                return (-1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply)
                            _5102 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_5102 + idx + 68] = mem[_4871 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5102 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5102 + -mem[64] + 100
                        if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                            revert with 'NH{q', 17
                        if not arg1 * _burnFee / 10000:
                            revert with 'NH{q', 18
                        if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _4078 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4078] = 30
                        mem[_4078 + 32] = 'SafeMath: subtraction overflow'
                        _5255 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5255] = 30
                        mem[_5255 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > 0:
                            _5578 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_5578 + idx + 68] = mem[_5255 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5578 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5578 + -mem[64] + 100
                        if 0 < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                            revert with 'NH{q', 17
                        _6944 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6944] = 30
                        mem[_6944 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _burnFee / 10000 * stor12 / totalSupply <= -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                            if -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                                revert with 'NH{q', 17
                            return ((-1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply) - (arg1 * _burnFee / 10000 * stor12 / totalSupply))
                        _7376 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_7376 + idx + 68] = mem[_6944 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_7376 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _7376 + -mem[64] + 100
                    if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                        revert with 'NH{q', 17
                    if not arg1 * _taxFee / 10000:
                        revert with 'NH{q', 18
                    if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _liquidityFee / 10000:
                        if not arg1 * _burnFee / 10000:
                            _3308 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3308] = 30
                            mem[_3308 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                                _3356 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_3356 + idx + 68] = mem[_3308 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3356 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _3356 + -mem[64] + 100
                            if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                revert with 'NH{q', 17
                            _3827 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3827] = 30
                            mem[_3827 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                _3958 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_3958 + idx + 68] = mem[_3827 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3958 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _3958 + -mem[64] + 100
                            if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _4870 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4870] = 30
                            mem[_4870 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                return (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply)
                            _5101 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_5101 + idx + 68] = mem[_4870 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5101 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5101 + -mem[64] + 100
                        if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                            revert with 'NH{q', 17
                        if not arg1 * _burnFee / 10000:
                            revert with 'NH{q', 18
                        if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _4077 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4077] = 30
                        mem[_4077 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                            _4217 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_4217 + idx + 68] = mem[_4077 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_4217 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _4217 + -mem[64] + 100
                        if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            revert with 'NH{q', 17
                        _5254 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5254] = 30
                        mem[_5254 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            _5575 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_5575 + idx + 68] = mem[_5254 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5575 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5575 + -mem[64] + 100
                        if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _6943 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6943] = 30
                        mem[_6943 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _burnFee / 10000 * stor12 / totalSupply <= -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                                revert with 'NH{q', 17
                            return ((-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _burnFee / 10000 * stor12 / totalSupply))
                        _7374 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_7374 + idx + 68] = mem[_6943 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_7374 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _7374 + -mem[64] + 100
                    if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                        revert with 'NH{q', 17
                    if not arg1 * _liquidityFee / 10000:
                        revert with 'NH{q', 18
                    if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _burnFee / 10000:
                        _4076 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4076] = 30
                        mem[_4076 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                            _4216 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_4216 + idx + 68] = mem[_4076 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_4216 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _4216 + -mem[64] + 100
                        if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            revert with 'NH{q', 17
                        _5253 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5253] = 30
                        mem[_5253 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            _5574 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_5574 + idx + 68] = mem[_5253 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5574 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5574 + -mem[64] + 100
                        if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                            revert with 'NH{q', 17
                        _6942 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6942] = 30
                        mem[_6942 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                            if (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                                revert with 'NH{q', 17
                            return ((-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply))
                        _7373 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_7373 + idx + 68] = mem[_6942 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_7373 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _7373 + -mem[64] + 100
                    if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                        revert with 'NH{q', 17
                    if not arg1 * _burnFee / 10000:
                        revert with 'NH{q', 18
                    if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _5759 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5759] = 30
                    mem[_5759 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                        _6018 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_6018 + idx + 68] = mem[_5759 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_6018 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _6018 + -mem[64] + 100
                    if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                        revert with 'NH{q', 17
                    _7532 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_7532] = 30
                    mem[_7532 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                        _7881 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_7881 + idx + 68] = mem[_7532 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_7881 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _7881 + -mem[64] + 100
                    if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                        revert with 'NH{q', 17
                    _9160 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9160] = 30
                    mem[_9160 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _burnFee / 10000 * stor12 / totalSupply <= (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                        if (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                            revert with 'NH{q', 17
                        return ((-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) - (arg1 * _burnFee / 10000 * stor12 / totalSupply))
                    _9516 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_9516 + idx + 68] = mem[_9160 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_9516 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _9516 + -mem[64] + 100
                if arg1 and stor12 / totalSupply > -1 / arg1:
                    revert with 'NH{q', 17
                if not arg1:
                    revert with 'NH{q', 18
                if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _taxFee / 10000:
                    if not arg1 * _liquidityFee / 10000:
                        if not arg1 * _burnFee / 10000:
                            _3307 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3307] = 30
                            mem[_3307 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor12 / totalSupply:
                                _3355 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_3355 + idx + 68] = mem[_3307 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3355 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _3355 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _3825 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3825] = 30
                            mem[_3825 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor12 / totalSupply:
                                _3957 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_3957 + idx + 68] = mem[_3825 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3957 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _3957 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _4869 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4869] = 30
                            mem[_4869 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor12 / totalSupply:
                                if arg1 * stor12 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                return (arg1 * stor12 / totalSupply)
                            _5098 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_5098 + idx + 68] = mem[_4869 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5098 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5098 + -mem[64] + 100
                        if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                            revert with 'NH{q', 17
                        if not arg1 * _burnFee / 10000:
                            revert with 'NH{q', 18
                        if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _4075 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4075] = 30
                        mem[_4075 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _4213 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_4213 + idx + 68] = mem[_4075 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_4213 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _4213 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _5251 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5251] = 30
                        mem[_5251 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _5571 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_5571 + idx + 68] = mem[_5251 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5571 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5571 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _6941 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6941] = 30
                        mem[_6941 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _burnFee / 10000 * stor12 / totalSupply <= arg1 * stor12 / totalSupply:
                            if arg1 * stor12 / totalSupply < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                                revert with 'NH{q', 17
                            return ((arg1 * stor12 / totalSupply) - (arg1 * _burnFee / 10000 * stor12 / totalSupply))
                        _7370 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_7370 + idx + 68] = mem[_6941 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_7370 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _7370 + -mem[64] + 100
                    if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                        revert with 'NH{q', 17
                    if not arg1 * _liquidityFee / 10000:
                        revert with 'NH{q', 18
                    if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _burnFee / 10000:
                        _4074 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4074] = 30
                        mem[_4074 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _4212 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_4212 + idx + 68] = mem[_4074 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_4212 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _4212 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _5250 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5250] = 30
                        mem[_5250 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                            _5570 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_5570 + idx + 68] = mem[_5250 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5570 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5570 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                            revert with 'NH{q', 17
                        _6940 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6940] = 30
                        mem[_6940 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                            if (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                                revert with 'NH{q', 17
                            return ((arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply))
                        _7369 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_7369 + idx + 68] = mem[_6940 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_7369 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _7369 + -mem[64] + 100
                    if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                        revert with 'NH{q', 17
                    if not arg1 * _burnFee / 10000:
                        revert with 'NH{q', 18
                    if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _5757 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5757] = 30
                    mem[_5757 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor12 / totalSupply:
                        _6013 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_6013 + idx + 68] = mem[_5757 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_6013 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _6013 + -mem[64] + 100
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 'NH{q', 17
                    _7530 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_7530] = 30
                    mem[_7530 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                        _7875 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_7875 + idx + 68] = mem[_7530 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_7875 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _7875 + -mem[64] + 100
                    if arg1 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                        revert with 'NH{q', 17
                    _9159 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9159] = 30
                    mem[_9159 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _burnFee / 10000 * stor12 / totalSupply <= (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                        if (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                            revert with 'NH{q', 17
                        return ((arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) - (arg1 * _burnFee / 10000 * stor12 / totalSupply))
                    _9513 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_9513 + idx + 68] = mem[_9159 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_9513 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _9513 + -mem[64] + 100
                if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                    revert with 'NH{q', 17
                if not arg1 * _taxFee / 10000:
                    revert with 'NH{q', 18
                if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _liquidityFee / 10000:
                    if not arg1 * _burnFee / 10000:
                        _4073 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4073] = 30
                        mem[_4073 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                            _4211 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_4211 + idx + 68] = mem[_4073 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_4211 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _4211 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            revert with 'NH{q', 17
                        _5248 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5248] = 30
                        mem[_5248 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                            _5569 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_5569 + idx + 68] = mem[_5248 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5569 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5569 + -mem[64] + 100
                        if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                            revert with 'NH{q', 17
                        _6939 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6939] = 30
                        mem[_6939 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                            if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                                revert with 'NH{q', 17
                            return ((arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply))
                        _7367 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_7367 + idx + 68] = mem[_6939 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_7367 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _7367 + -mem[64] + 100
                    if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                        revert with 'NH{q', 17
                    if not arg1 * _burnFee / 10000:
                        revert with 'NH{q', 18
                    if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _5756 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5756] = 30
                    mem[_5756 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                        _6010 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_6010 + idx + 68] = mem[_5756 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_6010 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _6010 + -mem[64] + 100
                    if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                        revert with 'NH{q', 17
                    _7529 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_7529] = 30
                    mem[_7529 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                        _7872 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_7872 + idx + 68] = mem[_7529 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_7872 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _7872 + -mem[64] + 100
                    if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                        revert with 'NH{q', 17
                    _9158 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9158] = 30
                    mem[_9158 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _burnFee / 10000 * stor12 / totalSupply <= (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                        if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                            revert with 'NH{q', 17
                        return ((arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _burnFee / 10000 * stor12 / totalSupply))
                    _9511 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_9511 + idx + 68] = mem[_9158 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_9511 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _9511 + -mem[64] + 100
                if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                    revert with 'NH{q', 17
                if not arg1 * _liquidityFee / 10000:
                    revert with 'NH{q', 18
                if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _burnFee / 10000:
                    _5755 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5755] = 30
                    mem[_5755 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                        _6009 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_6009 + idx + 68] = mem[_5755 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_6009 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _6009 + -mem[64] + 100
                    if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                        revert with 'NH{q', 17
                    _7528 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_7528] = 30
                    mem[_7528 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                        _7871 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_7871 + idx + 68] = mem[_7528 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_7871 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _7871 + -mem[64] + 100
                    if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                        revert with 'NH{q', 17
                    _9157 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9157] = 30
                    mem[_9157 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                        if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                            revert with 'NH{q', 17
                        return ((arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply))
                    _9510 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_9510 + idx + 68] = mem[_9157 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_9510 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _9510 + -mem[64] + 100
                if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                    revert with 'NH{q', 17
                if not arg1 * _burnFee / 10000:
                    revert with 'NH{q', 18
                if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                _8075 = mem[64]
                mem[64] = mem[64] + 64
                mem[_8075] = 30
                mem[_8075 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                    _8345 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_8345 + idx + 68] = mem[_8075 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_8345 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _8345 + -mem[64] + 100
                if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                    revert with 'NH{q', 17
                _9593 = mem[64]
                mem[64] = mem[64] + 64
                mem[_9593] = 30
                mem[_9593 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                    _9753 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_9753 + idx + 68] = mem[_9593 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_9753 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _9753 + -mem[64] + 100
                if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                    revert with 'NH{q', 17
                _10425 = mem[64]
                mem[64] = mem[64] + 64
                mem[_10425] = 30
                mem[_10425 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _burnFee / 10000 * stor12 / totalSupply <= (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                    if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                        revert with 'NH{q', 17
                    return ((arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) - (arg1 * _burnFee / 10000 * stor12 / totalSupply))
                _10573 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_10573 + idx + 68] = mem[_10425 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_10573 + 98] = 0
                revert with memory
                  from mem[64]
                   len _10573 + -mem[64] + 100
            if idx >= stor9.length:
                revert with 'NH{q', 50
            mem[0] = stor9[idx]
            mem[32] = 4
            if stor4[stor9[idx]] <= s:
                if idx >= stor9.length:
                    revert with 'NH{q', 50
                mem[0] = stor9[idx]
                mem[32] = 3
                _2347 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2347] = 30
                mem[_2347 + 32] = 'SafeMath: subtraction overflow'
                if stor3[stor9[idx]] > t:
                    _2443 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_2443 + idx + 68] = mem[_2347 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2443 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _2443 + -mem[64] + 100
                if t < stor3[stor9[idx]]:
                    revert with 'NH{q', 17
                if idx >= stor9.length:
                    revert with 'NH{q', 50
                mem[0] = stor9[idx]
                mem[32] = 4
                _2715 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2715] = 30
                mem[_2715 + 32] = 'SafeMath: subtraction overflow'
                if stor4[stor9[idx]] <= s:
                    if s < stor4[stor9[idx]]:
                        revert with 'NH{q', 17
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    s = s - stor4[stor9[idx]]
                    t = t - stor3[stor9[idx]]
                    continue 
                _2763 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_2763 + idx + 68] = mem[_2715 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_2763 + 98] = 0
                revert with memory
                  from mem[64]
                   len _2763 + -mem[64] + 100
            _2412 = mem[64]
            mem[64] = mem[64] + 64
            mem[_2412] = 26
            mem[_2412 + 32] = 'SafeMath: division by zero'
            if totalSupply <= 0:
                _2459 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_2459 + idx + 68] = mem[_2412 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_2459 + 94] = 0
                revert with memory
                  from mem[64]
                   len _2459 + -mem[64] + 100
            if not totalSupply:
                revert with 'NH{q', 18
            if not arg1:
                if not arg1 * _taxFee / 10000:
                    if not arg1 * _liquidityFee / 10000:
                        if not arg1 * _burnFee / 10000:
                            return 0
                        if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                            revert with 'NH{q', 17
                        if not arg1 * _burnFee / 10000:
                            revert with 'NH{q', 18
                        if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _3360 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3360] = 30
                        mem[_3360 + 32] = 'SafeMath: subtraction overflow'
                        _3967 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3967] = 30
                        mem[_3967 + 32] = 'SafeMath: subtraction overflow'
                        _5107 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5107] = 30
                        mem[_5107 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _burnFee / 10000 * stor12 / totalSupply <= 0:
                            if 0 < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                                revert with 'NH{q', 17
                            return (-1 * arg1 * _burnFee / 10000 * stor12 / totalSupply)
                        _5461 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_5461 + idx + 68] = mem[_5107 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_5461 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _5461 + -mem[64] + 100
                    if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                        revert with 'NH{q', 17
                    if not arg1 * _liquidityFee / 10000:
                        revert with 'NH{q', 18
                    if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _burnFee / 10000:
                        _3359 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3359] = 30
                        mem[_3359 + 32] = 'SafeMath: subtraction overflow'
                        _3966 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3966] = 30
                        mem[_3966 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > 0:
                            _4171 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_4171 + idx + 68] = mem[_3966 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_4171 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _4171 + -mem[64] + 100
                        if 0 < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                            revert with 'NH{q', 17
                        _5106 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5106] = 30
                        mem[_5106 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                            if -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply < 0:
                                revert with 'NH{q', 17
                            return (-1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply)
                        _5460 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_5460 + idx + 68] = mem[_5106 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_5460 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _5460 + -mem[64] + 100
                    if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                        revert with 'NH{q', 17
                    if not arg1 * _burnFee / 10000:
                        revert with 'NH{q', 18
                    if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _4226 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4226] = 30
                    mem[_4226 + 32] = 'SafeMath: subtraction overflow'
                    _5591 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5591] = 30
                    mem[_5591 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > 0:
                        _5891 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_5891 + idx + 68] = mem[_5591 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_5891 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _5891 + -mem[64] + 100
                    if 0 < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                        revert with 'NH{q', 17
                    _7384 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_7384] = 30
                    mem[_7384 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _burnFee / 10000 * stor12 / totalSupply <= -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                        if -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                            revert with 'NH{q', 17
                        return ((-1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply) - (arg1 * _burnFee / 10000 * stor12 / totalSupply))
                    _7738 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_7738 + idx + 68] = mem[_7384 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_7738 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _7738 + -mem[64] + 100
                if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                    revert with 'NH{q', 17
                if not arg1 * _taxFee / 10000:
                    revert with 'NH{q', 18
                if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _liquidityFee / 10000:
                    if not arg1 * _burnFee / 10000:
                        _3358 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3358] = 30
                        mem[_3358 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                            _3477 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_3477 + idx + 68] = mem[_3358 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3477 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _3477 + -mem[64] + 100
                        if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            revert with 'NH{q', 17
                        _3964 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3964] = 30
                        mem[_3964 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            _4170 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_4170 + idx + 68] = mem[_3964 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_4170 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _4170 + -mem[64] + 100
                        if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _5105 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5105] = 30
                        mem[_5105 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                                revert with 'NH{q', 17
                            return (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply)
                        _5459 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_5459 + idx + 68] = mem[_5105 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_5459 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _5459 + -mem[64] + 100
                    if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                        revert with 'NH{q', 17
                    if not arg1 * _burnFee / 10000:
                        revert with 'NH{q', 18
                    if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _4225 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4225] = 30
                    mem[_4225 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                        _4403 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_4403 + idx + 68] = mem[_4225 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4403 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _4403 + -mem[64] + 100
                    if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                        revert with 'NH{q', 17
                    _5590 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5590] = 30
                    mem[_5590 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                        _5888 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_5888 + idx + 68] = mem[_5590 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_5888 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _5888 + -mem[64] + 100
                    if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                        revert with 'NH{q', 17
                    _7383 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_7383] = 30
                    mem[_7383 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _burnFee / 10000 * stor12 / totalSupply <= -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                        if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                            revert with 'NH{q', 17
                        return ((-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _burnFee / 10000 * stor12 / totalSupply))
                    _7736 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_7736 + idx + 68] = mem[_7383 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_7736 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _7736 + -mem[64] + 100
                if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                    revert with 'NH{q', 17
                if not arg1 * _liquidityFee / 10000:
                    revert with 'NH{q', 18
                if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _burnFee / 10000:
                    _4224 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4224] = 30
                    mem[_4224 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                        _4402 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_4402 + idx + 68] = mem[_4224 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4402 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _4402 + -mem[64] + 100
                    if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                        revert with 'NH{q', 17
                    _5589 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5589] = 30
                    mem[_5589 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                        _5887 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_5887 + idx + 68] = mem[_5589 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_5887 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _5887 + -mem[64] + 100
                    if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                        revert with 'NH{q', 17
                    _7382 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_7382] = 30
                    mem[_7382 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                        if (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                            revert with 'NH{q', 17
                        return ((-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply))
                    _7735 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_7735 + idx + 68] = mem[_7382 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_7735 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _7735 + -mem[64] + 100
                if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                    revert with 'NH{q', 17
                if not arg1 * _burnFee / 10000:
                    revert with 'NH{q', 18
                if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                _6028 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6028] = 30
                mem[_6028 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                    _6294 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_6294 + idx + 68] = mem[_6028 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_6294 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _6294 + -mem[64] + 100
                if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                    revert with 'NH{q', 17
                _7896 = mem[64]
                mem[64] = mem[64] + 64
                mem[_7896] = 30
                mem[_7896 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                    _8229 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_8229 + idx + 68] = mem[_7896 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_8229 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _8229 + -mem[64] + 100
                if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                    revert with 'NH{q', 17
                _9523 = mem[64]
                mem[64] = mem[64] + 64
                mem[_9523] = 30
                mem[_9523 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _burnFee / 10000 * stor12 / totalSupply <= (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                    if (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                        revert with 'NH{q', 17
                    return ((-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) - (arg1 * _burnFee / 10000 * stor12 / totalSupply))
                _9688 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_9688 + idx + 68] = mem[_9523 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_9688 + 98] = 0
                revert with memory
                  from mem[64]
                   len _9688 + -mem[64] + 100
            if arg1 and stor12 / totalSupply > -1 / arg1:
                revert with 'NH{q', 17
            if not arg1:
                revert with 'NH{q', 18
            if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * _taxFee / 10000:
                if not arg1 * _liquidityFee / 10000:
                    if not arg1 * _burnFee / 10000:
                        _3357 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3357] = 30
                        mem[_3357 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _3476 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_3476 + idx + 68] = mem[_3357 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3476 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _3476 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _3962 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3962] = 30
                        mem[_3962 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _4169 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_4169 + idx + 68] = mem[_3962 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_4169 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _4169 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _5104 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5104] = 30
                        mem[_5104 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= arg1 * stor12 / totalSupply:
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 'NH{q', 17
                            return (arg1 * stor12 / totalSupply)
                        _5456 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_5456 + idx + 68] = mem[_5104 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_5456 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _5456 + -mem[64] + 100
                    if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                        revert with 'NH{q', 17
                    if not arg1 * _burnFee / 10000:
                        revert with 'NH{q', 18
                    if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _4223 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4223] = 30
                    mem[_4223 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor12 / totalSupply:
                        _4399 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_4399 + idx + 68] = mem[_4223 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4399 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _4399 + -mem[64] + 100
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 'NH{q', 17
                    _5587 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5587] = 30
                    mem[_5587 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor12 / totalSupply:
                        _5884 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_5884 + idx + 68] = mem[_5587 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_5884 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _5884 + -mem[64] + 100
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 'NH{q', 17
                    _7381 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_7381] = 30
                    mem[_7381 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _burnFee / 10000 * stor12 / totalSupply <= arg1 * stor12 / totalSupply:
                        if arg1 * stor12 / totalSupply < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                            revert with 'NH{q', 17
                        return ((arg1 * stor12 / totalSupply) - (arg1 * _burnFee / 10000 * stor12 / totalSupply))
                    _7732 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_7732 + idx + 68] = mem[_7381 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_7732 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _7732 + -mem[64] + 100
                if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                    revert with 'NH{q', 17
                if not arg1 * _liquidityFee / 10000:
                    revert with 'NH{q', 18
                if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _burnFee / 10000:
                    _4222 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4222] = 30
                    mem[_4222 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor12 / totalSupply:
                        _4398 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_4398 + idx + 68] = mem[_4222 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4398 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _4398 + -mem[64] + 100
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 'NH{q', 17
                    _5586 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5586] = 30
                    mem[_5586 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                        _5883 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_5883 + idx + 68] = mem[_5586 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_5883 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _5883 + -mem[64] + 100
                    if arg1 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                        revert with 'NH{q', 17
                    _7380 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_7380] = 30
                    mem[_7380 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                        if (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                            revert with 'NH{q', 17
                        return ((arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply))
                    _7731 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_7731 + idx + 68] = mem[_7380 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_7731 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _7731 + -mem[64] + 100
                if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                    revert with 'NH{q', 17
                if not arg1 * _burnFee / 10000:
                    revert with 'NH{q', 18
                if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                _6026 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6026] = 30
                mem[_6026 + 32] = 'SafeMath: subtraction overflow'
                if 0 > arg1 * stor12 / totalSupply:
                    _6289 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_6289 + idx + 68] = mem[_6026 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_6289 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _6289 + -mem[64] + 100
                if arg1 * stor12 / totalSupply < 0:
                    revert with 'NH{q', 17
                _7894 = mem[64]
                mem[64] = mem[64] + 64
                mem[_7894] = 30
                mem[_7894 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                    _8223 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_8223 + idx + 68] = mem[_7894 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_8223 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _8223 + -mem[64] + 100
                if arg1 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                    revert with 'NH{q', 17
                _9522 = mem[64]
                mem[64] = mem[64] + 64
                mem[_9522] = 30
                mem[_9522 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _burnFee / 10000 * stor12 / totalSupply <= (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                    if (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                        revert with 'NH{q', 17
                    return ((arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) - (arg1 * _burnFee / 10000 * stor12 / totalSupply))
                _9685 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_9685 + idx + 68] = mem[_9522 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_9685 + 98] = 0
                revert with memory
                  from mem[64]
                   len _9685 + -mem[64] + 100
            if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                revert with 'NH{q', 17
            if not arg1 * _taxFee / 10000:
                revert with 'NH{q', 18
            if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * _liquidityFee / 10000:
                if not arg1 * _burnFee / 10000:
                    _4221 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4221] = 30
                    mem[_4221 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                        _4397 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_4397 + idx + 68] = mem[_4221 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4397 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _4397 + -mem[64] + 100
                    if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                        revert with 'NH{q', 17
                    _5584 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5584] = 30
                    mem[_5584 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                        _5882 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_5882 + idx + 68] = mem[_5584 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_5882 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _5882 + -mem[64] + 100
                    if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                        revert with 'NH{q', 17
                    _7379 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_7379] = 30
                    mem[_7379 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                        if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                            revert with 'NH{q', 17
                        return ((arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply))
                    _7729 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_7729 + idx + 68] = mem[_7379 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_7729 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _7729 + -mem[64] + 100
                if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                    revert with 'NH{q', 17
                if not arg1 * _burnFee / 10000:
                    revert with 'NH{q', 18
                if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                _6025 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6025] = 30
                mem[_6025 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                    _6286 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_6286 + idx + 68] = mem[_6025 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_6286 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _6286 + -mem[64] + 100
                if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                    revert with 'NH{q', 17
                _7893 = mem[64]
                mem[64] = mem[64] + 64
                mem[_7893] = 30
                mem[_7893 + 32] = 'SafeMath: subtraction overflow'
                if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                    _8220 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_8220 + idx + 68] = mem[_7893 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_8220 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _8220 + -mem[64] + 100
                if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                    revert with 'NH{q', 17
                _9521 = mem[64]
                mem[64] = mem[64] + 64
                mem[_9521] = 30
                mem[_9521 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _burnFee / 10000 * stor12 / totalSupply <= (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                    if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                        revert with 'NH{q', 17
                    return ((arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _burnFee / 10000 * stor12 / totalSupply))
                _9683 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_9683 + idx + 68] = mem[_9521 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_9683 + 98] = 0
                revert with memory
                  from mem[64]
                   len _9683 + -mem[64] + 100
            if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                revert with 'NH{q', 17
            if not arg1 * _liquidityFee / 10000:
                revert with 'NH{q', 18
            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * _burnFee / 10000:
                _6024 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6024] = 30
                mem[_6024 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                    _6285 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_6285 + idx + 68] = mem[_6024 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_6285 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _6285 + -mem[64] + 100
                if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                    revert with 'NH{q', 17
                _7892 = mem[64]
                mem[64] = mem[64] + 64
                mem[_7892] = 30
                mem[_7892 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                    _8219 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_8219 + idx + 68] = mem[_7892 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_8219 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _8219 + -mem[64] + 100
                if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                    revert with 'NH{q', 17
                _9520 = mem[64]
                mem[64] = mem[64] + 64
                mem[_9520] = 30
                mem[_9520 + 32] = 'SafeMath: subtraction overflow'
                if 0 <= (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                    if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                        revert with 'NH{q', 17
                    return ((arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply))
                _9682 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_9682 + idx + 68] = mem[_9520 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_9682 + 98] = 0
                revert with memory
                  from mem[64]
                   len _9682 + -mem[64] + 100
            if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                revert with 'NH{q', 17
            if not arg1 * _burnFee / 10000:
                revert with 'NH{q', 18
            if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            _8354 = mem[64]
            mem[64] = mem[64] + 64
            mem[_8354] = 30
            mem[_8354 + 32] = 'SafeMath: subtraction overflow'
            if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                _8591 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_8591 + idx + 68] = mem[_8354 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_8591 + 98] = 0
                revert with memory
                  from mem[64]
                   len _8591 + -mem[64] + 100
            if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                revert with 'NH{q', 17
            _9768 = mem[64]
            mem[64] = mem[64] + 64
            mem[_9768] = 30
            mem[_9768 + 32] = 'SafeMath: subtraction overflow'
            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                _9951 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_9951 + idx + 68] = mem[_9768 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_9951 + 98] = 0
                revert with memory
                  from mem[64]
                   len _9951 + -mem[64] + 100
            if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                revert with 'NH{q', 17
            _10578 = mem[64]
            mem[64] = mem[64] + 64
            mem[_10578] = 30
            mem[_10578 + 32] = 'SafeMath: subtraction overflow'
            if arg1 * _burnFee / 10000 * stor12 / totalSupply <= (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                    revert with 'NH{q', 17
                return ((arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) - (arg1 * _burnFee / 10000 * stor12 / totalSupply))
            _10615 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[_10615 + idx + 68] = mem[_10578 + idx + 32]
                idx = idx + 32
                continue 
            mem[_10615 + 98] = 0
            revert with memory
              from mem[64]
               len _10615 + -mem[64] + 100
        if totalSupply <= 0:
            revert with 0, 'SafeMath: division by zero', 0
        if not totalSupply:
            revert with 'NH{q', 18
        if t >= stor12 / totalSupply:
            if s <= 0:
                revert with 0, 'SafeMath: division by zero', 0
            if not s:
                revert with 'NH{q', 18
            if not arg1:
                if not arg1 * _taxFee / 10000:
                    if not arg1 * _liquidityFee / 10000:
                        if not arg1 * _burnFee / 10000:
                            return 0
                        if arg1 * _burnFee / 10000 and t / s > -1 / arg1 * _burnFee / 10000:
                            revert with 'NH{q', 17
                        if not arg1 * _burnFee / 10000:
                            revert with 'NH{q', 18
                        if arg1 * _burnFee / 10000 * t / s / arg1 * _burnFee / 10000 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * _burnFee / 10000 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _burnFee / 10000 * t / s:
                            revert with 'NH{q', 17
                        return (-1 * arg1 * _burnFee / 10000 * t / s)
                    if arg1 * _liquidityFee / 10000 and t / s > -1 / arg1 * _liquidityFee / 10000:
                        revert with 'NH{q', 17
                    if not arg1 * _liquidityFee / 10000:
                        revert with 'NH{q', 18
                    if arg1 * _liquidityFee / 10000 * t / s / arg1 * _liquidityFee / 10000 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _burnFee / 10000:
                        if arg1 * _liquidityFee / 10000 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _liquidityFee / 10000 * t / s:
                            revert with 'NH{q', 17
                        if 0 > -1 * arg1 * _liquidityFee / 10000 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _liquidityFee / 10000 * t / s < 0:
                            revert with 'NH{q', 17
                        return (-1 * arg1 * _liquidityFee / 10000 * t / s)
                    if arg1 * _burnFee / 10000 and t / s > -1 / arg1 * _burnFee / 10000:
                        revert with 'NH{q', 17
                    if not arg1 * _burnFee / 10000:
                        revert with 'NH{q', 18
                    if arg1 * _burnFee / 10000 * t / s / arg1 * _burnFee / 10000 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * _liquidityFee / 10000 * t / s > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _liquidityFee / 10000 * t / s:
                        revert with 'NH{q', 17
                    if arg1 * _burnFee / 10000 * t / s > -1 * arg1 * _liquidityFee / 10000 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _liquidityFee / 10000 * t / s < arg1 * _burnFee / 10000 * t / s:
                        revert with 'NH{q', 17
                    return ((-1 * arg1 * _liquidityFee / 10000 * t / s) - (arg1 * _burnFee / 10000 * t / s))
                if arg1 * _taxFee / 10000 and t / s > -1 / arg1 * _taxFee / 10000:
                    revert with 'NH{q', 17
                if not arg1 * _taxFee / 10000:
                    revert with 'NH{q', 18
                if arg1 * _taxFee / 10000 * t / s / arg1 * _taxFee / 10000 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _liquidityFee / 10000:
                    if not arg1 * _burnFee / 10000:
                        if arg1 * _taxFee / 10000 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _taxFee / 10000 * t / s:
                            revert with 'NH{q', 17
                        if 0 > -1 * arg1 * _taxFee / 10000 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _taxFee / 10000 * t / s < 0:
                            revert with 'NH{q', 17
                        if 0 > -1 * arg1 * _taxFee / 10000 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _taxFee / 10000 * t / s < 0:
                            revert with 'NH{q', 17
                        return (-1 * arg1 * _taxFee / 10000 * t / s)
                    if arg1 * _burnFee / 10000 and t / s > -1 / arg1 * _burnFee / 10000:
                        revert with 'NH{q', 17
                    if not arg1 * _burnFee / 10000:
                        revert with 'NH{q', 18
                    if arg1 * _burnFee / 10000 * t / s / arg1 * _burnFee / 10000 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * _taxFee / 10000 * t / s > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _taxFee / 10000 * t / s:
                        revert with 'NH{q', 17
                    if 0 > -1 * arg1 * _taxFee / 10000 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _taxFee / 10000 * t / s < 0:
                        revert with 'NH{q', 17
                    if arg1 * _burnFee / 10000 * t / s > -1 * arg1 * _taxFee / 10000 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _taxFee / 10000 * t / s < arg1 * _burnFee / 10000 * t / s:
                        revert with 'NH{q', 17
                    return ((-1 * arg1 * _taxFee / 10000 * t / s) - (arg1 * _burnFee / 10000 * t / s))
                if arg1 * _liquidityFee / 10000 and t / s > -1 / arg1 * _liquidityFee / 10000:
                    revert with 'NH{q', 17
                if not arg1 * _liquidityFee / 10000:
                    revert with 'NH{q', 18
                if arg1 * _liquidityFee / 10000 * t / s / arg1 * _liquidityFee / 10000 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _burnFee / 10000:
                    if arg1 * _taxFee / 10000 * t / s > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _taxFee / 10000 * t / s:
                        revert with 'NH{q', 17
                    if arg1 * _liquidityFee / 10000 * t / s > -1 * arg1 * _taxFee / 10000 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _taxFee / 10000 * t / s < arg1 * _liquidityFee / 10000 * t / s:
                        revert with 'NH{q', 17
                    if 0 > (-1 * arg1 * _taxFee / 10000 * t / s) - (arg1 * _liquidityFee / 10000 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (-1 * arg1 * _taxFee / 10000 * t / s) - (arg1 * _liquidityFee / 10000 * t / s) < 0:
                        revert with 'NH{q', 17
                    return ((-1 * arg1 * _taxFee / 10000 * t / s) - (arg1 * _liquidityFee / 10000 * t / s))
                if arg1 * _burnFee / 10000 and t / s > -1 / arg1 * _burnFee / 10000:
                    revert with 'NH{q', 17
                if not arg1 * _burnFee / 10000:
                    revert with 'NH{q', 18
                if arg1 * _burnFee / 10000 * t / s / arg1 * _burnFee / 10000 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * _taxFee / 10000 * t / s > 0:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if 0 < arg1 * _taxFee / 10000 * t / s:
                    revert with 'NH{q', 17
                if arg1 * _liquidityFee / 10000 * t / s > -1 * arg1 * _taxFee / 10000 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if -1 * arg1 * _taxFee / 10000 * t / s < arg1 * _liquidityFee / 10000 * t / s:
                    revert with 'NH{q', 17
                if arg1 * _burnFee / 10000 * t / s > (-1 * arg1 * _taxFee / 10000 * t / s) - (arg1 * _liquidityFee / 10000 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (-1 * arg1 * _taxFee / 10000 * t / s) - (arg1 * _liquidityFee / 10000 * t / s) < arg1 * _burnFee / 10000 * t / s:
                    revert with 'NH{q', 17
                return ((-1 * arg1 * _taxFee / 10000 * t / s) - (arg1 * _liquidityFee / 10000 * t / s) - (arg1 * _burnFee / 10000 * t / s))
            if arg1 and t / s > -1 / arg1:
                revert with 'NH{q', 17
            if not arg1:
                revert with 'NH{q', 18
            if arg1 * t / s / arg1 != t / s:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * _taxFee / 10000:
                if not arg1 * _liquidityFee / 10000:
                    if not arg1 * _burnFee / 10000:
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 'NH{q', 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 'NH{q', 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 'NH{q', 17
                        return (arg1 * t / s)
                    if arg1 * _burnFee / 10000 and t / s > -1 / arg1 * _burnFee / 10000:
                        revert with 'NH{q', 17
                    if not arg1 * _burnFee / 10000:
                        revert with 'NH{q', 18
                    if arg1 * _burnFee / 10000 * t / s / arg1 * _burnFee / 10000 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 'NH{q', 17
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 'NH{q', 17
                    if arg1 * _burnFee / 10000 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * _burnFee / 10000 * t / s:
                        revert with 'NH{q', 17
                    return ((arg1 * t / s) - (arg1 * _burnFee / 10000 * t / s))
                if arg1 * _liquidityFee / 10000 and t / s > -1 / arg1 * _liquidityFee / 10000:
                    revert with 'NH{q', 17
                if not arg1 * _liquidityFee / 10000:
                    revert with 'NH{q', 18
                if arg1 * _liquidityFee / 10000 * t / s / arg1 * _liquidityFee / 10000 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _burnFee / 10000:
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 'NH{q', 17
                    if arg1 * _liquidityFee / 10000 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * _liquidityFee / 10000 * t / s:
                        revert with 'NH{q', 17
                    if 0 > (arg1 * t / s) - (arg1 * _liquidityFee / 10000 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * _liquidityFee / 10000 * t / s) < 0:
                        revert with 'NH{q', 17
                    return ((arg1 * t / s) - (arg1 * _liquidityFee / 10000 * t / s))
                if arg1 * _burnFee / 10000 and t / s > -1 / arg1 * _burnFee / 10000:
                    revert with 'NH{q', 17
                if not arg1 * _burnFee / 10000:
                    revert with 'NH{q', 18
                if arg1 * _burnFee / 10000 * t / s / arg1 * _burnFee / 10000 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < 0:
                    revert with 'NH{q', 17
                if arg1 * _liquidityFee / 10000 * t / s > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < arg1 * _liquidityFee / 10000 * t / s:
                    revert with 'NH{q', 17
                if arg1 * _burnFee / 10000 * t / s > (arg1 * t / s) - (arg1 * _liquidityFee / 10000 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * _liquidityFee / 10000 * t / s) < arg1 * _burnFee / 10000 * t / s:
                    revert with 'NH{q', 17
                return ((arg1 * t / s) - (arg1 * _liquidityFee / 10000 * t / s) - (arg1 * _burnFee / 10000 * t / s))
            if arg1 * _taxFee / 10000 and t / s > -1 / arg1 * _taxFee / 10000:
                revert with 'NH{q', 17
            if not arg1 * _taxFee / 10000:
                revert with 'NH{q', 18
            if arg1 * _taxFee / 10000 * t / s / arg1 * _taxFee / 10000 != t / s:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * _liquidityFee / 10000:
                if not arg1 * _burnFee / 10000:
                    if arg1 * _taxFee / 10000 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * _taxFee / 10000 * t / s:
                        revert with 'NH{q', 17
                    if 0 > (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) < 0:
                        revert with 'NH{q', 17
                    if 0 > (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) < 0:
                        revert with 'NH{q', 17
                    return ((arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s))
                if arg1 * _burnFee / 10000 and t / s > -1 / arg1 * _burnFee / 10000:
                    revert with 'NH{q', 17
                if not arg1 * _burnFee / 10000:
                    revert with 'NH{q', 18
                if arg1 * _burnFee / 10000 * t / s / arg1 * _burnFee / 10000 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * _taxFee / 10000 * t / s > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < arg1 * _taxFee / 10000 * t / s:
                    revert with 'NH{q', 17
                if 0 > (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) < 0:
                    revert with 'NH{q', 17
                if arg1 * _burnFee / 10000 * t / s > (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) < arg1 * _burnFee / 10000 * t / s:
                    revert with 'NH{q', 17
                return ((arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) - (arg1 * _burnFee / 10000 * t / s))
            if arg1 * _liquidityFee / 10000 and t / s > -1 / arg1 * _liquidityFee / 10000:
                revert with 'NH{q', 17
            if not arg1 * _liquidityFee / 10000:
                revert with 'NH{q', 18
            if arg1 * _liquidityFee / 10000 * t / s / arg1 * _liquidityFee / 10000 != t / s:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * _burnFee / 10000:
                if arg1 * _taxFee / 10000 * t / s > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < arg1 * _taxFee / 10000 * t / s:
                    revert with 'NH{q', 17
                if arg1 * _liquidityFee / 10000 * t / s > (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) < arg1 * _liquidityFee / 10000 * t / s:
                    revert with 'NH{q', 17
                if 0 > (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) - (arg1 * _liquidityFee / 10000 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) - (arg1 * _liquidityFee / 10000 * t / s) < 0:
                    revert with 'NH{q', 17
                return ((arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) - (arg1 * _liquidityFee / 10000 * t / s))
            if arg1 * _burnFee / 10000 and t / s > -1 / arg1 * _burnFee / 10000:
                revert with 'NH{q', 17
            if not arg1 * _burnFee / 10000:
                revert with 'NH{q', 18
            if arg1 * _burnFee / 10000 * t / s / arg1 * _burnFee / 10000 != t / s:
                revert with 0, 'SafeMath: multiplication overflow'
            if arg1 * _taxFee / 10000 * t / s > arg1 * t / s:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * t / s < arg1 * _taxFee / 10000 * t / s:
                revert with 'NH{q', 17
            if arg1 * _liquidityFee / 10000 * t / s > (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) < arg1 * _liquidityFee / 10000 * t / s:
                revert with 'NH{q', 17
            if arg1 * _burnFee / 10000 * t / s > (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) - (arg1 * _liquidityFee / 10000 * t / s):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) - (arg1 * _liquidityFee / 10000 * t / s) < arg1 * _burnFee / 10000 * t / s:
                revert with 'NH{q', 17
            return ((arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) - (arg1 * _liquidityFee / 10000 * t / s) - (arg1 * _burnFee / 10000 * t / s))
        if totalSupply <= 0:
            revert with 0, 'SafeMath: division by zero', 0
        if not totalSupply:
            revert with 'NH{q', 18
        if not arg1:
            if not arg1 * _taxFee / 10000:
                if not arg1 * _liquidityFee / 10000:
                    if not arg1 * _burnFee / 10000:
                        return 0
                    if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                        revert with 'NH{q', 17
                    if not arg1 * _burnFee / 10000:
                        revert with 'NH{q', 18
                    if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * _burnFee / 10000 * stor12 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                        revert with 'NH{q', 17
                    return (-1 * arg1 * _burnFee / 10000 * stor12 / totalSupply)
                if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                    revert with 'NH{q', 17
                if not arg1 * _liquidityFee / 10000:
                    revert with 'NH{q', 18
                if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _burnFee / 10000:
                    if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                        revert with 'NH{q', 17
                    if 0 > -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply < 0:
                        revert with 'NH{q', 17
                    return (-1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply)
                if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                    revert with 'NH{q', 17
                if not arg1 * _burnFee / 10000:
                    revert with 'NH{q', 18
                if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > 0:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if 0 < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                    revert with 'NH{q', 17
                if arg1 * _burnFee / 10000 * stor12 / totalSupply > -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                    revert with 'NH{q', 17
                return ((-1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply) - (arg1 * _burnFee / 10000 * stor12 / totalSupply))
            if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                revert with 'NH{q', 17
            if not arg1 * _taxFee / 10000:
                revert with 'NH{q', 18
            if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * _liquidityFee / 10000:
                if not arg1 * _burnFee / 10000:
                    if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                        revert with 'NH{q', 17
                    if 0 > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                        revert with 'NH{q', 17
                    if 0 > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                        revert with 'NH{q', 17
                    return (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply)
                if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                    revert with 'NH{q', 17
                if not arg1 * _burnFee / 10000:
                    revert with 'NH{q', 18
                if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                    revert with 'NH{q', 17
                if 0 > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                    revert with 'NH{q', 17
                if arg1 * _burnFee / 10000 * stor12 / totalSupply > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                    revert with 'NH{q', 17
                return ((-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _burnFee / 10000 * stor12 / totalSupply))
            if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                revert with 'NH{q', 17
            if not arg1 * _liquidityFee / 10000:
                revert with 'NH{q', 18
            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * _burnFee / 10000:
                if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                    revert with 'NH{q', 17
                if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                    revert with 'NH{q', 17
                if 0 > (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                    revert with 'NH{q', 17
                return ((-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply))
            if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                revert with 'NH{q', 17
            if not arg1 * _burnFee / 10000:
                revert with 'NH{q', 18
            if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                revert with 'NH{q', 17
            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                revert with 'NH{q', 17
            if arg1 * _burnFee / 10000 * stor12 / totalSupply > (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                revert with 'NH{q', 17
            return ((-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) - (arg1 * _burnFee / 10000 * stor12 / totalSupply))
        if arg1 and stor12 / totalSupply > -1 / arg1:
            revert with 'NH{q', 17
        if not arg1:
            revert with 'NH{q', 18
        if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
            revert with 0, 'SafeMath: multiplication overflow'
        if not arg1 * _taxFee / 10000:
            if not arg1 * _liquidityFee / 10000:
                if not arg1 * _burnFee / 10000:
                    if 0 > arg1 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 'NH{q', 17
                    if 0 > arg1 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 'NH{q', 17
                    if 0 > arg1 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 'NH{q', 17
                    return (arg1 * stor12 / totalSupply)
                if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                    revert with 'NH{q', 17
                if not arg1 * _burnFee / 10000:
                    revert with 'NH{q', 18
                if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 > arg1 * stor12 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor12 / totalSupply < 0:
                    revert with 'NH{q', 17
                if 0 > arg1 * stor12 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor12 / totalSupply < 0:
                    revert with 'NH{q', 17
                if arg1 * _burnFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor12 / totalSupply < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                    revert with 'NH{q', 17
                return ((arg1 * stor12 / totalSupply) - (arg1 * _burnFee / 10000 * stor12 / totalSupply))
            if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                revert with 'NH{q', 17
            if not arg1 * _liquidityFee / 10000:
                revert with 'NH{q', 18
            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * _burnFee / 10000:
                if 0 > arg1 * stor12 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor12 / totalSupply < 0:
                    revert with 'NH{q', 17
                if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                    revert with 'NH{q', 17
                if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                    revert with 'NH{q', 17
                return ((arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply))
            if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                revert with 'NH{q', 17
            if not arg1 * _burnFee / 10000:
                revert with 'NH{q', 18
            if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if 0 > arg1 * stor12 / totalSupply:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * stor12 / totalSupply < 0:
                revert with 'NH{q', 17
            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                revert with 'NH{q', 17
            if arg1 * _burnFee / 10000 * stor12 / totalSupply > (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                revert with 'NH{q', 17
            return ((arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) - (arg1 * _burnFee / 10000 * stor12 / totalSupply))
        if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
            revert with 'NH{q', 17
        if not arg1 * _taxFee / 10000:
            revert with 'NH{q', 18
        if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
            revert with 0, 'SafeMath: multiplication overflow'
        if not arg1 * _liquidityFee / 10000:
            if not arg1 * _burnFee / 10000:
                if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                    revert with 'NH{q', 17
                if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                    revert with 'NH{q', 17
                if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                    revert with 'NH{q', 17
                return ((arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply))
            if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                revert with 'NH{q', 17
            if not arg1 * _burnFee / 10000:
                revert with 'NH{q', 18
            if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                revert with 'NH{q', 17
            if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                revert with 'NH{q', 17
            if arg1 * _burnFee / 10000 * stor12 / totalSupply > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                revert with 'NH{q', 17
            return ((arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _burnFee / 10000 * stor12 / totalSupply))
        if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
            revert with 'NH{q', 17
        if not arg1 * _liquidityFee / 10000:
            revert with 'NH{q', 18
        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
            revert with 0, 'SafeMath: multiplication overflow'
        if not arg1 * _burnFee / 10000:
            if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                revert with 'NH{q', 17
            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                revert with 'NH{q', 17
            if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                revert with 'NH{q', 17
            return ((arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply))
        if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
            revert with 'NH{q', 17
        if not arg1 * _burnFee / 10000:
            revert with 'NH{q', 18
        if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
            revert with 0, 'SafeMath: multiplication overflow'
        if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
            revert with 'NH{q', 17
        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
            revert with 0, 'SafeMath: subtraction overflow', 0
        if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
            revert with 'NH{q', 17
        if arg1 * _burnFee / 10000 * stor12 / totalSupply > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
            revert with 0, 'SafeMath: subtraction overflow', 0
        if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < arg1 * _burnFee / 10000 * stor12 / totalSupply:
            revert with 'NH{q', 17
        return ((arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) - (arg1 * _burnFee / 10000 * stor12 / totalSupply))
    if not arg1:
        mem[96] = 26
        mem[128] = 'SafeMath: division by zero'
        if not arg1:
            mem[160] = 26
            mem[192] = 'SafeMath: division by zero'
            if not arg1:
                mem[224] = 26
                mem[256] = 'SafeMath: division by zero'
                mem[288] = 30
                mem[320] = 'SafeMath: subtraction overflow'
                if 0 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < 0:
                    revert with 'NH{q', 17
                mem[352] = 30
                mem[384] = 'SafeMath: subtraction overflow'
                if 0 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < 0:
                    revert with 'NH{q', 17
                mem[64] = 480
                mem[416] = 30
                mem[448] = 'SafeMath: subtraction overflow'
                if 0 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < 0:
                    revert with 'NH{q', 17
                idx = 0
                s = totalSupply
                t = stor12
                while idx < stor9.length:
                    mem[0] = stor9[idx]
                    mem[32] = 3
                    if stor3[stor9[idx]] > t:
                        _2341 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2341] = 26
                        mem[_2341 + 32] = 'SafeMath: division by zero'
                        if totalSupply <= 0:
                            _2441 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2441 + idx + 68] = mem[_2341 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2441 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2441 + -mem[64] + 100
                        if not totalSupply:
                            revert with 'NH{q', 18
                        if not arg1:
                            return 0
                        if arg1 and stor12 / totalSupply > -1 / arg1:
                            revert with 'NH{q', 17
                        if not arg1:
                            revert with 'NH{q', 18
                        if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _3346 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3346] = 30
                        mem[_3346 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _3417 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_3417 + idx + 68] = mem[_3346 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3417 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _3417 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _3930 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3930] = 30
                        mem[_3930 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _4065 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_4065 + idx + 68] = mem[_3930 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_4065 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _4065 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _4966 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4966] = 30
                        mem[_4966 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= arg1 * stor12 / totalSupply:
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 'NH{q', 17
                            return (arg1 * stor12 / totalSupply)
                        _5225 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_5225 + idx + 68] = mem[_4966 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_5225 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _5225 + -mem[64] + 100
                    if idx >= stor9.length:
                        revert with 'NH{q', 50
                    mem[0] = stor9[idx]
                    mem[32] = 4
                    if stor4[stor9[idx]] <= s:
                        if idx >= stor9.length:
                            revert with 'NH{q', 50
                        mem[0] = stor9[idx]
                        mem[32] = 3
                        _2407 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2407] = 30
                        mem[_2407 + 32] = 'SafeMath: subtraction overflow'
                        if stor3[stor9[idx]] > t:
                            _2458 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_2458 + idx + 68] = mem[_2407 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2458 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _2458 + -mem[64] + 100
                        if t < stor3[stor9[idx]]:
                            revert with 'NH{q', 17
                        if idx >= stor9.length:
                            revert with 'NH{q', 50
                        mem[0] = stor9[idx]
                        mem[32] = 4
                        _2730 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2730] = 30
                        mem[_2730 + 32] = 'SafeMath: subtraction overflow'
                        if stor4[stor9[idx]] <= s:
                            if s < stor4[stor9[idx]]:
                                revert with 'NH{q', 17
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            s = s - stor4[stor9[idx]]
                            t = t - stor3[stor9[idx]]
                            continue 
                        _2778 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_2778 + idx + 68] = mem[_2730 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2778 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _2778 + -mem[64] + 100
                    _2442 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2442] = 26
                    mem[_2442 + 32] = 'SafeMath: division by zero'
                    if totalSupply <= 0:
                        _2474 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2474 + idx + 68] = mem[_2442 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2474 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2474 + -mem[64] + 100
                    if not totalSupply:
                        revert with 'NH{q', 18
                    if not arg1:
                        return 0
                    if arg1 and stor12 / totalSupply > -1 / arg1:
                        revert with 'NH{q', 17
                    if not arg1:
                        revert with 'NH{q', 18
                    if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _3418 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3418] = 30
                    mem[_3418 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor12 / totalSupply:
                        _3506 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_3506 + idx + 68] = mem[_3418 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3506 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _3506 + -mem[64] + 100
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 'NH{q', 17
                    _4066 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4066] = 30
                    mem[_4066 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor12 / totalSupply:
                        _4210 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_4210 + idx + 68] = mem[_4066 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4210 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _4210 + -mem[64] + 100
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 'NH{q', 17
                    _5226 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5226] = 30
                    mem[_5226 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= arg1 * stor12 / totalSupply:
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 'NH{q', 17
                        return (arg1 * stor12 / totalSupply)
                    _5568 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_5568 + idx + 68] = mem[_5226 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_5568 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _5568 + -mem[64] + 100
                if totalSupply <= 0:
                    revert with 0, 'SafeMath: division by zero', 0
                if not totalSupply:
                    revert with 'NH{q', 18
                if t >= stor12 / totalSupply:
                    if s <= 0:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not s:
                        revert with 'NH{q', 18
                    if not arg1:
                        return 0
                    if arg1 and t / s > -1 / arg1:
                        revert with 'NH{q', 17
                    if not arg1:
                        revert with 'NH{q', 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 'NH{q', 17
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 'NH{q', 17
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 'NH{q', 17
                    return (arg1 * t / s)
                if totalSupply <= 0:
                    revert with 0, 'SafeMath: division by zero', 0
                if not totalSupply:
                    revert with 'NH{q', 18
                if not arg1:
                    return 0
                if arg1 and stor12 / totalSupply > -1 / arg1:
                    revert with 'NH{q', 17
                if not arg1:
                    revert with 'NH{q', 18
                if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 > arg1 * stor12 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor12 / totalSupply < 0:
                    revert with 'NH{q', 17
                if 0 > arg1 * stor12 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor12 / totalSupply < 0:
                    revert with 'NH{q', 17
                if 0 > arg1 * stor12 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor12 / totalSupply < 0:
                    revert with 'NH{q', 17
            else:
                if arg1 and _burnFee > -1 / arg1:
                    revert with 'NH{q', 17
                if not arg1:
                    revert with 'NH{q', 18
                if arg1 * _burnFee / arg1 != _burnFee:
                    revert with 0, 'SafeMath: multiplication overflow'
                mem[224] = 26
                mem[256] = 'SafeMath: division by zero'
                mem[288] = 30
                mem[320] = 'SafeMath: subtraction overflow'
                if 0 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < 0:
                    revert with 'NH{q', 17
                mem[352] = 30
                mem[384] = 'SafeMath: subtraction overflow'
                if 0 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < 0:
                    revert with 'NH{q', 17
                mem[64] = 480
                mem[416] = 30
                mem[448] = 'SafeMath: subtraction overflow'
                if arg1 * _burnFee / 10000 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < arg1 * _burnFee / 10000:
                    revert with 'NH{q', 17
                idx = 0
                s = totalSupply
                t = stor12
                while idx < stor9.length:
                    mem[0] = stor9[idx]
                    mem[32] = 3
                    if stor3[stor9[idx]] > t:
                        _2334 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2334] = 26
                        mem[_2334 + 32] = 'SafeMath: division by zero'
                        if totalSupply <= 0:
                            _2439 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2439 + idx + 68] = mem[_2334 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2439 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2439 + -mem[64] + 100
                        if not totalSupply:
                            revert with 'NH{q', 18
                        if not arg1:
                            if not arg1 * _burnFee / 10000:
                                return 0
                            if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                                revert with 'NH{q', 17
                            if not arg1 * _burnFee / 10000:
                                revert with 'NH{q', 18
                            if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _3345 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3345] = 30
                            mem[_3345 + 32] = 'SafeMath: subtraction overflow'
                            _3927 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3927] = 30
                            mem[_3927 + 32] = 'SafeMath: subtraction overflow'
                            _4963 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4963] = 30
                            mem[_4963 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _burnFee / 10000 * stor12 / totalSupply <= 0:
                                if 0 < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                                    revert with 'NH{q', 17
                                else:
                                    return 0
                            _5222 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_5222 + idx + 68] = mem[_4963 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5222 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5222 + -mem[64] + 100
                        if arg1 and stor12 / totalSupply > -1 / arg1:
                            revert with 'NH{q', 17
                        if not arg1:
                            revert with 'NH{q', 18
                        if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _burnFee / 10000:
                            _3344 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3344] = 30
                            mem[_3344 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor12 / totalSupply:
                                _3414 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_3414 + idx + 68] = mem[_3344 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3414 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _3414 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _3926 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3926] = 30
                            mem[_3926 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor12 / totalSupply:
                                _4061 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_4061 + idx + 68] = mem[_3926 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4061 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _4061 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _4962 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4962] = 30
                            mem[_4962 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor12 / totalSupply:
                                if arg1 * stor12 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                return (arg1 * stor12 / totalSupply)
                            _5221 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_5221 + idx + 68] = mem[_4962 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5221 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5221 + -mem[64] + 100
                        if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                            revert with 'NH{q', 17
                        if not arg1 * _burnFee / 10000:
                            revert with 'NH{q', 18
                        if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _4164 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4164] = 30
                        mem[_4164 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _4329 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_4329 + idx + 68] = mem[_4164 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_4329 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _4329 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _5444 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5444] = 30
                        mem[_5444 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _5730 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_5730 + idx + 68] = mem[_5444 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5730 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5730 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _7188 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_7188] = 30
                        mem[_7188 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _burnFee / 10000 * stor12 / totalSupply <= arg1 * stor12 / totalSupply:
                            if arg1 * stor12 / totalSupply < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                                revert with 'NH{q', 17
                            return (arg1 * stor12 / totalSupply)
                        _7492 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_7492 + idx + 68] = mem[_7188 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_7492 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _7492 + -mem[64] + 100
                    if idx >= stor9.length:
                        revert with 'NH{q', 50
                    mem[0] = stor9[idx]
                    mem[32] = 4
                    if stor4[stor9[idx]] <= s:
                        if idx >= stor9.length:
                            revert with 'NH{q', 50
                        mem[0] = stor9[idx]
                        mem[32] = 3
                        _2403 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2403] = 30
                        mem[_2403 + 32] = 'SafeMath: subtraction overflow'
                        if stor3[stor9[idx]] > t:
                            _2457 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_2457 + idx + 68] = mem[_2403 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2457 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _2457 + -mem[64] + 100
                        if t < stor3[stor9[idx]]:
                            revert with 'NH{q', 17
                        if idx >= stor9.length:
                            revert with 'NH{q', 50
                        mem[0] = stor9[idx]
                        mem[32] = 4
                        _2729 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2729] = 30
                        mem[_2729 + 32] = 'SafeMath: subtraction overflow'
                        if stor4[stor9[idx]] <= s:
                            if s < stor4[stor9[idx]]:
                                revert with 'NH{q', 17
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            s = s - stor4[stor9[idx]]
                            t = t - stor3[stor9[idx]]
                            continue 
                        _2777 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_2777 + idx + 68] = mem[_2729 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2777 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _2777 + -mem[64] + 100
                    _2440 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2440] = 26
                    mem[_2440 + 32] = 'SafeMath: division by zero'
                    if totalSupply <= 0:
                        _2473 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2473 + idx + 68] = mem[_2440 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2473 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2473 + -mem[64] + 100
                    if not totalSupply:
                        revert with 'NH{q', 18
                    if not arg1:
                        if not arg1 * _burnFee / 10000:
                            return 0
                        if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                            revert with 'NH{q', 17
                        if not arg1 * _burnFee / 10000:
                            revert with 'NH{q', 18
                        if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _3416 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3416] = 30
                        mem[_3416 + 32] = 'SafeMath: subtraction overflow'
                        _4064 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4064] = 30
                        mem[_4064 + 32] = 'SafeMath: subtraction overflow'
                        _5224 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5224] = 30
                        mem[_5224 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _burnFee / 10000 * stor12 / totalSupply <= 0:
                            if 0 < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                                revert with 'NH{q', 17
                            else:
                                return 0
                        _5565 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_5565 + idx + 68] = mem[_5224 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_5565 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _5565 + -mem[64] + 100
                    if arg1 and stor12 / totalSupply > -1 / arg1:
                        revert with 'NH{q', 17
                    if not arg1:
                        revert with 'NH{q', 18
                    if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _burnFee / 10000:
                        _3415 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3415] = 30
                        mem[_3415 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _3505 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_3505 + idx + 68] = mem[_3415 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3505 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _3505 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _4063 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4063] = 30
                        mem[_4063 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _4209 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_4209 + idx + 68] = mem[_4063 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_4209 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _4209 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _5223 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5223] = 30
                        mem[_5223 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= arg1 * stor12 / totalSupply:
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 'NH{q', 17
                            return (arg1 * stor12 / totalSupply)
                        _5564 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_5564 + idx + 68] = mem[_5223 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_5564 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _5564 + -mem[64] + 100
                    if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                        revert with 'NH{q', 17
                    if not arg1 * _burnFee / 10000:
                        revert with 'NH{q', 18
                    if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _4332 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4332] = 30
                    mem[_4332 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor12 / totalSupply:
                        _4508 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_4508 + idx + 68] = mem[_4332 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4508 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _4508 + -mem[64] + 100
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 'NH{q', 17
                    _5735 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5735] = 30
                    mem[_5735 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor12 / totalSupply:
                        _6001 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_6001 + idx + 68] = mem[_5735 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_6001 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _6001 + -mem[64] + 100
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 'NH{q', 17
                    _7495 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_7495] = 30
                    mem[_7495 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _burnFee / 10000 * stor12 / totalSupply <= arg1 * stor12 / totalSupply:
                        if arg1 * stor12 / totalSupply < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                            revert with 'NH{q', 17
                        return (arg1 * stor12 / totalSupply)
                    _7867 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_7867 + idx + 68] = mem[_7495 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_7867 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _7867 + -mem[64] + 100
                if totalSupply <= 0:
                    revert with 0, 'SafeMath: division by zero', 0
                if not totalSupply:
                    revert with 'NH{q', 18
                if t >= stor12 / totalSupply:
                    if s <= 0:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not s:
                        revert with 'NH{q', 18
                    if not arg1:
                        if arg1 * _burnFee / 10000:
                            if arg1 * _burnFee / 10000 and t / s > -1 / arg1 * _burnFee / 10000:
                                revert with 'NH{q', 17
                            if not arg1 * _burnFee / 10000:
                                revert with 'NH{q', 18
                            if arg1 * _burnFee / 10000 * t / s / arg1 * _burnFee / 10000 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * _burnFee / 10000 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * _burnFee / 10000 * t / s:
                                revert with 'NH{q', 17
                            else:
                                return 0
                        else:
                            return 0
                    if arg1 and t / s > -1 / arg1:
                        revert with 'NH{q', 17
                    if not arg1:
                        revert with 'NH{q', 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _burnFee / 10000:
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 'NH{q', 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 'NH{q', 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 'NH{q', 17
                    else:
                        if arg1 * _burnFee / 10000 and t / s > -1 / arg1 * _burnFee / 10000:
                            revert with 'NH{q', 17
                        if not arg1 * _burnFee / 10000:
                            revert with 'NH{q', 18
                        if arg1 * _burnFee / 10000 * t / s / arg1 * _burnFee / 10000 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 'NH{q', 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 'NH{q', 17
                        if arg1 * _burnFee / 10000 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < arg1 * _burnFee / 10000 * t / s:
                            revert with 'NH{q', 17
                    return (arg1 * t / s)
                if totalSupply <= 0:
                    revert with 0, 'SafeMath: division by zero', 0
                if not totalSupply:
                    revert with 'NH{q', 18
                if not arg1:
                    if arg1 * _burnFee / 10000:
                        if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                            revert with 'NH{q', 17
                        if not arg1 * _burnFee / 10000:
                            revert with 'NH{q', 18
                        if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * _burnFee / 10000 * stor12 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                            revert with 'NH{q', 17
                        else:
                            return 0
                    else:
                        return 0
                if arg1 and stor12 / totalSupply > -1 / arg1:
                    revert with 'NH{q', 17
                if not arg1:
                    revert with 'NH{q', 18
                if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _burnFee / 10000:
                    if 0 > arg1 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 'NH{q', 17
                    if 0 > arg1 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 'NH{q', 17
                    if 0 > arg1 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 'NH{q', 17
                else:
                    if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                        revert with 'NH{q', 17
                    if not arg1 * _burnFee / 10000:
                        revert with 'NH{q', 18
                    if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 'NH{q', 17
                    if 0 > arg1 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 'NH{q', 17
                    if arg1 * _burnFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor12 / totalSupply < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                        revert with 'NH{q', 17
        else:
            if arg1 and _liquidityFee > -1 / arg1:
                revert with 'NH{q', 17
            if not arg1:
                revert with 'NH{q', 18
            if arg1 * _liquidityFee / arg1 != _liquidityFee:
                revert with 0, 'SafeMath: multiplication overflow'
            mem[160] = 26
            mem[192] = 'SafeMath: division by zero'
            if not arg1:
                mem[224] = 26
                mem[256] = 'SafeMath: division by zero'
                mem[288] = 30
                mem[320] = 'SafeMath: subtraction overflow'
                if 0 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < 0:
                    revert with 'NH{q', 17
                mem[352] = 30
                mem[384] = 'SafeMath: subtraction overflow'
                if arg1 * _liquidityFee / 10000 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < arg1 * _liquidityFee / 10000:
                    revert with 'NH{q', 17
                mem[64] = 480
                mem[416] = 30
                mem[448] = 'SafeMath: subtraction overflow'
                if 0 > arg1 - (arg1 * _liquidityFee / 10000):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * _liquidityFee / 10000) < 0:
                    revert with 'NH{q', 17
                idx = 0
                s = totalSupply
                t = stor12
                while idx < stor9.length:
                    mem[0] = stor9[idx]
                    mem[32] = 3
                    if stor3[stor9[idx]] > t:
                        _2327 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2327] = 26
                        mem[_2327 + 32] = 'SafeMath: division by zero'
                        if totalSupply <= 0:
                            _2437 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2437 + idx + 68] = mem[_2327 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2437 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2437 + -mem[64] + 100
                        if not totalSupply:
                            revert with 'NH{q', 18
                        if not arg1:
                            if not arg1 * _liquidityFee / 10000:
                                return 0
                            if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                                revert with 'NH{q', 17
                            if not arg1 * _liquidityFee / 10000:
                                revert with 'NH{q', 18
                            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _3343 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3343] = 30
                            mem[_3343 + 32] = 'SafeMath: subtraction overflow'
                            _3922 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3922] = 30
                            mem[_3922 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > 0:
                                _4058 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_4058 + idx + 68] = mem[_3922 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4058 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _4058 + -mem[64] + 100
                            if 0 < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                revert with 'NH{q', 17
                            _4959 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4959] = 30
                            mem[_4959 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                if -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                else:
                                    return 0
                            _5217 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_5217 + idx + 68] = mem[_4959 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5217 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5217 + -mem[64] + 100
                        if arg1 and stor12 / totalSupply > -1 / arg1:
                            revert with 'NH{q', 17
                        if not arg1:
                            revert with 'NH{q', 18
                        if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _liquidityFee / 10000:
                            _3342 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3342] = 30
                            mem[_3342 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor12 / totalSupply:
                                _3411 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_3411 + idx + 68] = mem[_3342 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3411 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _3411 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _3921 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3921] = 30
                            mem[_3921 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor12 / totalSupply:
                                _4057 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_4057 + idx + 68] = mem[_3921 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4057 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _4057 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _4958 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4958] = 30
                            mem[_4958 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor12 / totalSupply:
                                if arg1 * stor12 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                return (arg1 * stor12 / totalSupply)
                            _5216 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_5216 + idx + 68] = mem[_4958 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5216 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5216 + -mem[64] + 100
                        if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                            revert with 'NH{q', 17
                        if not arg1 * _liquidityFee / 10000:
                            revert with 'NH{q', 18
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _4159 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4159] = 30
                        mem[_4159 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _4324 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_4324 + idx + 68] = mem[_4159 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_4324 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _4324 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _5437 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5437] = 30
                        mem[_5437 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                            _5723 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_5723 + idx + 68] = mem[_5437 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5723 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5723 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                            revert with 'NH{q', 17
                        _7177 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_7177] = 30
                        mem[_7177 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                            if (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                                revert with 'NH{q', 17
                            return (arg1 * stor12 / totalSupply)
                        _7488 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_7488 + idx + 68] = mem[_7177 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_7488 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _7488 + -mem[64] + 100
                    if idx >= stor9.length:
                        revert with 'NH{q', 50
                    mem[0] = stor9[idx]
                    mem[32] = 4
                    if stor4[stor9[idx]] <= s:
                        if idx >= stor9.length:
                            revert with 'NH{q', 50
                        mem[0] = stor9[idx]
                        mem[32] = 3
                        _2399 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2399] = 30
                        mem[_2399 + 32] = 'SafeMath: subtraction overflow'
                        if stor3[stor9[idx]] > t:
                            _2456 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_2456 + idx + 68] = mem[_2399 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2456 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _2456 + -mem[64] + 100
                        if t < stor3[stor9[idx]]:
                            revert with 'NH{q', 17
                        if idx >= stor9.length:
                            revert with 'NH{q', 50
                        mem[0] = stor9[idx]
                        mem[32] = 4
                        _2728 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2728] = 30
                        mem[_2728 + 32] = 'SafeMath: subtraction overflow'
                        if stor4[stor9[idx]] <= s:
                            if s < stor4[stor9[idx]]:
                                revert with 'NH{q', 17
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            s = s - stor4[stor9[idx]]
                            t = t - stor3[stor9[idx]]
                            continue 
                        _2776 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_2776 + idx + 68] = mem[_2728 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2776 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _2776 + -mem[64] + 100
                    _2438 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2438] = 26
                    mem[_2438 + 32] = 'SafeMath: division by zero'
                    if totalSupply <= 0:
                        _2472 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2472 + idx + 68] = mem[_2438 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2472 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2472 + -mem[64] + 100
                    if not totalSupply:
                        revert with 'NH{q', 18
                    if not arg1:
                        if not arg1 * _liquidityFee / 10000:
                            return 0
                        if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                            revert with 'NH{q', 17
                        if not arg1 * _liquidityFee / 10000:
                            revert with 'NH{q', 18
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _3413 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3413] = 30
                        mem[_3413 + 32] = 'SafeMath: subtraction overflow'
                        _4060 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4060] = 30
                        mem[_4060 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > 0:
                            _4208 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_4208 + idx + 68] = mem[_4060 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_4208 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _4208 + -mem[64] + 100
                        if 0 < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                            revert with 'NH{q', 17
                        _5219 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5219] = 30
                        mem[_5219 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                            if -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply < 0:
                                revert with 'NH{q', 17
                            else:
                                return 0
                        _5560 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_5560 + idx + 68] = mem[_5219 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_5560 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _5560 + -mem[64] + 100
                    if arg1 and stor12 / totalSupply > -1 / arg1:
                        revert with 'NH{q', 17
                    if not arg1:
                        revert with 'NH{q', 18
                    if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _liquidityFee / 10000:
                        _3412 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3412] = 30
                        mem[_3412 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _3504 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_3504 + idx + 68] = mem[_3412 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3504 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _3504 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _4059 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4059] = 30
                        mem[_4059 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _4207 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_4207 + idx + 68] = mem[_4059 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_4207 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _4207 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _5218 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5218] = 30
                        mem[_5218 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= arg1 * stor12 / totalSupply:
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 'NH{q', 17
                            return (arg1 * stor12 / totalSupply)
                        _5559 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_5559 + idx + 68] = mem[_5218 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_5559 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _5559 + -mem[64] + 100
                    if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                        revert with 'NH{q', 17
                    if not arg1 * _liquidityFee / 10000:
                        revert with 'NH{q', 18
                    if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _4328 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4328] = 30
                    mem[_4328 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor12 / totalSupply:
                        _4502 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_4502 + idx + 68] = mem[_4328 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4502 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _4502 + -mem[64] + 100
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 'NH{q', 17
                    _5729 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5729] = 30
                    mem[_5729 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                        _5995 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_5995 + idx + 68] = mem[_5729 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_5995 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _5995 + -mem[64] + 100
                    if arg1 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                        revert with 'NH{q', 17
                    _7491 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_7491] = 30
                    mem[_7491 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                        if (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                            revert with 'NH{q', 17
                        return (arg1 * stor12 / totalSupply)
                    _7862 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_7862 + idx + 68] = mem[_7491 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_7862 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _7862 + -mem[64] + 100
                if totalSupply <= 0:
                    revert with 0, 'SafeMath: division by zero', 0
                if not totalSupply:
                    revert with 'NH{q', 18
                if t >= stor12 / totalSupply:
                    if s <= 0:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not s:
                        revert with 'NH{q', 18
                    if not arg1:
                        if arg1 * _liquidityFee / 10000:
                            if arg1 * _liquidityFee / 10000 and t / s > -1 / arg1 * _liquidityFee / 10000:
                                revert with 'NH{q', 17
                            if not arg1 * _liquidityFee / 10000:
                                revert with 'NH{q', 18
                            if arg1 * _liquidityFee / 10000 * t / s / arg1 * _liquidityFee / 10000 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * _liquidityFee / 10000 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * _liquidityFee / 10000 * t / s:
                                revert with 'NH{q', 17
                            if 0 > -1 * arg1 * _liquidityFee / 10000 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * _liquidityFee / 10000 * t / s < 0:
                                revert with 'NH{q', 17
                            else:
                                return 0
                        else:
                            return 0
                    if arg1 and t / s > -1 / arg1:
                        revert with 'NH{q', 17
                    if not arg1:
                        revert with 'NH{q', 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _liquidityFee / 10000:
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 'NH{q', 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 'NH{q', 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 'NH{q', 17
                    else:
                        if arg1 * _liquidityFee / 10000 and t / s > -1 / arg1 * _liquidityFee / 10000:
                            revert with 'NH{q', 17
                        if not arg1 * _liquidityFee / 10000:
                            revert with 'NH{q', 18
                        if arg1 * _liquidityFee / 10000 * t / s / arg1 * _liquidityFee / 10000 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 'NH{q', 17
                        if arg1 * _liquidityFee / 10000 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < arg1 * _liquidityFee / 10000 * t / s:
                            revert with 'NH{q', 17
                        if 0 > (arg1 * t / s) - (arg1 * _liquidityFee / 10000 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (arg1 * _liquidityFee / 10000 * t / s) < 0:
                            revert with 'NH{q', 17
                    return (arg1 * t / s)
                if totalSupply <= 0:
                    revert with 0, 'SafeMath: division by zero', 0
                if not totalSupply:
                    revert with 'NH{q', 18
                if not arg1:
                    if arg1 * _liquidityFee / 10000:
                        if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                            revert with 'NH{q', 17
                        if not arg1 * _liquidityFee / 10000:
                            revert with 'NH{q', 18
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                            revert with 'NH{q', 17
                        if 0 > -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply < 0:
                            revert with 'NH{q', 17
                        else:
                            return 0
                    else:
                        return 0
                if arg1 and stor12 / totalSupply > -1 / arg1:
                    revert with 'NH{q', 17
                if not arg1:
                    revert with 'NH{q', 18
                if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _liquidityFee / 10000:
                    if 0 > arg1 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 'NH{q', 17
                    if 0 > arg1 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 'NH{q', 17
                    if 0 > arg1 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 'NH{q', 17
                else:
                    if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                        revert with 'NH{q', 17
                    if not arg1 * _liquidityFee / 10000:
                        revert with 'NH{q', 18
                    if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 'NH{q', 17
                    if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                        revert with 'NH{q', 17
                    if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                        revert with 'NH{q', 17
            else:
                if arg1 and _burnFee > -1 / arg1:
                    revert with 'NH{q', 17
                if not arg1:
                    revert with 'NH{q', 18
                if arg1 * _burnFee / arg1 != _burnFee:
                    revert with 0, 'SafeMath: multiplication overflow'
                mem[224] = 26
                mem[256] = 'SafeMath: division by zero'
                mem[288] = 30
                mem[320] = 'SafeMath: subtraction overflow'
                if 0 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < 0:
                    revert with 'NH{q', 17
                mem[352] = 30
                mem[384] = 'SafeMath: subtraction overflow'
                if arg1 * _liquidityFee / 10000 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < arg1 * _liquidityFee / 10000:
                    revert with 'NH{q', 17
                mem[64] = 480
                mem[416] = 30
                mem[448] = 'SafeMath: subtraction overflow'
                if arg1 * _burnFee / 10000 > arg1 - (arg1 * _liquidityFee / 10000):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * _liquidityFee / 10000) < arg1 * _burnFee / 10000:
                    revert with 'NH{q', 17
                idx = 0
                s = totalSupply
                t = stor12
                while idx < stor9.length:
                    mem[0] = stor9[idx]
                    mem[32] = 3
                    if stor3[stor9[idx]] > t:
                        _2320 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2320] = 26
                        mem[_2320 + 32] = 'SafeMath: division by zero'
                        if totalSupply <= 0:
                            _2435 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2435 + idx + 68] = mem[_2320 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2435 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2435 + -mem[64] + 100
                        if not totalSupply:
                            revert with 'NH{q', 18
                        if not arg1:
                            if not arg1 * _liquidityFee / 10000:
                                if not arg1 * _burnFee / 10000:
                                    return 0
                                if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                                    revert with 'NH{q', 17
                                if not arg1 * _burnFee / 10000:
                                    revert with 'NH{q', 18
                                if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _3341 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3341] = 30
                                mem[_3341 + 32] = 'SafeMath: subtraction overflow'
                                _3918 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3918] = 30
                                mem[_3918 + 32] = 'SafeMath: subtraction overflow'
                                _4953 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4953] = 30
                                mem[_4953 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _burnFee / 10000 * stor12 / totalSupply <= 0:
                                    if 0 < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                                        revert with 'NH{q', 17
                                    else:
                                        return 0
                                _5209 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_5209 + idx + 68] = mem[_4953 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5209 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _5209 + -mem[64] + 100
                            if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                                revert with 'NH{q', 17
                            if not arg1 * _liquidityFee / 10000:
                                revert with 'NH{q', 18
                            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _burnFee / 10000:
                                _3340 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3340] = 30
                                mem[_3340 + 32] = 'SafeMath: subtraction overflow'
                                _3917 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3917] = 30
                                mem[_3917 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > 0:
                                    _4051 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_4051 + idx + 68] = mem[_3917 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4051 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4051 + -mem[64] + 100
                                if 0 < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                    revert with 'NH{q', 17
                                _4952 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4952] = 30
                                mem[_4952 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                    if -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply < 0:
                                        revert with 'NH{q', 17
                                    else:
                                        return 0
                                _5208 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_5208 + idx + 68] = mem[_4952 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5208 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _5208 + -mem[64] + 100
                            if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                                revert with 'NH{q', 17
                            if not arg1 * _burnFee / 10000:
                                revert with 'NH{q', 18
                            if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _4156 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4156] = 30
                            mem[_4156 + 32] = 'SafeMath: subtraction overflow'
                            _5428 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5428] = 30
                            mem[_5428 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > 0:
                                _5714 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_5714 + idx + 68] = mem[_5428 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5714 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _5714 + -mem[64] + 100
                            if 0 < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                revert with 'NH{q', 17
                            _7164 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_7164] = 30
                            mem[_7164 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _burnFee / 10000 * stor12 / totalSupply <= -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                if -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                                    revert with 'NH{q', 17
                                else:
                                    return 0
                            _7482 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_7482 + idx + 68] = mem[_7164 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_7482 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _7482 + -mem[64] + 100
                        if arg1 and stor12 / totalSupply > -1 / arg1:
                            revert with 'NH{q', 17
                        if not arg1:
                            revert with 'NH{q', 18
                        if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _liquidityFee / 10000:
                            if not arg1 * _burnFee / 10000:
                                _3339 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3339] = 30
                                mem[_3339 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor12 / totalSupply:
                                    _3407 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_3407 + idx + 68] = mem[_3339 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_3407 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _3407 + -mem[64] + 100
                                if arg1 * stor12 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                _3915 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3915] = 30
                                mem[_3915 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor12 / totalSupply:
                                    _4050 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_4050 + idx + 68] = mem[_3915 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4050 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4050 + -mem[64] + 100
                                if arg1 * stor12 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                _4951 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4951] = 30
                                mem[_4951 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor12 / totalSupply:
                                    if arg1 * stor12 / totalSupply < 0:
                                        revert with 'NH{q', 17
                                    return (arg1 * stor12 / totalSupply)
                                _5207 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_5207 + idx + 68] = mem[_4951 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5207 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _5207 + -mem[64] + 100
                            if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                                revert with 'NH{q', 17
                            if not arg1 * _burnFee / 10000:
                                revert with 'NH{q', 18
                            if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _4155 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4155] = 30
                            mem[_4155 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor12 / totalSupply:
                                _4317 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_4317 + idx + 68] = mem[_4155 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4317 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _4317 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _5427 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5427] = 30
                            mem[_5427 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor12 / totalSupply:
                                _5711 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_5711 + idx + 68] = mem[_5427 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5711 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _5711 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _7163 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_7163] = 30
                            mem[_7163 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _burnFee / 10000 * stor12 / totalSupply <= arg1 * stor12 / totalSupply:
                                if arg1 * stor12 / totalSupply < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                                    revert with 'NH{q', 17
                                return (arg1 * stor12 / totalSupply)
                            _7480 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_7480 + idx + 68] = mem[_7163 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_7480 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _7480 + -mem[64] + 100
                        if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                            revert with 'NH{q', 17
                        if not arg1 * _liquidityFee / 10000:
                            revert with 'NH{q', 18
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _burnFee / 10000:
                            _4154 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4154] = 30
                            mem[_4154 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor12 / totalSupply:
                                _4316 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_4316 + idx + 68] = mem[_4154 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4316 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _4316 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _5426 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5426] = 30
                            mem[_5426 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                                _5710 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_5710 + idx + 68] = mem[_5426 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5710 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _5710 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                revert with 'NH{q', 17
                            _7162 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_7162] = 30
                            mem[_7162 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                                if (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                                    revert with 'NH{q', 17
                                return (arg1 * stor12 / totalSupply)
                            _7479 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_7479 + idx + 68] = mem[_7162 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_7479 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _7479 + -mem[64] + 100
                        if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                            revert with 'NH{q', 17
                        if not arg1 * _burnFee / 10000:
                            revert with 'NH{q', 18
                        if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _5868 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5868] = 30
                        mem[_5868 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _6120 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_6120 + idx + 68] = mem[_5868 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_6120 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _6120 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _7700 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_7700] = 30
                        mem[_7700 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                            _8025 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_8025 + idx + 68] = mem[_7700 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_8025 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _8025 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                            revert with 'NH{q', 17
                        _9364 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9364] = 30
                        mem[_9364 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _burnFee / 10000 * stor12 / totalSupply <= (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                            if (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                                revert with 'NH{q', 17
                            return (arg1 * stor12 / totalSupply)
                        _9568 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_9568 + idx + 68] = mem[_9364 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_9568 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _9568 + -mem[64] + 100
                    if idx >= stor9.length:
                        revert with 'NH{q', 50
                    mem[0] = stor9[idx]
                    mem[32] = 4
                    if stor4[stor9[idx]] <= s:
                        if idx >= stor9.length:
                            revert with 'NH{q', 50
                        mem[0] = stor9[idx]
                        mem[32] = 3
                        _2395 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2395] = 30
                        mem[_2395 + 32] = 'SafeMath: subtraction overflow'
                        if stor3[stor9[idx]] > t:
                            _2455 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_2455 + idx + 68] = mem[_2395 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2455 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _2455 + -mem[64] + 100
                        if t < stor3[stor9[idx]]:
                            revert with 'NH{q', 17
                        if idx >= stor9.length:
                            revert with 'NH{q', 50
                        mem[0] = stor9[idx]
                        mem[32] = 4
                        _2727 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2727] = 30
                        mem[_2727 + 32] = 'SafeMath: subtraction overflow'
                        if stor4[stor9[idx]] <= s:
                            if s < stor4[stor9[idx]]:
                                revert with 'NH{q', 17
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            s = s - stor4[stor9[idx]]
                            t = t - stor3[stor9[idx]]
                            continue 
                        _2775 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_2775 + idx + 68] = mem[_2727 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2775 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _2775 + -mem[64] + 100
                    _2436 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2436] = 26
                    mem[_2436 + 32] = 'SafeMath: division by zero'
                    if totalSupply <= 0:
                        _2471 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2471 + idx + 68] = mem[_2436 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2471 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2471 + -mem[64] + 100
                    if not totalSupply:
                        revert with 'NH{q', 18
                    if not arg1:
                        if not arg1 * _liquidityFee / 10000:
                            if not arg1 * _burnFee / 10000:
                                return 0
                            if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                                revert with 'NH{q', 17
                            if not arg1 * _burnFee / 10000:
                                revert with 'NH{q', 18
                            if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _3410 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3410] = 30
                            mem[_3410 + 32] = 'SafeMath: subtraction overflow'
                            _4056 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4056] = 30
                            mem[_4056 + 32] = 'SafeMath: subtraction overflow'
                            _5212 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5212] = 30
                            mem[_5212 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _burnFee / 10000 * stor12 / totalSupply <= 0:
                                if 0 < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                                    revert with 'NH{q', 17
                                else:
                                    return 0
                            _5555 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_5555 + idx + 68] = mem[_5212 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5555 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5555 + -mem[64] + 100
                        if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                            revert with 'NH{q', 17
                        if not arg1 * _liquidityFee / 10000:
                            revert with 'NH{q', 18
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _burnFee / 10000:
                            _3409 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3409] = 30
                            mem[_3409 + 32] = 'SafeMath: subtraction overflow'
                            _4055 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4055] = 30
                            mem[_4055 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > 0:
                                _4205 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_4205 + idx + 68] = mem[_4055 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4205 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _4205 + -mem[64] + 100
                            if 0 < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                revert with 'NH{q', 17
                            _5211 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5211] = 30
                            mem[_5211 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                if -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                else:
                                    return 0
                            _5554 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_5554 + idx + 68] = mem[_5211 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5554 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5554 + -mem[64] + 100
                        if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                            revert with 'NH{q', 17
                        if not arg1 * _burnFee / 10000:
                            revert with 'NH{q', 18
                        if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _4323 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4323] = 30
                        mem[_4323 + 32] = 'SafeMath: subtraction overflow'
                        _5722 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5722] = 30
                        mem[_5722 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > 0:
                            _5990 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_5990 + idx + 68] = mem[_5722 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5990 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5990 + -mem[64] + 100
                        if 0 < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                            revert with 'NH{q', 17
                        _7487 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_7487] = 30
                        mem[_7487 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _burnFee / 10000 * stor12 / totalSupply <= -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                            if -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                                revert with 'NH{q', 17
                            else:
                                return 0
                        _7857 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_7857 + idx + 68] = mem[_7487 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_7857 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _7857 + -mem[64] + 100
                    if arg1 and stor12 / totalSupply > -1 / arg1:
                        revert with 'NH{q', 17
                    if not arg1:
                        revert with 'NH{q', 18
                    if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _liquidityFee / 10000:
                        if not arg1 * _burnFee / 10000:
                            _3408 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3408] = 30
                            mem[_3408 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor12 / totalSupply:
                                _3503 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_3503 + idx + 68] = mem[_3408 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3503 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _3503 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _4053 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4053] = 30
                            mem[_4053 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor12 / totalSupply:
                                _4204 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_4204 + idx + 68] = mem[_4053 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4204 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _4204 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _5210 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5210] = 30
                            mem[_5210 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor12 / totalSupply:
                                if arg1 * stor12 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                return (arg1 * stor12 / totalSupply)
                            _5553 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_5553 + idx + 68] = mem[_5210 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5553 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5553 + -mem[64] + 100
                        if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                            revert with 'NH{q', 17
                        if not arg1 * _burnFee / 10000:
                            revert with 'NH{q', 18
                        if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _4322 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4322] = 30
                        mem[_4322 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _4496 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_4496 + idx + 68] = mem[_4322 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_4496 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _4496 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _5721 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5721] = 30
                        mem[_5721 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _5987 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_5987 + idx + 68] = mem[_5721 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5987 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5987 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _7486 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_7486] = 30
                        mem[_7486 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _burnFee / 10000 * stor12 / totalSupply <= arg1 * stor12 / totalSupply:
                            if arg1 * stor12 / totalSupply < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                                revert with 'NH{q', 17
                            return (arg1 * stor12 / totalSupply)
                        _7855 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_7855 + idx + 68] = mem[_7486 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_7855 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _7855 + -mem[64] + 100
                    if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                        revert with 'NH{q', 17
                    if not arg1 * _liquidityFee / 10000:
                        revert with 'NH{q', 18
                    if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _burnFee / 10000:
                        _4321 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4321] = 30
                        mem[_4321 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _4495 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_4495 + idx + 68] = mem[_4321 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_4495 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _4495 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _5720 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5720] = 30
                        mem[_5720 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                            _5986 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_5986 + idx + 68] = mem[_5720 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5986 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5986 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                            revert with 'NH{q', 17
                        _7485 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_7485] = 30
                        mem[_7485 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                            if (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                                revert with 'NH{q', 17
                            return (arg1 * stor12 / totalSupply)
                        _7854 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_7854 + idx + 68] = mem[_7485 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_7854 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _7854 + -mem[64] + 100
                    if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                        revert with 'NH{q', 17
                    if not arg1 * _burnFee / 10000:
                        revert with 'NH{q', 18
                    if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _6126 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6126] = 30
                    mem[_6126 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor12 / totalSupply:
                        _6419 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_6419 + idx + 68] = mem[_6126 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_6419 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _6419 + -mem[64] + 100
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 'NH{q', 17
                    _8035 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_8035] = 30
                    mem[_8035 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                        _8326 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_8326 + idx + 68] = mem[_8035 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_8326 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _8326 + -mem[64] + 100
                    if arg1 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                        revert with 'NH{q', 17
                    _9572 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9572] = 30
                    mem[_9572 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _burnFee / 10000 * stor12 / totalSupply <= (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                        if (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                            revert with 'NH{q', 17
                        return (arg1 * stor12 / totalSupply)
                    _9747 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_9747 + idx + 68] = mem[_9572 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_9747 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _9747 + -mem[64] + 100
                if totalSupply <= 0:
                    revert with 0, 'SafeMath: division by zero', 0
                if not totalSupply:
                    revert with 'NH{q', 18
                if t >= stor12 / totalSupply:
                    if s <= 0:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not s:
                        revert with 'NH{q', 18
                    if not arg1:
                        if not arg1 * _liquidityFee / 10000:
                            if arg1 * _burnFee / 10000:
                                if arg1 * _burnFee / 10000 and t / s > -1 / arg1 * _burnFee / 10000:
                                    revert with 'NH{q', 17
                                if not arg1 * _burnFee / 10000:
                                    revert with 'NH{q', 18
                                if arg1 * _burnFee / 10000 * t / s / arg1 * _burnFee / 10000 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _burnFee / 10000 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _burnFee / 10000 * t / s:
                                    revert with 'NH{q', 17
                        else:
                            if arg1 * _liquidityFee / 10000 and t / s > -1 / arg1 * _liquidityFee / 10000:
                                revert with 'NH{q', 17
                            if not arg1 * _liquidityFee / 10000:
                                revert with 'NH{q', 18
                            if arg1 * _liquidityFee / 10000 * t / s / arg1 * _liquidityFee / 10000 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _burnFee / 10000:
                                if arg1 * _liquidityFee / 10000 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _liquidityFee / 10000 * t / s:
                                    revert with 'NH{q', 17
                                if 0 > -1 * arg1 * _liquidityFee / 10000 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _liquidityFee / 10000 * t / s < 0:
                                    revert with 'NH{q', 17
                            else:
                                if arg1 * _burnFee / 10000 and t / s > -1 / arg1 * _burnFee / 10000:
                                    revert with 'NH{q', 17
                                if not arg1 * _burnFee / 10000:
                                    revert with 'NH{q', 18
                                if arg1 * _burnFee / 10000 * t / s / arg1 * _burnFee / 10000 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _liquidityFee / 10000 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _liquidityFee / 10000 * t / s:
                                    revert with 'NH{q', 17
                                if arg1 * _burnFee / 10000 * t / s > -1 * arg1 * _liquidityFee / 10000 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _liquidityFee / 10000 * t / s < arg1 * _burnFee / 10000 * t / s:
                                    revert with 'NH{q', 17
                        return 0
                    if arg1 and t / s > -1 / arg1:
                        revert with 'NH{q', 17
                    if not arg1:
                        revert with 'NH{q', 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _liquidityFee / 10000:
                        if not arg1 * _burnFee / 10000:
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 'NH{q', 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 'NH{q', 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 'NH{q', 17
                        else:
                            if arg1 * _burnFee / 10000 and t / s > -1 / arg1 * _burnFee / 10000:
                                revert with 'NH{q', 17
                            if not arg1 * _burnFee / 10000:
                                revert with 'NH{q', 18
                            if arg1 * _burnFee / 10000 * t / s / arg1 * _burnFee / 10000 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 'NH{q', 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 'NH{q', 17
                            if arg1 * _burnFee / 10000 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < arg1 * _burnFee / 10000 * t / s:
                                revert with 'NH{q', 17
                    else:
                        if arg1 * _liquidityFee / 10000 and t / s > -1 / arg1 * _liquidityFee / 10000:
                            revert with 'NH{q', 17
                        if not arg1 * _liquidityFee / 10000:
                            revert with 'NH{q', 18
                        if arg1 * _liquidityFee / 10000 * t / s / arg1 * _liquidityFee / 10000 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _burnFee / 10000:
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 'NH{q', 17
                            if arg1 * _liquidityFee / 10000 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < arg1 * _liquidityFee / 10000 * t / s:
                                revert with 'NH{q', 17
                            if 0 > (arg1 * t / s) - (arg1 * _liquidityFee / 10000 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (arg1 * _liquidityFee / 10000 * t / s) < 0:
                                revert with 'NH{q', 17
                        else:
                            if arg1 * _burnFee / 10000 and t / s > -1 / arg1 * _burnFee / 10000:
                                revert with 'NH{q', 17
                            if not arg1 * _burnFee / 10000:
                                revert with 'NH{q', 18
                            if arg1 * _burnFee / 10000 * t / s / arg1 * _burnFee / 10000 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 'NH{q', 17
                            if arg1 * _liquidityFee / 10000 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < arg1 * _liquidityFee / 10000 * t / s:
                                revert with 'NH{q', 17
                            if arg1 * _burnFee / 10000 * t / s > (arg1 * t / s) - (arg1 * _liquidityFee / 10000 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (arg1 * _liquidityFee / 10000 * t / s) < arg1 * _burnFee / 10000 * t / s:
                                revert with 'NH{q', 17
                    return (arg1 * t / s)
                if totalSupply <= 0:
                    revert with 0, 'SafeMath: division by zero', 0
                if not totalSupply:
                    revert with 'NH{q', 18
                if not arg1:
                    if not arg1 * _liquidityFee / 10000:
                        if arg1 * _burnFee / 10000:
                            if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                                revert with 'NH{q', 17
                            if not arg1 * _burnFee / 10000:
                                revert with 'NH{q', 18
                            if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * _burnFee / 10000 * stor12 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                                revert with 'NH{q', 17
                    else:
                        if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                            revert with 'NH{q', 17
                        if not arg1 * _liquidityFee / 10000:
                            revert with 'NH{q', 18
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _burnFee / 10000:
                            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                revert with 'NH{q', 17
                            if 0 > -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply < 0:
                                revert with 'NH{q', 17
                        else:
                            if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                                revert with 'NH{q', 17
                            if not arg1 * _burnFee / 10000:
                                revert with 'NH{q', 18
                            if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                revert with 'NH{q', 17
                            if arg1 * _burnFee / 10000 * stor12 / totalSupply > -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                                revert with 'NH{q', 17
                    return 0
                if arg1 and stor12 / totalSupply > -1 / arg1:
                    revert with 'NH{q', 17
                if not arg1:
                    revert with 'NH{q', 18
                if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _liquidityFee / 10000:
                    if not arg1 * _burnFee / 10000:
                        if 0 > arg1 * stor12 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 'NH{q', 17
                        if 0 > arg1 * stor12 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 'NH{q', 17
                        if 0 > arg1 * stor12 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 'NH{q', 17
                    else:
                        if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                            revert with 'NH{q', 17
                        if not arg1 * _burnFee / 10000:
                            revert with 'NH{q', 18
                        if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 'NH{q', 17
                        if 0 > arg1 * stor12 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 'NH{q', 17
                        if arg1 * _burnFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor12 / totalSupply < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                            revert with 'NH{q', 17
                else:
                    if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                        revert with 'NH{q', 17
                    if not arg1 * _liquidityFee / 10000:
                        revert with 'NH{q', 18
                    if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _burnFee / 10000:
                        if 0 > arg1 * stor12 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 'NH{q', 17
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                            revert with 'NH{q', 17
                        if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                            revert with 'NH{q', 17
                    else:
                        if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                            revert with 'NH{q', 17
                        if not arg1 * _burnFee / 10000:
                            revert with 'NH{q', 18
                        if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 'NH{q', 17
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                            revert with 'NH{q', 17
                        if arg1 * _burnFee / 10000 * stor12 / totalSupply > (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                            revert with 'NH{q', 17
    else:
        if arg1 and _taxFee > -1 / arg1:
            revert with 'NH{q', 17
        if not arg1:
            revert with 'NH{q', 18
        if arg1 * _taxFee / arg1 != _taxFee:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
        mem[96] = 26
        mem[128] = 'SafeMath: division by zero'
        if not arg1:
            mem[160] = 26
            mem[192] = 'SafeMath: division by zero'
            if not arg1:
                mem[224] = 26
                mem[256] = 'SafeMath: division by zero'
                mem[288] = 30
                mem[320] = 'SafeMath: subtraction overflow'
                if arg1 * _taxFee / 10000 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < arg1 * _taxFee / 10000:
                    revert with 'NH{q', 17
                mem[352] = 30
                mem[384] = 'SafeMath: subtraction overflow'
                if 0 > arg1 - (arg1 * _taxFee / 10000):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * _taxFee / 10000) < 0:
                    revert with 'NH{q', 17
                mem[64] = 480
                mem[416] = 30
                mem[448] = 'SafeMath: subtraction overflow'
                if 0 > arg1 - (arg1 * _taxFee / 10000):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * _taxFee / 10000) < 0:
                    revert with 'NH{q', 17
                idx = 0
                s = totalSupply
                t = stor12
                while idx < stor9.length:
                    mem[0] = stor9[idx]
                    mem[32] = 3
                    if stor3[stor9[idx]] > t:
                        _2313 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2313] = 26
                        mem[_2313 + 32] = 'SafeMath: division by zero'
                        if totalSupply <= 0:
                            _2433 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2433 + idx + 68] = mem[_2313 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2433 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2433 + -mem[64] + 100
                        if not totalSupply:
                            revert with 'NH{q', 18
                        if not arg1:
                            if not arg1 * _taxFee / 10000:
                                return 0
                            if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                                revert with 'NH{q', 17
                            if not arg1 * _taxFee / 10000:
                                revert with 'NH{q', 18
                            if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _3338 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3338] = 30
                            mem[_3338 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                                _3404 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_3404 + idx + 68] = mem[_3338 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3404 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _3404 + -mem[64] + 100
                            if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                revert with 'NH{q', 17
                            _3911 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3911] = 30
                            mem[_3911 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                _4046 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_4046 + idx + 68] = mem[_3911 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4046 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _4046 + -mem[64] + 100
                            if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _4946 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4946] = 30
                            mem[_4946 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                else:
                                    return 0
                            _5200 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_5200 + idx + 68] = mem[_4946 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5200 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5200 + -mem[64] + 100
                        if arg1 and stor12 / totalSupply > -1 / arg1:
                            revert with 'NH{q', 17
                        if not arg1:
                            revert with 'NH{q', 18
                        if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _taxFee / 10000:
                            _3337 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3337] = 30
                            mem[_3337 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor12 / totalSupply:
                                _3403 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_3403 + idx + 68] = mem[_3337 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3403 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _3403 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _3910 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3910] = 30
                            mem[_3910 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor12 / totalSupply:
                                _4045 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_4045 + idx + 68] = mem[_3910 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4045 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _4045 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _4945 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4945] = 30
                            mem[_4945 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor12 / totalSupply:
                                if arg1 * stor12 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                return (arg1 * stor12 / totalSupply)
                            _5199 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_5199 + idx + 68] = mem[_4945 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5199 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5199 + -mem[64] + 100
                        if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                            revert with 'NH{q', 17
                        if not arg1 * _taxFee / 10000:
                            revert with 'NH{q', 18
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _4149 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4149] = 30
                        mem[_4149 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                            _4310 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_4310 + idx + 68] = mem[_4149 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_4310 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _4310 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            revert with 'NH{q', 17
                        _5414 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5414] = 30
                        mem[_5414 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                            _5703 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_5703 + idx + 68] = mem[_5414 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5703 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5703 + -mem[64] + 100
                        if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                            revert with 'NH{q', 17
                        _7143 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_7143] = 30
                        mem[_7143 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                            if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                                revert with 'NH{q', 17
                            return (arg1 * stor12 / totalSupply)
                        _7474 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_7474 + idx + 68] = mem[_7143 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_7474 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _7474 + -mem[64] + 100
                    if idx >= stor9.length:
                        revert with 'NH{q', 50
                    mem[0] = stor9[idx]
                    mem[32] = 4
                    if stor4[stor9[idx]] <= s:
                        if idx >= stor9.length:
                            revert with 'NH{q', 50
                        mem[0] = stor9[idx]
                        mem[32] = 3
                        _2391 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2391] = 30
                        mem[_2391 + 32] = 'SafeMath: subtraction overflow'
                        if stor3[stor9[idx]] > t:
                            _2454 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_2454 + idx + 68] = mem[_2391 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2454 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _2454 + -mem[64] + 100
                        if t < stor3[stor9[idx]]:
                            revert with 'NH{q', 17
                        if idx >= stor9.length:
                            revert with 'NH{q', 50
                        mem[0] = stor9[idx]
                        mem[32] = 4
                        _2726 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2726] = 30
                        mem[_2726 + 32] = 'SafeMath: subtraction overflow'
                        if stor4[stor9[idx]] <= s:
                            if s < stor4[stor9[idx]]:
                                revert with 'NH{q', 17
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            s = s - stor4[stor9[idx]]
                            t = t - stor3[stor9[idx]]
                            continue 
                        _2774 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_2774 + idx + 68] = mem[_2726 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2774 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _2774 + -mem[64] + 100
                    _2434 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2434] = 26
                    mem[_2434 + 32] = 'SafeMath: division by zero'
                    if totalSupply <= 0:
                        _2470 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2470 + idx + 68] = mem[_2434 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2470 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2470 + -mem[64] + 100
                    if not totalSupply:
                        revert with 'NH{q', 18
                    if not arg1:
                        if not arg1 * _taxFee / 10000:
                            return 0
                        if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                            revert with 'NH{q', 17
                        if not arg1 * _taxFee / 10000:
                            revert with 'NH{q', 18
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _3406 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3406] = 30
                        mem[_3406 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                            _3502 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_3502 + idx + 68] = mem[_3406 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3502 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _3502 + -mem[64] + 100
                        if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            revert with 'NH{q', 17
                        _4049 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4049] = 30
                        mem[_4049 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            _4202 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_4202 + idx + 68] = mem[_4049 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_4202 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _4202 + -mem[64] + 100
                        if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _5202 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5202] = 30
                        mem[_5202 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                                revert with 'NH{q', 17
                            else:
                                return 0
                        _5548 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_5548 + idx + 68] = mem[_5202 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_5548 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _5548 + -mem[64] + 100
                    if arg1 and stor12 / totalSupply > -1 / arg1:
                        revert with 'NH{q', 17
                    if not arg1:
                        revert with 'NH{q', 18
                    if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _taxFee / 10000:
                        _3405 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3405] = 30
                        mem[_3405 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _3501 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_3501 + idx + 68] = mem[_3405 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3501 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _3501 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _4048 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4048] = 30
                        mem[_4048 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _4201 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_4201 + idx + 68] = mem[_4048 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_4201 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _4201 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _5201 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5201] = 30
                        mem[_5201 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= arg1 * stor12 / totalSupply:
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 'NH{q', 17
                            return (arg1 * stor12 / totalSupply)
                        _5547 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_5547 + idx + 68] = mem[_5201 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_5547 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _5547 + -mem[64] + 100
                    if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                        revert with 'NH{q', 17
                    if not arg1 * _taxFee / 10000:
                        revert with 'NH{q', 18
                    if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _4315 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4315] = 30
                    mem[_4315 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                        _4488 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_4488 + idx + 68] = mem[_4315 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4488 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _4488 + -mem[64] + 100
                    if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                        revert with 'NH{q', 17
                    _5709 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5709] = 30
                    mem[_5709 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                        _5980 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_5980 + idx + 68] = mem[_5709 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_5980 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _5980 + -mem[64] + 100
                    if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                        revert with 'NH{q', 17
                    _7477 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_7477] = 30
                    mem[_7477 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                        if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                            revert with 'NH{q', 17
                        return (arg1 * stor12 / totalSupply)
                    _7846 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_7846 + idx + 68] = mem[_7477 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_7846 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _7846 + -mem[64] + 100
                if totalSupply <= 0:
                    revert with 0, 'SafeMath: division by zero', 0
                if not totalSupply:
                    revert with 'NH{q', 18
                if t >= stor12 / totalSupply:
                    if s <= 0:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not s:
                        revert with 'NH{q', 18
                    if not arg1:
                        if arg1 * _taxFee / 10000:
                            if arg1 * _taxFee / 10000 and t / s > -1 / arg1 * _taxFee / 10000:
                                revert with 'NH{q', 17
                            if not arg1 * _taxFee / 10000:
                                revert with 'NH{q', 18
                            if arg1 * _taxFee / 10000 * t / s / arg1 * _taxFee / 10000 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * _taxFee / 10000 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * _taxFee / 10000 * t / s:
                                revert with 'NH{q', 17
                            if 0 > -1 * arg1 * _taxFee / 10000 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * _taxFee / 10000 * t / s < 0:
                                revert with 'NH{q', 17
                            if 0 > -1 * arg1 * _taxFee / 10000 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * _taxFee / 10000 * t / s < 0:
                                revert with 'NH{q', 17
                            else:
                                return 0
                        else:
                            return 0
                    if arg1 and t / s > -1 / arg1:
                        revert with 'NH{q', 17
                    if not arg1:
                        revert with 'NH{q', 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _taxFee / 10000:
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 'NH{q', 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 'NH{q', 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 'NH{q', 17
                    else:
                        if arg1 * _taxFee / 10000 and t / s > -1 / arg1 * _taxFee / 10000:
                            revert with 'NH{q', 17
                        if not arg1 * _taxFee / 10000:
                            revert with 'NH{q', 18
                        if arg1 * _taxFee / 10000 * t / s / arg1 * _taxFee / 10000 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * _taxFee / 10000 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < arg1 * _taxFee / 10000 * t / s:
                            revert with 'NH{q', 17
                        if 0 > (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) < 0:
                            revert with 'NH{q', 17
                        if 0 > (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) < 0:
                            revert with 'NH{q', 17
                    return (arg1 * t / s)
                if totalSupply <= 0:
                    revert with 0, 'SafeMath: division by zero', 0
                if not totalSupply:
                    revert with 'NH{q', 18
                if not arg1:
                    if arg1 * _taxFee / 10000:
                        if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                            revert with 'NH{q', 17
                        if not arg1 * _taxFee / 10000:
                            revert with 'NH{q', 18
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            revert with 'NH{q', 17
                        if 0 > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                            revert with 'NH{q', 17
                        if 0 > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                            revert with 'NH{q', 17
                        else:
                            return 0
                    else:
                        return 0
                if arg1 and stor12 / totalSupply > -1 / arg1:
                    revert with 'NH{q', 17
                if not arg1:
                    revert with 'NH{q', 18
                if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _taxFee / 10000:
                    if 0 > arg1 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 'NH{q', 17
                    if 0 > arg1 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 'NH{q', 17
                    if 0 > arg1 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 'NH{q', 17
                else:
                    if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                        revert with 'NH{q', 17
                    if not arg1 * _taxFee / 10000:
                        revert with 'NH{q', 18
                    if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                        revert with 'NH{q', 17
                    if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                        revert with 'NH{q', 17
                    if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                        revert with 'NH{q', 17
            else:
                if arg1 and _burnFee > -1 / arg1:
                    revert with 'NH{q', 17
                if not arg1:
                    revert with 'NH{q', 18
                if arg1 * _burnFee / arg1 != _burnFee:
                    revert with 0, 'SafeMath: multiplication overflow'
                mem[224] = 26
                mem[256] = 'SafeMath: division by zero'
                mem[288] = 30
                mem[320] = 'SafeMath: subtraction overflow'
                if arg1 * _taxFee / 10000 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < arg1 * _taxFee / 10000:
                    revert with 'NH{q', 17
                mem[352] = 30
                mem[384] = 'SafeMath: subtraction overflow'
                if 0 > arg1 - (arg1 * _taxFee / 10000):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * _taxFee / 10000) < 0:
                    revert with 'NH{q', 17
                mem[64] = 480
                mem[416] = 30
                mem[448] = 'SafeMath: subtraction overflow'
                if arg1 * _burnFee / 10000 > arg1 - (arg1 * _taxFee / 10000):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * _taxFee / 10000) < arg1 * _burnFee / 10000:
                    revert with 'NH{q', 17
                idx = 0
                s = totalSupply
                t = stor12
                while idx < stor9.length:
                    mem[0] = stor9[idx]
                    mem[32] = 3
                    if stor3[stor9[idx]] > t:
                        _2306 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2306] = 26
                        mem[_2306 + 32] = 'SafeMath: division by zero'
                        if totalSupply <= 0:
                            _2431 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2431 + idx + 68] = mem[_2306 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2431 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2431 + -mem[64] + 100
                        if not totalSupply:
                            revert with 'NH{q', 18
                        if not arg1:
                            if not arg1 * _taxFee / 10000:
                                if not arg1 * _burnFee / 10000:
                                    return 0
                                if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                                    revert with 'NH{q', 17
                                if not arg1 * _burnFee / 10000:
                                    revert with 'NH{q', 18
                                if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _3336 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3336] = 30
                                mem[_3336 + 32] = 'SafeMath: subtraction overflow'
                                _3904 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3904] = 30
                                mem[_3904 + 32] = 'SafeMath: subtraction overflow'
                                _4940 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4940] = 30
                                mem[_4940 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _burnFee / 10000 * stor12 / totalSupply <= 0:
                                    if 0 < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                                        revert with 'NH{q', 17
                                    else:
                                        return 0
                                _5194 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_5194 + idx + 68] = mem[_4940 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5194 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _5194 + -mem[64] + 100
                            if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                                revert with 'NH{q', 17
                            if not arg1 * _taxFee / 10000:
                                revert with 'NH{q', 18
                            if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _burnFee / 10000:
                                _3335 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3335] = 30
                                mem[_3335 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                                    _3399 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_3399 + idx + 68] = mem[_3335 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_3399 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _3399 + -mem[64] + 100
                                if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                    revert with 'NH{q', 17
                                _3903 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3903] = 30
                                mem[_3903 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                    _4036 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_4036 + idx + 68] = mem[_3903 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4036 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4036 + -mem[64] + 100
                                if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                _4939 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4939] = 30
                                mem[_4939 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                    if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                                        revert with 'NH{q', 17
                                    else:
                                        return 0
                                _5193 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_5193 + idx + 68] = mem[_4939 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5193 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _5193 + -mem[64] + 100
                            if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                                revert with 'NH{q', 17
                            if not arg1 * _burnFee / 10000:
                                revert with 'NH{q', 18
                            if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _4144 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4144] = 30
                            mem[_4144 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                                _4304 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_4304 + idx + 68] = mem[_4144 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4304 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _4304 + -mem[64] + 100
                            if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                revert with 'NH{q', 17
                            _5403 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5403] = 30
                            mem[_5403 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                _5694 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_5694 + idx + 68] = mem[_5403 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5694 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _5694 + -mem[64] + 100
                            if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _7130 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_7130] = 30
                            mem[_7130 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _burnFee / 10000 * stor12 / totalSupply <= -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                                    revert with 'NH{q', 17
                                else:
                                    return 0
                            _7468 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_7468 + idx + 68] = mem[_7130 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_7468 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _7468 + -mem[64] + 100
                        if arg1 and stor12 / totalSupply > -1 / arg1:
                            revert with 'NH{q', 17
                        if not arg1:
                            revert with 'NH{q', 18
                        if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _taxFee / 10000:
                            if not arg1 * _burnFee / 10000:
                                _3334 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3334] = 30
                                mem[_3334 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor12 / totalSupply:
                                    _3398 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_3398 + idx + 68] = mem[_3334 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_3398 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _3398 + -mem[64] + 100
                                if arg1 * stor12 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                _3901 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3901] = 30
                                mem[_3901 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor12 / totalSupply:
                                    _4035 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_4035 + idx + 68] = mem[_3901 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4035 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4035 + -mem[64] + 100
                                if arg1 * stor12 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                _4938 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4938] = 30
                                mem[_4938 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor12 / totalSupply:
                                    if arg1 * stor12 / totalSupply < 0:
                                        revert with 'NH{q', 17
                                    return (arg1 * stor12 / totalSupply)
                                _5191 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_5191 + idx + 68] = mem[_4938 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5191 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _5191 + -mem[64] + 100
                            if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                                revert with 'NH{q', 17
                            if not arg1 * _burnFee / 10000:
                                revert with 'NH{q', 18
                            if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _4143 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4143] = 30
                            mem[_4143 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor12 / totalSupply:
                                _4301 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_4301 + idx + 68] = mem[_4143 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4301 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _4301 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _5402 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5402] = 30
                            mem[_5402 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor12 / totalSupply:
                                _5691 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_5691 + idx + 68] = mem[_5402 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5691 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _5691 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _7129 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_7129] = 30
                            mem[_7129 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _burnFee / 10000 * stor12 / totalSupply <= arg1 * stor12 / totalSupply:
                                if arg1 * stor12 / totalSupply < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                                    revert with 'NH{q', 17
                                return (arg1 * stor12 / totalSupply)
                            _7466 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_7466 + idx + 68] = mem[_7129 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_7466 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _7466 + -mem[64] + 100
                        if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                            revert with 'NH{q', 17
                        if not arg1 * _taxFee / 10000:
                            revert with 'NH{q', 18
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _burnFee / 10000:
                            _4142 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4142] = 30
                            mem[_4142 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                                _4300 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_4300 + idx + 68] = mem[_4142 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4300 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _4300 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                revert with 'NH{q', 17
                            _5401 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5401] = 30
                            mem[_5401 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                                _5690 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_5690 + idx + 68] = mem[_5401 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5690 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _5690 + -mem[64] + 100
                            if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                                revert with 'NH{q', 17
                            _7128 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_7128] = 30
                            mem[_7128 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                                if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                                    revert with 'NH{q', 17
                                return (arg1 * stor12 / totalSupply)
                            _7465 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_7465 + idx + 68] = mem[_7128 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_7465 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _7465 + -mem[64] + 100
                        if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                            revert with 'NH{q', 17
                        if not arg1 * _burnFee / 10000:
                            revert with 'NH{q', 18
                        if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _5853 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5853] = 30
                        mem[_5853 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                            _6106 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_6106 + idx + 68] = mem[_5853 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_6106 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _6106 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            revert with 'NH{q', 17
                        _7678 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_7678] = 30
                        mem[_7678 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                            _8005 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_8005 + idx + 68] = mem[_7678 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_8005 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _8005 + -mem[64] + 100
                        if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                            revert with 'NH{q', 17
                        _9335 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9335] = 30
                        mem[_9335 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _burnFee / 10000 * stor12 / totalSupply <= (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                            if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                                revert with 'NH{q', 17
                            return (arg1 * stor12 / totalSupply)
                        _9562 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_9562 + idx + 68] = mem[_9335 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_9562 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _9562 + -mem[64] + 100
                    if idx >= stor9.length:
                        revert with 'NH{q', 50
                    mem[0] = stor9[idx]
                    mem[32] = 4
                    if stor4[stor9[idx]] <= s:
                        if idx >= stor9.length:
                            revert with 'NH{q', 50
                        mem[0] = stor9[idx]
                        mem[32] = 3
                        _2387 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2387] = 30
                        mem[_2387 + 32] = 'SafeMath: subtraction overflow'
                        if stor3[stor9[idx]] > t:
                            _2453 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_2453 + idx + 68] = mem[_2387 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2453 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _2453 + -mem[64] + 100
                        if t < stor3[stor9[idx]]:
                            revert with 'NH{q', 17
                        if idx >= stor9.length:
                            revert with 'NH{q', 50
                        mem[0] = stor9[idx]
                        mem[32] = 4
                        _2725 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2725] = 30
                        mem[_2725 + 32] = 'SafeMath: subtraction overflow'
                        if stor4[stor9[idx]] <= s:
                            if s < stor4[stor9[idx]]:
                                revert with 'NH{q', 17
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            s = s - stor4[stor9[idx]]
                            t = t - stor3[stor9[idx]]
                            continue 
                        _2773 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_2773 + idx + 68] = mem[_2725 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2773 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _2773 + -mem[64] + 100
                    _2432 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2432] = 26
                    mem[_2432 + 32] = 'SafeMath: division by zero'
                    if totalSupply <= 0:
                        _2469 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2469 + idx + 68] = mem[_2432 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2469 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2469 + -mem[64] + 100
                    if not totalSupply:
                        revert with 'NH{q', 18
                    if not arg1:
                        if not arg1 * _taxFee / 10000:
                            if not arg1 * _burnFee / 10000:
                                return 0
                            if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                                revert with 'NH{q', 17
                            if not arg1 * _burnFee / 10000:
                                revert with 'NH{q', 18
                            if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _3402 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3402] = 30
                            mem[_3402 + 32] = 'SafeMath: subtraction overflow'
                            _4042 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4042] = 30
                            mem[_4042 + 32] = 'SafeMath: subtraction overflow'
                            _5197 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5197] = 30
                            mem[_5197 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _burnFee / 10000 * stor12 / totalSupply <= 0:
                                if 0 < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                                    revert with 'NH{q', 17
                                else:
                                    return 0
                            _5541 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_5541 + idx + 68] = mem[_5197 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5541 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5541 + -mem[64] + 100
                        if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                            revert with 'NH{q', 17
                        if not arg1 * _taxFee / 10000:
                            revert with 'NH{q', 18
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _burnFee / 10000:
                            _3401 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3401] = 30
                            mem[_3401 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                                _3499 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_3499 + idx + 68] = mem[_3401 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3499 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _3499 + -mem[64] + 100
                            if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                revert with 'NH{q', 17
                            _4041 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4041] = 30
                            mem[_4041 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                _4200 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_4200 + idx + 68] = mem[_4041 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4200 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _4200 + -mem[64] + 100
                            if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _5196 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5196] = 30
                            mem[_5196 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                else:
                                    return 0
                            _5540 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_5540 + idx + 68] = mem[_5196 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5540 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5540 + -mem[64] + 100
                        if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                            revert with 'NH{q', 17
                        if not arg1 * _burnFee / 10000:
                            revert with 'NH{q', 18
                        if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _4309 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4309] = 30
                        mem[_4309 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                            _4483 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_4483 + idx + 68] = mem[_4309 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_4483 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _4483 + -mem[64] + 100
                        if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            revert with 'NH{q', 17
                        _5702 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5702] = 30
                        mem[_5702 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            _5975 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_5975 + idx + 68] = mem[_5702 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5975 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5975 + -mem[64] + 100
                        if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _7473 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_7473] = 30
                        mem[_7473 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _burnFee / 10000 * stor12 / totalSupply <= -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                                revert with 'NH{q', 17
                            else:
                                return 0
                        _7841 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_7841 + idx + 68] = mem[_7473 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_7841 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _7841 + -mem[64] + 100
                    if arg1 and stor12 / totalSupply > -1 / arg1:
                        revert with 'NH{q', 17
                    if not arg1:
                        revert with 'NH{q', 18
                    if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _taxFee / 10000:
                        if not arg1 * _burnFee / 10000:
                            _3400 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3400] = 30
                            mem[_3400 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor12 / totalSupply:
                                _3498 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_3498 + idx + 68] = mem[_3400 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3498 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _3498 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _4039 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4039] = 30
                            mem[_4039 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor12 / totalSupply:
                                _4199 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_4199 + idx + 68] = mem[_4039 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4199 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _4199 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _5195 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5195] = 30
                            mem[_5195 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor12 / totalSupply:
                                if arg1 * stor12 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                return (arg1 * stor12 / totalSupply)
                            _5538 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_5538 + idx + 68] = mem[_5195 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5538 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5538 + -mem[64] + 100
                        if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                            revert with 'NH{q', 17
                        if not arg1 * _burnFee / 10000:
                            revert with 'NH{q', 18
                        if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _4308 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4308] = 30
                        mem[_4308 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _4480 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_4480 + idx + 68] = mem[_4308 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_4480 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _4480 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _5701 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5701] = 30
                        mem[_5701 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _5972 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_5972 + idx + 68] = mem[_5701 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5972 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5972 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _7472 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_7472] = 30
                        mem[_7472 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _burnFee / 10000 * stor12 / totalSupply <= arg1 * stor12 / totalSupply:
                            if arg1 * stor12 / totalSupply < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                                revert with 'NH{q', 17
                            return (arg1 * stor12 / totalSupply)
                        _7839 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_7839 + idx + 68] = mem[_7472 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_7839 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _7839 + -mem[64] + 100
                    if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                        revert with 'NH{q', 17
                    if not arg1 * _taxFee / 10000:
                        revert with 'NH{q', 18
                    if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _burnFee / 10000:
                        _4307 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4307] = 30
                        mem[_4307 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                            _4479 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_4479 + idx + 68] = mem[_4307 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_4479 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _4479 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            revert with 'NH{q', 17
                        _5700 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5700] = 30
                        mem[_5700 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                            _5971 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_5971 + idx + 68] = mem[_5700 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5971 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5971 + -mem[64] + 100
                        if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                            revert with 'NH{q', 17
                        _7471 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_7471] = 30
                        mem[_7471 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                            if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                                revert with 'NH{q', 17
                            return (arg1 * stor12 / totalSupply)
                        _7838 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_7838 + idx + 68] = mem[_7471 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_7838 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _7838 + -mem[64] + 100
                    if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                        revert with 'NH{q', 17
                    if not arg1 * _burnFee / 10000:
                        revert with 'NH{q', 18
                    if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _6113 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6113] = 30
                    mem[_6113 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                        _6400 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_6400 + idx + 68] = mem[_6113 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_6400 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _6400 + -mem[64] + 100
                    if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                        revert with 'NH{q', 17
                    _8015 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_8015] = 30
                    mem[_8015 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                        _8312 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_8312 + idx + 68] = mem[_8015 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_8312 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _8312 + -mem[64] + 100
                    if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                        revert with 'NH{q', 17
                    _9566 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9566] = 30
                    mem[_9566 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _burnFee / 10000 * stor12 / totalSupply <= (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                        if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                            revert with 'NH{q', 17
                        return (arg1 * stor12 / totalSupply)
                    _9740 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_9740 + idx + 68] = mem[_9566 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_9740 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _9740 + -mem[64] + 100
                if totalSupply <= 0:
                    revert with 0, 'SafeMath: division by zero', 0
                if not totalSupply:
                    revert with 'NH{q', 18
                if t >= stor12 / totalSupply:
                    if s <= 0:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not s:
                        revert with 'NH{q', 18
                    if not arg1:
                        if not arg1 * _taxFee / 10000:
                            if arg1 * _burnFee / 10000:
                                if arg1 * _burnFee / 10000 and t / s > -1 / arg1 * _burnFee / 10000:
                                    revert with 'NH{q', 17
                                if not arg1 * _burnFee / 10000:
                                    revert with 'NH{q', 18
                                if arg1 * _burnFee / 10000 * t / s / arg1 * _burnFee / 10000 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _burnFee / 10000 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _burnFee / 10000 * t / s:
                                    revert with 'NH{q', 17
                        else:
                            if arg1 * _taxFee / 10000 and t / s > -1 / arg1 * _taxFee / 10000:
                                revert with 'NH{q', 17
                            if not arg1 * _taxFee / 10000:
                                revert with 'NH{q', 18
                            if arg1 * _taxFee / 10000 * t / s / arg1 * _taxFee / 10000 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _burnFee / 10000:
                                if arg1 * _taxFee / 10000 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _taxFee / 10000 * t / s:
                                    revert with 'NH{q', 17
                                if 0 > -1 * arg1 * _taxFee / 10000 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _taxFee / 10000 * t / s < 0:
                                    revert with 'NH{q', 17
                                if 0 > -1 * arg1 * _taxFee / 10000 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _taxFee / 10000 * t / s < 0:
                                    revert with 'NH{q', 17
                            else:
                                if arg1 * _burnFee / 10000 and t / s > -1 / arg1 * _burnFee / 10000:
                                    revert with 'NH{q', 17
                                if not arg1 * _burnFee / 10000:
                                    revert with 'NH{q', 18
                                if arg1 * _burnFee / 10000 * t / s / arg1 * _burnFee / 10000 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _taxFee / 10000 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _taxFee / 10000 * t / s:
                                    revert with 'NH{q', 17
                                if 0 > -1 * arg1 * _taxFee / 10000 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _taxFee / 10000 * t / s < 0:
                                    revert with 'NH{q', 17
                                if arg1 * _burnFee / 10000 * t / s > -1 * arg1 * _taxFee / 10000 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _taxFee / 10000 * t / s < arg1 * _burnFee / 10000 * t / s:
                                    revert with 'NH{q', 17
                        return 0
                    if arg1 and t / s > -1 / arg1:
                        revert with 'NH{q', 17
                    if not arg1:
                        revert with 'NH{q', 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _taxFee / 10000:
                        if not arg1 * _burnFee / 10000:
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 'NH{q', 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 'NH{q', 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 'NH{q', 17
                        else:
                            if arg1 * _burnFee / 10000 and t / s > -1 / arg1 * _burnFee / 10000:
                                revert with 'NH{q', 17
                            if not arg1 * _burnFee / 10000:
                                revert with 'NH{q', 18
                            if arg1 * _burnFee / 10000 * t / s / arg1 * _burnFee / 10000 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 'NH{q', 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 'NH{q', 17
                            if arg1 * _burnFee / 10000 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < arg1 * _burnFee / 10000 * t / s:
                                revert with 'NH{q', 17
                    else:
                        if arg1 * _taxFee / 10000 and t / s > -1 / arg1 * _taxFee / 10000:
                            revert with 'NH{q', 17
                        if not arg1 * _taxFee / 10000:
                            revert with 'NH{q', 18
                        if arg1 * _taxFee / 10000 * t / s / arg1 * _taxFee / 10000 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _burnFee / 10000:
                            if arg1 * _taxFee / 10000 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < arg1 * _taxFee / 10000 * t / s:
                                revert with 'NH{q', 17
                            if 0 > (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) < 0:
                                revert with 'NH{q', 17
                            if 0 > (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) < 0:
                                revert with 'NH{q', 17
                        else:
                            if arg1 * _burnFee / 10000 and t / s > -1 / arg1 * _burnFee / 10000:
                                revert with 'NH{q', 17
                            if not arg1 * _burnFee / 10000:
                                revert with 'NH{q', 18
                            if arg1 * _burnFee / 10000 * t / s / arg1 * _burnFee / 10000 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * _taxFee / 10000 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < arg1 * _taxFee / 10000 * t / s:
                                revert with 'NH{q', 17
                            if 0 > (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) < 0:
                                revert with 'NH{q', 17
                            if arg1 * _burnFee / 10000 * t / s > (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) < arg1 * _burnFee / 10000 * t / s:
                                revert with 'NH{q', 17
                    return (arg1 * t / s)
                if totalSupply <= 0:
                    revert with 0, 'SafeMath: division by zero', 0
                if not totalSupply:
                    revert with 'NH{q', 18
                if not arg1:
                    if not arg1 * _taxFee / 10000:
                        if arg1 * _burnFee / 10000:
                            if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                                revert with 'NH{q', 17
                            if not arg1 * _burnFee / 10000:
                                revert with 'NH{q', 18
                            if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * _burnFee / 10000 * stor12 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                                revert with 'NH{q', 17
                    else:
                        if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                            revert with 'NH{q', 17
                        if not arg1 * _taxFee / 10000:
                            revert with 'NH{q', 18
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _burnFee / 10000:
                            if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                revert with 'NH{q', 17
                            if 0 > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                                revert with 'NH{q', 17
                            if 0 > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                                revert with 'NH{q', 17
                        else:
                            if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                                revert with 'NH{q', 17
                            if not arg1 * _burnFee / 10000:
                                revert with 'NH{q', 18
                            if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                revert with 'NH{q', 17
                            if 0 > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                                revert with 'NH{q', 17
                            if arg1 * _burnFee / 10000 * stor12 / totalSupply > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                                revert with 'NH{q', 17
                    return 0
                if arg1 and stor12 / totalSupply > -1 / arg1:
                    revert with 'NH{q', 17
                if not arg1:
                    revert with 'NH{q', 18
                if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _taxFee / 10000:
                    if not arg1 * _burnFee / 10000:
                        if 0 > arg1 * stor12 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 'NH{q', 17
                        if 0 > arg1 * stor12 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 'NH{q', 17
                        if 0 > arg1 * stor12 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 'NH{q', 17
                    else:
                        if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                            revert with 'NH{q', 17
                        if not arg1 * _burnFee / 10000:
                            revert with 'NH{q', 18
                        if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 'NH{q', 17
                        if 0 > arg1 * stor12 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 'NH{q', 17
                        if arg1 * _burnFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor12 / totalSupply < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                            revert with 'NH{q', 17
                else:
                    if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                        revert with 'NH{q', 17
                    if not arg1 * _taxFee / 10000:
                        revert with 'NH{q', 18
                    if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _burnFee / 10000:
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            revert with 'NH{q', 17
                        if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                            revert with 'NH{q', 17
                        if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                            revert with 'NH{q', 17
                    else:
                        if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                            revert with 'NH{q', 17
                        if not arg1 * _burnFee / 10000:
                            revert with 'NH{q', 18
                        if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            revert with 'NH{q', 17
                        if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                            revert with 'NH{q', 17
                        if arg1 * _burnFee / 10000 * stor12 / totalSupply > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                            revert with 'NH{q', 17
        else:
            if arg1 and _liquidityFee > -1 / arg1:
                revert with 'NH{q', 17
            if not arg1:
                revert with 'NH{q', 18
            if arg1 * _liquidityFee / arg1 != _liquidityFee:
                revert with 0, 'SafeMath: multiplication overflow'
            mem[160] = 26
            mem[192] = 'SafeMath: division by zero'
            if not arg1:
                mem[224] = 26
                mem[256] = 'SafeMath: division by zero'
                mem[288] = 30
                mem[320] = 'SafeMath: subtraction overflow'
                if arg1 * _taxFee / 10000 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < arg1 * _taxFee / 10000:
                    revert with 'NH{q', 17
                mem[352] = 30
                mem[384] = 'SafeMath: subtraction overflow'
                if arg1 * _liquidityFee / 10000 > arg1 - (arg1 * _taxFee / 10000):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * _taxFee / 10000) < arg1 * _liquidityFee / 10000:
                    revert with 'NH{q', 17
                mem[64] = 480
                mem[416] = 30
                mem[448] = 'SafeMath: subtraction overflow'
                if 0 > arg1 - (arg1 * _taxFee / 10000) - (arg1 * _liquidityFee / 10000):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * _taxFee / 10000) - (arg1 * _liquidityFee / 10000) < 0:
                    revert with 'NH{q', 17
                idx = 0
                s = totalSupply
                t = stor12
                while idx < stor9.length:
                    mem[0] = stor9[idx]
                    mem[32] = 3
                    if stor3[stor9[idx]] > t:
                        _2299 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2299] = 26
                        mem[_2299 + 32] = 'SafeMath: division by zero'
                        if totalSupply <= 0:
                            _2429 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2429 + idx + 68] = mem[_2299 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2429 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2429 + -mem[64] + 100
                        if not totalSupply:
                            revert with 'NH{q', 18
                        if not arg1:
                            if not arg1 * _taxFee / 10000:
                                if not arg1 * _liquidityFee / 10000:
                                    return 0
                                if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                                    revert with 'NH{q', 17
                                if not arg1 * _liquidityFee / 10000:
                                    revert with 'NH{q', 18
                                if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _3333 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3333] = 30
                                mem[_3333 + 32] = 'SafeMath: subtraction overflow'
                                _3894 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3894] = 30
                                mem[_3894 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > 0:
                                    _4028 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_4028 + idx + 68] = mem[_3894 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4028 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4028 + -mem[64] + 100
                                if 0 < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                    revert with 'NH{q', 17
                                _4933 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4933] = 30
                                mem[_4933 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                    if -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply < 0:
                                        revert with 'NH{q', 17
                                    else:
                                        return 0
                                _5185 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_5185 + idx + 68] = mem[_4933 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5185 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _5185 + -mem[64] + 100
                            if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                                revert with 'NH{q', 17
                            if not arg1 * _taxFee / 10000:
                                revert with 'NH{q', 18
                            if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _liquidityFee / 10000:
                                _3332 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3332] = 30
                                mem[_3332 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                                    _3394 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_3394 + idx + 68] = mem[_3332 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_3394 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _3394 + -mem[64] + 100
                                if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                    revert with 'NH{q', 17
                                _3893 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3893] = 30
                                mem[_3893 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                    _4027 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_4027 + idx + 68] = mem[_3893 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4027 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4027 + -mem[64] + 100
                                if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                _4932 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4932] = 30
                                mem[_4932 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                    if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                                        revert with 'NH{q', 17
                                    else:
                                        return 0
                                _5184 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_5184 + idx + 68] = mem[_4932 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5184 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _5184 + -mem[64] + 100
                            if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                                revert with 'NH{q', 17
                            if not arg1 * _liquidityFee / 10000:
                                revert with 'NH{q', 18
                            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _4135 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4135] = 30
                            mem[_4135 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                                _4293 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_4293 + idx + 68] = mem[_4135 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4293 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _4293 + -mem[64] + 100
                            if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                revert with 'NH{q', 17
                            _5385 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5385] = 30
                            mem[_5385 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                _5681 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_5681 + idx + 68] = mem[_5385 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5681 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _5681 + -mem[64] + 100
                            if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                revert with 'NH{q', 17
                            _7109 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_7109] = 30
                            mem[_7109 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                                if (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                                    revert with 'NH{q', 17
                                else:
                                    return 0
                            _7458 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_7458 + idx + 68] = mem[_7109 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_7458 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _7458 + -mem[64] + 100
                        if arg1 and stor12 / totalSupply > -1 / arg1:
                            revert with 'NH{q', 17
                        if not arg1:
                            revert with 'NH{q', 18
                        if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _taxFee / 10000:
                            if not arg1 * _liquidityFee / 10000:
                                _3331 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3331] = 30
                                mem[_3331 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor12 / totalSupply:
                                    _3393 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_3393 + idx + 68] = mem[_3331 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_3393 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _3393 + -mem[64] + 100
                                if arg1 * stor12 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                _3892 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3892] = 30
                                mem[_3892 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor12 / totalSupply:
                                    _4026 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_4026 + idx + 68] = mem[_3892 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4026 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4026 + -mem[64] + 100
                                if arg1 * stor12 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                _4931 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4931] = 30
                                mem[_4931 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor12 / totalSupply:
                                    if arg1 * stor12 / totalSupply < 0:
                                        revert with 'NH{q', 17
                                    return (arg1 * stor12 / totalSupply)
                                _5182 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_5182 + idx + 68] = mem[_4931 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5182 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _5182 + -mem[64] + 100
                            if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                                revert with 'NH{q', 17
                            if not arg1 * _liquidityFee / 10000:
                                revert with 'NH{q', 18
                            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _4134 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4134] = 30
                            mem[_4134 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor12 / totalSupply:
                                _4290 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_4290 + idx + 68] = mem[_4134 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4290 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _4290 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _5384 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5384] = 30
                            mem[_5384 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                                _5678 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_5678 + idx + 68] = mem[_5384 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5678 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _5678 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                revert with 'NH{q', 17
                            _7108 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_7108] = 30
                            mem[_7108 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                                if (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                                    revert with 'NH{q', 17
                                return (arg1 * stor12 / totalSupply)
                            _7456 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_7456 + idx + 68] = mem[_7108 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_7456 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _7456 + -mem[64] + 100
                        if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                            revert with 'NH{q', 17
                        if not arg1 * _taxFee / 10000:
                            revert with 'NH{q', 18
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _liquidityFee / 10000:
                            _4133 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4133] = 30
                            mem[_4133 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                                _4289 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_4289 + idx + 68] = mem[_4133 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4289 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _4289 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                revert with 'NH{q', 17
                            _5383 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5383] = 30
                            mem[_5383 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                                _5677 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_5677 + idx + 68] = mem[_5383 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5677 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _5677 + -mem[64] + 100
                            if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                                revert with 'NH{q', 17
                            _7107 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_7107] = 30
                            mem[_7107 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                                if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                                    revert with 'NH{q', 17
                                return (arg1 * stor12 / totalSupply)
                            _7455 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_7455 + idx + 68] = mem[_7107 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_7455 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _7455 + -mem[64] + 100
                        if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                            revert with 'NH{q', 17
                        if not arg1 * _liquidityFee / 10000:
                            revert with 'NH{q', 18
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _5839 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5839] = 30
                        mem[_5839 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                            _6095 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_6095 + idx + 68] = mem[_5839 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_6095 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _6095 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            revert with 'NH{q', 17
                        _7660 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_7660] = 30
                        mem[_7660 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                            _7991 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_7991 + idx + 68] = mem[_7660 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_7991 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _7991 + -mem[64] + 100
                        if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                            revert with 'NH{q', 17
                        _9314 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9314] = 30
                        mem[_9314 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                            if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                                revert with 'NH{q', 17
                            return (arg1 * stor12 / totalSupply)
                        _9557 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_9557 + idx + 68] = mem[_9314 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_9557 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _9557 + -mem[64] + 100
                    if idx >= stor9.length:
                        revert with 'NH{q', 50
                    mem[0] = stor9[idx]
                    mem[32] = 4
                    if stor4[stor9[idx]] <= s:
                        if idx >= stor9.length:
                            revert with 'NH{q', 50
                        mem[0] = stor9[idx]
                        mem[32] = 3
                        _2383 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2383] = 30
                        mem[_2383 + 32] = 'SafeMath: subtraction overflow'
                        if stor3[stor9[idx]] > t:
                            _2452 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_2452 + idx + 68] = mem[_2383 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2452 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _2452 + -mem[64] + 100
                        if t < stor3[stor9[idx]]:
                            revert with 'NH{q', 17
                        if idx >= stor9.length:
                            revert with 'NH{q', 50
                        mem[0] = stor9[idx]
                        mem[32] = 4
                        _2724 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2724] = 30
                        mem[_2724 + 32] = 'SafeMath: subtraction overflow'
                        if stor4[stor9[idx]] <= s:
                            if s < stor4[stor9[idx]]:
                                revert with 'NH{q', 17
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            s = s - stor4[stor9[idx]]
                            t = t - stor3[stor9[idx]]
                            continue 
                        _2772 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_2772 + idx + 68] = mem[_2724 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2772 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _2772 + -mem[64] + 100
                    _2430 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2430] = 26
                    mem[_2430 + 32] = 'SafeMath: division by zero'
                    if totalSupply <= 0:
                        _2468 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2468 + idx + 68] = mem[_2430 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2468 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2468 + -mem[64] + 100
                    if not totalSupply:
                        revert with 'NH{q', 18
                    if not arg1:
                        if not arg1 * _taxFee / 10000:
                            if not arg1 * _liquidityFee / 10000:
                                return 0
                            if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                                revert with 'NH{q', 17
                            if not arg1 * _liquidityFee / 10000:
                                revert with 'NH{q', 18
                            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _3397 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3397] = 30
                            mem[_3397 + 32] = 'SafeMath: subtraction overflow'
                            _4032 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4032] = 30
                            mem[_4032 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > 0:
                                _4198 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_4198 + idx + 68] = mem[_4032 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4198 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _4198 + -mem[64] + 100
                            if 0 < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                revert with 'NH{q', 17
                            _5188 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5188] = 30
                            mem[_5188 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                if -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                else:
                                    return 0
                            _5531 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_5531 + idx + 68] = mem[_5188 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5531 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5531 + -mem[64] + 100
                        if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                            revert with 'NH{q', 17
                        if not arg1 * _taxFee / 10000:
                            revert with 'NH{q', 18
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _liquidityFee / 10000:
                            _3396 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3396] = 30
                            mem[_3396 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                                _3496 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_3496 + idx + 68] = mem[_3396 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3496 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _3496 + -mem[64] + 100
                            if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                revert with 'NH{q', 17
                            _4031 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4031] = 30
                            mem[_4031 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                _4197 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_4197 + idx + 68] = mem[_4031 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4197 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _4197 + -mem[64] + 100
                            if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _5187 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5187] = 30
                            mem[_5187 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                else:
                                    return 0
                            _5530 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_5530 + idx + 68] = mem[_5187 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5530 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5530 + -mem[64] + 100
                        if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                            revert with 'NH{q', 17
                        if not arg1 * _liquidityFee / 10000:
                            revert with 'NH{q', 18
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _4299 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4299] = 30
                        mem[_4299 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                            _4473 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_4473 + idx + 68] = mem[_4299 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_4473 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _4473 + -mem[64] + 100
                        if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            revert with 'NH{q', 17
                        _5689 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5689] = 30
                        mem[_5689 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            _5965 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_5965 + idx + 68] = mem[_5689 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5965 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5965 + -mem[64] + 100
                        if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                            revert with 'NH{q', 17
                        _7463 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_7463] = 30
                        mem[_7463 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                            if (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                                revert with 'NH{q', 17
                            else:
                                return 0
                        _7828 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_7828 + idx + 68] = mem[_7463 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_7828 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _7828 + -mem[64] + 100
                    if arg1 and stor12 / totalSupply > -1 / arg1:
                        revert with 'NH{q', 17
                    if not arg1:
                        revert with 'NH{q', 18
                    if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _taxFee / 10000:
                        if not arg1 * _liquidityFee / 10000:
                            _3395 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3395] = 30
                            mem[_3395 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor12 / totalSupply:
                                _3495 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_3495 + idx + 68] = mem[_3395 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3495 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _3495 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _4030 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4030] = 30
                            mem[_4030 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor12 / totalSupply:
                                _4196 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_4196 + idx + 68] = mem[_4030 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4196 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _4196 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _5186 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5186] = 30
                            mem[_5186 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor12 / totalSupply:
                                if arg1 * stor12 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                return (arg1 * stor12 / totalSupply)
                            _5528 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_5528 + idx + 68] = mem[_5186 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5528 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5528 + -mem[64] + 100
                        if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                            revert with 'NH{q', 17
                        if not arg1 * _liquidityFee / 10000:
                            revert with 'NH{q', 18
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _4298 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4298] = 30
                        mem[_4298 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _4470 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_4470 + idx + 68] = mem[_4298 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_4470 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _4470 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _5688 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5688] = 30
                        mem[_5688 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                            _5962 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_5962 + idx + 68] = mem[_5688 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5962 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5962 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                            revert with 'NH{q', 17
                        _7462 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_7462] = 30
                        mem[_7462 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                            if (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                                revert with 'NH{q', 17
                            return (arg1 * stor12 / totalSupply)
                        _7826 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_7826 + idx + 68] = mem[_7462 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_7826 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _7826 + -mem[64] + 100
                    if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                        revert with 'NH{q', 17
                    if not arg1 * _taxFee / 10000:
                        revert with 'NH{q', 18
                    if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _liquidityFee / 10000:
                        _4297 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4297] = 30
                        mem[_4297 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                            _4469 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_4469 + idx + 68] = mem[_4297 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_4469 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _4469 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            revert with 'NH{q', 17
                        _5687 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5687] = 30
                        mem[_5687 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                            _5961 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_5961 + idx + 68] = mem[_5687 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5961 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5961 + -mem[64] + 100
                        if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                            revert with 'NH{q', 17
                        _7461 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_7461] = 30
                        mem[_7461 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                            if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                                revert with 'NH{q', 17
                            return (arg1 * stor12 / totalSupply)
                        _7825 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_7825 + idx + 68] = mem[_7461 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_7825 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _7825 + -mem[64] + 100
                    if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                        revert with 'NH{q', 17
                    if not arg1 * _liquidityFee / 10000:
                        revert with 'NH{q', 18
                    if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _6102 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6102] = 30
                    mem[_6102 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                        _6387 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_6387 + idx + 68] = mem[_6102 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_6387 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _6387 + -mem[64] + 100
                    if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                        revert with 'NH{q', 17
                    _8001 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_8001] = 30
                    mem[_8001 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                        _8302 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_8302 + idx + 68] = mem[_8001 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_8302 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _8302 + -mem[64] + 100
                    if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                        revert with 'NH{q', 17
                    _9561 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9561] = 30
                    mem[_9561 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                        if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                            revert with 'NH{q', 17
                        return (arg1 * stor12 / totalSupply)
                    _9734 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_9734 + idx + 68] = mem[_9561 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_9734 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _9734 + -mem[64] + 100
                if totalSupply <= 0:
                    revert with 0, 'SafeMath: division by zero', 0
                if not totalSupply:
                    revert with 'NH{q', 18
                if t >= stor12 / totalSupply:
                    if s <= 0:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not s:
                        revert with 'NH{q', 18
                    if not arg1:
                        if not arg1 * _taxFee / 10000:
                            if arg1 * _liquidityFee / 10000:
                                if arg1 * _liquidityFee / 10000 and t / s > -1 / arg1 * _liquidityFee / 10000:
                                    revert with 'NH{q', 17
                                if not arg1 * _liquidityFee / 10000:
                                    revert with 'NH{q', 18
                                if arg1 * _liquidityFee / 10000 * t / s / arg1 * _liquidityFee / 10000 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _liquidityFee / 10000 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _liquidityFee / 10000 * t / s:
                                    revert with 'NH{q', 17
                                if 0 > -1 * arg1 * _liquidityFee / 10000 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _liquidityFee / 10000 * t / s < 0:
                                    revert with 'NH{q', 17
                        else:
                            if arg1 * _taxFee / 10000 and t / s > -1 / arg1 * _taxFee / 10000:
                                revert with 'NH{q', 17
                            if not arg1 * _taxFee / 10000:
                                revert with 'NH{q', 18
                            if arg1 * _taxFee / 10000 * t / s / arg1 * _taxFee / 10000 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _liquidityFee / 10000:
                                if arg1 * _taxFee / 10000 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _taxFee / 10000 * t / s:
                                    revert with 'NH{q', 17
                                if 0 > -1 * arg1 * _taxFee / 10000 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _taxFee / 10000 * t / s < 0:
                                    revert with 'NH{q', 17
                                if 0 > -1 * arg1 * _taxFee / 10000 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _taxFee / 10000 * t / s < 0:
                                    revert with 'NH{q', 17
                            else:
                                if arg1 * _liquidityFee / 10000 and t / s > -1 / arg1 * _liquidityFee / 10000:
                                    revert with 'NH{q', 17
                                if not arg1 * _liquidityFee / 10000:
                                    revert with 'NH{q', 18
                                if arg1 * _liquidityFee / 10000 * t / s / arg1 * _liquidityFee / 10000 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _taxFee / 10000 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _taxFee / 10000 * t / s:
                                    revert with 'NH{q', 17
                                if arg1 * _liquidityFee / 10000 * t / s > -1 * arg1 * _taxFee / 10000 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _taxFee / 10000 * t / s < arg1 * _liquidityFee / 10000 * t / s:
                                    revert with 'NH{q', 17
                                if 0 > (-1 * arg1 * _taxFee / 10000 * t / s) - (arg1 * _liquidityFee / 10000 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (-1 * arg1 * _taxFee / 10000 * t / s) - (arg1 * _liquidityFee / 10000 * t / s) < 0:
                                    revert with 'NH{q', 17
                        return 0
                    if arg1 and t / s > -1 / arg1:
                        revert with 'NH{q', 17
                    if not arg1:
                        revert with 'NH{q', 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _taxFee / 10000:
                        if not arg1 * _liquidityFee / 10000:
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 'NH{q', 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 'NH{q', 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 'NH{q', 17
                        else:
                            if arg1 * _liquidityFee / 10000 and t / s > -1 / arg1 * _liquidityFee / 10000:
                                revert with 'NH{q', 17
                            if not arg1 * _liquidityFee / 10000:
                                revert with 'NH{q', 18
                            if arg1 * _liquidityFee / 10000 * t / s / arg1 * _liquidityFee / 10000 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 'NH{q', 17
                            if arg1 * _liquidityFee / 10000 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < arg1 * _liquidityFee / 10000 * t / s:
                                revert with 'NH{q', 17
                            if 0 > (arg1 * t / s) - (arg1 * _liquidityFee / 10000 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (arg1 * _liquidityFee / 10000 * t / s) < 0:
                                revert with 'NH{q', 17
                    else:
                        if arg1 * _taxFee / 10000 and t / s > -1 / arg1 * _taxFee / 10000:
                            revert with 'NH{q', 17
                        if not arg1 * _taxFee / 10000:
                            revert with 'NH{q', 18
                        if arg1 * _taxFee / 10000 * t / s / arg1 * _taxFee / 10000 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _liquidityFee / 10000:
                            if arg1 * _taxFee / 10000 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < arg1 * _taxFee / 10000 * t / s:
                                revert with 'NH{q', 17
                            if 0 > (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) < 0:
                                revert with 'NH{q', 17
                            if 0 > (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) < 0:
                                revert with 'NH{q', 17
                        else:
                            if arg1 * _liquidityFee / 10000 and t / s > -1 / arg1 * _liquidityFee / 10000:
                                revert with 'NH{q', 17
                            if not arg1 * _liquidityFee / 10000:
                                revert with 'NH{q', 18
                            if arg1 * _liquidityFee / 10000 * t / s / arg1 * _liquidityFee / 10000 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * _taxFee / 10000 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < arg1 * _taxFee / 10000 * t / s:
                                revert with 'NH{q', 17
                            if arg1 * _liquidityFee / 10000 * t / s > (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) < arg1 * _liquidityFee / 10000 * t / s:
                                revert with 'NH{q', 17
                            if 0 > (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) - (arg1 * _liquidityFee / 10000 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) - (arg1 * _liquidityFee / 10000 * t / s) < 0:
                                revert with 'NH{q', 17
                    return (arg1 * t / s)
                if totalSupply <= 0:
                    revert with 0, 'SafeMath: division by zero', 0
                if not totalSupply:
                    revert with 'NH{q', 18
                if not arg1:
                    if not arg1 * _taxFee / 10000:
                        if arg1 * _liquidityFee / 10000:
                            if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                                revert with 'NH{q', 17
                            if not arg1 * _liquidityFee / 10000:
                                revert with 'NH{q', 18
                            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                revert with 'NH{q', 17
                            if 0 > -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply < 0:
                                revert with 'NH{q', 17
                    else:
                        if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                            revert with 'NH{q', 17
                        if not arg1 * _taxFee / 10000:
                            revert with 'NH{q', 18
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _liquidityFee / 10000:
                            if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                revert with 'NH{q', 17
                            if 0 > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                                revert with 'NH{q', 17
                            if 0 > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                                revert with 'NH{q', 17
                        else:
                            if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                                revert with 'NH{q', 17
                            if not arg1 * _liquidityFee / 10000:
                                revert with 'NH{q', 18
                            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                revert with 'NH{q', 17
                            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                revert with 'NH{q', 17
                            if 0 > (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                                revert with 'NH{q', 17
                    return 0
                if arg1 and stor12 / totalSupply > -1 / arg1:
                    revert with 'NH{q', 17
                if not arg1:
                    revert with 'NH{q', 18
                if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _taxFee / 10000:
                    if not arg1 * _liquidityFee / 10000:
                        if 0 > arg1 * stor12 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 'NH{q', 17
                        if 0 > arg1 * stor12 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 'NH{q', 17
                        if 0 > arg1 * stor12 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 'NH{q', 17
                    else:
                        if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                            revert with 'NH{q', 17
                        if not arg1 * _liquidityFee / 10000:
                            revert with 'NH{q', 18
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 'NH{q', 17
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                            revert with 'NH{q', 17
                        if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                            revert with 'NH{q', 17
                else:
                    if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                        revert with 'NH{q', 17
                    if not arg1 * _taxFee / 10000:
                        revert with 'NH{q', 18
                    if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _liquidityFee / 10000:
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            revert with 'NH{q', 17
                        if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                            revert with 'NH{q', 17
                        if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                            revert with 'NH{q', 17
                    else:
                        if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                            revert with 'NH{q', 17
                        if not arg1 * _liquidityFee / 10000:
                            revert with 'NH{q', 18
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            revert with 'NH{q', 17
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                            revert with 'NH{q', 17
                        if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                            revert with 'NH{q', 17
            else:
                if arg1 and _burnFee > -1 / arg1:
                    revert with 'NH{q', 17
                if not arg1:
                    revert with 'NH{q', 18
                if arg1 * _burnFee / arg1 != _burnFee:
                    revert with 0, 'SafeMath: multiplication overflow'
                mem[224] = 26
                mem[256] = 'SafeMath: division by zero'
                mem[288] = 30
                mem[320] = 'SafeMath: subtraction overflow'
                if arg1 * _taxFee / 10000 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < arg1 * _taxFee / 10000:
                    revert with 'NH{q', 17
                mem[352] = 30
                mem[384] = 'SafeMath: subtraction overflow'
                if arg1 * _liquidityFee / 10000 > arg1 - (arg1 * _taxFee / 10000):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * _taxFee / 10000) < arg1 * _liquidityFee / 10000:
                    revert with 'NH{q', 17
                mem[64] = 480
                mem[416] = 30
                mem[448] = 'SafeMath: subtraction overflow'
                if arg1 * _burnFee / 10000 > arg1 - (arg1 * _taxFee / 10000) - (arg1 * _liquidityFee / 10000):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * _taxFee / 10000) - (arg1 * _liquidityFee / 10000) < arg1 * _burnFee / 10000:
                    revert with 'NH{q', 17
                idx = 0
                s = totalSupply
                t = stor12
                while idx < stor9.length:
                    mem[0] = stor9[idx]
                    mem[32] = 3
                    if stor3[stor9[idx]] > t:
                        _2292 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2292] = 26
                        mem[_2292 + 32] = 'SafeMath: division by zero'
                        if totalSupply <= 0:
                            _2427 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2427 + idx + 68] = mem[_2292 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2427 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2427 + -mem[64] + 100
                        if not totalSupply:
                            revert with 'NH{q', 18
                        if not arg1:
                            if not arg1 * _taxFee / 10000:
                                if not arg1 * _liquidityFee / 10000:
                                    if not arg1 * _burnFee / 10000:
                                        return 0
                                    if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                                        revert with 'NH{q', 17
                                    if not arg1 * _burnFee / 10000:
                                        revert with 'NH{q', 18
                                    if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _3330 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3330] = 30
                                    mem[_3330 + 32] = 'SafeMath: subtraction overflow'
                                    _3886 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3886] = 30
                                    mem[_3886 + 32] = 'SafeMath: subtraction overflow'
                                    _4924 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4924] = 30
                                    mem[_4924 + 32] = 'SafeMath: subtraction overflow'
                                    if arg1 * _burnFee / 10000 * stor12 / totalSupply <= 0:
                                        if 0 < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                                            revert with 'NH{q', 17
                                        else:
                                            return 0
                                    _5171 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_5171 + idx + 68] = mem[_4924 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_5171 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _5171 + -mem[64] + 100
                                if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                                    revert with 'NH{q', 17
                                if not arg1 * _liquidityFee / 10000:
                                    revert with 'NH{q', 18
                                if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not arg1 * _burnFee / 10000:
                                    _3329 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3329] = 30
                                    mem[_3329 + 32] = 'SafeMath: subtraction overflow'
                                    _3885 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3885] = 30
                                    mem[_3885 + 32] = 'SafeMath: subtraction overflow'
                                    if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > 0:
                                        _4015 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_4015 + idx + 68] = mem[_3885 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_4015 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _4015 + -mem[64] + 100
                                    if 0 < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                        revert with 'NH{q', 17
                                    _4923 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4923] = 30
                                    mem[_4923 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                        if -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply < 0:
                                            revert with 'NH{q', 17
                                        else:
                                            return 0
                                    _5170 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_5170 + idx + 68] = mem[_4923 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_5170 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _5170 + -mem[64] + 100
                                if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                                    revert with 'NH{q', 17
                                if not arg1 * _burnFee / 10000:
                                    revert with 'NH{q', 18
                                if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _4128 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4128] = 30
                                mem[_4128 + 32] = 'SafeMath: subtraction overflow'
                                _5366 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5366] = 30
                                mem[_5366 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > 0:
                                    _5663 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_5663 + idx + 68] = mem[_5366 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_5663 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _5663 + -mem[64] + 100
                                if 0 < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                    revert with 'NH{q', 17
                                _7086 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_7086] = 30
                                mem[_7086 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _burnFee / 10000 * stor12 / totalSupply <= -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                    if -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                                        revert with 'NH{q', 17
                                    else:
                                        return 0
                                _7443 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_7443 + idx + 68] = mem[_7086 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_7443 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _7443 + -mem[64] + 100
                            if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                                revert with 'NH{q', 17
                            if not arg1 * _taxFee / 10000:
                                revert with 'NH{q', 18
                            if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _liquidityFee / 10000:
                                if not arg1 * _burnFee / 10000:
                                    _3328 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3328] = 30
                                    mem[_3328 + 32] = 'SafeMath: subtraction overflow'
                                    if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                                        _3388 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_3388 + idx + 68] = mem[_3328 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_3388 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _3388 + -mem[64] + 100
                                    if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                        revert with 'NH{q', 17
                                    _3883 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3883] = 30
                                    mem[_3883 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                        _4014 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_4014 + idx + 68] = mem[_3883 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_4014 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _4014 + -mem[64] + 100
                                    if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                                        revert with 'NH{q', 17
                                    _4922 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4922] = 30
                                    mem[_4922 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                        if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                                            revert with 'NH{q', 17
                                        else:
                                            return 0
                                    _5169 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_5169 + idx + 68] = mem[_4922 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_5169 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _5169 + -mem[64] + 100
                                if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                                    revert with 'NH{q', 17
                                if not arg1 * _burnFee / 10000:
                                    revert with 'NH{q', 18
                                if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _4127 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4127] = 30
                                mem[_4127 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                                    _4279 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_4279 + idx + 68] = mem[_4127 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4279 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4279 + -mem[64] + 100
                                if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                    revert with 'NH{q', 17
                                _5365 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5365] = 30
                                mem[_5365 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                    _5660 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_5660 + idx + 68] = mem[_5365 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_5660 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _5660 + -mem[64] + 100
                                if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                _7085 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_7085] = 30
                                mem[_7085 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _burnFee / 10000 * stor12 / totalSupply <= -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                    if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                                        revert with 'NH{q', 17
                                    else:
                                        return 0
                                _7441 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_7441 + idx + 68] = mem[_7085 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_7441 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _7441 + -mem[64] + 100
                            if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                                revert with 'NH{q', 17
                            if not arg1 * _liquidityFee / 10000:
                                revert with 'NH{q', 18
                            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _burnFee / 10000:
                                _4126 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4126] = 30
                                mem[_4126 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                                    _4278 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_4278 + idx + 68] = mem[_4126 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4278 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4278 + -mem[64] + 100
                                if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                    revert with 'NH{q', 17
                                _5364 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5364] = 30
                                mem[_5364 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                    _5659 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_5659 + idx + 68] = mem[_5364 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_5659 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _5659 + -mem[64] + 100
                                if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                    revert with 'NH{q', 17
                                _7084 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_7084] = 30
                                mem[_7084 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                                    if (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                                        revert with 'NH{q', 17
                                    else:
                                        return 0
                                _7440 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_7440 + idx + 68] = mem[_7084 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_7440 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _7440 + -mem[64] + 100
                            if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                                revert with 'NH{q', 17
                            if not arg1 * _burnFee / 10000:
                                revert with 'NH{q', 18
                            if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _5830 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5830] = 30
                            mem[_5830 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                                _6082 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_6082 + idx + 68] = mem[_5830 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_6082 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _6082 + -mem[64] + 100
                            if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                revert with 'NH{q', 17
                            _7642 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_7642] = 30
                            mem[_7642 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                _7972 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_7972 + idx + 68] = mem[_7642 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_7972 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _7972 + -mem[64] + 100
                            if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                revert with 'NH{q', 17
                            _9293 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_9293] = 30
                            mem[_9293 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _burnFee / 10000 * stor12 / totalSupply <= (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                                if (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                                    revert with 'NH{q', 17
                                else:
                                    return 0
                            _9549 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_9549 + idx + 68] = mem[_9293 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_9549 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _9549 + -mem[64] + 100
                        if arg1 and stor12 / totalSupply > -1 / arg1:
                            revert with 'NH{q', 17
                        if not arg1:
                            revert with 'NH{q', 18
                        if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _taxFee / 10000:
                            if not arg1 * _liquidityFee / 10000:
                                if not arg1 * _burnFee / 10000:
                                    _3327 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3327] = 30
                                    mem[_3327 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg1 * stor12 / totalSupply:
                                        _3387 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_3387 + idx + 68] = mem[_3327 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_3387 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _3387 + -mem[64] + 100
                                    if arg1 * stor12 / totalSupply < 0:
                                        revert with 'NH{q', 17
                                    _3881 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3881] = 30
                                    mem[_3881 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg1 * stor12 / totalSupply:
                                        _4013 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_4013 + idx + 68] = mem[_3881 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_4013 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _4013 + -mem[64] + 100
                                    if arg1 * stor12 / totalSupply < 0:
                                        revert with 'NH{q', 17
                                    _4921 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4921] = 30
                                    mem[_4921 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= arg1 * stor12 / totalSupply:
                                        if arg1 * stor12 / totalSupply < 0:
                                            revert with 'NH{q', 17
                                        return (arg1 * stor12 / totalSupply)
                                    _5166 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_5166 + idx + 68] = mem[_4921 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_5166 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _5166 + -mem[64] + 100
                                if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                                    revert with 'NH{q', 17
                                if not arg1 * _burnFee / 10000:
                                    revert with 'NH{q', 18
                                if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _4125 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4125] = 30
                                mem[_4125 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor12 / totalSupply:
                                    _4275 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_4275 + idx + 68] = mem[_4125 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4275 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4275 + -mem[64] + 100
                                if arg1 * stor12 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                _5362 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5362] = 30
                                mem[_5362 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor12 / totalSupply:
                                    _5656 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_5656 + idx + 68] = mem[_5362 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_5656 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _5656 + -mem[64] + 100
                                if arg1 * stor12 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                _7083 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_7083] = 30
                                mem[_7083 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _burnFee / 10000 * stor12 / totalSupply <= arg1 * stor12 / totalSupply:
                                    if arg1 * stor12 / totalSupply < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                                        revert with 'NH{q', 17
                                    return (arg1 * stor12 / totalSupply)
                                _7437 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_7437 + idx + 68] = mem[_7083 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_7437 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _7437 + -mem[64] + 100
                            if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                                revert with 'NH{q', 17
                            if not arg1 * _liquidityFee / 10000:
                                revert with 'NH{q', 18
                            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _burnFee / 10000:
                                _4124 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4124] = 30
                                mem[_4124 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor12 / totalSupply:
                                    _4274 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_4274 + idx + 68] = mem[_4124 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4274 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4274 + -mem[64] + 100
                                if arg1 * stor12 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                _5361 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5361] = 30
                                mem[_5361 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                                    _5655 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_5655 + idx + 68] = mem[_5361 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_5655 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _5655 + -mem[64] + 100
                                if arg1 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                    revert with 'NH{q', 17
                                _7082 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_7082] = 30
                                mem[_7082 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                                    if (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                                        revert with 'NH{q', 17
                                    return (arg1 * stor12 / totalSupply)
                                _7436 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_7436 + idx + 68] = mem[_7082 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_7436 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _7436 + -mem[64] + 100
                            if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                                revert with 'NH{q', 17
                            if not arg1 * _burnFee / 10000:
                                revert with 'NH{q', 18
                            if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _5828 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5828] = 30
                            mem[_5828 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor12 / totalSupply:
                                _6077 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_6077 + idx + 68] = mem[_5828 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_6077 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _6077 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _7640 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_7640] = 30
                            mem[_7640 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                                _7966 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_7966 + idx + 68] = mem[_7640 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_7966 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _7966 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                revert with 'NH{q', 17
                            _9292 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_9292] = 30
                            mem[_9292 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _burnFee / 10000 * stor12 / totalSupply <= (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                                if (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                                    revert with 'NH{q', 17
                                return (arg1 * stor12 / totalSupply)
                            _9546 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_9546 + idx + 68] = mem[_9292 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_9546 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _9546 + -mem[64] + 100
                        if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                            revert with 'NH{q', 17
                        if not arg1 * _taxFee / 10000:
                            revert with 'NH{q', 18
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _liquidityFee / 10000:
                            if not arg1 * _burnFee / 10000:
                                _4123 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4123] = 30
                                mem[_4123 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                                    _4273 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_4273 + idx + 68] = mem[_4123 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4273 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4273 + -mem[64] + 100
                                if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                    revert with 'NH{q', 17
                                _5359 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5359] = 30
                                mem[_5359 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                                    _5654 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_5654 + idx + 68] = mem[_5359 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_5654 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _5654 + -mem[64] + 100
                                if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                                    revert with 'NH{q', 17
                                _7081 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_7081] = 30
                                mem[_7081 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                                    if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                                        revert with 'NH{q', 17
                                    return (arg1 * stor12 / totalSupply)
                                _7434 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_7434 + idx + 68] = mem[_7081 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_7434 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _7434 + -mem[64] + 100
                            if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                                revert with 'NH{q', 17
                            if not arg1 * _burnFee / 10000:
                                revert with 'NH{q', 18
                            if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _5827 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5827] = 30
                            mem[_5827 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                                _6074 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_6074 + idx + 68] = mem[_5827 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_6074 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _6074 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                revert with 'NH{q', 17
                            _7639 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_7639] = 30
                            mem[_7639 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                                _7963 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_7963 + idx + 68] = mem[_7639 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_7963 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _7963 + -mem[64] + 100
                            if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                                revert with 'NH{q', 17
                            _9291 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_9291] = 30
                            mem[_9291 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _burnFee / 10000 * stor12 / totalSupply <= (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                                if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                                    revert with 'NH{q', 17
                                return (arg1 * stor12 / totalSupply)
                            _9544 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_9544 + idx + 68] = mem[_9291 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_9544 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _9544 + -mem[64] + 100
                        if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                            revert with 'NH{q', 17
                        if not arg1 * _liquidityFee / 10000:
                            revert with 'NH{q', 18
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _burnFee / 10000:
                            _5826 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5826] = 30
                            mem[_5826 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                                _6073 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_6073 + idx + 68] = mem[_5826 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_6073 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _6073 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                revert with 'NH{q', 17
                            _7638 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_7638] = 30
                            mem[_7638 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                                _7962 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_7962 + idx + 68] = mem[_7638 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_7962 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _7962 + -mem[64] + 100
                            if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                revert with 'NH{q', 17
                            _9290 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_9290] = 30
                            mem[_9290 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                                if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                                    revert with 'NH{q', 17
                                return (arg1 * stor12 / totalSupply)
                            _9543 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_9543 + idx + 68] = mem[_9290 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_9543 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _9543 + -mem[64] + 100
                        if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                            revert with 'NH{q', 17
                        if not arg1 * _burnFee / 10000:
                            revert with 'NH{q', 18
                        if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _8158 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_8158] = 30
                        mem[_8158 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                            _8379 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_8379 + idx + 68] = mem[_8158 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_8379 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _8379 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            revert with 'NH{q', 17
                        _9642 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9642] = 30
                        mem[_9642 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                            _9805 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_9805 + idx + 68] = mem[_9642 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_9805 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _9805 + -mem[64] + 100
                        if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                            revert with 'NH{q', 17
                        _10492 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10492] = 30
                        mem[_10492 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _burnFee / 10000 * stor12 / totalSupply <= (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                            if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                                revert with 'NH{q', 17
                            return (arg1 * stor12 / totalSupply)
                        _10582 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_10582 + idx + 68] = mem[_10492 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_10582 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _10582 + -mem[64] + 100
                    if idx >= stor9.length:
                        revert with 'NH{q', 50
                    mem[0] = stor9[idx]
                    mem[32] = 4
                    if stor4[stor9[idx]] <= s:
                        if idx >= stor9.length:
                            revert with 'NH{q', 50
                        mem[0] = stor9[idx]
                        mem[32] = 3
                        _2379 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2379] = 30
                        mem[_2379 + 32] = 'SafeMath: subtraction overflow'
                        if stor3[stor9[idx]] > t:
                            _2451 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_2451 + idx + 68] = mem[_2379 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2451 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _2451 + -mem[64] + 100
                        if t < stor3[stor9[idx]]:
                            revert with 'NH{q', 17
                        if idx >= stor9.length:
                            revert with 'NH{q', 50
                        mem[0] = stor9[idx]
                        mem[32] = 4
                        _2723 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2723] = 30
                        mem[_2723 + 32] = 'SafeMath: subtraction overflow'
                        if stor4[stor9[idx]] <= s:
                            if s < stor4[stor9[idx]]:
                                revert with 'NH{q', 17
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            s = s - stor4[stor9[idx]]
                            t = t - stor3[stor9[idx]]
                            continue 
                        _2771 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_2771 + idx + 68] = mem[_2723 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2771 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _2771 + -mem[64] + 100
                    _2428 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2428] = 26
                    mem[_2428 + 32] = 'SafeMath: division by zero'
                    if totalSupply <= 0:
                        _2467 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2467 + idx + 68] = mem[_2428 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2467 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2467 + -mem[64] + 100
                    if not totalSupply:
                        revert with 'NH{q', 18
                    if not arg1:
                        if not arg1 * _taxFee / 10000:
                            if not arg1 * _liquidityFee / 10000:
                                if not arg1 * _burnFee / 10000:
                                    return 0
                                if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                                    revert with 'NH{q', 17
                                if not arg1 * _burnFee / 10000:
                                    revert with 'NH{q', 18
                                if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _3392 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3392] = 30
                                mem[_3392 + 32] = 'SafeMath: subtraction overflow'
                                _4023 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4023] = 30
                                mem[_4023 + 32] = 'SafeMath: subtraction overflow'
                                _5175 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5175] = 30
                                mem[_5175 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _burnFee / 10000 * stor12 / totalSupply <= 0:
                                    if 0 < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                                        revert with 'NH{q', 17
                                    else:
                                        return 0
                                _5521 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_5521 + idx + 68] = mem[_5175 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5521 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _5521 + -mem[64] + 100
                            if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                                revert with 'NH{q', 17
                            if not arg1 * _liquidityFee / 10000:
                                revert with 'NH{q', 18
                            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _burnFee / 10000:
                                _3391 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3391] = 30
                                mem[_3391 + 32] = 'SafeMath: subtraction overflow'
                                _4022 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4022] = 30
                                mem[_4022 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > 0:
                                    _4193 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_4193 + idx + 68] = mem[_4022 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4193 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4193 + -mem[64] + 100
                                if 0 < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                    revert with 'NH{q', 17
                                _5174 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5174] = 30
                                mem[_5174 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                    if -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply < 0:
                                        revert with 'NH{q', 17
                                    else:
                                        return 0
                                _5520 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_5520 + idx + 68] = mem[_5174 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5520 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _5520 + -mem[64] + 100
                            if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                                revert with 'NH{q', 17
                            if not arg1 * _burnFee / 10000:
                                revert with 'NH{q', 18
                            if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _4288 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4288] = 30
                            mem[_4288 + 32] = 'SafeMath: subtraction overflow'
                            _5676 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5676] = 30
                            mem[_5676 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > 0:
                                _5955 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_5955 + idx + 68] = mem[_5676 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5955 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _5955 + -mem[64] + 100
                            if 0 < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                revert with 'NH{q', 17
                            _7451 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_7451] = 30
                            mem[_7451 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _burnFee / 10000 * stor12 / totalSupply <= -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                if -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                                    revert with 'NH{q', 17
                                else:
                                    return 0
                            _7815 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_7815 + idx + 68] = mem[_7451 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_7815 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _7815 + -mem[64] + 100
                        if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                            revert with 'NH{q', 17
                        if not arg1 * _taxFee / 10000:
                            revert with 'NH{q', 18
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _liquidityFee / 10000:
                            if not arg1 * _burnFee / 10000:
                                _3390 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3390] = 30
                                mem[_3390 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                                    _3493 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_3493 + idx + 68] = mem[_3390 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_3493 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _3493 + -mem[64] + 100
                                if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                    revert with 'NH{q', 17
                                _4020 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4020] = 30
                                mem[_4020 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                    _4192 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_4192 + idx + 68] = mem[_4020 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4192 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4192 + -mem[64] + 100
                                if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                _5173 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5173] = 30
                                mem[_5173 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                    if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                                        revert with 'NH{q', 17
                                    else:
                                        return 0
                                _5519 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_5519 + idx + 68] = mem[_5173 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5519 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _5519 + -mem[64] + 100
                            if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                                revert with 'NH{q', 17
                            if not arg1 * _burnFee / 10000:
                                revert with 'NH{q', 18
                            if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _4287 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4287] = 30
                            mem[_4287 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                                _4463 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_4463 + idx + 68] = mem[_4287 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4463 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _4463 + -mem[64] + 100
                            if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                revert with 'NH{q', 17
                            _5675 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5675] = 30
                            mem[_5675 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                _5952 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_5952 + idx + 68] = mem[_5675 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5952 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _5952 + -mem[64] + 100
                            if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _7450 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_7450] = 30
                            mem[_7450 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _burnFee / 10000 * stor12 / totalSupply <= -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                                    revert with 'NH{q', 17
                                else:
                                    return 0
                            _7813 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_7813 + idx + 68] = mem[_7450 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_7813 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _7813 + -mem[64] + 100
                        if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                            revert with 'NH{q', 17
                        if not arg1 * _liquidityFee / 10000:
                            revert with 'NH{q', 18
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _burnFee / 10000:
                            _4286 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4286] = 30
                            mem[_4286 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                                _4462 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_4462 + idx + 68] = mem[_4286 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4462 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _4462 + -mem[64] + 100
                            if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                revert with 'NH{q', 17
                            _5674 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5674] = 30
                            mem[_5674 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                _5951 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_5951 + idx + 68] = mem[_5674 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5951 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _5951 + -mem[64] + 100
                            if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                revert with 'NH{q', 17
                            _7449 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_7449] = 30
                            mem[_7449 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                                if (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                                    revert with 'NH{q', 17
                                else:
                                    return 0
                            _7812 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_7812 + idx + 68] = mem[_7449 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_7812 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _7812 + -mem[64] + 100
                        if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                            revert with 'NH{q', 17
                        if not arg1 * _burnFee / 10000:
                            revert with 'NH{q', 18
                        if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _6092 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6092] = 30
                        mem[_6092 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                            _6375 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_6375 + idx + 68] = mem[_6092 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_6375 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _6375 + -mem[64] + 100
                        if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            revert with 'NH{q', 17
                        _7987 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_7987] = 30
                        mem[_7987 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            _8292 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_8292 + idx + 68] = mem[_7987 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_8292 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _8292 + -mem[64] + 100
                        if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                            revert with 'NH{q', 17
                        _9556 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9556] = 30
                        mem[_9556 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _burnFee / 10000 * stor12 / totalSupply <= (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                            if (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                                revert with 'NH{q', 17
                            else:
                                return 0
                        _9728 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_9728 + idx + 68] = mem[_9556 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_9728 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _9728 + -mem[64] + 100
                    if arg1 and stor12 / totalSupply > -1 / arg1:
                        revert with 'NH{q', 17
                    if not arg1:
                        revert with 'NH{q', 18
                    if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _taxFee / 10000:
                        if not arg1 * _liquidityFee / 10000:
                            if not arg1 * _burnFee / 10000:
                                _3389 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3389] = 30
                                mem[_3389 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor12 / totalSupply:
                                    _3492 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_3492 + idx + 68] = mem[_3389 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_3492 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _3492 + -mem[64] + 100
                                if arg1 * stor12 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                _4018 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4018] = 30
                                mem[_4018 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor12 / totalSupply:
                                    _4191 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_4191 + idx + 68] = mem[_4018 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4191 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4191 + -mem[64] + 100
                                if arg1 * stor12 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                _5172 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5172] = 30
                                mem[_5172 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor12 / totalSupply:
                                    if arg1 * stor12 / totalSupply < 0:
                                        revert with 'NH{q', 17
                                    return (arg1 * stor12 / totalSupply)
                                _5516 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_5516 + idx + 68] = mem[_5172 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5516 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _5516 + -mem[64] + 100
                            if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                                revert with 'NH{q', 17
                            if not arg1 * _burnFee / 10000:
                                revert with 'NH{q', 18
                            if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _4285 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4285] = 30
                            mem[_4285 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor12 / totalSupply:
                                _4459 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_4459 + idx + 68] = mem[_4285 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4459 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _4459 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _5672 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5672] = 30
                            mem[_5672 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor12 / totalSupply:
                                _5948 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_5948 + idx + 68] = mem[_5672 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5948 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _5948 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _7448 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_7448] = 30
                            mem[_7448 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _burnFee / 10000 * stor12 / totalSupply <= arg1 * stor12 / totalSupply:
                                if arg1 * stor12 / totalSupply < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                                    revert with 'NH{q', 17
                                return (arg1 * stor12 / totalSupply)
                            _7809 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_7809 + idx + 68] = mem[_7448 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_7809 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _7809 + -mem[64] + 100
                        if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                            revert with 'NH{q', 17
                        if not arg1 * _liquidityFee / 10000:
                            revert with 'NH{q', 18
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _burnFee / 10000:
                            _4284 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4284] = 30
                            mem[_4284 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor12 / totalSupply:
                                _4458 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_4458 + idx + 68] = mem[_4284 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4458 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _4458 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _5671 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5671] = 30
                            mem[_5671 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                                _5947 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_5947 + idx + 68] = mem[_5671 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5947 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _5947 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                revert with 'NH{q', 17
                            _7447 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_7447] = 30
                            mem[_7447 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                                if (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                                    revert with 'NH{q', 17
                                return (arg1 * stor12 / totalSupply)
                            _7808 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_7808 + idx + 68] = mem[_7447 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_7808 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _7808 + -mem[64] + 100
                        if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                            revert with 'NH{q', 17
                        if not arg1 * _burnFee / 10000:
                            revert with 'NH{q', 18
                        if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _6090 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6090] = 30
                        mem[_6090 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _6370 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_6370 + idx + 68] = mem[_6090 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_6370 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _6370 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _7985 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_7985] = 30
                        mem[_7985 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                            _8286 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_8286 + idx + 68] = mem[_7985 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_8286 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _8286 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                            revert with 'NH{q', 17
                        _9555 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9555] = 30
                        mem[_9555 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _burnFee / 10000 * stor12 / totalSupply <= (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                            if (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                                revert with 'NH{q', 17
                            return (arg1 * stor12 / totalSupply)
                        _9725 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_9725 + idx + 68] = mem[_9555 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_9725 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _9725 + -mem[64] + 100
                    if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                        revert with 'NH{q', 17
                    if not arg1 * _taxFee / 10000:
                        revert with 'NH{q', 18
                    if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _liquidityFee / 10000:
                        if not arg1 * _burnFee / 10000:
                            _4283 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4283] = 30
                            mem[_4283 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                                _4457 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_4457 + idx + 68] = mem[_4283 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4457 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _4457 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                revert with 'NH{q', 17
                            _5669 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5669] = 30
                            mem[_5669 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                                _5946 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_5946 + idx + 68] = mem[_5669 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5946 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _5946 + -mem[64] + 100
                            if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                                revert with 'NH{q', 17
                            _7446 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_7446] = 30
                            mem[_7446 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                                if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                                    revert with 'NH{q', 17
                                return (arg1 * stor12 / totalSupply)
                            _7806 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_7806 + idx + 68] = mem[_7446 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_7806 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _7806 + -mem[64] + 100
                        if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                            revert with 'NH{q', 17
                        if not arg1 * _burnFee / 10000:
                            revert with 'NH{q', 18
                        if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _6089 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6089] = 30
                        mem[_6089 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                            _6367 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_6367 + idx + 68] = mem[_6089 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_6367 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _6367 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            revert with 'NH{q', 17
                        _7984 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_7984] = 30
                        mem[_7984 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                            _8283 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_8283 + idx + 68] = mem[_7984 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_8283 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _8283 + -mem[64] + 100
                        if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                            revert with 'NH{q', 17
                        _9554 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9554] = 30
                        mem[_9554 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _burnFee / 10000 * stor12 / totalSupply <= (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                            if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                                revert with 'NH{q', 17
                            return (arg1 * stor12 / totalSupply)
                        _9723 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_9723 + idx + 68] = mem[_9554 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_9723 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _9723 + -mem[64] + 100
                    if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                        revert with 'NH{q', 17
                    if not arg1 * _liquidityFee / 10000:
                        revert with 'NH{q', 18
                    if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _burnFee / 10000:
                        _6088 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6088] = 30
                        mem[_6088 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                            _6366 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_6366 + idx + 68] = mem[_6088 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_6366 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _6366 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            revert with 'NH{q', 17
                        _7983 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_7983] = 30
                        mem[_7983 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                            _8282 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_8282 + idx + 68] = mem[_7983 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_8282 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _8282 + -mem[64] + 100
                        if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                            revert with 'NH{q', 17
                        _9553 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9553] = 30
                        mem[_9553 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                            if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                                revert with 'NH{q', 17
                            return (arg1 * stor12 / totalSupply)
                        _9722 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_9722 + idx + 68] = mem[_9553 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_9722 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _9722 + -mem[64] + 100
                    if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                        revert with 'NH{q', 17
                    if not arg1 * _burnFee / 10000:
                        revert with 'NH{q', 18
                    if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _8388 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_8388] = 30
                    mem[_8388 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                        _8642 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_8642 + idx + 68] = mem[_8388 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_8642 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _8642 + -mem[64] + 100
                    if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                        revert with 'NH{q', 17
                    _9820 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9820] = 30
                    mem[_9820 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                        _9984 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_9984 + idx + 68] = mem[_9820 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_9984 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _9984 + -mem[64] + 100
                    if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                        revert with 'NH{q', 17
                    _10587 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_10587] = 30
                    mem[_10587 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _burnFee / 10000 * stor12 / totalSupply <= (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                        if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                            revert with 'NH{q', 17
                        return (arg1 * stor12 / totalSupply)
                    _10625 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_10625 + idx + 68] = mem[_10587 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_10625 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _10625 + -mem[64] + 100
                if totalSupply <= 0:
                    revert with 0, 'SafeMath: division by zero', 0
                if not totalSupply:
                    revert with 'NH{q', 18
                if t >= stor12 / totalSupply:
                    if s <= 0:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not s:
                        revert with 'NH{q', 18
                    if not arg1:
                        if not arg1 * _taxFee / 10000:
                            if not arg1 * _liquidityFee / 10000:
                                if arg1 * _burnFee / 10000:
                                    if arg1 * _burnFee / 10000 and t / s > -1 / arg1 * _burnFee / 10000:
                                        revert with 'NH{q', 17
                                    if not arg1 * _burnFee / 10000:
                                        revert with 'NH{q', 18
                                    if arg1 * _burnFee / 10000 * t / s / arg1 * _burnFee / 10000 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if arg1 * _burnFee / 10000 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _burnFee / 10000 * t / s:
                                        revert with 'NH{q', 17
                            else:
                                if arg1 * _liquidityFee / 10000 and t / s > -1 / arg1 * _liquidityFee / 10000:
                                    revert with 'NH{q', 17
                                if not arg1 * _liquidityFee / 10000:
                                    revert with 'NH{q', 18
                                if arg1 * _liquidityFee / 10000 * t / s / arg1 * _liquidityFee / 10000 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not arg1 * _burnFee / 10000:
                                    if arg1 * _liquidityFee / 10000 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _liquidityFee / 10000 * t / s:
                                        revert with 'NH{q', 17
                                    if 0 > -1 * arg1 * _liquidityFee / 10000 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _liquidityFee / 10000 * t / s < 0:
                                        revert with 'NH{q', 17
                                else:
                                    if arg1 * _burnFee / 10000 and t / s > -1 / arg1 * _burnFee / 10000:
                                        revert with 'NH{q', 17
                                    if not arg1 * _burnFee / 10000:
                                        revert with 'NH{q', 18
                                    if arg1 * _burnFee / 10000 * t / s / arg1 * _burnFee / 10000 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if arg1 * _liquidityFee / 10000 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _liquidityFee / 10000 * t / s:
                                        revert with 'NH{q', 17
                                    if arg1 * _burnFee / 10000 * t / s > -1 * arg1 * _liquidityFee / 10000 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _liquidityFee / 10000 * t / s < arg1 * _burnFee / 10000 * t / s:
                                        revert with 'NH{q', 17
                        else:
                            if arg1 * _taxFee / 10000 and t / s > -1 / arg1 * _taxFee / 10000:
                                revert with 'NH{q', 17
                            if not arg1 * _taxFee / 10000:
                                revert with 'NH{q', 18
                            if arg1 * _taxFee / 10000 * t / s / arg1 * _taxFee / 10000 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _liquidityFee / 10000:
                                if not arg1 * _burnFee / 10000:
                                    if arg1 * _taxFee / 10000 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _taxFee / 10000 * t / s:
                                        revert with 'NH{q', 17
                                    if 0 > -1 * arg1 * _taxFee / 10000 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _taxFee / 10000 * t / s < 0:
                                        revert with 'NH{q', 17
                                    if 0 > -1 * arg1 * _taxFee / 10000 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _taxFee / 10000 * t / s < 0:
                                        revert with 'NH{q', 17
                                else:
                                    if arg1 * _burnFee / 10000 and t / s > -1 / arg1 * _burnFee / 10000:
                                        revert with 'NH{q', 17
                                    if not arg1 * _burnFee / 10000:
                                        revert with 'NH{q', 18
                                    if arg1 * _burnFee / 10000 * t / s / arg1 * _burnFee / 10000 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if arg1 * _taxFee / 10000 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _taxFee / 10000 * t / s:
                                        revert with 'NH{q', 17
                                    if 0 > -1 * arg1 * _taxFee / 10000 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _taxFee / 10000 * t / s < 0:
                                        revert with 'NH{q', 17
                                    if arg1 * _burnFee / 10000 * t / s > -1 * arg1 * _taxFee / 10000 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _taxFee / 10000 * t / s < arg1 * _burnFee / 10000 * t / s:
                                        revert with 'NH{q', 17
                            else:
                                if arg1 * _liquidityFee / 10000 and t / s > -1 / arg1 * _liquidityFee / 10000:
                                    revert with 'NH{q', 17
                                if not arg1 * _liquidityFee / 10000:
                                    revert with 'NH{q', 18
                                if arg1 * _liquidityFee / 10000 * t / s / arg1 * _liquidityFee / 10000 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not arg1 * _burnFee / 10000:
                                    if arg1 * _taxFee / 10000 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _taxFee / 10000 * t / s:
                                        revert with 'NH{q', 17
                                    if arg1 * _liquidityFee / 10000 * t / s > -1 * arg1 * _taxFee / 10000 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _taxFee / 10000 * t / s < arg1 * _liquidityFee / 10000 * t / s:
                                        revert with 'NH{q', 17
                                    if 0 > (-1 * arg1 * _taxFee / 10000 * t / s) - (arg1 * _liquidityFee / 10000 * t / s):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if (-1 * arg1 * _taxFee / 10000 * t / s) - (arg1 * _liquidityFee / 10000 * t / s) < 0:
                                        revert with 'NH{q', 17
                                else:
                                    if arg1 * _burnFee / 10000 and t / s > -1 / arg1 * _burnFee / 10000:
                                        revert with 'NH{q', 17
                                    if not arg1 * _burnFee / 10000:
                                        revert with 'NH{q', 18
                                    if arg1 * _burnFee / 10000 * t / s / arg1 * _burnFee / 10000 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if arg1 * _taxFee / 10000 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _taxFee / 10000 * t / s:
                                        revert with 'NH{q', 17
                                    if arg1 * _liquidityFee / 10000 * t / s > -1 * arg1 * _taxFee / 10000 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _taxFee / 10000 * t / s < arg1 * _liquidityFee / 10000 * t / s:
                                        revert with 'NH{q', 17
                                    if arg1 * _burnFee / 10000 * t / s > (-1 * arg1 * _taxFee / 10000 * t / s) - (arg1 * _liquidityFee / 10000 * t / s):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if (-1 * arg1 * _taxFee / 10000 * t / s) - (arg1 * _liquidityFee / 10000 * t / s) < arg1 * _burnFee / 10000 * t / s:
                                        revert with 'NH{q', 17
                        return 0
                    if arg1 and t / s > -1 / arg1:
                        revert with 'NH{q', 17
                    if not arg1:
                        revert with 'NH{q', 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _taxFee / 10000:
                        if not arg1 * _liquidityFee / 10000:
                            if not arg1 * _burnFee / 10000:
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 'NH{q', 17
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 'NH{q', 17
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 'NH{q', 17
                            else:
                                if arg1 * _burnFee / 10000 and t / s > -1 / arg1 * _burnFee / 10000:
                                    revert with 'NH{q', 17
                                if not arg1 * _burnFee / 10000:
                                    revert with 'NH{q', 18
                                if arg1 * _burnFee / 10000 * t / s / arg1 * _burnFee / 10000 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 'NH{q', 17
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 'NH{q', 17
                                if arg1 * _burnFee / 10000 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _burnFee / 10000 * t / s:
                                    revert with 'NH{q', 17
                        else:
                            if arg1 * _liquidityFee / 10000 and t / s > -1 / arg1 * _liquidityFee / 10000:
                                revert with 'NH{q', 17
                            if not arg1 * _liquidityFee / 10000:
                                revert with 'NH{q', 18
                            if arg1 * _liquidityFee / 10000 * t / s / arg1 * _liquidityFee / 10000 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _burnFee / 10000:
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 'NH{q', 17
                                if arg1 * _liquidityFee / 10000 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _liquidityFee / 10000 * t / s:
                                    revert with 'NH{q', 17
                                if 0 > (arg1 * t / s) - (arg1 * _liquidityFee / 10000 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _liquidityFee / 10000 * t / s) < 0:
                                    revert with 'NH{q', 17
                            else:
                                if arg1 * _burnFee / 10000 and t / s > -1 / arg1 * _burnFee / 10000:
                                    revert with 'NH{q', 17
                                if not arg1 * _burnFee / 10000:
                                    revert with 'NH{q', 18
                                if arg1 * _burnFee / 10000 * t / s / arg1 * _burnFee / 10000 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 'NH{q', 17
                                if arg1 * _liquidityFee / 10000 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _liquidityFee / 10000 * t / s:
                                    revert with 'NH{q', 17
                                if arg1 * _burnFee / 10000 * t / s > (arg1 * t / s) - (arg1 * _liquidityFee / 10000 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _liquidityFee / 10000 * t / s) < arg1 * _burnFee / 10000 * t / s:
                                    revert with 'NH{q', 17
                    else:
                        if arg1 * _taxFee / 10000 and t / s > -1 / arg1 * _taxFee / 10000:
                            revert with 'NH{q', 17
                        if not arg1 * _taxFee / 10000:
                            revert with 'NH{q', 18
                        if arg1 * _taxFee / 10000 * t / s / arg1 * _taxFee / 10000 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _liquidityFee / 10000:
                            if not arg1 * _burnFee / 10000:
                                if arg1 * _taxFee / 10000 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _taxFee / 10000 * t / s:
                                    revert with 'NH{q', 17
                                if 0 > (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) < 0:
                                    revert with 'NH{q', 17
                                if 0 > (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) < 0:
                                    revert with 'NH{q', 17
                            else:
                                if arg1 * _burnFee / 10000 and t / s > -1 / arg1 * _burnFee / 10000:
                                    revert with 'NH{q', 17
                                if not arg1 * _burnFee / 10000:
                                    revert with 'NH{q', 18
                                if arg1 * _burnFee / 10000 * t / s / arg1 * _burnFee / 10000 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _taxFee / 10000 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _taxFee / 10000 * t / s:
                                    revert with 'NH{q', 17
                                if 0 > (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) < 0:
                                    revert with 'NH{q', 17
                                if arg1 * _burnFee / 10000 * t / s > (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) < arg1 * _burnFee / 10000 * t / s:
                                    revert with 'NH{q', 17
                        else:
                            if arg1 * _liquidityFee / 10000 and t / s > -1 / arg1 * _liquidityFee / 10000:
                                revert with 'NH{q', 17
                            if not arg1 * _liquidityFee / 10000:
                                revert with 'NH{q', 18
                            if arg1 * _liquidityFee / 10000 * t / s / arg1 * _liquidityFee / 10000 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _burnFee / 10000:
                                if arg1 * _taxFee / 10000 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _taxFee / 10000 * t / s:
                                    revert with 'NH{q', 17
                                if arg1 * _liquidityFee / 10000 * t / s > (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) < arg1 * _liquidityFee / 10000 * t / s:
                                    revert with 'NH{q', 17
                                if 0 > (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) - (arg1 * _liquidityFee / 10000 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) - (arg1 * _liquidityFee / 10000 * t / s) < 0:
                                    revert with 'NH{q', 17
                            else:
                                if arg1 * _burnFee / 10000 and t / s > -1 / arg1 * _burnFee / 10000:
                                    revert with 'NH{q', 17
                                if not arg1 * _burnFee / 10000:
                                    revert with 'NH{q', 18
                                if arg1 * _burnFee / 10000 * t / s / arg1 * _burnFee / 10000 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _taxFee / 10000 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _taxFee / 10000 * t / s:
                                    revert with 'NH{q', 17
                                if arg1 * _liquidityFee / 10000 * t / s > (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) < arg1 * _liquidityFee / 10000 * t / s:
                                    revert with 'NH{q', 17
                                if arg1 * _burnFee / 10000 * t / s > (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) - (arg1 * _liquidityFee / 10000 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) - (arg1 * _liquidityFee / 10000 * t / s) < arg1 * _burnFee / 10000 * t / s:
                                    revert with 'NH{q', 17
                    return (arg1 * t / s)
                if totalSupply <= 0:
                    revert with 0, 'SafeMath: division by zero', 0
                if not totalSupply:
                    revert with 'NH{q', 18
                if not arg1:
                    if not arg1 * _taxFee / 10000:
                        if not arg1 * _liquidityFee / 10000:
                            if arg1 * _burnFee / 10000:
                                if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                                    revert with 'NH{q', 17
                                if not arg1 * _burnFee / 10000:
                                    revert with 'NH{q', 18
                                if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _burnFee / 10000 * stor12 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                                    revert with 'NH{q', 17
                        else:
                            if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                                revert with 'NH{q', 17
                            if not arg1 * _liquidityFee / 10000:
                                revert with 'NH{q', 18
                            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _burnFee / 10000:
                                if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                    revert with 'NH{q', 17
                                if 0 > -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply < 0:
                                    revert with 'NH{q', 17
                            else:
                                if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                                    revert with 'NH{q', 17
                                if not arg1 * _burnFee / 10000:
                                    revert with 'NH{q', 18
                                if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                    revert with 'NH{q', 17
                                if arg1 * _burnFee / 10000 * stor12 / totalSupply > -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                                    revert with 'NH{q', 17
                    else:
                        if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                            revert with 'NH{q', 17
                        if not arg1 * _taxFee / 10000:
                            revert with 'NH{q', 18
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _liquidityFee / 10000:
                            if not arg1 * _burnFee / 10000:
                                if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                    revert with 'NH{q', 17
                                if 0 > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                if 0 > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                                    revert with 'NH{q', 17
                            else:
                                if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                                    revert with 'NH{q', 17
                                if not arg1 * _burnFee / 10000:
                                    revert with 'NH{q', 18
                                if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                    revert with 'NH{q', 17
                                if 0 > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                if arg1 * _burnFee / 10000 * stor12 / totalSupply > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                                    revert with 'NH{q', 17
                        else:
                            if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                                revert with 'NH{q', 17
                            if not arg1 * _liquidityFee / 10000:
                                revert with 'NH{q', 18
                            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _burnFee / 10000:
                                if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                    revert with 'NH{q', 17
                                if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                    revert with 'NH{q', 17
                                if 0 > (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                                    revert with 'NH{q', 17
                            else:
                                if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                                    revert with 'NH{q', 17
                                if not arg1 * _burnFee / 10000:
                                    revert with 'NH{q', 18
                                if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                    revert with 'NH{q', 17
                                if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                    revert with 'NH{q', 17
                                if arg1 * _burnFee / 10000 * stor12 / totalSupply > (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                                    revert with 'NH{q', 17
                    return 0
                if arg1 and stor12 / totalSupply > -1 / arg1:
                    revert with 'NH{q', 17
                if not arg1:
                    revert with 'NH{q', 18
                if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _taxFee / 10000:
                    if not arg1 * _liquidityFee / 10000:
                        if not arg1 * _burnFee / 10000:
                            if 0 > arg1 * stor12 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 'NH{q', 17
                            if 0 > arg1 * stor12 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 'NH{q', 17
                            if 0 > arg1 * stor12 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 'NH{q', 17
                        else:
                            if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                                revert with 'NH{q', 17
                            if not arg1 * _burnFee / 10000:
                                revert with 'NH{q', 18
                            if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg1 * stor12 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 'NH{q', 17
                            if 0 > arg1 * stor12 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 'NH{q', 17
                            if arg1 * _burnFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor12 / totalSupply < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                                revert with 'NH{q', 17
                    else:
                        if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                            revert with 'NH{q', 17
                        if not arg1 * _liquidityFee / 10000:
                            revert with 'NH{q', 18
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _burnFee / 10000:
                            if 0 > arg1 * stor12 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 'NH{q', 17
                            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                revert with 'NH{q', 17
                            if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                                revert with 'NH{q', 17
                        else:
                            if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                                revert with 'NH{q', 17
                            if not arg1 * _burnFee / 10000:
                                revert with 'NH{q', 18
                            if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg1 * stor12 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 'NH{q', 17
                            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                revert with 'NH{q', 17
                            if arg1 * _burnFee / 10000 * stor12 / totalSupply > (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                                revert with 'NH{q', 17
                else:
                    if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                        revert with 'NH{q', 17
                    if not arg1 * _taxFee / 10000:
                        revert with 'NH{q', 18
                    if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _liquidityFee / 10000:
                        if not arg1 * _burnFee / 10000:
                            if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                revert with 'NH{q', 17
                            if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                                revert with 'NH{q', 17
                            if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                                revert with 'NH{q', 17
                        else:
                            if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                                revert with 'NH{q', 17
                            if not arg1 * _burnFee / 10000:
                                revert with 'NH{q', 18
                            if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                revert with 'NH{q', 17
                            if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                                revert with 'NH{q', 17
                            if arg1 * _burnFee / 10000 * stor12 / totalSupply > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                                revert with 'NH{q', 17
                    else:
                        if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                            revert with 'NH{q', 17
                        if not arg1 * _liquidityFee / 10000:
                            revert with 'NH{q', 18
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _burnFee / 10000:
                            if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                revert with 'NH{q', 17
                            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                revert with 'NH{q', 17
                            if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                                revert with 'NH{q', 17
                        else:
                            if arg1 * _burnFee / 10000 and stor12 / totalSupply > -1 / arg1 * _burnFee / 10000:
                                revert with 'NH{q', 17
                            if not arg1 * _burnFee / 10000:
                                revert with 'NH{q', 18
                            if arg1 * _burnFee / 10000 * stor12 / totalSupply / arg1 * _burnFee / 10000 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                revert with 'NH{q', 17
                            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                revert with 'NH{q', 17
                            if arg1 * _burnFee / 10000 * stor12 / totalSupply > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < arg1 * _burnFee / 10000 * stor12 / totalSupply:
                                revert with 'NH{q', 17
    return (arg1 * stor12 / totalSupply)
}



}

contract main {




// =====================  Runtime code  =====================


#
#  - withdraw(uint256 arg1)
#  - sub_5b65f8fb(?)
#
array of address stor0;
address rewardWalletAddress;
array of address players;
uint256 totalDeposited;
uint256 latestRound;
address lendingPoolAddress;
address sub_b8ab24bdAddress;
address assetAddress;
address sub_48996015Address;
address sub_36b43005Address;
address sub_dad2b06eAddress;
address WAVAXAddress;
address sub_34496167Address;
uint256 sub_cde8e5d3;
uint8 stor14;
uint256 stor14; offset 8
uint256 sub_7796ff37;
uint8 stor15;
uint256 stor15; offset 8
uint256 sub_2f6236be;
uint8 stor16;
uint256 stor16; offset 8
uint256 sub_7e72b29f;
uint32 stor17;
uint256 stor17; offset 24
uint256 sub_0b4b41bc;
uint256 sub_84beb6e6;
address treasuryAddress;
address rewardTokenAddress;
uint256 sub_f12c8e0d;
uint256 sub_7f94bf16;
uint256 lastRewardTimestamp;
uint256 sub_a9ac33dd;
uint256 sub_bf4c8572;
uint256 _randomness;
address routerAddress;
mapping of struct userInfo;

function sub_0b4b41bc(?) payable {
    return sub_0b4b41bc
}

function userInfo(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return userInfo[arg1].field_0, userInfo[arg1].field_256
}

function sub_2f6236be(?) payable {
    return sub_2f6236be
}

function sub_34496167(?) payable {
    return sub_34496167Address
}

function sub_36b43005(?) payable {
    return sub_36b43005Address
}

function asset() payable {
    return assetAddress
}

function sub_48996015(?) payable {
    return sub_48996015Address
}

function treasury() payable {
    return treasuryAddress
}

function latestRound() payable {
    return latestRound
}

function lotteryState() payable {
    require stor0.length.field_160 < 2
    return stor0.length.field_160
}

function WAVAX() payable {
    return WAVAXAddress
}

function sub_7796ff37(?) payable {
    return sub_7796ff37
}

function sub_7e72b29f(?) payable {
    return sub_7e72b29f
}

function sub_7f94bf16(?) payable {
    return sub_7f94bf16
}

function sub_84beb6e6(?) payable {
    return sub_84beb6e6
}

function _randomness() payable {
    return _randomness
}

function owner() payable {
    return address(stor0.length)
}

function lendingPool() payable {
    return lendingPoolAddress
}

function sub_a9ac33dd(?) payable {
    return sub_a9ac33dd
}

function sub_b8ab24bd(?) payable {
    return sub_b8ab24bdAddress
}

function sub_bf4c8572(?) payable {
    return sub_bf4c8572
}

function sub_cde8e5d3(?) payable {
    return sub_cde8e5d3
}

function sub_dad2b06e(?) payable {
    return sub_dad2b06eAddress
}

function sub_f12c8e0d(?) payable {
    return sub_f12c8e0d
}

function players(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    require arg1 < players.length
    return players[arg1]
}

function rewardToken() payable {
    return rewardTokenAddress
}

function lastRewardTimestamp() payable {
    return lastRewardTimestamp
}

function router() payable {
    return routerAddress
}

function rewardWallet() payable {
    return rewardWalletAddress
}

function totalDeposited() payable {
    return totalDeposited
}

function _fallback() payable {
    revert
}

function sub_6bc6f057(?) payable {
    return (sub_f12c8e0d + sub_7f94bf16)
}

function sub_38bd0014(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if address(stor0.length) != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    sub_cde8e5d3 = arg1
}

function renounceOwnership() payable {
    if address(stor0.length) != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    emit OwnershipTransferred(address(stor0.length), 0);
    address(stor0.length) = 0
}

function updateRouter(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if address(stor0.length) != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    routerAddress = arg1
}

function updateTreasuryWallet(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if address(stor0.length) != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    treasuryAddress = arg1
}

function updateRewardToken(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if address(stor0.length) != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    rewardTokenAddress = arg1
}

function updateRewardWallet(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if address(stor0.length) != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    rewardWalletAddress = arg1
}

function sub_deecf042(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    if address(stor0.length) != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    sub_34496167Address = address(arg1)
}

function sub_326f7f04(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == uint8(arg1)
    if address(stor0.length) != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    stor17.field_0 % 16777216 = 24 * 3600 * uint8(arg1) % 16777216
    Mask(232, 0, stor17.field_24) = 0
}

function interestEarned() payable {
    require ext_code.size(sub_b8ab24bdAddress)
    staticcall sub_b8ab24bdAddress.0x70a08231 with:
            gas gas_remaining wei
           args this.address
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[0]
    return (ext_call.return_data[0] - totalDeposited)
}

function transferOwnership(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if address(stor0.length) != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Ownable: new owner is the zero address'
    emit OwnershipTransferred(address(stor0.length), arg1);
    address(stor0.length) = arg1
}

function getMultiplier(uint256 arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    if arg1 > arg2:
        revert with 0, 'SafeMath: subtraction overflow'
    if not arg2 - arg1:
        return 0
    require arg2 - arg1
    if arg2 - arg1 / arg2 - arg1 != 1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
    return (arg2 - arg1)
}

function sub_f25675e1(?) payable {
    require calldata.size - 4 >= 96
    require arg1 == uint8(arg1)
    require arg2 == uint8(arg2)
    require arg3 == uint8(arg3)
    if address(stor0.length) != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if uint8(arg1 + arg3 + arg2) != 10000:
        revert with 0, 'total should be 100%'
    uint8(stor15.field_0) = uint8(arg1)
    Mask(248, 0, stor15.field_8) = 0
    uint8(stor14.field_0) = uint8(arg2)
    Mask(248, 0, stor14.field_8) = 0
    uint8(stor16.field_0) = uint8(arg3)
    Mask(248, 0, stor16.field_8) = 0
}

function sub_0cc066af(?) payable {
    require calldata.size - 4 >= 96
    require arg1 == address(arg1)
    require arg2 == arg2
    require arg3 == address(arg3)
    if address(stor0.length) != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if address(arg1) == sub_b8ab24bdAddress:
        revert with 0, 'Token should not be bAsset'
    if address(arg1) == rewardTokenAddress:
        revert with 0, 'Token should not be rewardToken'
    require ext_code.size(address(arg1))
    call address(arg1).0xa9059cbb with:
         gas gas_remaining wei
        args address(arg3), arg2
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
}

function expand(uint256 arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    require arg2 <= test266151307()
    mem[96] = arg2
    mem[64] = (32 * arg2) + 128
    if not arg2:
        idx = 0
        while idx < arg2:
            mem[mem[64] + 32] = arg1
            mem[mem[64] + 64] = idx
            _26 = mem[64]
            mem[mem[64]] = 64
            mem[64] = mem[64] + 96
            require idx < mem[96]
            mem[(32 * idx) + 128] = sha3(mem[_26 + 32 len mem[_26]])
            idx = idx + 1
            continue 
    else:
        mem[128 len 32 * arg2] = call.data[calldata.size len 32 * arg2]
        idx = 0
        while idx < arg2:
            mem[mem[64] + 32] = arg1
            mem[mem[64] + 64] = idx
            _30 = mem[64]
            mem[mem[64]] = 64
            mem[64] = mem[64] + 96
            require idx < mem[96]
            mem[(32 * idx) + 128] = sha3(mem[_30 + 32 len mem[_30]])
            idx = idx + 1
            continue 
    mem[mem[64]] = 32
    mem[mem[64] + 32] = mem[96]
    mem[mem[64] + 64 len 32 * mem[96]] = mem[128 len 32 * mem[96]]
    return 32, mem[mem[64] + 32 len (32 * mem[96]) + 32]
}

function sub_92dab350(?) payable {
    require stor0.length.field_160 <= 1
    if stor0.length.field_160 != 1:
        revert with 0, 'drawing has not been started'
    if players.length < sub_cde8e5d3:
        require players.length <= test266151307()
        mem[96] = players.length
        mem[64] = (32 * players.length) + 128
        if not players.length:
            idx = 0
            while idx < players.length:
                mem[mem[64] + 32] = _randomness
                mem[mem[64] + 64] = idx
                _124 = mem[64]
                mem[mem[64]] = 64
                mem[64] = mem[64] + 96
                require idx < mem[96]
                mem[(32 * idx) + 128] = sha3(mem[_124 + 32 len mem[_124]])
                idx = idx + 1
                continue 
            if players.length <= 0:
                revert with 0, 'SafeMath: division by zero'
            require players.length
            idx = 0
            while uint8(idx) < mem[96]:
                require uint8(idx) < mem[96]
                require players.length
                require mem[(32 * uint8(idx)) + 128] % players.length < players.length
                mem[32] = 28
                require uint8(idx) < mem[96]
                require players.length
                require mem[(32 * uint8(idx)) + 128] % players.length < players.length
                stor0.length++
                mem[0] = 0
                stor0[stor0.length].field_0 = players[mem[(32 * uint8(idx)) + 128] % players.length]
                userInfo[stor2[mem[(32 * uint8(idx)) + 128] % stor2.length]].field_0 += sub_bf4c8572 / players.length
                idx = idx + 1
                continue 
            if totalDeposited + sub_bf4c8572 < totalDeposited:
                revert with 0, 'SafeMath: addition overflow'
            totalDeposited += sub_bf4c8572
            stor0.length.field_160 = 0
            latestRound++
            _223 = mem[64]
            mem[mem[64]] = 32
            mem[mem[64] + 32] = stor0.length
            idx = 0
            s = 0
            t = mem[64] + 64
            while idx < stor0.length:
                mem[t] = stor0[s].field_0
                idx = idx + 1
                s = s + 1
                t = t + 32
                continue 
            emit 0x6b35d61e: mem[mem[64] len _223 + (32 * stor0.length) + -mem[64] + 64]
        else:
            mem[128 len 32 * players.length] = call.data[calldata.size len 32 * players.length]
            idx = 0
            while idx < players.length:
                mem[mem[64] + 32] = _randomness
                mem[mem[64] + 64] = idx
                _131 = mem[64]
                mem[mem[64]] = 64
                mem[64] = mem[64] + 96
                require idx < mem[96]
                mem[(32 * idx) + 128] = sha3(mem[_131 + 32 len mem[_131]])
                idx = idx + 1
                continue 
            if players.length <= 0:
                revert with 0, 'SafeMath: division by zero'
            require players.length
            idx = 0
            while uint8(idx) < mem[96]:
                require uint8(idx) < mem[96]
                require players.length
                require mem[(32 * uint8(idx)) + 128] % players.length < players.length
                mem[32] = 28
                require uint8(idx) < mem[96]
                require players.length
                require mem[(32 * uint8(idx)) + 128] % players.length < players.length
                stor0.length++
                mem[0] = 0
                stor0[stor0.length].field_0 = players[mem[(32 * uint8(idx)) + 128] % players.length]
                userInfo[stor2[mem[(32 * uint8(idx)) + 128] % stor2.length]].field_0 += sub_bf4c8572 / players.length
                idx = idx + 1
                continue 
            if totalDeposited + sub_bf4c8572 < totalDeposited:
                revert with 0, 'SafeMath: addition overflow'
            totalDeposited += sub_bf4c8572
            stor0.length.field_160 = 0
            latestRound++
            _226 = mem[64]
            mem[mem[64]] = 32
            mem[mem[64] + 32] = stor0.length
            idx = 0
            s = 0
            t = mem[64] + 64
            while idx < stor0.length:
                mem[t] = stor0[s].field_0
                idx = idx + 1
                s = s + 1
                t = t + 32
                continue 
            emit 0x6b35d61e: mem[mem[64] len _226 + (32 * stor0.length) + -mem[64] + 64]
    else:
        require sub_cde8e5d3 <= test266151307()
        mem[96] = sub_cde8e5d3
        mem[64] = (32 * sub_cde8e5d3) + 128
        if not sub_cde8e5d3:
            idx = 0
            while idx < sub_cde8e5d3:
                mem[mem[64] + 32] = _randomness
                mem[mem[64] + 64] = idx
                _139 = mem[64]
                mem[mem[64]] = 64
                mem[64] = mem[64] + 96
                require idx < mem[96]
                mem[(32 * idx) + 128] = sha3(mem[_139 + 32 len mem[_139]])
                idx = idx + 1
                continue 
            if sub_cde8e5d3 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require sub_cde8e5d3
            idx = 0
            while uint8(idx) < mem[96]:
                require uint8(idx) < mem[96]
                require players.length
                require mem[(32 * uint8(idx)) + 128] % players.length < players.length
                mem[32] = 28
                require uint8(idx) < mem[96]
                require players.length
                require mem[(32 * uint8(idx)) + 128] % players.length < players.length
                stor0.length++
                mem[0] = 0
                stor0[stor0.length].field_0 = players[mem[(32 * uint8(idx)) + 128] % players.length]
                userInfo[stor2[mem[(32 * uint8(idx)) + 128] % stor2.length]].field_0 += sub_bf4c8572 / sub_cde8e5d3
                idx = idx + 1
                continue 
            if totalDeposited + sub_bf4c8572 < totalDeposited:
                revert with 0, 'SafeMath: addition overflow'
            totalDeposited += sub_bf4c8572
            stor0.length.field_160 = 0
            latestRound++
            _221 = mem[64]
            mem[mem[64]] = 32
            mem[mem[64] + 32] = stor0.length
            idx = 0
            s = 0
            t = mem[64] + 64
            while idx < stor0.length:
                mem[t] = stor0[s].field_0
                idx = idx + 1
                s = s + 1
                t = t + 32
                continue 
            emit 0x6b35d61e: mem[mem[64] len _221 + (32 * stor0.length) + -mem[64] + 64]
        else:
            mem[128 len 32 * sub_cde8e5d3] = call.data[calldata.size len 32 * sub_cde8e5d3]
            idx = 0
            while idx < sub_cde8e5d3:
                mem[mem[64] + 32] = _randomness
                mem[mem[64] + 64] = idx
                _147 = mem[64]
                mem[mem[64]] = 64
                mem[64] = mem[64] + 96
                require idx < mem[96]
                mem[(32 * idx) + 128] = sha3(mem[_147 + 32 len mem[_147]])
                idx = idx + 1
                continue 
            if sub_cde8e5d3 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require sub_cde8e5d3
            idx = 0
            while uint8(idx) < mem[96]:
                require uint8(idx) < mem[96]
                require players.length
                require mem[(32 * uint8(idx)) + 128] % players.length < players.length
                mem[32] = 28
                require uint8(idx) < mem[96]
                require players.length
                require mem[(32 * uint8(idx)) + 128] % players.length < players.length
                stor0.length++
                mem[0] = 0
                stor0[stor0.length].field_0 = players[mem[(32 * uint8(idx)) + 128] % players.length]
                userInfo[stor2[mem[(32 * uint8(idx)) + 128] % stor2.length]].field_0 += sub_bf4c8572 / sub_cde8e5d3
                idx = idx + 1
                continue 
            if totalDeposited + sub_bf4c8572 < totalDeposited:
                revert with 0, 'SafeMath: addition overflow'
            totalDeposited += sub_bf4c8572
            stor0.length.field_160 = 0
            latestRound++
            _222 = mem[64]
            mem[mem[64]] = 32
            mem[mem[64] + 32] = stor0.length
            idx = 0
            s = 0
            t = mem[64] + 64
            while idx < stor0.length:
                mem[t] = stor0[s].field_0
                idx = idx + 1
                s = s + 1
                t = t + 32
                continue 
            emit 0x6b35d61e: mem[mem[64] len _222 + (32 * stor0.length) + -mem[64] + 64]
    emit randomness(_randomness);
}

function pendingTaksh(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if block.timestamp <= lastRewardTimestamp:
        if not userInfo[address(arg1)].field_0:
            if userInfo[address(arg1)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            return -userInfo[address(arg1)].field_256
        require userInfo[address(arg1)].field_0
        if userInfo[address(arg1)].field_0 * sub_a9ac33dd / userInfo[address(arg1)].field_0 != sub_a9ac33dd:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
        if userInfo[address(arg1)].field_256 > userInfo[address(arg1)].field_0 * sub_a9ac33dd / 10^12:
            revert with 0, 'SafeMath: subtraction overflow'
        return ((userInfo[address(arg1)].field_0 * sub_a9ac33dd / 10^12) - userInfo[address(arg1)].field_256)
    if not totalDeposited:
        if not userInfo[address(arg1)].field_0:
            if userInfo[address(arg1)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            return -userInfo[address(arg1)].field_256
        require userInfo[address(arg1)].field_0
        if userInfo[address(arg1)].field_0 * sub_a9ac33dd / userInfo[address(arg1)].field_0 != sub_a9ac33dd:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
        if userInfo[address(arg1)].field_256 > userInfo[address(arg1)].field_0 * sub_a9ac33dd / 10^12:
            revert with 0, 'SafeMath: subtraction overflow'
        return ((userInfo[address(arg1)].field_0 * sub_a9ac33dd / 10^12) - userInfo[address(arg1)].field_256)
    if lastRewardTimestamp > block.timestamp:
        revert with 0, 'SafeMath: subtraction overflow'
    if not block.timestamp - lastRewardTimestamp:
        if totalDeposited <= 0:
            revert with 0, 'SafeMath: division by zero'
        require totalDeposited
        if sub_a9ac33dd + (0 / totalDeposited) < sub_a9ac33dd:
            revert with 0, 'SafeMath: addition overflow'
        if not userInfo[address(arg1)].field_0:
            if userInfo[address(arg1)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            return -userInfo[address(arg1)].field_256
        require userInfo[address(arg1)].field_0
        if (sub_a9ac33dd * userInfo[address(arg1)].field_0) + (0 / totalDeposited * userInfo[address(arg1)].field_0) / userInfo[address(arg1)].field_0 != sub_a9ac33dd + (0 / totalDeposited):
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
        if userInfo[address(arg1)].field_256 > (sub_a9ac33dd * userInfo[address(arg1)].field_0) + (0 / totalDeposited * userInfo[address(arg1)].field_0) / 10^12:
            revert with 0, 'SafeMath: subtraction overflow'
        return (((sub_a9ac33dd * userInfo[address(arg1)].field_0) + (0 / totalDeposited * userInfo[address(arg1)].field_0) / 10^12) - userInfo[address(arg1)].field_256)
    require block.timestamp - lastRewardTimestamp
    if block.timestamp - lastRewardTimestamp / block.timestamp - lastRewardTimestamp != 1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
    if not block.timestamp - lastRewardTimestamp:
        if totalDeposited <= 0:
            revert with 0, 'SafeMath: division by zero'
        require totalDeposited
        if sub_a9ac33dd + (0 / totalDeposited) < sub_a9ac33dd:
            revert with 0, 'SafeMath: addition overflow'
        if not userInfo[address(arg1)].field_0:
            if userInfo[address(arg1)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            return -userInfo[address(arg1)].field_256
        require userInfo[address(arg1)].field_0
        if (sub_a9ac33dd * userInfo[address(arg1)].field_0) + (0 / totalDeposited * userInfo[address(arg1)].field_0) / userInfo[address(arg1)].field_0 != sub_a9ac33dd + (0 / totalDeposited):
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
        if userInfo[address(arg1)].field_256 > (sub_a9ac33dd * userInfo[address(arg1)].field_0) + (0 / totalDeposited * userInfo[address(arg1)].field_0) / 10^12:
            revert with 0, 'SafeMath: subtraction overflow'
        return (((sub_a9ac33dd * userInfo[address(arg1)].field_0) + (0 / totalDeposited * userInfo[address(arg1)].field_0) / 10^12) - userInfo[address(arg1)].field_256)
    require block.timestamp - lastRewardTimestamp
    if (sub_f12c8e0d * block.timestamp) + (sub_7f94bf16 * block.timestamp) - (sub_f12c8e0d * lastRewardTimestamp) - (sub_7f94bf16 * lastRewardTimestamp) / block.timestamp - lastRewardTimestamp != sub_f12c8e0d + sub_7f94bf16:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
    if not (sub_f12c8e0d * block.timestamp) + (sub_7f94bf16 * block.timestamp) - (sub_f12c8e0d * lastRewardTimestamp) - (sub_7f94bf16 * lastRewardTimestamp):
        if totalDeposited <= 0:
            revert with 0, 'SafeMath: division by zero'
        require totalDeposited
        if sub_a9ac33dd + (0 / totalDeposited) < sub_a9ac33dd:
            revert with 0, 'SafeMath: addition overflow'
        if not userInfo[address(arg1)].field_0:
            if userInfo[address(arg1)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            return -userInfo[address(arg1)].field_256
        require userInfo[address(arg1)].field_0
        if (sub_a9ac33dd * userInfo[address(arg1)].field_0) + (0 / totalDeposited * userInfo[address(arg1)].field_0) / userInfo[address(arg1)].field_0 != sub_a9ac33dd + (0 / totalDeposited):
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
        if userInfo[address(arg1)].field_256 > (sub_a9ac33dd * userInfo[address(arg1)].field_0) + (0 / totalDeposited * userInfo[address(arg1)].field_0) / 10^12:
            revert with 0, 'SafeMath: subtraction overflow'
        return (((sub_a9ac33dd * userInfo[address(arg1)].field_0) + (0 / totalDeposited * userInfo[address(arg1)].field_0) / 10^12) - userInfo[address(arg1)].field_256)
    require (sub_f12c8e0d * block.timestamp) + (sub_7f94bf16 * block.timestamp) - (sub_f12c8e0d * lastRewardTimestamp) - (sub_7f94bf16 * lastRewardTimestamp)
    if (sub_f12c8e0d * block.timestamp) + (sub_7f94bf16 * block.timestamp) - (sub_f12c8e0d * lastRewardTimestamp) - (sub_7f94bf16 * lastRewardTimestamp) / (sub_f12c8e0d * block.timestamp) + (sub_7f94bf16 * block.timestamp) - (sub_f12c8e0d * lastRewardTimestamp) - (sub_7f94bf16 * lastRewardTimestamp) != 1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
    if not (sub_f12c8e0d * block.timestamp) + (sub_7f94bf16 * block.timestamp) - (sub_f12c8e0d * lastRewardTimestamp) - (sub_7f94bf16 * lastRewardTimestamp):
        if totalDeposited <= 0:
            revert with 0, 'SafeMath: division by zero'
        require totalDeposited
        if sub_a9ac33dd + (0 / totalDeposited) < sub_a9ac33dd:
            revert with 0, 'SafeMath: addition overflow'
        if not userInfo[address(arg1)].field_0:
            if userInfo[address(arg1)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            return -userInfo[address(arg1)].field_256
        require userInfo[address(arg1)].field_0
        if (sub_a9ac33dd * userInfo[address(arg1)].field_0) + (0 / totalDeposited * userInfo[address(arg1)].field_0) / userInfo[address(arg1)].field_0 != sub_a9ac33dd + (0 / totalDeposited):
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
        if userInfo[address(arg1)].field_256 > (sub_a9ac33dd * userInfo[address(arg1)].field_0) + (0 / totalDeposited * userInfo[address(arg1)].field_0) / 10^12:
            revert with 0, 'SafeMath: subtraction overflow'
        return (((sub_a9ac33dd * userInfo[address(arg1)].field_0) + (0 / totalDeposited * userInfo[address(arg1)].field_0) / 10^12) - userInfo[address(arg1)].field_256)
    require (sub_f12c8e0d * block.timestamp) + (sub_7f94bf16 * block.timestamp) - (sub_f12c8e0d * lastRewardTimestamp) - (sub_7f94bf16 * lastRewardTimestamp)
    if (10^12 * sub_f12c8e0d * block.timestamp) + (10^12 * sub_7f94bf16 * block.timestamp) - (10^12 * sub_f12c8e0d * lastRewardTimestamp) - (10^12 * sub_7f94bf16 * lastRewardTimestamp) / (sub_f12c8e0d * block.timestamp) + (sub_7f94bf16 * block.timestamp) - (sub_f12c8e0d * lastRewardTimestamp) - (sub_7f94bf16 * lastRewardTimestamp) != 10^12:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
    if totalDeposited <= 0:
        revert with 0, 'SafeMath: division by zero'
    require totalDeposited
    if sub_a9ac33dd + ((10^12 * sub_f12c8e0d * block.timestamp) + (10^12 * sub_7f94bf16 * block.timestamp) - (10^12 * sub_f12c8e0d * lastRewardTimestamp) - (10^12 * sub_7f94bf16 * lastRewardTimestamp) / totalDeposited) < sub_a9ac33dd:
        revert with 0, 'SafeMath: addition overflow'
    if not userInfo[address(arg1)].field_0:
        if userInfo[address(arg1)].field_256 > 0:
            revert with 0, 'SafeMath: subtraction overflow'
        return -userInfo[address(arg1)].field_256
    require userInfo[address(arg1)].field_0
    if (sub_a9ac33dd * userInfo[address(arg1)].field_0) + ((10^12 * sub_f12c8e0d * block.timestamp) + (10^12 * sub_7f94bf16 * block.timestamp) - (10^12 * sub_f12c8e0d * lastRewardTimestamp) - (10^12 * sub_7f94bf16 * lastRewardTimestamp) / totalDeposited * userInfo[address(arg1)].field_0) / userInfo[address(arg1)].field_0 != sub_a9ac33dd + ((10^12 * sub_f12c8e0d * block.timestamp) + (10^12 * sub_7f94bf16 * block.timestamp) - (10^12 * sub_f12c8e0d * lastRewardTimestamp) - (10^12 * sub_7f94bf16 * lastRewardTimestamp) / totalDeposited):
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
    if userInfo[address(arg1)].field_256 > (sub_a9ac33dd * userInfo[address(arg1)].field_0) + ((10^12 * sub_f12c8e0d * block.timestamp) + (10^12 * sub_7f94bf16 * block.timestamp) - (10^12 * sub_f12c8e0d * lastRewardTimestamp) - (10^12 * sub_7f94bf16 * lastRewardTimestamp) / totalDeposited * userInfo[address(arg1)].field_0) / 10^12:
        revert with 0, 'SafeMath: subtraction overflow'
    return (((sub_a9ac33dd * userInfo[address(arg1)].field_0) + ((10^12 * sub_f12c8e0d * block.timestamp) + (10^12 * sub_7f94bf16 * block.timestamp) - (10^12 * sub_f12c8e0d * lastRewardTimestamp) - (10^12 * sub_7f94bf16 * lastRewardTimestamp) / totalDeposited * userInfo[address(arg1)].field_0) / 10^12) - userInfo[address(arg1)].field_256)
}

function updatePool() payable {
    if block.timestamp > lastRewardTimestamp:
        if totalDeposited:
            if sub_f12c8e0d + sub_7f94bf16:
                if lastRewardTimestamp > block.timestamp:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not block.timestamp - lastRewardTimestamp:
                    require ext_code.size(rewardWalletAddress)
                    call rewardWalletAddress.requestReward(uint256 arg1) with:
                         gas gas_remaining wei
                        args 0
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if totalDeposited <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalDeposited
                    if sub_a9ac33dd + (0 / totalDeposited) < sub_a9ac33dd:
                        revert with 0, 'SafeMath: addition overflow'
                    sub_a9ac33dd += 0 / totalDeposited
                else:
                    require block.timestamp - lastRewardTimestamp
                    if block.timestamp - lastRewardTimestamp / block.timestamp - lastRewardTimestamp != 1:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
                    if not block.timestamp - lastRewardTimestamp:
                        if not block.timestamp - lastRewardTimestamp:
                            require ext_code.size(rewardWalletAddress)
                            call rewardWalletAddress.requestReward(uint256 arg1) with:
                                 gas gas_remaining wei
                                args 0
                        else:
                            require block.timestamp - lastRewardTimestamp
                            if (block.timestamp * sub_f12c8e0d) - (lastRewardTimestamp * sub_f12c8e0d) / block.timestamp - lastRewardTimestamp != sub_f12c8e0d:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
                            if not (block.timestamp * sub_f12c8e0d) - (lastRewardTimestamp * sub_f12c8e0d):
                                require ext_code.size(rewardWalletAddress)
                                call rewardWalletAddress.requestReward(uint256 arg1) with:
                                     gas gas_remaining wei
                                    args 0
                            else:
                                require (block.timestamp * sub_f12c8e0d) - (lastRewardTimestamp * sub_f12c8e0d)
                                if (block.timestamp * sub_f12c8e0d) - (lastRewardTimestamp * sub_f12c8e0d) / (block.timestamp * sub_f12c8e0d) - (lastRewardTimestamp * sub_f12c8e0d) != 1:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
                                require ext_code.size(rewardWalletAddress)
                                call rewardWalletAddress.requestReward(uint256 arg1) with:
                                     gas gas_remaining wei
                                    args ((block.timestamp * sub_f12c8e0d) - (lastRewardTimestamp * sub_f12c8e0d))
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if totalDeposited <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalDeposited
                        if sub_a9ac33dd + (0 / totalDeposited) < sub_a9ac33dd:
                            revert with 0, 'SafeMath: addition overflow'
                        sub_a9ac33dd += 0 / totalDeposited
                    else:
                        require block.timestamp - lastRewardTimestamp
                        if (sub_f12c8e0d * block.timestamp) + (sub_7f94bf16 * block.timestamp) - (sub_f12c8e0d * lastRewardTimestamp) - (sub_7f94bf16 * lastRewardTimestamp) / block.timestamp - lastRewardTimestamp != sub_f12c8e0d + sub_7f94bf16:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
                        if not (sub_f12c8e0d * block.timestamp) + (sub_7f94bf16 * block.timestamp) - (sub_f12c8e0d * lastRewardTimestamp) - (sub_7f94bf16 * lastRewardTimestamp):
                            if not block.timestamp - lastRewardTimestamp:
                                require ext_code.size(rewardWalletAddress)
                                call rewardWalletAddress.requestReward(uint256 arg1) with:
                                     gas gas_remaining wei
                                    args 0
                            else:
                                require block.timestamp - lastRewardTimestamp
                                if (block.timestamp * sub_f12c8e0d) - (lastRewardTimestamp * sub_f12c8e0d) / block.timestamp - lastRewardTimestamp != sub_f12c8e0d:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
                                if not (block.timestamp * sub_f12c8e0d) - (lastRewardTimestamp * sub_f12c8e0d):
                                    require ext_code.size(rewardWalletAddress)
                                    call rewardWalletAddress.requestReward(uint256 arg1) with:
                                         gas gas_remaining wei
                                        args 0
                                else:
                                    require (block.timestamp * sub_f12c8e0d) - (lastRewardTimestamp * sub_f12c8e0d)
                                    if (block.timestamp * sub_f12c8e0d) - (lastRewardTimestamp * sub_f12c8e0d) / (block.timestamp * sub_f12c8e0d) - (lastRewardTimestamp * sub_f12c8e0d) != 1:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
                                    require ext_code.size(rewardWalletAddress)
                                    call rewardWalletAddress.requestReward(uint256 arg1) with:
                                         gas gas_remaining wei
                                        args ((block.timestamp * sub_f12c8e0d) - (lastRewardTimestamp * sub_f12c8e0d))
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if totalDeposited <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require totalDeposited
                            if sub_a9ac33dd + (0 / totalDeposited) < sub_a9ac33dd:
                                revert with 0, 'SafeMath: addition overflow'
                            sub_a9ac33dd += 0 / totalDeposited
                        else:
                            require (sub_f12c8e0d * block.timestamp) + (sub_7f94bf16 * block.timestamp) - (sub_f12c8e0d * lastRewardTimestamp) - (sub_7f94bf16 * lastRewardTimestamp)
                            if (sub_f12c8e0d * block.timestamp) + (sub_7f94bf16 * block.timestamp) - (sub_f12c8e0d * lastRewardTimestamp) - (sub_7f94bf16 * lastRewardTimestamp) / (sub_f12c8e0d * block.timestamp) + (sub_7f94bf16 * block.timestamp) - (sub_f12c8e0d * lastRewardTimestamp) - (sub_7f94bf16 * lastRewardTimestamp) != 1:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
                            if not block.timestamp - lastRewardTimestamp:
                                require ext_code.size(rewardWalletAddress)
                                call rewardWalletAddress.requestReward(uint256 arg1) with:
                                     gas gas_remaining wei
                                    args 0
                            else:
                                require block.timestamp - lastRewardTimestamp
                                if (block.timestamp * sub_f12c8e0d) - (lastRewardTimestamp * sub_f12c8e0d) / block.timestamp - lastRewardTimestamp != sub_f12c8e0d:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
                                if not (block.timestamp * sub_f12c8e0d) - (lastRewardTimestamp * sub_f12c8e0d):
                                    require ext_code.size(rewardWalletAddress)
                                    call rewardWalletAddress.requestReward(uint256 arg1) with:
                                         gas gas_remaining wei
                                        args 0
                                else:
                                    require (block.timestamp * sub_f12c8e0d) - (lastRewardTimestamp * sub_f12c8e0d)
                                    if (block.timestamp * sub_f12c8e0d) - (lastRewardTimestamp * sub_f12c8e0d) / (block.timestamp * sub_f12c8e0d) - (lastRewardTimestamp * sub_f12c8e0d) != 1:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
                                    require ext_code.size(rewardWalletAddress)
                                    call rewardWalletAddress.requestReward(uint256 arg1) with:
                                         gas gas_remaining wei
                                        args ((block.timestamp * sub_f12c8e0d) - (lastRewardTimestamp * sub_f12c8e0d))
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if not (sub_f12c8e0d * block.timestamp) + (sub_7f94bf16 * block.timestamp) - (sub_f12c8e0d * lastRewardTimestamp) - (sub_7f94bf16 * lastRewardTimestamp):
                                if totalDeposited <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require totalDeposited
                                if sub_a9ac33dd + (0 / totalDeposited) < sub_a9ac33dd:
                                    revert with 0, 'SafeMath: addition overflow'
                                sub_a9ac33dd += 0 / totalDeposited
                            else:
                                require (sub_f12c8e0d * block.timestamp) + (sub_7f94bf16 * block.timestamp) - (sub_f12c8e0d * lastRewardTimestamp) - (sub_7f94bf16 * lastRewardTimestamp)
                                if (10^12 * sub_f12c8e0d * block.timestamp) + (10^12 * sub_7f94bf16 * block.timestamp) - (10^12 * sub_f12c8e0d * lastRewardTimestamp) - (10^12 * sub_7f94bf16 * lastRewardTimestamp) / (sub_f12c8e0d * block.timestamp) + (sub_7f94bf16 * block.timestamp) - (sub_f12c8e0d * lastRewardTimestamp) - (sub_7f94bf16 * lastRewardTimestamp) != 10^12:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
                                if totalDeposited <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require totalDeposited
                                if sub_a9ac33dd + ((10^12 * sub_f12c8e0d * block.timestamp) + (10^12 * sub_7f94bf16 * block.timestamp) - (10^12 * sub_f12c8e0d * lastRewardTimestamp) - (10^12 * sub_7f94bf16 * lastRewardTimestamp) / totalDeposited) < sub_a9ac33dd:
                                    revert with 0, 'SafeMath: addition overflow'
                                sub_a9ac33dd += (10^12 * sub_f12c8e0d * block.timestamp) + (10^12 * sub_7f94bf16 * block.timestamp) - (10^12 * sub_f12c8e0d * lastRewardTimestamp) - (10^12 * sub_7f94bf16 * lastRewardTimestamp) / totalDeposited
        lastRewardTimestamp = block.timestamp
}

function updateEmissionRate(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if address(stor0.length) != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    require stor0.length.field_160 <= 1
    if stor0.length.field_160 == 1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Cannot do any TX during Calculation'
    if latestRound:
        if block.timestamp > lastRewardTimestamp:
            if totalDeposited:
                if sub_f12c8e0d + sub_7f94bf16:
                    if lastRewardTimestamp > block.timestamp:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not block.timestamp - lastRewardTimestamp:
                        require ext_code.size(rewardWalletAddress)
                        call rewardWalletAddress.requestReward(uint256 arg1) with:
                             gas gas_remaining wei
                            args 0
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if totalDeposited <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalDeposited
                        if sub_a9ac33dd + (0 / totalDeposited) < sub_a9ac33dd:
                            revert with 0, 'SafeMath: addition overflow'
                        sub_a9ac33dd += 0 / totalDeposited
                    else:
                        require block.timestamp - lastRewardTimestamp
                        if block.timestamp - lastRewardTimestamp / block.timestamp - lastRewardTimestamp != 1:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
                        if not block.timestamp - lastRewardTimestamp:
                            if not block.timestamp - lastRewardTimestamp:
                                require ext_code.size(rewardWalletAddress)
                                call rewardWalletAddress.requestReward(uint256 arg1) with:
                                     gas gas_remaining wei
                                    args 0
                            else:
                                require block.timestamp - lastRewardTimestamp
                                if (block.timestamp * sub_f12c8e0d) - (lastRewardTimestamp * sub_f12c8e0d) / block.timestamp - lastRewardTimestamp != sub_f12c8e0d:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
                                if not (block.timestamp * sub_f12c8e0d) - (lastRewardTimestamp * sub_f12c8e0d):
                                    require ext_code.size(rewardWalletAddress)
                                    call rewardWalletAddress.requestReward(uint256 arg1) with:
                                         gas gas_remaining wei
                                        args 0
                                else:
                                    require (block.timestamp * sub_f12c8e0d) - (lastRewardTimestamp * sub_f12c8e0d)
                                    if (block.timestamp * sub_f12c8e0d) - (lastRewardTimestamp * sub_f12c8e0d) / (block.timestamp * sub_f12c8e0d) - (lastRewardTimestamp * sub_f12c8e0d) != 1:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
                                    require ext_code.size(rewardWalletAddress)
                                    call rewardWalletAddress.requestReward(uint256 arg1) with:
                                         gas gas_remaining wei
                                        args ((block.timestamp * sub_f12c8e0d) - (lastRewardTimestamp * sub_f12c8e0d))
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if totalDeposited <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require totalDeposited
                            if sub_a9ac33dd + (0 / totalDeposited) < sub_a9ac33dd:
                                revert with 0, 'SafeMath: addition overflow'
                            sub_a9ac33dd += 0 / totalDeposited
                        else:
                            require block.timestamp - lastRewardTimestamp
                            if (sub_f12c8e0d * block.timestamp) + (sub_7f94bf16 * block.timestamp) - (sub_f12c8e0d * lastRewardTimestamp) - (sub_7f94bf16 * lastRewardTimestamp) / block.timestamp - lastRewardTimestamp != sub_f12c8e0d + sub_7f94bf16:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
                            if not (sub_f12c8e0d * block.timestamp) + (sub_7f94bf16 * block.timestamp) - (sub_f12c8e0d * lastRewardTimestamp) - (sub_7f94bf16 * lastRewardTimestamp):
                                if not block.timestamp - lastRewardTimestamp:
                                    require ext_code.size(rewardWalletAddress)
                                    call rewardWalletAddress.requestReward(uint256 arg1) with:
                                         gas gas_remaining wei
                                        args 0
                                else:
                                    require block.timestamp - lastRewardTimestamp
                                    if (block.timestamp * sub_f12c8e0d) - (lastRewardTimestamp * sub_f12c8e0d) / block.timestamp - lastRewardTimestamp != sub_f12c8e0d:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
                                    if not (block.timestamp * sub_f12c8e0d) - (lastRewardTimestamp * sub_f12c8e0d):
                                        require ext_code.size(rewardWalletAddress)
                                        call rewardWalletAddress.requestReward(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args 0
                                    else:
                                        require (block.timestamp * sub_f12c8e0d) - (lastRewardTimestamp * sub_f12c8e0d)
                                        if (block.timestamp * sub_f12c8e0d) - (lastRewardTimestamp * sub_f12c8e0d) / (block.timestamp * sub_f12c8e0d) - (lastRewardTimestamp * sub_f12c8e0d) != 1:
                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
                                        require ext_code.size(rewardWalletAddress)
                                        call rewardWalletAddress.requestReward(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args ((block.timestamp * sub_f12c8e0d) - (lastRewardTimestamp * sub_f12c8e0d))
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if totalDeposited <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require totalDeposited
                                if sub_a9ac33dd + (0 / totalDeposited) < sub_a9ac33dd:
                                    revert with 0, 'SafeMath: addition overflow'
                                sub_a9ac33dd += 0 / totalDeposited
                            else:
                                require (sub_f12c8e0d * block.timestamp) + (sub_7f94bf16 * block.timestamp) - (sub_f12c8e0d * lastRewardTimestamp) - (sub_7f94bf16 * lastRewardTimestamp)
                                if (sub_f12c8e0d * block.timestamp) + (sub_7f94bf16 * block.timestamp) - (sub_f12c8e0d * lastRewardTimestamp) - (sub_7f94bf16 * lastRewardTimestamp) / (sub_f12c8e0d * block.timestamp) + (sub_7f94bf16 * block.timestamp) - (sub_f12c8e0d * lastRewardTimestamp) - (sub_7f94bf16 * lastRewardTimestamp) != 1:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
                                if not block.timestamp - lastRewardTimestamp:
                                    require ext_code.size(rewardWalletAddress)
                                    call rewardWalletAddress.requestReward(uint256 arg1) with:
                                         gas gas_remaining wei
                                        args 0
                                else:
                                    require block.timestamp - lastRewardTimestamp
                                    if (block.timestamp * sub_f12c8e0d) - (lastRewardTimestamp * sub_f12c8e0d) / block.timestamp - lastRewardTimestamp != sub_f12c8e0d:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
                                    if not (block.timestamp * sub_f12c8e0d) - (lastRewardTimestamp * sub_f12c8e0d):
                                        require ext_code.size(rewardWalletAddress)
                                        call rewardWalletAddress.requestReward(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args 0
                                    else:
                                        require (block.timestamp * sub_f12c8e0d) - (lastRewardTimestamp * sub_f12c8e0d)
                                        if (block.timestamp * sub_f12c8e0d) - (lastRewardTimestamp * sub_f12c8e0d) / (block.timestamp * sub_f12c8e0d) - (lastRewardTimestamp * sub_f12c8e0d) != 1:
                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
                                        require ext_code.size(rewardWalletAddress)
                                        call rewardWalletAddress.requestReward(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args ((block.timestamp * sub_f12c8e0d) - (lastRewardTimestamp * sub_f12c8e0d))
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if not (sub_f12c8e0d * block.timestamp) + (sub_7f94bf16 * block.timestamp) - (sub_f12c8e0d * lastRewardTimestamp) - (sub_7f94bf16 * lastRewardTimestamp):
                                    if totalDeposited <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require totalDeposited
                                    if sub_a9ac33dd + (0 / totalDeposited) < sub_a9ac33dd:
                                        revert with 0, 'SafeMath: addition overflow'
                                    sub_a9ac33dd += 0 / totalDeposited
                                else:
                                    require (sub_f12c8e0d * block.timestamp) + (sub_7f94bf16 * block.timestamp) - (sub_f12c8e0d * lastRewardTimestamp) - (sub_7f94bf16 * lastRewardTimestamp)
                                    if (10^12 * sub_f12c8e0d * block.timestamp) + (10^12 * sub_7f94bf16 * block.timestamp) - (10^12 * sub_f12c8e0d * lastRewardTimestamp) - (10^12 * sub_7f94bf16 * lastRewardTimestamp) / (sub_f12c8e0d * block.timestamp) + (sub_7f94bf16 * block.timestamp) - (sub_f12c8e0d * lastRewardTimestamp) - (sub_7f94bf16 * lastRewardTimestamp) != 10^12:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
                                    if totalDeposited <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require totalDeposited
                                    if sub_a9ac33dd + ((10^12 * sub_f12c8e0d * block.timestamp) + (10^12 * sub_7f94bf16 * block.timestamp) - (10^12 * sub_f12c8e0d * lastRewardTimestamp) - (10^12 * sub_7f94bf16 * lastRewardTimestamp) / totalDeposited) < sub_a9ac33dd:
                                        revert with 0, 'SafeMath: addition overflow'
                                    sub_a9ac33dd += (10^12 * sub_f12c8e0d * block.timestamp) + (10^12 * sub_7f94bf16 * block.timestamp) - (10^12 * sub_f12c8e0d * lastRewardTimestamp) - (10^12 * sub_7f94bf16 * lastRewardTimestamp) / totalDeposited
            lastRewardTimestamp = block.timestamp
    sub_f12c8e0d = arg1
    emit UpdateEmission(arg1);
}

function reinvest() payable {
    require stor0.length.field_160 <= 1
    if stor0.length.field_160:
        revert with 0, 'LOTTERY != OPEN'
    mem[96] = 1
    mem[128] = sub_b8ab24bdAddress
    mem[160] = 0x8e2eba0900000000000000000000000000000000000000000000000000000000
    mem[164] = this.address
    mem[196] = 64
    mem[228] = 1
    idx = 0
    s = 128
    t = 260
    while idx < 1:
        mem[t] = mem[s + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ext_code.size(sub_36b43005Address)
    call sub_36b43005Address.claim(address arg1, address[] arg2) with:
         gas gas_remaining wei
        args address(this.address), Array(len=1, data=mem[260])
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require ext_code.size(sub_dad2b06eAddress)
    call sub_dad2b06eAddress.exit(bool arg1) with:
         gas gas_remaining wei
        args 0
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    mem[164] = this.address
    require ext_code.size(sub_48996015Address)
    staticcall sub_48996015Address.0x70a08231 with:
            gas gas_remaining wei
           args this.address
    mem[160] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[0]
    mem[ceil32(return_data.size) + 164] = routerAddress
    mem[ceil32(return_data.size) + 196] = -1
    require ext_code.size(sub_48996015Address)
    call sub_48996015Address.approve(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args routerAddress, -1
    mem[ceil32(return_data.size) + 160] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if sub_48996015Address == WAVAXAddress:
        mem[(2 * ceil32(return_data.size)) + 160] = 2
        mem[(2 * ceil32(return_data.size)) + 192] = sub_48996015Address
        mem[(2 * ceil32(return_data.size)) + 224] = assetAddress
        mem[(2 * ceil32(return_data.size)) + 256] = 0x38ed173900000000000000000000000000000000000000000000000000000000
        mem[(2 * ceil32(return_data.size)) + 260] = ext_call.return_data[0]
        mem[(2 * ceil32(return_data.size)) + 292] = 0
        mem[(2 * ceil32(return_data.size)) + 324] = 160
        mem[(2 * ceil32(return_data.size)) + 420] = 2
        idx = 0
        s = (2 * ceil32(return_data.size)) + 192
        t = (2 * ceil32(return_data.size)) + 452
        while idx < 2:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        mem[(2 * ceil32(return_data.size)) + 356] = this.address
        mem[(2 * ceil32(return_data.size)) + 388] = block.timestamp
        require ext_code.size(routerAddress)
        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
             gas gas_remaining wei
            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp, 2, mem[(2 * ceil32(return_data.size)) + 452 len 64]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[(2 * ceil32(return_data.size)) + 256 len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = (4 * ceil32(return_data.size)) + 256
        require return_data.size >= 32
        _171 = mem[(2 * ceil32(return_data.size)) + 256 len 4], ext_call.return_data[0 len 28]
        require mem[(2 * ceil32(return_data.size)) + 256 len 4], ext_call.return_data[0 len 28] <= test266151307()
        require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 256 len 4], ext_call.return_data[0 len 28] + 287 < (2 * ceil32(return_data.size)) + return_data.size + 256
        _174 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 256 len 4], ext_call.return_data[0 len 28] + 256]
        require mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 256 len 4], ext_call.return_data[0 len 28] + 256] <= test266151307()
        require (4 * ceil32(return_data.size)) + (32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 256 len 4], ext_call.return_data[0 len 28] + 256]) + 288 <= test266151307() and (32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 256 len 4], ext_call.return_data[0 len 28] + 256]) + 32 >= 0
        mem[64] = (4 * ceil32(return_data.size)) + (32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 256 len 4], ext_call.return_data[0 len 28] + 256]) + 288
        mem[(4 * ceil32(return_data.size)) + 256] = _174
        require _171 + (32 * _174) + 32 <= return_data.size
        idx = 0
        s = (2 * ceil32(return_data.size)) + _171 + 288
        t = (4 * ceil32(return_data.size)) + 288
        while idx < _174:
            require mem[s] == mem[s]
            mem[t] = mem[s]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        mem[mem[64] + 4] = this.address
        require ext_code.size(assetAddress)
        staticcall assetAddress.0x70a08231 with:
                gas gas_remaining wei
               args address(this.address)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _222 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _225 = mem[_222]
        require mem[_222] == mem[_222]
        mem[mem[64] + 4] = lendingPoolAddress
        mem[mem[64] + 36] = _225
        require ext_code.size(assetAddress)
        call assetAddress.approve(address arg1, uint256 arg2) with:
             gas gas_remaining wei
            args lendingPoolAddress, _225
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _234 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        require mem[_234] == bool(mem[_234])
        require ext_code.size(lendingPoolAddress)
        call lendingPoolAddress.deposit(address arg1, uint256 arg2, address arg3, uint16 arg4) with:
             gas gas_remaining wei
            args assetAddress, _225, address(this.address), 0
    else:
        if assetAddress == WAVAXAddress:
            mem[(2 * ceil32(return_data.size)) + 160] = 2
            mem[(2 * ceil32(return_data.size)) + 192] = sub_48996015Address
            mem[(2 * ceil32(return_data.size)) + 224] = assetAddress
            mem[(2 * ceil32(return_data.size)) + 256] = 0x38ed173900000000000000000000000000000000000000000000000000000000
            mem[(2 * ceil32(return_data.size)) + 260] = ext_call.return_data[0]
            mem[(2 * ceil32(return_data.size)) + 292] = 0
            mem[(2 * ceil32(return_data.size)) + 324] = 160
            mem[(2 * ceil32(return_data.size)) + 420] = 2
            idx = 0
            s = (2 * ceil32(return_data.size)) + 192
            t = (2 * ceil32(return_data.size)) + 452
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[(2 * ceil32(return_data.size)) + 356] = this.address
            mem[(2 * ceil32(return_data.size)) + 388] = block.timestamp
            require ext_code.size(routerAddress)
            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                 gas gas_remaining wei
                args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp, 2, mem[(2 * ceil32(return_data.size)) + 452 len 64]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[(2 * ceil32(return_data.size)) + 256 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = (4 * ceil32(return_data.size)) + 256
            require return_data.size >= 32
            _173 = mem[(2 * ceil32(return_data.size)) + 256 len 4], ext_call.return_data[0 len 28]
            require mem[(2 * ceil32(return_data.size)) + 256 len 4], ext_call.return_data[0 len 28] <= test266151307()
            require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 256 len 4], ext_call.return_data[0 len 28] + 287 < (2 * ceil32(return_data.size)) + return_data.size + 256
            _176 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 256 len 4], ext_call.return_data[0 len 28] + 256]
            require mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 256 len 4], ext_call.return_data[0 len 28] + 256] <= test266151307()
            require (4 * ceil32(return_data.size)) + (32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 256 len 4], ext_call.return_data[0 len 28] + 256]) + 288 <= test266151307() and (32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 256 len 4], ext_call.return_data[0 len 28] + 256]) + 32 >= 0
            mem[64] = (4 * ceil32(return_data.size)) + (32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 256 len 4], ext_call.return_data[0 len 28] + 256]) + 288
            mem[(4 * ceil32(return_data.size)) + 256] = _176
            require _173 + (32 * _176) + 32 <= return_data.size
            idx = 0
            s = (2 * ceil32(return_data.size)) + _173 + 288
            t = (4 * ceil32(return_data.size)) + 288
            while idx < _176:
                require mem[s] == mem[s]
                mem[t] = mem[s]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[mem[64] + 4] = this.address
            require ext_code.size(assetAddress)
            staticcall assetAddress.0x70a08231 with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _224 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _227 = mem[_224]
            require mem[_224] == mem[_224]
            mem[mem[64] + 4] = lendingPoolAddress
            mem[mem[64] + 36] = _227
            require ext_code.size(assetAddress)
            call assetAddress.approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args lendingPoolAddress, _227
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _236 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_236] == bool(mem[_236])
            require ext_code.size(lendingPoolAddress)
            call lendingPoolAddress.deposit(address arg1, uint256 arg2, address arg3, uint16 arg4) with:
                 gas gas_remaining wei
                args assetAddress, _227, address(this.address), 0
        else:
            mem[(2 * ceil32(return_data.size)) + 160] = 3
            mem[(2 * ceil32(return_data.size)) + 192] = sub_48996015Address
            mem[(2 * ceil32(return_data.size)) + 224] = WAVAXAddress
            mem[(2 * ceil32(return_data.size)) + 256] = assetAddress
            mem[(2 * ceil32(return_data.size)) + 288] = 0x38ed173900000000000000000000000000000000000000000000000000000000
            mem[(2 * ceil32(return_data.size)) + 292] = ext_call.return_data[0]
            mem[(2 * ceil32(return_data.size)) + 324] = 0
            mem[(2 * ceil32(return_data.size)) + 356] = 160
            mem[(2 * ceil32(return_data.size)) + 452] = 3
            idx = 0
            s = (2 * ceil32(return_data.size)) + 192
            t = (2 * ceil32(return_data.size)) + 484
            while idx < 3:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[(2 * ceil32(return_data.size)) + 388] = this.address
            mem[(2 * ceil32(return_data.size)) + 420] = block.timestamp
            require ext_code.size(routerAddress)
            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                 gas gas_remaining wei
                args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp, 3, mem[(2 * ceil32(return_data.size)) + 484 len 96]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[(2 * ceil32(return_data.size)) + 288 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = (4 * ceil32(return_data.size)) + 288
            require return_data.size >= 32
            _172 = mem[(2 * ceil32(return_data.size)) + 288 len 4], ext_call.return_data[0 len 28]
            require mem[(2 * ceil32(return_data.size)) + 288 len 4], ext_call.return_data[0 len 28] <= test266151307()
            require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 288 len 4], ext_call.return_data[0 len 28] + 319 < (2 * ceil32(return_data.size)) + return_data.size + 288
            _175 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 288 len 4], ext_call.return_data[0 len 28] + 288]
            require mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 288 len 4], ext_call.return_data[0 len 28] + 288] <= test266151307()
            require (4 * ceil32(return_data.size)) + (32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 288 len 4], ext_call.return_data[0 len 28] + 288]) + 320 <= test266151307() and (32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 288 len 4], ext_call.return_data[0 len 28] + 288]) + 32 >= 0
            mem[64] = (4 * ceil32(return_data.size)) + (32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 288 len 4], ext_call.return_data[0 len 28] + 288]) + 320
            mem[(4 * ceil32(return_data.size)) + 288] = _175
            require _172 + (32 * _175) + 32 <= return_data.size
            idx = 0
            s = (2 * ceil32(return_data.size)) + _172 + 320
            t = (4 * ceil32(return_data.size)) + 320
            while idx < _175:
                require mem[s] == mem[s]
                mem[t] = mem[s]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[mem[64] + 4] = this.address
            require ext_code.size(assetAddress)
            staticcall assetAddress.0x70a08231 with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _223 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _226 = mem[_223]
            require mem[_223] == mem[_223]
            mem[mem[64] + 4] = lendingPoolAddress
            mem[mem[64] + 36] = _226
            require ext_code.size(assetAddress)
            call assetAddress.approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args lendingPoolAddress, _226
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _235 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_235] == bool(mem[_235])
            require ext_code.size(lendingPoolAddress)
            call lendingPoolAddress.deposit(address arg1, uint256 arg2, address arg3, uint16 arg4) with:
                 gas gas_remaining wei
                args assetAddress, _226, address(this.address), 0
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}

function deposit(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    require stor0.length.field_160 <= 1
    if stor0.length.field_160:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Can't deposit while calculating the winner'
    if not latestRound:
        totalDeposited += arg1
        if not userInfo[address(msg.sender)].field_0:
            players.length++
            players[players.length] = msg.sender
        if arg1 <= 0:
            if not userInfo[address(msg.sender)].field_0:
                userInfo[address(msg.sender)].field_256 = 0
            else:
                require userInfo[address(msg.sender)].field_0
                if userInfo[address(msg.sender)].field_0 * sub_a9ac33dd / userInfo[address(msg.sender)].field_0 != sub_a9ac33dd:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
                userInfo[address(msg.sender)].field_256 = userInfo[address(msg.sender)].field_0 * sub_a9ac33dd / 10^12
        else:
            require ext_code.size(assetAddress)
            call assetAddress.0x23b872dd with:
                 gas gas_remaining wei
                args msg.sender, address(this.address), arg1
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            require ext_code.size(assetAddress)
            call assetAddress.approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args lendingPoolAddress, arg1
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            require ext_code.size(lendingPoolAddress)
            call lendingPoolAddress.deposit(address arg1, uint256 arg2, address arg3, uint16 arg4) with:
                 gas gas_remaining wei
                args assetAddress, arg1, address(this.address), 0
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if userInfo[address(msg.sender)].field_0 + arg1 < userInfo[address(msg.sender)].field_0:
                revert with 0, 'SafeMath: addition overflow'
            userInfo[address(msg.sender)].field_0 += arg1
            if not userInfo[address(msg.sender)].field_0:
                userInfo[address(msg.sender)].field_256 = 0
            else:
                require userInfo[address(msg.sender)].field_0
                if userInfo[address(msg.sender)].field_0 * sub_a9ac33dd / userInfo[address(msg.sender)].field_0 != sub_a9ac33dd:
                    revert with 0, 'SafeMath: multiplication overflow'
                userInfo[address(msg.sender)].field_256 = userInfo[address(msg.sender)].field_0 * sub_a9ac33dd / 10^12
    else:
        if block.timestamp > lastRewardTimestamp:
            if totalDeposited:
                if sub_f12c8e0d + sub_7f94bf16:
                    if lastRewardTimestamp > block.timestamp:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not block.timestamp - lastRewardTimestamp:
                        require ext_code.size(rewardWalletAddress)
                        call rewardWalletAddress.requestReward(uint256 arg1) with:
                             gas gas_remaining wei
                            args 0
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if totalDeposited <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalDeposited
                        if sub_a9ac33dd + (0 / totalDeposited) < sub_a9ac33dd:
                            revert with 0, 'SafeMath: addition overflow'
                        sub_a9ac33dd += 0 / totalDeposited
                    else:
                        require block.timestamp - lastRewardTimestamp
                        if block.timestamp - lastRewardTimestamp / block.timestamp - lastRewardTimestamp != 1:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
                        if not block.timestamp - lastRewardTimestamp:
                            if not block.timestamp - lastRewardTimestamp:
                                require ext_code.size(rewardWalletAddress)
                                call rewardWalletAddress.requestReward(uint256 arg1) with:
                                     gas gas_remaining wei
                                    args 0
                            else:
                                require block.timestamp - lastRewardTimestamp
                                if (block.timestamp * sub_f12c8e0d) - (lastRewardTimestamp * sub_f12c8e0d) / block.timestamp - lastRewardTimestamp != sub_f12c8e0d:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
                                if not (block.timestamp * sub_f12c8e0d) - (lastRewardTimestamp * sub_f12c8e0d):
                                    require ext_code.size(rewardWalletAddress)
                                    call rewardWalletAddress.requestReward(uint256 arg1) with:
                                         gas gas_remaining wei
                                        args 0
                                else:
                                    require (block.timestamp * sub_f12c8e0d) - (lastRewardTimestamp * sub_f12c8e0d)
                                    if (block.timestamp * sub_f12c8e0d) - (lastRewardTimestamp * sub_f12c8e0d) / (block.timestamp * sub_f12c8e0d) - (lastRewardTimestamp * sub_f12c8e0d) != 1:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
                                    require ext_code.size(rewardWalletAddress)
                                    call rewardWalletAddress.requestReward(uint256 arg1) with:
                                         gas gas_remaining wei
                                        args ((block.timestamp * sub_f12c8e0d) - (lastRewardTimestamp * sub_f12c8e0d))
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if totalDeposited <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require totalDeposited
                            if sub_a9ac33dd + (0 / totalDeposited) < sub_a9ac33dd:
                                revert with 0, 'SafeMath: addition overflow'
                            sub_a9ac33dd += 0 / totalDeposited
                        else:
                            require block.timestamp - lastRewardTimestamp
                            if (sub_f12c8e0d * block.timestamp) + (sub_7f94bf16 * block.timestamp) - (sub_f12c8e0d * lastRewardTimestamp) - (sub_7f94bf16 * lastRewardTimestamp) / block.timestamp - lastRewardTimestamp != sub_f12c8e0d + sub_7f94bf16:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
                            if not (sub_f12c8e0d * block.timestamp) + (sub_7f94bf16 * block.timestamp) - (sub_f12c8e0d * lastRewardTimestamp) - (sub_7f94bf16 * lastRewardTimestamp):
                                if not block.timestamp - lastRewardTimestamp:
                                    require ext_code.size(rewardWalletAddress)
                                    call rewardWalletAddress.requestReward(uint256 arg1) with:
                                         gas gas_remaining wei
                                        args 0
                                else:
                                    require block.timestamp - lastRewardTimestamp
                                    if (block.timestamp * sub_f12c8e0d) - (lastRewardTimestamp * sub_f12c8e0d) / block.timestamp - lastRewardTimestamp != sub_f12c8e0d:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
                                    if not (block.timestamp * sub_f12c8e0d) - (lastRewardTimestamp * sub_f12c8e0d):
                                        require ext_code.size(rewardWalletAddress)
                                        call rewardWalletAddress.requestReward(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args 0
                                    else:
                                        require (block.timestamp * sub_f12c8e0d) - (lastRewardTimestamp * sub_f12c8e0d)
                                        if (block.timestamp * sub_f12c8e0d) - (lastRewardTimestamp * sub_f12c8e0d) / (block.timestamp * sub_f12c8e0d) - (lastRewardTimestamp * sub_f12c8e0d) != 1:
                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
                                        require ext_code.size(rewardWalletAddress)
                                        call rewardWalletAddress.requestReward(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args ((block.timestamp * sub_f12c8e0d) - (lastRewardTimestamp * sub_f12c8e0d))
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if totalDeposited <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require totalDeposited
                                if sub_a9ac33dd + (0 / totalDeposited) < sub_a9ac33dd:
                                    revert with 0, 'SafeMath: addition overflow'
                                sub_a9ac33dd += 0 / totalDeposited
                            else:
                                require (sub_f12c8e0d * block.timestamp) + (sub_7f94bf16 * block.timestamp) - (sub_f12c8e0d * lastRewardTimestamp) - (sub_7f94bf16 * lastRewardTimestamp)
                                if (sub_f12c8e0d * block.timestamp) + (sub_7f94bf16 * block.timestamp) - (sub_f12c8e0d * lastRewardTimestamp) - (sub_7f94bf16 * lastRewardTimestamp) / (sub_f12c8e0d * block.timestamp) + (sub_7f94bf16 * block.timestamp) - (sub_f12c8e0d * lastRewardTimestamp) - (sub_7f94bf16 * lastRewardTimestamp) != 1:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
                                if not block.timestamp - lastRewardTimestamp:
                                    require ext_code.size(rewardWalletAddress)
                                    call rewardWalletAddress.requestReward(uint256 arg1) with:
                                         gas gas_remaining wei
                                        args 0
                                else:
                                    require block.timestamp - lastRewardTimestamp
                                    if (block.timestamp * sub_f12c8e0d) - (lastRewardTimestamp * sub_f12c8e0d) / block.timestamp - lastRewardTimestamp != sub_f12c8e0d:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
                                    if not (block.timestamp * sub_f12c8e0d) - (lastRewardTimestamp * sub_f12c8e0d):
                                        require ext_code.size(rewardWalletAddress)
                                        call rewardWalletAddress.requestReward(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args 0
                                    else:
                                        require (block.timestamp * sub_f12c8e0d) - (lastRewardTimestamp * sub_f12c8e0d)
                                        if (block.timestamp * sub_f12c8e0d) - (lastRewardTimestamp * sub_f12c8e0d) / (block.timestamp * sub_f12c8e0d) - (lastRewardTimestamp * sub_f12c8e0d) != 1:
                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
                                        require ext_code.size(rewardWalletAddress)
                                        call rewardWalletAddress.requestReward(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args ((block.timestamp * sub_f12c8e0d) - (lastRewardTimestamp * sub_f12c8e0d))
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if not (sub_f12c8e0d * block.timestamp) + (sub_7f94bf16 * block.timestamp) - (sub_f12c8e0d * lastRewardTimestamp) - (sub_7f94bf16 * lastRewardTimestamp):
                                    if totalDeposited <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require totalDeposited
                                    if sub_a9ac33dd + (0 / totalDeposited) < sub_a9ac33dd:
                                        revert with 0, 'SafeMath: addition overflow'
                                    sub_a9ac33dd += 0 / totalDeposited
                                else:
                                    require (sub_f12c8e0d * block.timestamp) + (sub_7f94bf16 * block.timestamp) - (sub_f12c8e0d * lastRewardTimestamp) - (sub_7f94bf16 * lastRewardTimestamp)
                                    if (10^12 * sub_f12c8e0d * block.timestamp) + (10^12 * sub_7f94bf16 * block.timestamp) - (10^12 * sub_f12c8e0d * lastRewardTimestamp) - (10^12 * sub_7f94bf16 * lastRewardTimestamp) / (sub_f12c8e0d * block.timestamp) + (sub_7f94bf16 * block.timestamp) - (sub_f12c8e0d * lastRewardTimestamp) - (sub_7f94bf16 * lastRewardTimestamp) != 10^12:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
                                    if totalDeposited <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require totalDeposited
                                    if sub_a9ac33dd + ((10^12 * sub_f12c8e0d * block.timestamp) + (10^12 * sub_7f94bf16 * block.timestamp) - (10^12 * sub_f12c8e0d * lastRewardTimestamp) - (10^12 * sub_7f94bf16 * lastRewardTimestamp) / totalDeposited) < sub_a9ac33dd:
                                        revert with 0, 'SafeMath: addition overflow'
                                    sub_a9ac33dd += (10^12 * sub_f12c8e0d * block.timestamp) + (10^12 * sub_7f94bf16 * block.timestamp) - (10^12 * sub_f12c8e0d * lastRewardTimestamp) - (10^12 * sub_7f94bf16 * lastRewardTimestamp) / totalDeposited
            lastRewardTimestamp = block.timestamp
        totalDeposited += arg1
        if not latestRound:
            if not userInfo[address(msg.sender)].field_0:
                players.length++
                players[players.length] = msg.sender
            if arg1 <= 0:
                if not userInfo[address(msg.sender)].field_0:
                    userInfo[address(msg.sender)].field_256 = 0
                else:
                    require userInfo[address(msg.sender)].field_0
                    if userInfo[address(msg.sender)].field_0 * sub_a9ac33dd / userInfo[address(msg.sender)].field_0 != sub_a9ac33dd:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
                    userInfo[address(msg.sender)].field_256 = userInfo[address(msg.sender)].field_0 * sub_a9ac33dd / 10^12
            else:
                require ext_code.size(assetAddress)
                call assetAddress.0x23b872dd with:
                     gas gas_remaining wei
                    args msg.sender, address(this.address), arg1
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                require ext_code.size(assetAddress)
                call assetAddress.approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args lendingPoolAddress, arg1
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                require ext_code.size(lendingPoolAddress)
                call lendingPoolAddress.deposit(address arg1, uint256 arg2, address arg3, uint16 arg4) with:
                     gas gas_remaining wei
                    args assetAddress, arg1, address(this.address), 0
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if userInfo[address(msg.sender)].field_0 + arg1 < userInfo[address(msg.sender)].field_0:
                    revert with 0, 'SafeMath: addition overflow'
                userInfo[address(msg.sender)].field_0 += arg1
                if not userInfo[address(msg.sender)].field_0:
                    userInfo[address(msg.sender)].field_256 = 0
                else:
                    require userInfo[address(msg.sender)].field_0
                    if userInfo[address(msg.sender)].field_0 * sub_a9ac33dd / userInfo[address(msg.sender)].field_0 != sub_a9ac33dd:
                        revert with 0, 'SafeMath: multiplication overflow'
                    userInfo[address(msg.sender)].field_256 = userInfo[address(msg.sender)].field_0 * sub_a9ac33dd / 10^12
        else:
            if userInfo[address(msg.sender)].field_0 <= 0:
                if not userInfo[address(msg.sender)].field_0:
                    players.length++
                    players[players.length] = msg.sender
                if arg1 <= 0:
                    if not userInfo[address(msg.sender)].field_0:
                        userInfo[address(msg.sender)].field_256 = 0
                    else:
                        require userInfo[address(msg.sender)].field_0
                        if userInfo[address(msg.sender)].field_0 * sub_a9ac33dd / userInfo[address(msg.sender)].field_0 != sub_a9ac33dd:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
                        userInfo[address(msg.sender)].field_256 = userInfo[address(msg.sender)].field_0 * sub_a9ac33dd / 10^12
                else:
                    require ext_code.size(assetAddress)
                    call assetAddress.0x23b872dd with:
                         gas gas_remaining wei
                        args msg.sender, address(this.address), arg1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                    require ext_code.size(assetAddress)
                    call assetAddress.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args lendingPoolAddress, arg1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                    require ext_code.size(lendingPoolAddress)
                    call lendingPoolAddress.deposit(address arg1, uint256 arg2, address arg3, uint16 arg4) with:
                         gas gas_remaining wei
                        args assetAddress, arg1, address(this.address), 0
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if userInfo[address(msg.sender)].field_0 + arg1 < userInfo[address(msg.sender)].field_0:
                        revert with 0, 'SafeMath: addition overflow'
                    userInfo[address(msg.sender)].field_0 += arg1
                    if not userInfo[address(msg.sender)].field_0:
                        userInfo[address(msg.sender)].field_256 = 0
                    else:
                        require userInfo[address(msg.sender)].field_0
                        if userInfo[address(msg.sender)].field_0 * sub_a9ac33dd / userInfo[address(msg.sender)].field_0 != sub_a9ac33dd:
                            revert with 0, 'SafeMath: multiplication overflow'
                        userInfo[address(msg.sender)].field_256 = userInfo[address(msg.sender)].field_0 * sub_a9ac33dd / 10^12
            else:
                if not userInfo[address(msg.sender)].field_0:
                    if userInfo[address(msg.sender)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if -userInfo[address(msg.sender)].field_256 <= 0:
                        if not userInfo[address(msg.sender)].field_0:
                            players.length++
                            players[players.length] = msg.sender
                        if arg1 <= 0:
                            if not userInfo[address(msg.sender)].field_0:
                                userInfo[address(msg.sender)].field_256 = 0
                            else:
                                require userInfo[address(msg.sender)].field_0
                                if userInfo[address(msg.sender)].field_0 * sub_a9ac33dd / userInfo[address(msg.sender)].field_0 != sub_a9ac33dd:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
                                userInfo[address(msg.sender)].field_256 = userInfo[address(msg.sender)].field_0 * sub_a9ac33dd / 10^12
                        else:
                            require ext_code.size(assetAddress)
                            call assetAddress.0x23b872dd with:
                                 gas gas_remaining wei
                                args msg.sender, address(this.address), arg1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            require ext_code.size(assetAddress)
                            call assetAddress.approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args lendingPoolAddress, arg1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            require ext_code.size(lendingPoolAddress)
                            call lendingPoolAddress.deposit(address arg1, uint256 arg2, address arg3, uint16 arg4) with:
                                 gas gas_remaining wei
                                args assetAddress, arg1, address(this.address), 0
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if userInfo[address(msg.sender)].field_0 + arg1 < userInfo[address(msg.sender)].field_0:
                                revert with 0, 'SafeMath: addition overflow'
                            userInfo[address(msg.sender)].field_0 += arg1
                            if not userInfo[address(msg.sender)].field_0:
                                userInfo[address(msg.sender)].field_256 = 0
                            else:
                                require userInfo[address(msg.sender)].field_0
                                if userInfo[address(msg.sender)].field_0 * sub_a9ac33dd / userInfo[address(msg.sender)].field_0 != sub_a9ac33dd:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                userInfo[address(msg.sender)].field_256 = userInfo[address(msg.sender)].field_0 * sub_a9ac33dd / 10^12
                    else:
                        require ext_code.size(rewardTokenAddress)
                        staticcall rewardTokenAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[0]
                        require ext_code.size(rewardTokenAddress)
                        if -userInfo[address(msg.sender)].field_256 <= ext_call.return_data[0]:
                            call rewardTokenAddress.0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, -userInfo[address(msg.sender)].field_256
                        else:
                            call rewardTokenAddress.0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                        if not ext_call.return_data[0]:
                            revert with 0, 'safeTokenTransfer: transfer failed'
                        if not userInfo[address(msg.sender)].field_0:
                            players.length++
                            players[players.length] = msg.sender
                        if arg1 > 0:
                            require ext_code.size(assetAddress)
                            call assetAddress.0x23b872dd with:
                                 gas gas_remaining wei
                                args msg.sender, address(this.address), arg1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            require ext_code.size(assetAddress)
                            call assetAddress.approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args lendingPoolAddress, arg1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            require ext_code.size(lendingPoolAddress)
                            call lendingPoolAddress.deposit(address arg1, uint256 arg2, address arg3, uint16 arg4) with:
                                 gas gas_remaining wei
                                args assetAddress, arg1, address(this.address), 0
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if userInfo[address(msg.sender)].field_0 + arg1 < userInfo[address(msg.sender)].field_0:
                                revert with 0, 'SafeMath: addition overflow'
                            userInfo[address(msg.sender)].field_0 += arg1
                        if not userInfo[address(msg.sender)].field_0:
                            userInfo[address(msg.sender)].field_256 = 0
                        else:
                            require userInfo[address(msg.sender)].field_0
                            if userInfo[address(msg.sender)].field_0 * sub_a9ac33dd / userInfo[address(msg.sender)].field_0 != sub_a9ac33dd:
                                revert with 0, 'SafeMath: multiplication overflow'
                            userInfo[address(msg.sender)].field_256 = userInfo[address(msg.sender)].field_0 * sub_a9ac33dd / 10^12
                else:
                    require userInfo[address(msg.sender)].field_0
                    if userInfo[address(msg.sender)].field_0 * sub_a9ac33dd / userInfo[address(msg.sender)].field_0 != sub_a9ac33dd:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
                    if userInfo[address(msg.sender)].field_256 > userInfo[address(msg.sender)].field_0 * sub_a9ac33dd / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if (userInfo[address(msg.sender)].field_0 * sub_a9ac33dd / 10^12) - userInfo[address(msg.sender)].field_256 <= 0:
                        if not userInfo[address(msg.sender)].field_0:
                            players.length++
                            players[players.length] = msg.sender
                        if arg1 <= 0:
                            if not userInfo[address(msg.sender)].field_0:
                                userInfo[address(msg.sender)].field_256 = 0
                            else:
                                require userInfo[address(msg.sender)].field_0
                                if userInfo[address(msg.sender)].field_0 * sub_a9ac33dd / userInfo[address(msg.sender)].field_0 != sub_a9ac33dd:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
                                userInfo[address(msg.sender)].field_256 = userInfo[address(msg.sender)].field_0 * sub_a9ac33dd / 10^12
                        else:
                            require ext_code.size(assetAddress)
                            call assetAddress.0x23b872dd with:
                                 gas gas_remaining wei
                                args msg.sender, address(this.address), arg1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            require ext_code.size(assetAddress)
                            call assetAddress.approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args lendingPoolAddress, arg1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            require ext_code.size(lendingPoolAddress)
                            call lendingPoolAddress.deposit(address arg1, uint256 arg2, address arg3, uint16 arg4) with:
                                 gas gas_remaining wei
                                args assetAddress, arg1, address(this.address), 0
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if userInfo[address(msg.sender)].field_0 + arg1 < userInfo[address(msg.sender)].field_0:
                                revert with 0, 'SafeMath: addition overflow'
                            userInfo[address(msg.sender)].field_0 += arg1
                            if not userInfo[address(msg.sender)].field_0:
                                userInfo[address(msg.sender)].field_256 = 0
                            else:
                                require userInfo[address(msg.sender)].field_0
                                if userInfo[address(msg.sender)].field_0 * sub_a9ac33dd / userInfo[address(msg.sender)].field_0 != sub_a9ac33dd:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                userInfo[address(msg.sender)].field_256 = userInfo[address(msg.sender)].field_0 * sub_a9ac33dd / 10^12
                    else:
                        require ext_code.size(rewardTokenAddress)
                        staticcall rewardTokenAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[0]
                        require ext_code.size(rewardTokenAddress)
                        if (userInfo[address(msg.sender)].field_0 * sub_a9ac33dd / 10^12) - userInfo[address(msg.sender)].field_256 <= ext_call.return_data[0]:
                            call rewardTokenAddress.0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, (userInfo[address(msg.sender)].field_0 * sub_a9ac33dd / 10^12) - userInfo[address(msg.sender)].field_256
                        else:
                            call rewardTokenAddress.0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                        if not ext_call.return_data[0]:
                            revert with 0, 'safeTokenTransfer: transfer failed'
                        if not userInfo[address(msg.sender)].field_0:
                            players.length++
                            players[players.length] = msg.sender
                        if arg1 > 0:
                            require ext_code.size(assetAddress)
                            call assetAddress.0x23b872dd with:
                                 gas gas_remaining wei
                                args msg.sender, address(this.address), arg1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            require ext_code.size(assetAddress)
                            call assetAddress.approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args lendingPoolAddress, arg1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            require ext_code.size(lendingPoolAddress)
                            call lendingPoolAddress.deposit(address arg1, uint256 arg2, address arg3, uint16 arg4) with:
                                 gas gas_remaining wei
                                args assetAddress, arg1, address(this.address), 0
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if userInfo[address(msg.sender)].field_0 + arg1 < userInfo[address(msg.sender)].field_0:
                                revert with 0, 'SafeMath: addition overflow'
                            userInfo[address(msg.sender)].field_0 += arg1
                        if not userInfo[address(msg.sender)].field_0:
                            userInfo[address(msg.sender)].field_256 = 0
                        else:
                            require userInfo[address(msg.sender)].field_0
                            if userInfo[address(msg.sender)].field_0 * sub_a9ac33dd / userInfo[address(msg.sender)].field_0 != sub_a9ac33dd:
                                revert with 0, 'SafeMath: multiplication overflow'
                            userInfo[address(msg.sender)].field_256 = userInfo[address(msg.sender)].field_0 * sub_a9ac33dd / 10^12
    emit Deposit(msg.sender, arg1);
}

function drawWinner(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if address(stor0.length) != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    stor0.length.field_160 = 1
    _randomness = arg1
    if sub_84beb6e6 + sub_0b4b41bc < sub_84beb6e6:
        revert with 0, 'SafeMath: addition overflow'
    if sub_84beb6e6 + sub_0b4b41bc > block.timestamp:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'it's not yet time for the round to end'
    if not latestRound:
        lastRewardTimestamp = block.timestamp
        mem[100] = this.address
        require ext_code.size(sub_b8ab24bdAddress)
        staticcall sub_b8ab24bdAddress.0x70a08231 with:
                gas gas_remaining wei
               args this.address
        mem[96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[0]
        if not ext_call.return_data[0] - totalDeposited:
            if not ext_call.return_data[0] - totalDeposited:
                if not ext_call.return_data[0] - totalDeposited:
                    sub_bf4c8572 = 0
                    mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                    mem[ceil32(return_data.size) + 132] = -1
                    require ext_code.size(sub_b8ab24bdAddress)
                    call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args lendingPoolAddress, -1
                    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                    mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                    mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                    mem[(2 * ceil32(return_data.size)) + 164] = this.address
                    require ext_code.size(lendingPoolAddress)
                    call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                         gas gas_remaining wei
                        args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                    mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                    mem[(4 * ceil32(return_data.size)) + 132] = -1
                    require ext_code.size(assetAddress)
                    call assetAddress.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args routerAddress, -1
                    mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                    if assetAddress == WAVAXAddress:
                        mem[(6 * ceil32(return_data.size)) + 96] = 2
                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                        mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                        mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(6 * ceil32(return_data.size)) + 196] = 0
                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                        mem[(6 * ceil32(return_data.size)) + 260] = 160
                        mem[(6 * ceil32(return_data.size)) + 356] = 2
                        idx = 0
                        s = (6 * ceil32(return_data.size)) + 128
                        t = (6 * ceil32(return_data.size)) + 388
                        while idx < 2:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[(6 * ceil32(return_data.size)) + 292] = this.address
                        mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                        require ext_code.size(routerAddress)
                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (7 * ceil32(return_data.size)) + 192
                        require return_data.size >= 32
                        _3132 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                        require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                        _3279 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                        mem[(7 * ceil32(return_data.size)) + 192] = _3279
                        require _3132 + (32 * _3279) + 32 <= return_data.size
                        idx = 0
                        s = (6 * ceil32(return_data.size)) + _3132 + 224
                        t = (7 * ceil32(return_data.size)) + 224
                        while idx < _3279:
                            require mem[s] == mem[s]
                            mem[t] = mem[s]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(rewardTokenAddress)
                        staticcall rewardTokenAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _12180 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_12180] == mem[_12180]
                        if sub_0b4b41bc <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require sub_0b4b41bc
                        sub_7f94bf16 = mem[_12180] / sub_0b4b41bc
                        mem[mem[64] + 4] = treasuryAddress
                        mem[mem[64] + 36] = 0
                        require ext_code.size(assetAddress)
                        call assetAddress.0xa9059cbb with:
                             gas gas_remaining wei
                            args treasuryAddress, 0
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _15350 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_15350] == bool(mem[_15350])
                    else:
                        if rewardTokenAddress == WAVAXAddress:
                            mem[(6 * ceil32(return_data.size)) + 96] = 2
                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                            mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                            mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[(6 * ceil32(return_data.size)) + 196] = 0
                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                            mem[(6 * ceil32(return_data.size)) + 260] = 160
                            mem[(6 * ceil32(return_data.size)) + 356] = 2
                            idx = 0
                            s = (6 * ceil32(return_data.size)) + 128
                            t = (6 * ceil32(return_data.size)) + 388
                            while idx < 2:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[(6 * ceil32(return_data.size)) + 292] = this.address
                            mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                            require ext_code.size(routerAddress)
                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (7 * ceil32(return_data.size)) + 192
                            require return_data.size >= 32
                            _3134 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                            require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                            _3281 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                            mem[(7 * ceil32(return_data.size)) + 192] = _3281
                            require _3134 + (32 * _3281) + 32 <= return_data.size
                            idx = 0
                            s = (6 * ceil32(return_data.size)) + _3134 + 224
                            t = (7 * ceil32(return_data.size)) + 224
                            while idx < _3281:
                                require mem[s] == mem[s]
                                mem[t] = mem[s]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(rewardTokenAddress)
                            staticcall rewardTokenAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _12182 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_12182] == mem[_12182]
                            if sub_0b4b41bc <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require sub_0b4b41bc
                            sub_7f94bf16 = mem[_12182] / sub_0b4b41bc
                            mem[mem[64] + 4] = treasuryAddress
                            mem[mem[64] + 36] = 0
                            require ext_code.size(assetAddress)
                            call assetAddress.0xa9059cbb with:
                                 gas gas_remaining wei
                                args treasuryAddress, 0
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _15352 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_15352] == bool(mem[_15352])
                        else:
                            mem[(6 * ceil32(return_data.size)) + 96] = 3
                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                            mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                            mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                            mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                            mem[(6 * ceil32(return_data.size)) + 260] = 0
                            mem[(6 * ceil32(return_data.size)) + 292] = 160
                            mem[(6 * ceil32(return_data.size)) + 388] = 3
                            idx = 0
                            s = (6 * ceil32(return_data.size)) + 128
                            t = (6 * ceil32(return_data.size)) + 420
                            while idx < 3:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[(6 * ceil32(return_data.size)) + 324] = this.address
                            mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                            require ext_code.size(routerAddress)
                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args 0, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (7 * ceil32(return_data.size)) + 224
                            require return_data.size >= 32
                            _3133 = mem[(6 * ceil32(return_data.size)) + 224 len 4], 0
                            require mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 <= test266151307()
                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                            _3280 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]
                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224] <= test266151307()
                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 32 >= 0
                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256
                            mem[(7 * ceil32(return_data.size)) + 224] = _3280
                            require _3133 + (32 * _3280) + 32 <= return_data.size
                            idx = 0
                            s = (6 * ceil32(return_data.size)) + _3133 + 256
                            t = (7 * ceil32(return_data.size)) + 256
                            while idx < _3280:
                                require mem[s] == mem[s]
                                mem[t] = mem[s]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(rewardTokenAddress)
                            staticcall rewardTokenAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _12181 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_12181] == mem[_12181]
                            if sub_0b4b41bc <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require sub_0b4b41bc
                            sub_7f94bf16 = mem[_12181] / sub_0b4b41bc
                            mem[mem[64] + 4] = treasuryAddress
                            mem[mem[64] + 36] = 0
                            require ext_code.size(assetAddress)
                            call assetAddress.0xa9059cbb with:
                                 gas gas_remaining wei
                                args treasuryAddress, 0
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _15351 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_15351] == bool(mem[_15351])
                else:
                    require ext_call.return_data[0] - totalDeposited
                    if (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / ext_call.return_data[0] - totalDeposited != sub_7e72b29f:
                        revert with 0, 'SafeMath: multiplication overflow'
                    sub_bf4c8572 = (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / 10000
                    mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                    mem[ceil32(return_data.size) + 132] = -1
                    require ext_code.size(sub_b8ab24bdAddress)
                    call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args lendingPoolAddress, -1
                    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                    mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                    mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                    mem[(2 * ceil32(return_data.size)) + 164] = this.address
                    require ext_code.size(lendingPoolAddress)
                    call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                         gas gas_remaining wei
                        args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                    mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                    mem[(4 * ceil32(return_data.size)) + 132] = -1
                    require ext_code.size(assetAddress)
                    call assetAddress.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args routerAddress, -1
                    mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                    if assetAddress == WAVAXAddress:
                        mem[(6 * ceil32(return_data.size)) + 96] = 2
                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                        mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                        mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(6 * ceil32(return_data.size)) + 196] = 0
                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                        mem[(6 * ceil32(return_data.size)) + 260] = 160
                        mem[(6 * ceil32(return_data.size)) + 356] = 2
                        idx = 0
                        s = (6 * ceil32(return_data.size)) + 128
                        t = (6 * ceil32(return_data.size)) + 388
                        while idx < 2:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[(6 * ceil32(return_data.size)) + 292] = this.address
                        mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                        require ext_code.size(routerAddress)
                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (7 * ceil32(return_data.size)) + 192
                        require return_data.size >= 32
                        _3129 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                        require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                        _3276 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                        mem[(7 * ceil32(return_data.size)) + 192] = _3276
                        require _3129 + (32 * _3276) + 32 <= return_data.size
                        idx = 0
                        s = (6 * ceil32(return_data.size)) + _3129 + 224
                        t = (7 * ceil32(return_data.size)) + 224
                        while idx < _3276:
                            require mem[s] == mem[s]
                            mem[t] = mem[s]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(rewardTokenAddress)
                        staticcall rewardTokenAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _12177 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_12177] == mem[_12177]
                        if sub_0b4b41bc <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require sub_0b4b41bc
                        sub_7f94bf16 = mem[_12177] / sub_0b4b41bc
                        mem[mem[64] + 4] = treasuryAddress
                        mem[mem[64] + 36] = 0
                        require ext_code.size(assetAddress)
                        call assetAddress.0xa9059cbb with:
                             gas gas_remaining wei
                            args treasuryAddress, 0
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _15347 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_15347] == bool(mem[_15347])
                    else:
                        if rewardTokenAddress == WAVAXAddress:
                            mem[(6 * ceil32(return_data.size)) + 96] = 2
                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                            mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                            mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[(6 * ceil32(return_data.size)) + 196] = 0
                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                            mem[(6 * ceil32(return_data.size)) + 260] = 160
                            mem[(6 * ceil32(return_data.size)) + 356] = 2
                            idx = 0
                            s = (6 * ceil32(return_data.size)) + 128
                            t = (6 * ceil32(return_data.size)) + 388
                            while idx < 2:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[(6 * ceil32(return_data.size)) + 292] = this.address
                            mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                            require ext_code.size(routerAddress)
                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (7 * ceil32(return_data.size)) + 192
                            require return_data.size >= 32
                            _3131 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                            require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                            _3278 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                            mem[(7 * ceil32(return_data.size)) + 192] = _3278
                            require _3131 + (32 * _3278) + 32 <= return_data.size
                            idx = 0
                            s = (6 * ceil32(return_data.size)) + _3131 + 224
                            t = (7 * ceil32(return_data.size)) + 224
                            while idx < _3278:
                                require mem[s] == mem[s]
                                mem[t] = mem[s]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(rewardTokenAddress)
                            staticcall rewardTokenAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _12179 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_12179] == mem[_12179]
                            if sub_0b4b41bc <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require sub_0b4b41bc
                            sub_7f94bf16 = mem[_12179] / sub_0b4b41bc
                            mem[mem[64] + 4] = treasuryAddress
                            mem[mem[64] + 36] = 0
                            require ext_code.size(assetAddress)
                            call assetAddress.0xa9059cbb with:
                                 gas gas_remaining wei
                                args treasuryAddress, 0
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _15349 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_15349] == bool(mem[_15349])
                        else:
                            mem[(6 * ceil32(return_data.size)) + 96] = 3
                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                            mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                            mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                            mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                            mem[(6 * ceil32(return_data.size)) + 260] = 0
                            mem[(6 * ceil32(return_data.size)) + 292] = 160
                            mem[(6 * ceil32(return_data.size)) + 388] = 3
                            idx = 0
                            s = (6 * ceil32(return_data.size)) + 128
                            t = (6 * ceil32(return_data.size)) + 420
                            while idx < 3:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[(6 * ceil32(return_data.size)) + 324] = this.address
                            mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                            require ext_code.size(routerAddress)
                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args 0, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (7 * ceil32(return_data.size)) + 224
                            require return_data.size >= 32
                            _3130 = mem[(6 * ceil32(return_data.size)) + 224 len 4], 0
                            require mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 <= test266151307()
                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                            _3277 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]
                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224] <= test266151307()
                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 32 >= 0
                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256
                            mem[(7 * ceil32(return_data.size)) + 224] = _3277
                            require _3130 + (32 * _3277) + 32 <= return_data.size
                            idx = 0
                            s = (6 * ceil32(return_data.size)) + _3130 + 256
                            t = (7 * ceil32(return_data.size)) + 256
                            while idx < _3277:
                                require mem[s] == mem[s]
                                mem[t] = mem[s]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(rewardTokenAddress)
                            staticcall rewardTokenAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _12178 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_12178] == mem[_12178]
                            if sub_0b4b41bc <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require sub_0b4b41bc
                            sub_7f94bf16 = mem[_12178] / sub_0b4b41bc
                            mem[mem[64] + 4] = treasuryAddress
                            mem[mem[64] + 36] = 0
                            require ext_code.size(assetAddress)
                            call assetAddress.0xa9059cbb with:
                                 gas gas_remaining wei
                                args treasuryAddress, 0
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _15348 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_15348] == bool(mem[_15348])
            else:
                require ext_call.return_data[0] - totalDeposited
                if (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / ext_call.return_data[0] - totalDeposited != sub_2f6236be:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not ext_call.return_data[0] - totalDeposited:
                    sub_bf4c8572 = 0
                    mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                    mem[ceil32(return_data.size) + 132] = -1
                    require ext_code.size(sub_b8ab24bdAddress)
                    call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args lendingPoolAddress, -1
                    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                    mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                    mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                    mem[(2 * ceil32(return_data.size)) + 164] = this.address
                    require ext_code.size(lendingPoolAddress)
                    call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                         gas gas_remaining wei
                        args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                    mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                    mem[(4 * ceil32(return_data.size)) + 132] = -1
                    require ext_code.size(assetAddress)
                    call assetAddress.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args routerAddress, -1
                    mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                    if assetAddress == WAVAXAddress:
                        mem[(6 * ceil32(return_data.size)) + 96] = 2
                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                        mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                        mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                        mem[(6 * ceil32(return_data.size)) + 260] = 160
                        mem[(6 * ceil32(return_data.size)) + 356] = 2
                        idx = 0
                        s = (6 * ceil32(return_data.size)) + 128
                        t = (6 * ceil32(return_data.size)) + 388
                        while idx < 2:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[(6 * ceil32(return_data.size)) + 292] = this.address
                        mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                        require ext_code.size(routerAddress)
                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (7 * ceil32(return_data.size)) + 192
                        require return_data.size >= 32
                        _3126 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                        require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                        _3273 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                        mem[(7 * ceil32(return_data.size)) + 192] = _3273
                        require _3126 + (32 * _3273) + 32 <= return_data.size
                        idx = 0
                        s = (6 * ceil32(return_data.size)) + _3126 + 224
                        t = (7 * ceil32(return_data.size)) + 224
                        while idx < _3273:
                            require mem[s] == mem[s]
                            mem[t] = mem[s]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(rewardTokenAddress)
                        staticcall rewardTokenAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _12174 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_12174] == mem[_12174]
                        if sub_0b4b41bc <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require sub_0b4b41bc
                        sub_7f94bf16 = mem[_12174] / sub_0b4b41bc
                        mem[mem[64] + 4] = treasuryAddress
                        mem[mem[64] + 36] = 0
                        require ext_code.size(assetAddress)
                        call assetAddress.0xa9059cbb with:
                             gas gas_remaining wei
                            args treasuryAddress, 0
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _15344 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_15344] == bool(mem[_15344])
                    else:
                        if rewardTokenAddress == WAVAXAddress:
                            mem[(6 * ceil32(return_data.size)) + 96] = 2
                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                            mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                            mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                            mem[(6 * ceil32(return_data.size)) + 260] = 160
                            mem[(6 * ceil32(return_data.size)) + 356] = 2
                            idx = 0
                            s = (6 * ceil32(return_data.size)) + 128
                            t = (6 * ceil32(return_data.size)) + 388
                            while idx < 2:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[(6 * ceil32(return_data.size)) + 292] = this.address
                            mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                            require ext_code.size(routerAddress)
                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (7 * ceil32(return_data.size)) + 192
                            require return_data.size >= 32
                            _3128 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                            require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                            _3275 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                            mem[(7 * ceil32(return_data.size)) + 192] = _3275
                            require _3128 + (32 * _3275) + 32 <= return_data.size
                            idx = 0
                            s = (6 * ceil32(return_data.size)) + _3128 + 224
                            t = (7 * ceil32(return_data.size)) + 224
                            while idx < _3275:
                                require mem[s] == mem[s]
                                mem[t] = mem[s]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(rewardTokenAddress)
                            staticcall rewardTokenAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _12176 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_12176] == mem[_12176]
                            if sub_0b4b41bc <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require sub_0b4b41bc
                            sub_7f94bf16 = mem[_12176] / sub_0b4b41bc
                            mem[mem[64] + 4] = treasuryAddress
                            mem[mem[64] + 36] = 0
                            require ext_code.size(assetAddress)
                            call assetAddress.0xa9059cbb with:
                                 gas gas_remaining wei
                                args treasuryAddress, 0
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _15346 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_15346] == bool(mem[_15346])
                        else:
                            mem[(6 * ceil32(return_data.size)) + 96] = 3
                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                            mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                            mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                            mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[(6 * ceil32(return_data.size)) + 228] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                            mem[(6 * ceil32(return_data.size)) + 260] = 0
                            mem[(6 * ceil32(return_data.size)) + 292] = 160
                            mem[(6 * ceil32(return_data.size)) + 388] = 3
                            idx = 0
                            s = (6 * ceil32(return_data.size)) + 128
                            t = (6 * ceil32(return_data.size)) + 420
                            while idx < 3:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[(6 * ceil32(return_data.size)) + 324] = this.address
                            mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                            require ext_code.size(routerAddress)
                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (7 * ceil32(return_data.size)) + 224
                            require return_data.size >= 32
                            _3127 = mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                            require mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                            _3274 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]
                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224] <= test266151307()
                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 32 >= 0
                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256
                            mem[(7 * ceil32(return_data.size)) + 224] = _3274
                            require _3127 + (32 * _3274) + 32 <= return_data.size
                            idx = 0
                            s = (6 * ceil32(return_data.size)) + _3127 + 256
                            t = (7 * ceil32(return_data.size)) + 256
                            while idx < _3274:
                                require mem[s] == mem[s]
                                mem[t] = mem[s]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(rewardTokenAddress)
                            staticcall rewardTokenAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _12175 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_12175] == mem[_12175]
                            if sub_0b4b41bc <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require sub_0b4b41bc
                            sub_7f94bf16 = mem[_12175] / sub_0b4b41bc
                            mem[mem[64] + 4] = treasuryAddress
                            mem[mem[64] + 36] = 0
                            require ext_code.size(assetAddress)
                            call assetAddress.0xa9059cbb with:
                                 gas gas_remaining wei
                                args treasuryAddress, 0
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _15345 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_15345] == bool(mem[_15345])
                else:
                    require ext_call.return_data[0] - totalDeposited
                    if (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / ext_call.return_data[0] - totalDeposited != sub_7e72b29f:
                        revert with 0, 'SafeMath: multiplication overflow'
                    sub_bf4c8572 = (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / 10000
                    mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                    mem[ceil32(return_data.size) + 132] = -1
                    require ext_code.size(sub_b8ab24bdAddress)
                    call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args lendingPoolAddress, -1
                    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                    mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                    mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                    mem[(2 * ceil32(return_data.size)) + 164] = this.address
                    require ext_code.size(lendingPoolAddress)
                    call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                         gas gas_remaining wei
                        args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                    mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                    mem[(4 * ceil32(return_data.size)) + 132] = -1
                    require ext_code.size(assetAddress)
                    call assetAddress.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args routerAddress, -1
                    mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                    if assetAddress == WAVAXAddress:
                        mem[(6 * ceil32(return_data.size)) + 96] = 2
                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                        mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                        mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                        mem[(6 * ceil32(return_data.size)) + 260] = 160
                        mem[(6 * ceil32(return_data.size)) + 356] = 2
                        idx = 0
                        s = (6 * ceil32(return_data.size)) + 128
                        t = (6 * ceil32(return_data.size)) + 388
                        while idx < 2:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[(6 * ceil32(return_data.size)) + 292] = this.address
                        mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                        require ext_code.size(routerAddress)
                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (7 * ceil32(return_data.size)) + 192
                        require return_data.size >= 32
                        _3123 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                        require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                        _3270 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                        mem[(7 * ceil32(return_data.size)) + 192] = _3270
                        require _3123 + (32 * _3270) + 32 <= return_data.size
                        idx = 0
                        s = (6 * ceil32(return_data.size)) + _3123 + 224
                        t = (7 * ceil32(return_data.size)) + 224
                        while idx < _3270:
                            require mem[s] == mem[s]
                            mem[t] = mem[s]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(rewardTokenAddress)
                        staticcall rewardTokenAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _12171 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_12171] == mem[_12171]
                        if sub_0b4b41bc <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require sub_0b4b41bc
                        sub_7f94bf16 = mem[_12171] / sub_0b4b41bc
                        mem[mem[64] + 4] = treasuryAddress
                        mem[mem[64] + 36] = 0
                        require ext_code.size(assetAddress)
                        call assetAddress.0xa9059cbb with:
                             gas gas_remaining wei
                            args treasuryAddress, 0
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _15341 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_15341] == bool(mem[_15341])
                    else:
                        if rewardTokenAddress == WAVAXAddress:
                            mem[(6 * ceil32(return_data.size)) + 96] = 2
                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                            mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                            mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                            mem[(6 * ceil32(return_data.size)) + 260] = 160
                            mem[(6 * ceil32(return_data.size)) + 356] = 2
                            idx = 0
                            s = (6 * ceil32(return_data.size)) + 128
                            t = (6 * ceil32(return_data.size)) + 388
                            while idx < 2:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[(6 * ceil32(return_data.size)) + 292] = this.address
                            mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                            require ext_code.size(routerAddress)
                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (7 * ceil32(return_data.size)) + 192
                            require return_data.size >= 32
                            _3125 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                            require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                            _3272 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                            mem[(7 * ceil32(return_data.size)) + 192] = _3272
                            require _3125 + (32 * _3272) + 32 <= return_data.size
                            idx = 0
                            s = (6 * ceil32(return_data.size)) + _3125 + 224
                            t = (7 * ceil32(return_data.size)) + 224
                            while idx < _3272:
                                require mem[s] == mem[s]
                                mem[t] = mem[s]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(rewardTokenAddress)
                            staticcall rewardTokenAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _12173 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_12173] == mem[_12173]
                            if sub_0b4b41bc <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require sub_0b4b41bc
                            sub_7f94bf16 = mem[_12173] / sub_0b4b41bc
                            mem[mem[64] + 4] = treasuryAddress
                            mem[mem[64] + 36] = 0
                            require ext_code.size(assetAddress)
                            call assetAddress.0xa9059cbb with:
                                 gas gas_remaining wei
                                args treasuryAddress, 0
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _15343 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_15343] == bool(mem[_15343])
                        else:
                            mem[(6 * ceil32(return_data.size)) + 96] = 3
                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                            mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                            mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                            mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[(6 * ceil32(return_data.size)) + 228] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                            mem[(6 * ceil32(return_data.size)) + 260] = 0
                            mem[(6 * ceil32(return_data.size)) + 292] = 160
                            mem[(6 * ceil32(return_data.size)) + 388] = 3
                            idx = 0
                            s = (6 * ceil32(return_data.size)) + 128
                            t = (6 * ceil32(return_data.size)) + 420
                            while idx < 3:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[(6 * ceil32(return_data.size)) + 324] = this.address
                            mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                            require ext_code.size(routerAddress)
                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (7 * ceil32(return_data.size)) + 224
                            require return_data.size >= 32
                            _3124 = mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                            require mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                            _3271 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]
                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224] <= test266151307()
                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 32 >= 0
                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256
                            mem[(7 * ceil32(return_data.size)) + 224] = _3271
                            require _3124 + (32 * _3271) + 32 <= return_data.size
                            idx = 0
                            s = (6 * ceil32(return_data.size)) + _3124 + 256
                            t = (7 * ceil32(return_data.size)) + 256
                            while idx < _3271:
                                require mem[s] == mem[s]
                                mem[t] = mem[s]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(rewardTokenAddress)
                            staticcall rewardTokenAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _12172 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_12172] == mem[_12172]
                            if sub_0b4b41bc <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require sub_0b4b41bc
                            sub_7f94bf16 = mem[_12172] / sub_0b4b41bc
                            mem[mem[64] + 4] = treasuryAddress
                            mem[mem[64] + 36] = 0
                            require ext_code.size(assetAddress)
                            call assetAddress.0xa9059cbb with:
                                 gas gas_remaining wei
                                args treasuryAddress, 0
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _15342 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_15342] == bool(mem[_15342])
        else:
            require ext_call.return_data[0] - totalDeposited
            if (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / ext_call.return_data[0] - totalDeposited != sub_7796ff37:
                revert with 0, 'SafeMath: multiplication overflow'
            if not ext_call.return_data[0] - totalDeposited:
                if not ext_call.return_data[0] - totalDeposited:
                    sub_bf4c8572 = 0
                    mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                    mem[ceil32(return_data.size) + 132] = -1
                    require ext_code.size(sub_b8ab24bdAddress)
                    call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args lendingPoolAddress, -1
                    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                    mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                    mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                    mem[(2 * ceil32(return_data.size)) + 164] = this.address
                    require ext_code.size(lendingPoolAddress)
                    call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                         gas gas_remaining wei
                        args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                    mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                    mem[(4 * ceil32(return_data.size)) + 132] = -1
                    require ext_code.size(assetAddress)
                    call assetAddress.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args routerAddress, -1
                    mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                    if assetAddress == WAVAXAddress:
                        mem[(6 * ceil32(return_data.size)) + 96] = 2
                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                        mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                        mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(6 * ceil32(return_data.size)) + 196] = 0
                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                        mem[(6 * ceil32(return_data.size)) + 260] = 160
                        mem[(6 * ceil32(return_data.size)) + 356] = 2
                        idx = 0
                        s = (6 * ceil32(return_data.size)) + 128
                        t = (6 * ceil32(return_data.size)) + 388
                        while idx < 2:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[(6 * ceil32(return_data.size)) + 292] = this.address
                        mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                        require ext_code.size(routerAddress)
                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (7 * ceil32(return_data.size)) + 192
                        require return_data.size >= 32
                        _3120 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                        require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                        _3267 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                        mem[(7 * ceil32(return_data.size)) + 192] = _3267
                        require _3120 + (32 * _3267) + 32 <= return_data.size
                        idx = 0
                        s = (6 * ceil32(return_data.size)) + _3120 + 224
                        t = (7 * ceil32(return_data.size)) + 224
                        while idx < _3267:
                            require mem[s] == mem[s]
                            mem[t] = mem[s]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(rewardTokenAddress)
                        staticcall rewardTokenAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _12168 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_12168] == mem[_12168]
                        if sub_0b4b41bc <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require sub_0b4b41bc
                        sub_7f94bf16 = mem[_12168] / sub_0b4b41bc
                        mem[mem[64] + 4] = treasuryAddress
                        mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                        require ext_code.size(assetAddress)
                        call assetAddress.0xa9059cbb with:
                             gas gas_remaining wei
                            args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _15338 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_15338] == bool(mem[_15338])
                    else:
                        if rewardTokenAddress == WAVAXAddress:
                            mem[(6 * ceil32(return_data.size)) + 96] = 2
                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                            mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                            mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[(6 * ceil32(return_data.size)) + 196] = 0
                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                            mem[(6 * ceil32(return_data.size)) + 260] = 160
                            mem[(6 * ceil32(return_data.size)) + 356] = 2
                            idx = 0
                            s = (6 * ceil32(return_data.size)) + 128
                            t = (6 * ceil32(return_data.size)) + 388
                            while idx < 2:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[(6 * ceil32(return_data.size)) + 292] = this.address
                            mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                            require ext_code.size(routerAddress)
                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (7 * ceil32(return_data.size)) + 192
                            require return_data.size >= 32
                            _3122 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                            require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                            _3269 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                            mem[(7 * ceil32(return_data.size)) + 192] = _3269
                            require _3122 + (32 * _3269) + 32 <= return_data.size
                            idx = 0
                            s = (6 * ceil32(return_data.size)) + _3122 + 224
                            t = (7 * ceil32(return_data.size)) + 224
                            while idx < _3269:
                                require mem[s] == mem[s]
                                mem[t] = mem[s]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(rewardTokenAddress)
                            staticcall rewardTokenAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _12170 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_12170] == mem[_12170]
                            if sub_0b4b41bc <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require sub_0b4b41bc
                            sub_7f94bf16 = mem[_12170] / sub_0b4b41bc
                            mem[mem[64] + 4] = treasuryAddress
                            mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                            require ext_code.size(assetAddress)
                            call assetAddress.0xa9059cbb with:
                                 gas gas_remaining wei
                                args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _15340 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_15340] == bool(mem[_15340])
                        else:
                            mem[(6 * ceil32(return_data.size)) + 96] = 3
                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                            mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                            mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                            mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                            mem[(6 * ceil32(return_data.size)) + 260] = 0
                            mem[(6 * ceil32(return_data.size)) + 292] = 160
                            mem[(6 * ceil32(return_data.size)) + 388] = 3
                            idx = 0
                            s = (6 * ceil32(return_data.size)) + 128
                            t = (6 * ceil32(return_data.size)) + 420
                            while idx < 3:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[(6 * ceil32(return_data.size)) + 324] = this.address
                            mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                            require ext_code.size(routerAddress)
                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args 0, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (7 * ceil32(return_data.size)) + 224
                            require return_data.size >= 32
                            _3121 = mem[(6 * ceil32(return_data.size)) + 224 len 4], 0
                            require mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 <= test266151307()
                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                            _3268 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]
                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224] <= test266151307()
                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 32 >= 0
                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256
                            mem[(7 * ceil32(return_data.size)) + 224] = _3268
                            require _3121 + (32 * _3268) + 32 <= return_data.size
                            idx = 0
                            s = (6 * ceil32(return_data.size)) + _3121 + 256
                            t = (7 * ceil32(return_data.size)) + 256
                            while idx < _3268:
                                require mem[s] == mem[s]
                                mem[t] = mem[s]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(rewardTokenAddress)
                            staticcall rewardTokenAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _12169 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_12169] == mem[_12169]
                            if sub_0b4b41bc <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require sub_0b4b41bc
                            sub_7f94bf16 = mem[_12169] / sub_0b4b41bc
                            mem[mem[64] + 4] = treasuryAddress
                            mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                            require ext_code.size(assetAddress)
                            call assetAddress.0xa9059cbb with:
                                 gas gas_remaining wei
                                args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _15339 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_15339] == bool(mem[_15339])
                else:
                    require ext_call.return_data[0] - totalDeposited
                    if (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / ext_call.return_data[0] - totalDeposited != sub_7e72b29f:
                        revert with 0, 'SafeMath: multiplication overflow'
                    sub_bf4c8572 = (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / 10000
                    mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                    mem[ceil32(return_data.size) + 132] = -1
                    require ext_code.size(sub_b8ab24bdAddress)
                    call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args lendingPoolAddress, -1
                    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                    mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                    mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                    mem[(2 * ceil32(return_data.size)) + 164] = this.address
                    require ext_code.size(lendingPoolAddress)
                    call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                         gas gas_remaining wei
                        args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                    mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                    mem[(4 * ceil32(return_data.size)) + 132] = -1
                    require ext_code.size(assetAddress)
                    call assetAddress.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args routerAddress, -1
                    mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                    if assetAddress == WAVAXAddress:
                        mem[(6 * ceil32(return_data.size)) + 96] = 2
                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                        mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                        mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(6 * ceil32(return_data.size)) + 196] = 0
                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                        mem[(6 * ceil32(return_data.size)) + 260] = 160
                        mem[(6 * ceil32(return_data.size)) + 356] = 2
                        idx = 0
                        s = (6 * ceil32(return_data.size)) + 128
                        t = (6 * ceil32(return_data.size)) + 388
                        while idx < 2:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[(6 * ceil32(return_data.size)) + 292] = this.address
                        mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                        require ext_code.size(routerAddress)
                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (7 * ceil32(return_data.size)) + 192
                        require return_data.size >= 32
                        _3117 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                        require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                        _3264 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                        mem[(7 * ceil32(return_data.size)) + 192] = _3264
                        require _3117 + (32 * _3264) + 32 <= return_data.size
                        idx = 0
                        s = (6 * ceil32(return_data.size)) + _3117 + 224
                        t = (7 * ceil32(return_data.size)) + 224
                        while idx < _3264:
                            require mem[s] == mem[s]
                            mem[t] = mem[s]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(rewardTokenAddress)
                        staticcall rewardTokenAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _12165 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_12165] == mem[_12165]
                        if sub_0b4b41bc <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require sub_0b4b41bc
                        sub_7f94bf16 = mem[_12165] / sub_0b4b41bc
                        mem[mem[64] + 4] = treasuryAddress
                        mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                        require ext_code.size(assetAddress)
                        call assetAddress.0xa9059cbb with:
                             gas gas_remaining wei
                            args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _15335 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_15335] == bool(mem[_15335])
                    else:
                        if rewardTokenAddress == WAVAXAddress:
                            mem[(6 * ceil32(return_data.size)) + 96] = 2
                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                            mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                            mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[(6 * ceil32(return_data.size)) + 196] = 0
                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                            mem[(6 * ceil32(return_data.size)) + 260] = 160
                            mem[(6 * ceil32(return_data.size)) + 356] = 2
                            idx = 0
                            s = (6 * ceil32(return_data.size)) + 128
                            t = (6 * ceil32(return_data.size)) + 388
                            while idx < 2:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[(6 * ceil32(return_data.size)) + 292] = this.address
                            mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                            require ext_code.size(routerAddress)
                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (7 * ceil32(return_data.size)) + 192
                            require return_data.size >= 32
                            _3119 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                            require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                            _3266 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                            mem[(7 * ceil32(return_data.size)) + 192] = _3266
                            require _3119 + (32 * _3266) + 32 <= return_data.size
                            idx = 0
                            s = (6 * ceil32(return_data.size)) + _3119 + 224
                            t = (7 * ceil32(return_data.size)) + 224
                            while idx < _3266:
                                require mem[s] == mem[s]
                                mem[t] = mem[s]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(rewardTokenAddress)
                            staticcall rewardTokenAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _12167 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_12167] == mem[_12167]
                            if sub_0b4b41bc <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require sub_0b4b41bc
                            sub_7f94bf16 = mem[_12167] / sub_0b4b41bc
                            mem[mem[64] + 4] = treasuryAddress
                            mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                            require ext_code.size(assetAddress)
                            call assetAddress.0xa9059cbb with:
                                 gas gas_remaining wei
                                args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _15337 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_15337] == bool(mem[_15337])
                        else:
                            mem[(6 * ceil32(return_data.size)) + 96] = 3
                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                            mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                            mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                            mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                            mem[(6 * ceil32(return_data.size)) + 260] = 0
                            mem[(6 * ceil32(return_data.size)) + 292] = 160
                            mem[(6 * ceil32(return_data.size)) + 388] = 3
                            idx = 0
                            s = (6 * ceil32(return_data.size)) + 128
                            t = (6 * ceil32(return_data.size)) + 420
                            while idx < 3:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[(6 * ceil32(return_data.size)) + 324] = this.address
                            mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                            require ext_code.size(routerAddress)
                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args 0, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (7 * ceil32(return_data.size)) + 224
                            require return_data.size >= 32
                            _3118 = mem[(6 * ceil32(return_data.size)) + 224 len 4], 0
                            require mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 <= test266151307()
                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                            _3265 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]
                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224] <= test266151307()
                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 32 >= 0
                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256
                            mem[(7 * ceil32(return_data.size)) + 224] = _3265
                            require _3118 + (32 * _3265) + 32 <= return_data.size
                            idx = 0
                            s = (6 * ceil32(return_data.size)) + _3118 + 256
                            t = (7 * ceil32(return_data.size)) + 256
                            while idx < _3265:
                                require mem[s] == mem[s]
                                mem[t] = mem[s]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(rewardTokenAddress)
                            staticcall rewardTokenAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _12166 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_12166] == mem[_12166]
                            if sub_0b4b41bc <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require sub_0b4b41bc
                            sub_7f94bf16 = mem[_12166] / sub_0b4b41bc
                            mem[mem[64] + 4] = treasuryAddress
                            mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                            require ext_code.size(assetAddress)
                            call assetAddress.0xa9059cbb with:
                                 gas gas_remaining wei
                                args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _15336 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_15336] == bool(mem[_15336])
            else:
                require ext_call.return_data[0] - totalDeposited
                if (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / ext_call.return_data[0] - totalDeposited != sub_2f6236be:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not ext_call.return_data[0] - totalDeposited:
                    sub_bf4c8572 = 0
                    mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                    mem[ceil32(return_data.size) + 132] = -1
                    require ext_code.size(sub_b8ab24bdAddress)
                    call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args lendingPoolAddress, -1
                    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                    mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                    mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                    mem[(2 * ceil32(return_data.size)) + 164] = this.address
                    require ext_code.size(lendingPoolAddress)
                    call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                         gas gas_remaining wei
                        args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                    mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                    mem[(4 * ceil32(return_data.size)) + 132] = -1
                    require ext_code.size(assetAddress)
                    call assetAddress.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args routerAddress, -1
                    mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                    if assetAddress == WAVAXAddress:
                        mem[(6 * ceil32(return_data.size)) + 96] = 2
                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                        mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                        mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                        mem[(6 * ceil32(return_data.size)) + 260] = 160
                        mem[(6 * ceil32(return_data.size)) + 356] = 2
                        idx = 0
                        s = (6 * ceil32(return_data.size)) + 128
                        t = (6 * ceil32(return_data.size)) + 388
                        while idx < 2:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[(6 * ceil32(return_data.size)) + 292] = this.address
                        mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                        require ext_code.size(routerAddress)
                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (7 * ceil32(return_data.size)) + 192
                        require return_data.size >= 32
                        _3114 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                        require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                        _3261 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                        mem[(7 * ceil32(return_data.size)) + 192] = _3261
                        require _3114 + (32 * _3261) + 32 <= return_data.size
                        idx = 0
                        s = (6 * ceil32(return_data.size)) + _3114 + 224
                        t = (7 * ceil32(return_data.size)) + 224
                        while idx < _3261:
                            require mem[s] == mem[s]
                            mem[t] = mem[s]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(rewardTokenAddress)
                        staticcall rewardTokenAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _12162 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_12162] == mem[_12162]
                        if sub_0b4b41bc <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require sub_0b4b41bc
                        sub_7f94bf16 = mem[_12162] / sub_0b4b41bc
                        mem[mem[64] + 4] = treasuryAddress
                        mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                        require ext_code.size(assetAddress)
                        call assetAddress.0xa9059cbb with:
                             gas gas_remaining wei
                            args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _15332 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_15332] == bool(mem[_15332])
                    else:
                        if rewardTokenAddress == WAVAXAddress:
                            mem[(6 * ceil32(return_data.size)) + 96] = 2
                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                            mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                            mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                            mem[(6 * ceil32(return_data.size)) + 260] = 160
                            mem[(6 * ceil32(return_data.size)) + 356] = 2
                            idx = 0
                            s = (6 * ceil32(return_data.size)) + 128
                            t = (6 * ceil32(return_data.size)) + 388
                            while idx < 2:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[(6 * ceil32(return_data.size)) + 292] = this.address
                            mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                            require ext_code.size(routerAddress)
                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (7 * ceil32(return_data.size)) + 192
                            require return_data.size >= 32
                            _3116 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                            require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                            _3263 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                            mem[(7 * ceil32(return_data.size)) + 192] = _3263
                            require _3116 + (32 * _3263) + 32 <= return_data.size
                            idx = 0
                            s = (6 * ceil32(return_data.size)) + _3116 + 224
                            t = (7 * ceil32(return_data.size)) + 224
                            while idx < _3263:
                                require mem[s] == mem[s]
                                mem[t] = mem[s]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(rewardTokenAddress)
                            staticcall rewardTokenAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _12164 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_12164] == mem[_12164]
                            if sub_0b4b41bc <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require sub_0b4b41bc
                            sub_7f94bf16 = mem[_12164] / sub_0b4b41bc
                            mem[mem[64] + 4] = treasuryAddress
                            mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                            require ext_code.size(assetAddress)
                            call assetAddress.0xa9059cbb with:
                                 gas gas_remaining wei
                                args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _15334 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_15334] == bool(mem[_15334])
                        else:
                            mem[(6 * ceil32(return_data.size)) + 96] = 3
                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                            mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                            mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                            mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[(6 * ceil32(return_data.size)) + 228] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                            mem[(6 * ceil32(return_data.size)) + 260] = 0
                            mem[(6 * ceil32(return_data.size)) + 292] = 160
                            mem[(6 * ceil32(return_data.size)) + 388] = 3
                            idx = 0
                            s = (6 * ceil32(return_data.size)) + 128
                            t = (6 * ceil32(return_data.size)) + 420
                            while idx < 3:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[(6 * ceil32(return_data.size)) + 324] = this.address
                            mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                            require ext_code.size(routerAddress)
                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (7 * ceil32(return_data.size)) + 224
                            require return_data.size >= 32
                            _3115 = mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                            require mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                            _3262 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]
                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224] <= test266151307()
                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 32 >= 0
                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256
                            mem[(7 * ceil32(return_data.size)) + 224] = _3262
                            require _3115 + (32 * _3262) + 32 <= return_data.size
                            idx = 0
                            s = (6 * ceil32(return_data.size)) + _3115 + 256
                            t = (7 * ceil32(return_data.size)) + 256
                            while idx < _3262:
                                require mem[s] == mem[s]
                                mem[t] = mem[s]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(rewardTokenAddress)
                            staticcall rewardTokenAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _12163 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_12163] == mem[_12163]
                            if sub_0b4b41bc <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require sub_0b4b41bc
                            sub_7f94bf16 = mem[_12163] / sub_0b4b41bc
                            mem[mem[64] + 4] = treasuryAddress
                            mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                            require ext_code.size(assetAddress)
                            call assetAddress.0xa9059cbb with:
                                 gas gas_remaining wei
                                args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _15333 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_15333] == bool(mem[_15333])
                else:
                    require ext_call.return_data[0] - totalDeposited
                    if (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / ext_call.return_data[0] - totalDeposited != sub_7e72b29f:
                        revert with 0, 'SafeMath: multiplication overflow'
                    sub_bf4c8572 = (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / 10000
                    mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                    mem[ceil32(return_data.size) + 132] = -1
                    require ext_code.size(sub_b8ab24bdAddress)
                    call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args lendingPoolAddress, -1
                    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                    mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                    mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                    mem[(2 * ceil32(return_data.size)) + 164] = this.address
                    require ext_code.size(lendingPoolAddress)
                    call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                         gas gas_remaining wei
                        args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                    mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                    mem[(4 * ceil32(return_data.size)) + 132] = -1
                    require ext_code.size(assetAddress)
                    call assetAddress.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args routerAddress, -1
                    mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                    if assetAddress == WAVAXAddress:
                        mem[(6 * ceil32(return_data.size)) + 96] = 2
                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                        mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                        mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                        mem[(6 * ceil32(return_data.size)) + 260] = 160
                        mem[(6 * ceil32(return_data.size)) + 356] = 2
                        idx = 0
                        s = (6 * ceil32(return_data.size)) + 128
                        t = (6 * ceil32(return_data.size)) + 388
                        while idx < 2:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[(6 * ceil32(return_data.size)) + 292] = this.address
                        mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                        require ext_code.size(routerAddress)
                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (7 * ceil32(return_data.size)) + 192
                        require return_data.size >= 32
                        _3111 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                        require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                        _3258 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                        mem[(7 * ceil32(return_data.size)) + 192] = _3258
                        require _3111 + (32 * _3258) + 32 <= return_data.size
                        idx = 0
                        s = (6 * ceil32(return_data.size)) + _3111 + 224
                        t = (7 * ceil32(return_data.size)) + 224
                        while idx < _3258:
                            require mem[s] == mem[s]
                            mem[t] = mem[s]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(rewardTokenAddress)
                        staticcall rewardTokenAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _12159 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_12159] == mem[_12159]
                        if sub_0b4b41bc <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require sub_0b4b41bc
                        sub_7f94bf16 = mem[_12159] / sub_0b4b41bc
                        mem[mem[64] + 4] = treasuryAddress
                        mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                        require ext_code.size(assetAddress)
                        call assetAddress.0xa9059cbb with:
                             gas gas_remaining wei
                            args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _15329 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_15329] == bool(mem[_15329])
                    else:
                        if rewardTokenAddress == WAVAXAddress:
                            mem[(6 * ceil32(return_data.size)) + 96] = 2
                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                            mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                            mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                            mem[(6 * ceil32(return_data.size)) + 260] = 160
                            mem[(6 * ceil32(return_data.size)) + 356] = 2
                            idx = 0
                            s = (6 * ceil32(return_data.size)) + 128
                            t = (6 * ceil32(return_data.size)) + 388
                            while idx < 2:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[(6 * ceil32(return_data.size)) + 292] = this.address
                            mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                            require ext_code.size(routerAddress)
                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (7 * ceil32(return_data.size)) + 192
                            require return_data.size >= 32
                            _3113 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                            require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                            _3260 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                            mem[(7 * ceil32(return_data.size)) + 192] = _3260
                            require _3113 + (32 * _3260) + 32 <= return_data.size
                            idx = 0
                            s = (6 * ceil32(return_data.size)) + _3113 + 224
                            t = (7 * ceil32(return_data.size)) + 224
                            while idx < _3260:
                                require mem[s] == mem[s]
                                mem[t] = mem[s]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(rewardTokenAddress)
                            staticcall rewardTokenAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _12161 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_12161] == mem[_12161]
                            if sub_0b4b41bc <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require sub_0b4b41bc
                            sub_7f94bf16 = mem[_12161] / sub_0b4b41bc
                            mem[mem[64] + 4] = treasuryAddress
                            mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                            require ext_code.size(assetAddress)
                            call assetAddress.0xa9059cbb with:
                                 gas gas_remaining wei
                                args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _15331 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_15331] == bool(mem[_15331])
                        else:
                            mem[(6 * ceil32(return_data.size)) + 96] = 3
                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                            mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                            mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                            mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[(6 * ceil32(return_data.size)) + 228] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                            mem[(6 * ceil32(return_data.size)) + 260] = 0
                            mem[(6 * ceil32(return_data.size)) + 292] = 160
                            mem[(6 * ceil32(return_data.size)) + 388] = 3
                            idx = 0
                            s = (6 * ceil32(return_data.size)) + 128
                            t = (6 * ceil32(return_data.size)) + 420
                            while idx < 3:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[(6 * ceil32(return_data.size)) + 324] = this.address
                            mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                            require ext_code.size(routerAddress)
                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (7 * ceil32(return_data.size)) + 224
                            require return_data.size >= 32
                            _3112 = mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                            require mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                            _3259 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]
                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224] <= test266151307()
                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 32 >= 0
                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256
                            mem[(7 * ceil32(return_data.size)) + 224] = _3259
                            require _3112 + (32 * _3259) + 32 <= return_data.size
                            idx = 0
                            s = (6 * ceil32(return_data.size)) + _3112 + 256
                            t = (7 * ceil32(return_data.size)) + 256
                            while idx < _3259:
                                require mem[s] == mem[s]
                                mem[t] = mem[s]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(rewardTokenAddress)
                            staticcall rewardTokenAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _12160 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_12160] == mem[_12160]
                            if sub_0b4b41bc <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require sub_0b4b41bc
                            sub_7f94bf16 = mem[_12160] / sub_0b4b41bc
                            mem[mem[64] + 4] = treasuryAddress
                            mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                            require ext_code.size(assetAddress)
                            call assetAddress.0xa9059cbb with:
                                 gas gas_remaining wei
                                args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _15330 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_15330] == bool(mem[_15330])
    else:
        if block.timestamp <= lastRewardTimestamp:
            mem[100] = this.address
            require ext_code.size(sub_b8ab24bdAddress)
            staticcall sub_b8ab24bdAddress.0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            mem[96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[0]
            if not ext_call.return_data[0] - totalDeposited:
                if not ext_call.return_data[0] - totalDeposited:
                    if not ext_call.return_data[0] - totalDeposited:
                        sub_bf4c8572 = 0
                        mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                        mem[ceil32(return_data.size) + 132] = -1
                        require ext_code.size(sub_b8ab24bdAddress)
                        call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args lendingPoolAddress, -1
                        mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                        mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                        mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                        mem[(2 * ceil32(return_data.size)) + 164] = this.address
                        require ext_code.size(lendingPoolAddress)
                        call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                        mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[0]
                        mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                        mem[(4 * ceil32(return_data.size)) + 132] = -1
                        require ext_code.size(assetAddress)
                        call assetAddress.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args routerAddress, -1
                        mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                        if assetAddress == WAVAXAddress:
                            mem[(6 * ceil32(return_data.size)) + 96] = 2
                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                            mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                            mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[(6 * ceil32(return_data.size)) + 196] = 0
                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                            mem[(6 * ceil32(return_data.size)) + 260] = 160
                            mem[(6 * ceil32(return_data.size)) + 356] = 2
                            idx = 0
                            s = (6 * ceil32(return_data.size)) + 128
                            t = (6 * ceil32(return_data.size)) + 388
                            while idx < 2:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[(6 * ceil32(return_data.size)) + 292] = this.address
                            mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                            require ext_code.size(routerAddress)
                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (7 * ceil32(return_data.size)) + 192
                            require return_data.size >= 32
                            _3108 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                            require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                            _3255 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                            mem[(7 * ceil32(return_data.size)) + 192] = _3255
                            require _3108 + (32 * _3255) + 32 <= return_data.size
                            idx = 0
                            s = (6 * ceil32(return_data.size)) + _3108 + 224
                            t = (7 * ceil32(return_data.size)) + 224
                            while idx < _3255:
                                require mem[s] == mem[s]
                                mem[t] = mem[s]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(rewardTokenAddress)
                            staticcall rewardTokenAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _12156 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_12156] == mem[_12156]
                            if sub_0b4b41bc <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require sub_0b4b41bc
                            sub_7f94bf16 = mem[_12156] / sub_0b4b41bc
                            mem[mem[64] + 4] = treasuryAddress
                            mem[mem[64] + 36] = 0
                            require ext_code.size(assetAddress)
                            call assetAddress.0xa9059cbb with:
                                 gas gas_remaining wei
                                args treasuryAddress, 0
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _15326 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_15326] == bool(mem[_15326])
                        else:
                            if rewardTokenAddress == WAVAXAddress:
                                mem[(6 * ceil32(return_data.size)) + 96] = 2
                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(6 * ceil32(return_data.size)) + 196] = 0
                                mem[(6 * ceil32(return_data.size)) + 228] = 0
                                mem[(6 * ceil32(return_data.size)) + 260] = 160
                                mem[(6 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (6 * ceil32(return_data.size)) + 128
                                t = (6 * ceil32(return_data.size)) + 388
                                while idx < 2:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (7 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _3110 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                _3257 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                mem[(7 * ceil32(return_data.size)) + 192] = _3257
                                require _3110 + (32 * _3257) + 32 <= return_data.size
                                idx = 0
                                s = (6 * ceil32(return_data.size)) + _3110 + 224
                                t = (7 * ceil32(return_data.size)) + 224
                                while idx < _3257:
                                    require mem[s] == mem[s]
                                    mem[t] = mem[s]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(rewardTokenAddress)
                                staticcall rewardTokenAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _12158 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_12158] == mem[_12158]
                                if sub_0b4b41bc <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require sub_0b4b41bc
                                sub_7f94bf16 = mem[_12158] / sub_0b4b41bc
                                mem[mem[64] + 4] = treasuryAddress
                                mem[mem[64] + 36] = 0
                                require ext_code.size(assetAddress)
                                call assetAddress.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args treasuryAddress, 0
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _15328 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_15328] == bool(mem[_15328])
                            else:
                                mem[(6 * ceil32(return_data.size)) + 96] = 3
                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(6 * ceil32(return_data.size)) + 228] = 0
                                mem[(6 * ceil32(return_data.size)) + 260] = 0
                                mem[(6 * ceil32(return_data.size)) + 292] = 160
                                mem[(6 * ceil32(return_data.size)) + 388] = 3
                                idx = 0
                                s = (6 * ceil32(return_data.size)) + 128
                                t = (6 * ceil32(return_data.size)) + 420
                                while idx < 3:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args 0, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (7 * ceil32(return_data.size)) + 224
                                require return_data.size >= 32
                                _3109 = mem[(6 * ceil32(return_data.size)) + 224 len 4], 0
                                require mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 <= test266151307()
                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                _3256 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]
                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224] <= test266151307()
                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 32 >= 0
                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256
                                mem[(7 * ceil32(return_data.size)) + 224] = _3256
                                require _3109 + (32 * _3256) + 32 <= return_data.size
                                idx = 0
                                s = (6 * ceil32(return_data.size)) + _3109 + 256
                                t = (7 * ceil32(return_data.size)) + 256
                                while idx < _3256:
                                    require mem[s] == mem[s]
                                    mem[t] = mem[s]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(rewardTokenAddress)
                                staticcall rewardTokenAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _12157 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_12157] == mem[_12157]
                                if sub_0b4b41bc <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require sub_0b4b41bc
                                sub_7f94bf16 = mem[_12157] / sub_0b4b41bc
                                mem[mem[64] + 4] = treasuryAddress
                                mem[mem[64] + 36] = 0
                                require ext_code.size(assetAddress)
                                call assetAddress.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args treasuryAddress, 0
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _15327 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_15327] == bool(mem[_15327])
                    else:
                        require ext_call.return_data[0] - totalDeposited
                        if (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / ext_call.return_data[0] - totalDeposited != sub_7e72b29f:
                            revert with 0, 'SafeMath: multiplication overflow'
                        sub_bf4c8572 = (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / 10000
                        mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                        mem[ceil32(return_data.size) + 132] = -1
                        require ext_code.size(sub_b8ab24bdAddress)
                        call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args lendingPoolAddress, -1
                        mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                        mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                        mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                        mem[(2 * ceil32(return_data.size)) + 164] = this.address
                        require ext_code.size(lendingPoolAddress)
                        call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                        mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[0]
                        mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                        mem[(4 * ceil32(return_data.size)) + 132] = -1
                        require ext_code.size(assetAddress)
                        call assetAddress.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args routerAddress, -1
                        mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                        if assetAddress == WAVAXAddress:
                            mem[(6 * ceil32(return_data.size)) + 96] = 2
                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                            mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                            mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[(6 * ceil32(return_data.size)) + 196] = 0
                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                            mem[(6 * ceil32(return_data.size)) + 260] = 160
                            mem[(6 * ceil32(return_data.size)) + 356] = 2
                            idx = 0
                            s = (6 * ceil32(return_data.size)) + 128
                            t = (6 * ceil32(return_data.size)) + 388
                            while idx < 2:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[(6 * ceil32(return_data.size)) + 292] = this.address
                            mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                            require ext_code.size(routerAddress)
                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (7 * ceil32(return_data.size)) + 192
                            require return_data.size >= 32
                            _3105 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                            require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                            _3252 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                            mem[(7 * ceil32(return_data.size)) + 192] = _3252
                            require _3105 + (32 * _3252) + 32 <= return_data.size
                            idx = 0
                            s = (6 * ceil32(return_data.size)) + _3105 + 224
                            t = (7 * ceil32(return_data.size)) + 224
                            while idx < _3252:
                                require mem[s] == mem[s]
                                mem[t] = mem[s]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(rewardTokenAddress)
                            staticcall rewardTokenAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _12153 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_12153] == mem[_12153]
                            if sub_0b4b41bc <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require sub_0b4b41bc
                            sub_7f94bf16 = mem[_12153] / sub_0b4b41bc
                            mem[mem[64] + 4] = treasuryAddress
                            mem[mem[64] + 36] = 0
                            require ext_code.size(assetAddress)
                            call assetAddress.0xa9059cbb with:
                                 gas gas_remaining wei
                                args treasuryAddress, 0
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _15323 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_15323] == bool(mem[_15323])
                        else:
                            if rewardTokenAddress == WAVAXAddress:
                                mem[(6 * ceil32(return_data.size)) + 96] = 2
                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(6 * ceil32(return_data.size)) + 196] = 0
                                mem[(6 * ceil32(return_data.size)) + 228] = 0
                                mem[(6 * ceil32(return_data.size)) + 260] = 160
                                mem[(6 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (6 * ceil32(return_data.size)) + 128
                                t = (6 * ceil32(return_data.size)) + 388
                                while idx < 2:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (7 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _3107 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                _3254 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                mem[(7 * ceil32(return_data.size)) + 192] = _3254
                                require _3107 + (32 * _3254) + 32 <= return_data.size
                                idx = 0
                                s = (6 * ceil32(return_data.size)) + _3107 + 224
                                t = (7 * ceil32(return_data.size)) + 224
                                while idx < _3254:
                                    require mem[s] == mem[s]
                                    mem[t] = mem[s]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(rewardTokenAddress)
                                staticcall rewardTokenAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _12155 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_12155] == mem[_12155]
                                if sub_0b4b41bc <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require sub_0b4b41bc
                                sub_7f94bf16 = mem[_12155] / sub_0b4b41bc
                                mem[mem[64] + 4] = treasuryAddress
                                mem[mem[64] + 36] = 0
                                require ext_code.size(assetAddress)
                                call assetAddress.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args treasuryAddress, 0
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _15325 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_15325] == bool(mem[_15325])
                            else:
                                mem[(6 * ceil32(return_data.size)) + 96] = 3
                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(6 * ceil32(return_data.size)) + 228] = 0
                                mem[(6 * ceil32(return_data.size)) + 260] = 0
                                mem[(6 * ceil32(return_data.size)) + 292] = 160
                                mem[(6 * ceil32(return_data.size)) + 388] = 3
                                idx = 0
                                s = (6 * ceil32(return_data.size)) + 128
                                t = (6 * ceil32(return_data.size)) + 420
                                while idx < 3:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args 0, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (7 * ceil32(return_data.size)) + 224
                                require return_data.size >= 32
                                _3106 = mem[(6 * ceil32(return_data.size)) + 224 len 4], 0
                                require mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 <= test266151307()
                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                _3253 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]
                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224] <= test266151307()
                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 32 >= 0
                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256
                                mem[(7 * ceil32(return_data.size)) + 224] = _3253
                                require _3106 + (32 * _3253) + 32 <= return_data.size
                                idx = 0
                                s = (6 * ceil32(return_data.size)) + _3106 + 256
                                t = (7 * ceil32(return_data.size)) + 256
                                while idx < _3253:
                                    require mem[s] == mem[s]
                                    mem[t] = mem[s]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(rewardTokenAddress)
                                staticcall rewardTokenAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _12154 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_12154] == mem[_12154]
                                if sub_0b4b41bc <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require sub_0b4b41bc
                                sub_7f94bf16 = mem[_12154] / sub_0b4b41bc
                                mem[mem[64] + 4] = treasuryAddress
                                mem[mem[64] + 36] = 0
                                require ext_code.size(assetAddress)
                                call assetAddress.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args treasuryAddress, 0
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _15324 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_15324] == bool(mem[_15324])
                else:
                    require ext_call.return_data[0] - totalDeposited
                    if (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / ext_call.return_data[0] - totalDeposited != sub_2f6236be:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not ext_call.return_data[0] - totalDeposited:
                        sub_bf4c8572 = 0
                        mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                        mem[ceil32(return_data.size) + 132] = -1
                        require ext_code.size(sub_b8ab24bdAddress)
                        call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args lendingPoolAddress, -1
                        mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                        mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                        mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                        mem[(2 * ceil32(return_data.size)) + 164] = this.address
                        require ext_code.size(lendingPoolAddress)
                        call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                        mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[0]
                        mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                        mem[(4 * ceil32(return_data.size)) + 132] = -1
                        require ext_code.size(assetAddress)
                        call assetAddress.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args routerAddress, -1
                        mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                        if assetAddress == WAVAXAddress:
                            mem[(6 * ceil32(return_data.size)) + 96] = 2
                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                            mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                            mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                            mem[(6 * ceil32(return_data.size)) + 260] = 160
                            mem[(6 * ceil32(return_data.size)) + 356] = 2
                            idx = 0
                            s = (6 * ceil32(return_data.size)) + 128
                            t = (6 * ceil32(return_data.size)) + 388
                            while idx < 2:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[(6 * ceil32(return_data.size)) + 292] = this.address
                            mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                            require ext_code.size(routerAddress)
                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (7 * ceil32(return_data.size)) + 192
                            require return_data.size >= 32
                            _3102 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                            require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                            _3249 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                            mem[(7 * ceil32(return_data.size)) + 192] = _3249
                            require _3102 + (32 * _3249) + 32 <= return_data.size
                            idx = 0
                            s = (6 * ceil32(return_data.size)) + _3102 + 224
                            t = (7 * ceil32(return_data.size)) + 224
                            while idx < _3249:
                                require mem[s] == mem[s]
                                mem[t] = mem[s]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(rewardTokenAddress)
                            staticcall rewardTokenAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _12150 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_12150] == mem[_12150]
                            if sub_0b4b41bc <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require sub_0b4b41bc
                            sub_7f94bf16 = mem[_12150] / sub_0b4b41bc
                            mem[mem[64] + 4] = treasuryAddress
                            mem[mem[64] + 36] = 0
                            require ext_code.size(assetAddress)
                            call assetAddress.0xa9059cbb with:
                                 gas gas_remaining wei
                                args treasuryAddress, 0
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _15320 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_15320] == bool(mem[_15320])
                        else:
                            if rewardTokenAddress == WAVAXAddress:
                                mem[(6 * ceil32(return_data.size)) + 96] = 2
                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                mem[(6 * ceil32(return_data.size)) + 228] = 0
                                mem[(6 * ceil32(return_data.size)) + 260] = 160
                                mem[(6 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (6 * ceil32(return_data.size)) + 128
                                t = (6 * ceil32(return_data.size)) + 388
                                while idx < 2:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (7 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _3104 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                _3251 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                mem[(7 * ceil32(return_data.size)) + 192] = _3251
                                require _3104 + (32 * _3251) + 32 <= return_data.size
                                idx = 0
                                s = (6 * ceil32(return_data.size)) + _3104 + 224
                                t = (7 * ceil32(return_data.size)) + 224
                                while idx < _3251:
                                    require mem[s] == mem[s]
                                    mem[t] = mem[s]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(rewardTokenAddress)
                                staticcall rewardTokenAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _12152 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_12152] == mem[_12152]
                                if sub_0b4b41bc <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require sub_0b4b41bc
                                sub_7f94bf16 = mem[_12152] / sub_0b4b41bc
                                mem[mem[64] + 4] = treasuryAddress
                                mem[mem[64] + 36] = 0
                                require ext_code.size(assetAddress)
                                call assetAddress.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args treasuryAddress, 0
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _15322 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_15322] == bool(mem[_15322])
                            else:
                                mem[(6 * ceil32(return_data.size)) + 96] = 3
                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(6 * ceil32(return_data.size)) + 228] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                mem[(6 * ceil32(return_data.size)) + 260] = 0
                                mem[(6 * ceil32(return_data.size)) + 292] = 160
                                mem[(6 * ceil32(return_data.size)) + 388] = 3
                                idx = 0
                                s = (6 * ceil32(return_data.size)) + 128
                                t = (6 * ceil32(return_data.size)) + 420
                                while idx < 3:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (7 * ceil32(return_data.size)) + 224
                                require return_data.size >= 32
                                _3103 = mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                require mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                _3250 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]
                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224] <= test266151307()
                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 32 >= 0
                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256
                                mem[(7 * ceil32(return_data.size)) + 224] = _3250
                                require _3103 + (32 * _3250) + 32 <= return_data.size
                                idx = 0
                                s = (6 * ceil32(return_data.size)) + _3103 + 256
                                t = (7 * ceil32(return_data.size)) + 256
                                while idx < _3250:
                                    require mem[s] == mem[s]
                                    mem[t] = mem[s]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(rewardTokenAddress)
                                staticcall rewardTokenAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _12151 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_12151] == mem[_12151]
                                if sub_0b4b41bc <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require sub_0b4b41bc
                                sub_7f94bf16 = mem[_12151] / sub_0b4b41bc
                                mem[mem[64] + 4] = treasuryAddress
                                mem[mem[64] + 36] = 0
                                require ext_code.size(assetAddress)
                                call assetAddress.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args treasuryAddress, 0
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _15321 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_15321] == bool(mem[_15321])
                    else:
                        require ext_call.return_data[0] - totalDeposited
                        if (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / ext_call.return_data[0] - totalDeposited != sub_7e72b29f:
                            revert with 0, 'SafeMath: multiplication overflow'
                        sub_bf4c8572 = (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / 10000
                        mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                        mem[ceil32(return_data.size) + 132] = -1
                        require ext_code.size(sub_b8ab24bdAddress)
                        call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args lendingPoolAddress, -1
                        mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                        mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                        mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                        mem[(2 * ceil32(return_data.size)) + 164] = this.address
                        require ext_code.size(lendingPoolAddress)
                        call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                        mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[0]
                        mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                        mem[(4 * ceil32(return_data.size)) + 132] = -1
                        require ext_code.size(assetAddress)
                        call assetAddress.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args routerAddress, -1
                        mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                        if assetAddress == WAVAXAddress:
                            mem[(6 * ceil32(return_data.size)) + 96] = 2
                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                            mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                            mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                            mem[(6 * ceil32(return_data.size)) + 260] = 160
                            mem[(6 * ceil32(return_data.size)) + 356] = 2
                            idx = 0
                            s = (6 * ceil32(return_data.size)) + 128
                            t = (6 * ceil32(return_data.size)) + 388
                            while idx < 2:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[(6 * ceil32(return_data.size)) + 292] = this.address
                            mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                            require ext_code.size(routerAddress)
                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (7 * ceil32(return_data.size)) + 192
                            require return_data.size >= 32
                            _3101 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                            require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                            _3247 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                            mem[(7 * ceil32(return_data.size)) + 192] = _3247
                            require _3101 + (32 * _3247) + 32 <= return_data.size
                            idx = 0
                            s = (6 * ceil32(return_data.size)) + _3101 + 224
                            t = (7 * ceil32(return_data.size)) + 224
                            while idx < _3247:
                                require mem[s] == mem[s]
                                mem[t] = mem[s]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(rewardTokenAddress)
                            staticcall rewardTokenAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _12149 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_12149] == mem[_12149]
                            if sub_0b4b41bc <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require sub_0b4b41bc
                            sub_7f94bf16 = mem[_12149] / sub_0b4b41bc
                            mem[mem[64] + 4] = treasuryAddress
                            mem[mem[64] + 36] = 0
                            require ext_code.size(assetAddress)
                            call assetAddress.0xa9059cbb with:
                                 gas gas_remaining wei
                                args treasuryAddress, 0
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _15317 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_15317] == bool(mem[_15317])
                        else:
                            if rewardTokenAddress == WAVAXAddress:
                                mem[(6 * ceil32(return_data.size)) + 96] = 2
                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                mem[(6 * ceil32(return_data.size)) + 228] = 0
                                mem[(6 * ceil32(return_data.size)) + 260] = 160
                                mem[(6 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (6 * ceil32(return_data.size)) + 128
                                t = (6 * ceil32(return_data.size)) + 388
                                while idx < 2:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (7 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _12918 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                _13312 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                mem[(7 * ceil32(return_data.size)) + 192] = _13312
                                require _12918 + (32 * _13312) + 32 <= return_data.size
                                idx = 0
                                s = (6 * ceil32(return_data.size)) + _12918 + 224
                                t = (7 * ceil32(return_data.size)) + 224
                                while idx < _13312:
                                    require mem[s] == mem[s]
                                    mem[t] = mem[s]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(rewardTokenAddress)
                                staticcall rewardTokenAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _19370 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_19370] == mem[_19370]
                                if sub_0b4b41bc <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require sub_0b4b41bc
                                sub_7f94bf16 = mem[_19370] / sub_0b4b41bc
                                mem[mem[64] + 4] = treasuryAddress
                                mem[mem[64] + 36] = 0
                                require ext_code.size(assetAddress)
                                call assetAddress.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args treasuryAddress, 0
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _21536 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_21536] == bool(mem[_21536])
                            else:
                                mem[(6 * ceil32(return_data.size)) + 96] = 3
                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(6 * ceil32(return_data.size)) + 228] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                mem[(6 * ceil32(return_data.size)) + 260] = 0
                                mem[(6 * ceil32(return_data.size)) + 292] = 160
                                mem[(6 * ceil32(return_data.size)) + 388] = 3
                                idx = 0
                                s = (6 * ceil32(return_data.size)) + 128
                                t = (6 * ceil32(return_data.size)) + 420
                                while idx < 3:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (7 * ceil32(return_data.size)) + 224
                                require return_data.size >= 32
                                _12917 = mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                require mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                _13311 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]
                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224] <= test266151307()
                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 32 >= 0
                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256
                                mem[(7 * ceil32(return_data.size)) + 224] = _13311
                                require _12917 + (32 * _13311) + 32 <= return_data.size
                                idx = 0
                                s = (6 * ceil32(return_data.size)) + _12917 + 256
                                t = (7 * ceil32(return_data.size)) + 256
                                while idx < _13311:
                                    require mem[s] == mem[s]
                                    mem[t] = mem[s]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(rewardTokenAddress)
                                staticcall rewardTokenAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _19369 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_19369] == mem[_19369]
                                if sub_0b4b41bc <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require sub_0b4b41bc
                                sub_7f94bf16 = mem[_19369] / sub_0b4b41bc
                                mem[mem[64] + 4] = treasuryAddress
                                mem[mem[64] + 36] = 0
                                require ext_code.size(assetAddress)
                                call assetAddress.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args treasuryAddress, 0
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _21535 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_21535] == bool(mem[_21535])
            else:
                require ext_call.return_data[0] - totalDeposited
                if (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / ext_call.return_data[0] - totalDeposited != sub_7796ff37:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not ext_call.return_data[0] - totalDeposited:
                    if not ext_call.return_data[0] - totalDeposited:
                        sub_bf4c8572 = 0
                        mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                        mem[ceil32(return_data.size) + 132] = -1
                        require ext_code.size(sub_b8ab24bdAddress)
                        call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args lendingPoolAddress, -1
                        mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                        mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                        mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                        mem[(2 * ceil32(return_data.size)) + 164] = this.address
                        require ext_code.size(lendingPoolAddress)
                        call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                        mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[0]
                        mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                        mem[(4 * ceil32(return_data.size)) + 132] = -1
                        require ext_code.size(assetAddress)
                        call assetAddress.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args routerAddress, -1
                        mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                        if assetAddress == WAVAXAddress:
                            mem[(6 * ceil32(return_data.size)) + 96] = 2
                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                            mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                            mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[(6 * ceil32(return_data.size)) + 196] = 0
                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                            mem[(6 * ceil32(return_data.size)) + 260] = 160
                            mem[(6 * ceil32(return_data.size)) + 356] = 2
                            idx = 0
                            s = (6 * ceil32(return_data.size)) + 128
                            t = (6 * ceil32(return_data.size)) + 388
                            while idx < 2:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[(6 * ceil32(return_data.size)) + 292] = this.address
                            mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                            require ext_code.size(routerAddress)
                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (7 * ceil32(return_data.size)) + 192
                            require return_data.size >= 32
                            _3098 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                            require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                            _3244 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                            mem[(7 * ceil32(return_data.size)) + 192] = _3244
                            require _3098 + (32 * _3244) + 32 <= return_data.size
                            idx = 0
                            s = (6 * ceil32(return_data.size)) + _3098 + 224
                            t = (7 * ceil32(return_data.size)) + 224
                            while idx < _3244:
                                require mem[s] == mem[s]
                                mem[t] = mem[s]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(rewardTokenAddress)
                            staticcall rewardTokenAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _12146 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_12146] == mem[_12146]
                            if sub_0b4b41bc <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require sub_0b4b41bc
                            sub_7f94bf16 = mem[_12146] / sub_0b4b41bc
                            mem[mem[64] + 4] = treasuryAddress
                            mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                            require ext_code.size(assetAddress)
                            call assetAddress.0xa9059cbb with:
                                 gas gas_remaining wei
                                args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _15314 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_15314] == bool(mem[_15314])
                        else:
                            if rewardTokenAddress == WAVAXAddress:
                                mem[(6 * ceil32(return_data.size)) + 96] = 2
                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(6 * ceil32(return_data.size)) + 196] = 0
                                mem[(6 * ceil32(return_data.size)) + 228] = 0
                                mem[(6 * ceil32(return_data.size)) + 260] = 160
                                mem[(6 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (6 * ceil32(return_data.size)) + 128
                                t = (6 * ceil32(return_data.size)) + 388
                                while idx < 2:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (7 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _3100 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                _3246 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                mem[(7 * ceil32(return_data.size)) + 192] = _3246
                                require _3100 + (32 * _3246) + 32 <= return_data.size
                                idx = 0
                                s = (6 * ceil32(return_data.size)) + _3100 + 224
                                t = (7 * ceil32(return_data.size)) + 224
                                while idx < _3246:
                                    require mem[s] == mem[s]
                                    mem[t] = mem[s]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(rewardTokenAddress)
                                staticcall rewardTokenAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _12148 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_12148] == mem[_12148]
                                if sub_0b4b41bc <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require sub_0b4b41bc
                                sub_7f94bf16 = mem[_12148] / sub_0b4b41bc
                                mem[mem[64] + 4] = treasuryAddress
                                mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                require ext_code.size(assetAddress)
                                call assetAddress.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _15316 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_15316] == bool(mem[_15316])
                            else:
                                mem[(6 * ceil32(return_data.size)) + 96] = 3
                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(6 * ceil32(return_data.size)) + 228] = 0
                                mem[(6 * ceil32(return_data.size)) + 260] = 0
                                mem[(6 * ceil32(return_data.size)) + 292] = 160
                                mem[(6 * ceil32(return_data.size)) + 388] = 3
                                idx = 0
                                s = (6 * ceil32(return_data.size)) + 128
                                t = (6 * ceil32(return_data.size)) + 420
                                while idx < 3:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args 0, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (7 * ceil32(return_data.size)) + 224
                                require return_data.size >= 32
                                _3099 = mem[(6 * ceil32(return_data.size)) + 224 len 4], 0
                                require mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 <= test266151307()
                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                _3245 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]
                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224] <= test266151307()
                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 32 >= 0
                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256
                                mem[(7 * ceil32(return_data.size)) + 224] = _3245
                                require _3099 + (32 * _3245) + 32 <= return_data.size
                                idx = 0
                                s = (6 * ceil32(return_data.size)) + _3099 + 256
                                t = (7 * ceil32(return_data.size)) + 256
                                while idx < _3245:
                                    require mem[s] == mem[s]
                                    mem[t] = mem[s]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(rewardTokenAddress)
                                staticcall rewardTokenAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _12147 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_12147] == mem[_12147]
                                if sub_0b4b41bc <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require sub_0b4b41bc
                                sub_7f94bf16 = mem[_12147] / sub_0b4b41bc
                                mem[mem[64] + 4] = treasuryAddress
                                mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                require ext_code.size(assetAddress)
                                call assetAddress.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _15315 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_15315] == bool(mem[_15315])
                    else:
                        require ext_call.return_data[0] - totalDeposited
                        if (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / ext_call.return_data[0] - totalDeposited != sub_7e72b29f:
                            revert with 0, 'SafeMath: multiplication overflow'
                        sub_bf4c8572 = (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / 10000
                        mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                        mem[ceil32(return_data.size) + 132] = -1
                        require ext_code.size(sub_b8ab24bdAddress)
                        call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args lendingPoolAddress, -1
                        mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                        mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                        mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                        mem[(2 * ceil32(return_data.size)) + 164] = this.address
                        require ext_code.size(lendingPoolAddress)
                        call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                        mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[0]
                        mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                        mem[(4 * ceil32(return_data.size)) + 132] = -1
                        require ext_code.size(assetAddress)
                        call assetAddress.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args routerAddress, -1
                        mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                        if assetAddress == WAVAXAddress:
                            mem[(6 * ceil32(return_data.size)) + 96] = 2
                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                            mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                            mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[(6 * ceil32(return_data.size)) + 196] = 0
                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                            mem[(6 * ceil32(return_data.size)) + 260] = 160
                            mem[(6 * ceil32(return_data.size)) + 356] = 2
                            idx = 0
                            s = (6 * ceil32(return_data.size)) + 128
                            t = (6 * ceil32(return_data.size)) + 388
                            while idx < 2:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[(6 * ceil32(return_data.size)) + 292] = this.address
                            mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                            require ext_code.size(routerAddress)
                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (7 * ceil32(return_data.size)) + 192
                            require return_data.size >= 32
                            _3097 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                            require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                            _3242 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                            mem[(7 * ceil32(return_data.size)) + 192] = _3242
                            require _3097 + (32 * _3242) + 32 <= return_data.size
                            idx = 0
                            s = (6 * ceil32(return_data.size)) + _3097 + 224
                            t = (7 * ceil32(return_data.size)) + 224
                            while idx < _3242:
                                require mem[s] == mem[s]
                                mem[t] = mem[s]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(rewardTokenAddress)
                            staticcall rewardTokenAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _12145 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_12145] == mem[_12145]
                            if sub_0b4b41bc <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require sub_0b4b41bc
                            sub_7f94bf16 = mem[_12145] / sub_0b4b41bc
                            mem[mem[64] + 4] = treasuryAddress
                            mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                            require ext_code.size(assetAddress)
                            call assetAddress.0xa9059cbb with:
                                 gas gas_remaining wei
                                args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _15311 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_15311] == bool(mem[_15311])
                        else:
                            if rewardTokenAddress == WAVAXAddress:
                                mem[(6 * ceil32(return_data.size)) + 96] = 2
                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(6 * ceil32(return_data.size)) + 196] = 0
                                mem[(6 * ceil32(return_data.size)) + 228] = 0
                                mem[(6 * ceil32(return_data.size)) + 260] = 160
                                mem[(6 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (6 * ceil32(return_data.size)) + 128
                                t = (6 * ceil32(return_data.size)) + 388
                                while idx < 2:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (7 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _12912 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                _13310 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                mem[(7 * ceil32(return_data.size)) + 192] = _13310
                                require _12912 + (32 * _13310) + 32 <= return_data.size
                                idx = 0
                                s = (6 * ceil32(return_data.size)) + _12912 + 224
                                t = (7 * ceil32(return_data.size)) + 224
                                while idx < _13310:
                                    require mem[s] == mem[s]
                                    mem[t] = mem[s]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(rewardTokenAddress)
                                staticcall rewardTokenAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _19368 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_19368] == mem[_19368]
                                if sub_0b4b41bc <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require sub_0b4b41bc
                                sub_7f94bf16 = mem[_19368] / sub_0b4b41bc
                                mem[mem[64] + 4] = treasuryAddress
                                mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                require ext_code.size(assetAddress)
                                call assetAddress.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _21534 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_21534] == bool(mem[_21534])
                            else:
                                mem[(6 * ceil32(return_data.size)) + 96] = 3
                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(6 * ceil32(return_data.size)) + 228] = 0
                                mem[(6 * ceil32(return_data.size)) + 260] = 0
                                mem[(6 * ceil32(return_data.size)) + 292] = 160
                                mem[(6 * ceil32(return_data.size)) + 388] = 3
                                idx = 0
                                s = (6 * ceil32(return_data.size)) + 128
                                t = (6 * ceil32(return_data.size)) + 420
                                while idx < 3:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args 0, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (7 * ceil32(return_data.size)) + 224
                                require return_data.size >= 32
                                _12911 = mem[(6 * ceil32(return_data.size)) + 224 len 4], 0
                                require mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 <= test266151307()
                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                _13309 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]
                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224] <= test266151307()
                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 32 >= 0
                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256
                                mem[(7 * ceil32(return_data.size)) + 224] = _13309
                                require _12911 + (32 * _13309) + 32 <= return_data.size
                                idx = 0
                                s = (6 * ceil32(return_data.size)) + _12911 + 256
                                t = (7 * ceil32(return_data.size)) + 256
                                while idx < _13309:
                                    require mem[s] == mem[s]
                                    mem[t] = mem[s]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(rewardTokenAddress)
                                staticcall rewardTokenAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _19367 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_19367] == mem[_19367]
                                if sub_0b4b41bc <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require sub_0b4b41bc
                                sub_7f94bf16 = mem[_19367] / sub_0b4b41bc
                                mem[mem[64] + 4] = treasuryAddress
                                mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                require ext_code.size(assetAddress)
                                call assetAddress.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _21533 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_21533] == bool(mem[_21533])
                else:
                    require ext_call.return_data[0] - totalDeposited
                    if (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / ext_call.return_data[0] - totalDeposited != sub_2f6236be:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not ext_call.return_data[0] - totalDeposited:
                        sub_bf4c8572 = 0
                        mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                        mem[ceil32(return_data.size) + 132] = -1
                        require ext_code.size(sub_b8ab24bdAddress)
                        call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args lendingPoolAddress, -1
                        mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                        mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                        mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                        mem[(2 * ceil32(return_data.size)) + 164] = this.address
                        require ext_code.size(lendingPoolAddress)
                        call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                        mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[0]
                        mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                        mem[(4 * ceil32(return_data.size)) + 132] = -1
                        require ext_code.size(assetAddress)
                        call assetAddress.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args routerAddress, -1
                        mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                        if assetAddress == WAVAXAddress:
                            mem[(6 * ceil32(return_data.size)) + 96] = 2
                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                            mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                            mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                            mem[(6 * ceil32(return_data.size)) + 260] = 160
                            mem[(6 * ceil32(return_data.size)) + 356] = 2
                            idx = 0
                            s = (6 * ceil32(return_data.size)) + 128
                            t = (6 * ceil32(return_data.size)) + 388
                            while idx < 2:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[(6 * ceil32(return_data.size)) + 292] = this.address
                            mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                            require ext_code.size(routerAddress)
                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (7 * ceil32(return_data.size)) + 192
                            require return_data.size >= 32
                            _3096 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                            require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                            _3240 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                            mem[(7 * ceil32(return_data.size)) + 192] = _3240
                            require _3096 + (32 * _3240) + 32 <= return_data.size
                            idx = 0
                            s = (6 * ceil32(return_data.size)) + _3096 + 224
                            t = (7 * ceil32(return_data.size)) + 224
                            while idx < _3240:
                                require mem[s] == mem[s]
                                mem[t] = mem[s]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(rewardTokenAddress)
                            staticcall rewardTokenAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _12144 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_12144] == mem[_12144]
                            if sub_0b4b41bc <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require sub_0b4b41bc
                            sub_7f94bf16 = mem[_12144] / sub_0b4b41bc
                            mem[mem[64] + 4] = treasuryAddress
                            mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                            require ext_code.size(assetAddress)
                            call assetAddress.0xa9059cbb with:
                                 gas gas_remaining wei
                                args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _15308 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_15308] == bool(mem[_15308])
                        else:
                            if rewardTokenAddress == WAVAXAddress:
                                mem[(6 * ceil32(return_data.size)) + 96] = 2
                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                mem[(6 * ceil32(return_data.size)) + 228] = 0
                                mem[(6 * ceil32(return_data.size)) + 260] = 160
                                mem[(6 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (6 * ceil32(return_data.size)) + 128
                                t = (6 * ceil32(return_data.size)) + 388
                                while idx < 2:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (7 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _12909 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                _13308 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                mem[(7 * ceil32(return_data.size)) + 192] = _13308
                                require _12909 + (32 * _13308) + 32 <= return_data.size
                                idx = 0
                                s = (6 * ceil32(return_data.size)) + _12909 + 224
                                t = (7 * ceil32(return_data.size)) + 224
                                while idx < _13308:
                                    require mem[s] == mem[s]
                                    mem[t] = mem[s]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(rewardTokenAddress)
                                staticcall rewardTokenAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _19366 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_19366] == mem[_19366]
                                if sub_0b4b41bc <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require sub_0b4b41bc
                                sub_7f94bf16 = mem[_19366] / sub_0b4b41bc
                                mem[mem[64] + 4] = treasuryAddress
                                mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                require ext_code.size(assetAddress)
                                call assetAddress.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _21532 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_21532] == bool(mem[_21532])
                            else:
                                mem[(6 * ceil32(return_data.size)) + 96] = 3
                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(6 * ceil32(return_data.size)) + 228] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                mem[(6 * ceil32(return_data.size)) + 260] = 0
                                mem[(6 * ceil32(return_data.size)) + 292] = 160
                                mem[(6 * ceil32(return_data.size)) + 388] = 3
                                idx = 0
                                s = (6 * ceil32(return_data.size)) + 128
                                t = (6 * ceil32(return_data.size)) + 420
                                while idx < 3:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (7 * ceil32(return_data.size)) + 224
                                require return_data.size >= 32
                                _12908 = mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                require mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                _13307 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]
                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224] <= test266151307()
                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 32 >= 0
                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256
                                mem[(7 * ceil32(return_data.size)) + 224] = _13307
                                require _12908 + (32 * _13307) + 32 <= return_data.size
                                idx = 0
                                s = (6 * ceil32(return_data.size)) + _12908 + 256
                                t = (7 * ceil32(return_data.size)) + 256
                                while idx < _13307:
                                    require mem[s] == mem[s]
                                    mem[t] = mem[s]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(rewardTokenAddress)
                                staticcall rewardTokenAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _19365 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_19365] == mem[_19365]
                                if sub_0b4b41bc <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require sub_0b4b41bc
                                sub_7f94bf16 = mem[_19365] / sub_0b4b41bc
                                mem[mem[64] + 4] = treasuryAddress
                                mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                require ext_code.size(assetAddress)
                                call assetAddress.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _21531 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_21531] == bool(mem[_21531])
                    else:
                        require ext_call.return_data[0] - totalDeposited
                        if (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / ext_call.return_data[0] - totalDeposited != sub_7e72b29f:
                            revert with 0, 'SafeMath: multiplication overflow'
                        sub_bf4c8572 = (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / 10000
                        mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                        mem[ceil32(return_data.size) + 132] = -1
                        require ext_code.size(sub_b8ab24bdAddress)
                        call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args lendingPoolAddress, -1
                        mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                        mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                        mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                        mem[(2 * ceil32(return_data.size)) + 164] = this.address
                        require ext_code.size(lendingPoolAddress)
                        call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                        mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[0]
                        mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                        mem[(4 * ceil32(return_data.size)) + 132] = -1
                        require ext_code.size(assetAddress)
                        call assetAddress.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args routerAddress, -1
                        mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                        if assetAddress == WAVAXAddress:
                            mem[(6 * ceil32(return_data.size)) + 96] = 2
                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                            mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                            mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                            mem[(6 * ceil32(return_data.size)) + 260] = 160
                            mem[(6 * ceil32(return_data.size)) + 356] = 2
                            idx = 0
                            s = (6 * ceil32(return_data.size)) + 128
                            t = (6 * ceil32(return_data.size)) + 388
                            while idx < 2:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[(6 * ceil32(return_data.size)) + 292] = this.address
                            mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                            require ext_code.size(routerAddress)
                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (7 * ceil32(return_data.size)) + 192
                            require return_data.size >= 32
                            _12904 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                            require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                            _13304 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                            mem[(7 * ceil32(return_data.size)) + 192] = _13304
                            require _12904 + (32 * _13304) + 32 <= return_data.size
                            idx = 0
                            s = (6 * ceil32(return_data.size)) + _12904 + 224
                            t = (7 * ceil32(return_data.size)) + 224
                            while idx < _13304:
                                require mem[s] == mem[s]
                                mem[t] = mem[s]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(rewardTokenAddress)
                            staticcall rewardTokenAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _19362 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_19362] == mem[_19362]
                            if sub_0b4b41bc <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require sub_0b4b41bc
                            sub_7f94bf16 = mem[_19362] / sub_0b4b41bc
                            mem[mem[64] + 4] = treasuryAddress
                            mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                            require ext_code.size(assetAddress)
                            call assetAddress.0xa9059cbb with:
                                 gas gas_remaining wei
                                args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _21528 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_21528] == bool(mem[_21528])
                        else:
                            if rewardTokenAddress == WAVAXAddress:
                                mem[(6 * ceil32(return_data.size)) + 96] = 2
                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                mem[(6 * ceil32(return_data.size)) + 228] = 0
                                mem[(6 * ceil32(return_data.size)) + 260] = 160
                                mem[(6 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (6 * ceil32(return_data.size)) + 128
                                t = (6 * ceil32(return_data.size)) + 388
                                while idx < 2:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (7 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _12906 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                _13306 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                mem[(7 * ceil32(return_data.size)) + 192] = _13306
                                require _12906 + (32 * _13306) + 32 <= return_data.size
                                idx = 0
                                s = (6 * ceil32(return_data.size)) + _12906 + 224
                                t = (7 * ceil32(return_data.size)) + 224
                                while idx < _13306:
                                    require mem[s] == mem[s]
                                    mem[t] = mem[s]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(rewardTokenAddress)
                                staticcall rewardTokenAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _19364 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_19364] == mem[_19364]
                                if sub_0b4b41bc <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require sub_0b4b41bc
                                sub_7f94bf16 = mem[_19364] / sub_0b4b41bc
                                mem[mem[64] + 4] = treasuryAddress
                                mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                require ext_code.size(assetAddress)
                                call assetAddress.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _21530 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_21530] == bool(mem[_21530])
                            else:
                                mem[(6 * ceil32(return_data.size)) + 96] = 3
                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(6 * ceil32(return_data.size)) + 228] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                mem[(6 * ceil32(return_data.size)) + 260] = 0
                                mem[(6 * ceil32(return_data.size)) + 292] = 160
                                mem[(6 * ceil32(return_data.size)) + 388] = 3
                                idx = 0
                                s = (6 * ceil32(return_data.size)) + 128
                                t = (6 * ceil32(return_data.size)) + 420
                                while idx < 3:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (7 * ceil32(return_data.size)) + 224
                                require return_data.size >= 32
                                _12905 = mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                require mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                _13305 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]
                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224] <= test266151307()
                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 32 >= 0
                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256
                                mem[(7 * ceil32(return_data.size)) + 224] = _13305
                                require _12905 + (32 * _13305) + 32 <= return_data.size
                                idx = 0
                                s = (6 * ceil32(return_data.size)) + _12905 + 256
                                t = (7 * ceil32(return_data.size)) + 256
                                while idx < _13305:
                                    require mem[s] == mem[s]
                                    mem[t] = mem[s]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(rewardTokenAddress)
                                staticcall rewardTokenAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _19363 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_19363] == mem[_19363]
                                if sub_0b4b41bc <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require sub_0b4b41bc
                                sub_7f94bf16 = mem[_19363] / sub_0b4b41bc
                                mem[mem[64] + 4] = treasuryAddress
                                mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                require ext_code.size(assetAddress)
                                call assetAddress.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _21529 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_21529] == bool(mem[_21529])
        else:
            if not totalDeposited:
                lastRewardTimestamp = block.timestamp
                mem[100] = this.address
                require ext_code.size(sub_b8ab24bdAddress)
                staticcall sub_b8ab24bdAddress.0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                if not ext_call.return_data[0] - totalDeposited:
                    if not ext_call.return_data[0] - totalDeposited:
                        if not ext_call.return_data[0] - totalDeposited:
                            sub_bf4c8572 = 0
                            mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                            mem[ceil32(return_data.size) + 132] = -1
                            require ext_code.size(sub_b8ab24bdAddress)
                            call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args lendingPoolAddress, -1
                            mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                            mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                            mem[(2 * ceil32(return_data.size)) + 164] = this.address
                            require ext_code.size(lendingPoolAddress)
                            call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                            mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[0]
                            mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                            mem[(4 * ceil32(return_data.size)) + 132] = -1
                            require ext_code.size(assetAddress)
                            call assetAddress.approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args routerAddress, -1
                            mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            if assetAddress == WAVAXAddress:
                                mem[(6 * ceil32(return_data.size)) + 96] = 2
                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(6 * ceil32(return_data.size)) + 196] = 0
                                mem[(6 * ceil32(return_data.size)) + 228] = 0
                                mem[(6 * ceil32(return_data.size)) + 260] = 160
                                mem[(6 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (6 * ceil32(return_data.size)) + 128
                                t = (6 * ceil32(return_data.size)) + 388
                                while idx < 2:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (7 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _3063 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                _3200 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                mem[(7 * ceil32(return_data.size)) + 192] = _3200
                                require _3063 + (32 * _3200) + 32 <= return_data.size
                                idx = 0
                                s = (6 * ceil32(return_data.size)) + _3063 + 224
                                t = (7 * ceil32(return_data.size)) + 224
                                while idx < _3200:
                                    require mem[s] == mem[s]
                                    mem[t] = mem[s]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(rewardTokenAddress)
                                staticcall rewardTokenAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _12139 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_12139] == mem[_12139]
                                if sub_0b4b41bc <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require sub_0b4b41bc
                                sub_7f94bf16 = mem[_12139] / sub_0b4b41bc
                                mem[mem[64] + 4] = treasuryAddress
                                mem[mem[64] + 36] = 0
                                require ext_code.size(assetAddress)
                                call assetAddress.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args treasuryAddress, 0
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _14966 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_14966] == bool(mem[_14966])
                            else:
                                if rewardTokenAddress == WAVAXAddress:
                                    mem[(6 * ceil32(return_data.size)) + 96] = 2
                                    mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                    mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                    mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[(6 * ceil32(return_data.size)) + 196] = 0
                                    mem[(6 * ceil32(return_data.size)) + 228] = 0
                                    mem[(6 * ceil32(return_data.size)) + 260] = 160
                                    mem[(6 * ceil32(return_data.size)) + 356] = 2
                                    idx = 0
                                    s = (6 * ceil32(return_data.size)) + 128
                                    t = (6 * ceil32(return_data.size)) + 388
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                    mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = (7 * ceil32(return_data.size)) + 192
                                    require return_data.size >= 32
                                    _3065 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                    require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                    require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                    _3202 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                    require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                    require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                    mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                    mem[(7 * ceil32(return_data.size)) + 192] = _3202
                                    require _3065 + (32 * _3202) + 32 <= return_data.size
                                    idx = 0
                                    s = (6 * ceil32(return_data.size)) + _3065 + 224
                                    t = (7 * ceil32(return_data.size)) + 224
                                    while idx < _3202:
                                        require mem[s] == mem[s]
                                        mem[t] = mem[s]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(rewardTokenAddress)
                                    staticcall rewardTokenAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _12141 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_12141] == mem[_12141]
                                    if sub_0b4b41bc <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require sub_0b4b41bc
                                    sub_7f94bf16 = mem[_12141] / sub_0b4b41bc
                                    mem[mem[64] + 4] = treasuryAddress
                                    mem[mem[64] + 36] = 0
                                    require ext_code.size(assetAddress)
                                    call assetAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args treasuryAddress, 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _14968 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_14968] == bool(mem[_14968])
                                else:
                                    mem[(6 * ceil32(return_data.size)) + 96] = 3
                                    mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                    mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                    mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                    mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[(6 * ceil32(return_data.size)) + 228] = 0
                                    mem[(6 * ceil32(return_data.size)) + 260] = 0
                                    mem[(6 * ceil32(return_data.size)) + 292] = 160
                                    mem[(6 * ceil32(return_data.size)) + 388] = 3
                                    idx = 0
                                    s = (6 * ceil32(return_data.size)) + 128
                                    t = (6 * ceil32(return_data.size)) + 420
                                    while idx < 3:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                    mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args 0, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = (7 * ceil32(return_data.size)) + 224
                                    require return_data.size >= 32
                                    _3064 = mem[(6 * ceil32(return_data.size)) + 224 len 4], 0
                                    require mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 <= test266151307()
                                    require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                    _3201 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]
                                    require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224] <= test266151307()
                                    require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 32 >= 0
                                    mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256
                                    mem[(7 * ceil32(return_data.size)) + 224] = _3201
                                    require _3064 + (32 * _3201) + 32 <= return_data.size
                                    idx = 0
                                    s = (6 * ceil32(return_data.size)) + _3064 + 256
                                    t = (7 * ceil32(return_data.size)) + 256
                                    while idx < _3201:
                                        require mem[s] == mem[s]
                                        mem[t] = mem[s]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(rewardTokenAddress)
                                    staticcall rewardTokenAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _12140 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_12140] == mem[_12140]
                                    if sub_0b4b41bc <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require sub_0b4b41bc
                                    sub_7f94bf16 = mem[_12140] / sub_0b4b41bc
                                    mem[mem[64] + 4] = treasuryAddress
                                    mem[mem[64] + 36] = 0
                                    require ext_code.size(assetAddress)
                                    call assetAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args treasuryAddress, 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _14967 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_14967] == bool(mem[_14967])
                        else:
                            require ext_call.return_data[0] - totalDeposited
                            if (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / ext_call.return_data[0] - totalDeposited != sub_7e72b29f:
                                revert with 0, 'SafeMath: multiplication overflow'
                            sub_bf4c8572 = (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / 10000
                            mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                            mem[ceil32(return_data.size) + 132] = -1
                            require ext_code.size(sub_b8ab24bdAddress)
                            call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args lendingPoolAddress, -1
                            mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                            mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                            mem[(2 * ceil32(return_data.size)) + 164] = this.address
                            require ext_code.size(lendingPoolAddress)
                            call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                            mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[0]
                            mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                            mem[(4 * ceil32(return_data.size)) + 132] = -1
                            require ext_code.size(assetAddress)
                            call assetAddress.approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args routerAddress, -1
                            mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            if assetAddress == WAVAXAddress:
                                mem[(6 * ceil32(return_data.size)) + 96] = 2
                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(6 * ceil32(return_data.size)) + 196] = 0
                                mem[(6 * ceil32(return_data.size)) + 228] = 0
                                mem[(6 * ceil32(return_data.size)) + 260] = 160
                                mem[(6 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (6 * ceil32(return_data.size)) + 128
                                t = (6 * ceil32(return_data.size)) + 388
                                while idx < 2:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (7 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _3062 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                _3198 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                mem[(7 * ceil32(return_data.size)) + 192] = _3198
                                require _3062 + (32 * _3198) + 32 <= return_data.size
                                idx = 0
                                s = (6 * ceil32(return_data.size)) + _3062 + 224
                                t = (7 * ceil32(return_data.size)) + 224
                                while idx < _3198:
                                    require mem[s] == mem[s]
                                    mem[t] = mem[s]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(rewardTokenAddress)
                                staticcall rewardTokenAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _12138 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_12138] == mem[_12138]
                                if sub_0b4b41bc <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require sub_0b4b41bc
                                sub_7f94bf16 = mem[_12138] / sub_0b4b41bc
                                mem[mem[64] + 4] = treasuryAddress
                                mem[mem[64] + 36] = 0
                                require ext_code.size(assetAddress)
                                call assetAddress.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args treasuryAddress, 0
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _14963 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_14963] == bool(mem[_14963])
                            else:
                                if rewardTokenAddress == WAVAXAddress:
                                    mem[(6 * ceil32(return_data.size)) + 96] = 2
                                    mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                    mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                    mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[(6 * ceil32(return_data.size)) + 196] = 0
                                    mem[(6 * ceil32(return_data.size)) + 228] = 0
                                    mem[(6 * ceil32(return_data.size)) + 260] = 160
                                    mem[(6 * ceil32(return_data.size)) + 356] = 2
                                    idx = 0
                                    s = (6 * ceil32(return_data.size)) + 128
                                    t = (6 * ceil32(return_data.size)) + 388
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                    mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = (7 * ceil32(return_data.size)) + 192
                                    require return_data.size >= 32
                                    _12564 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                    require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                    require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                    _12969 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                    require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                    require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                    mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                    mem[(7 * ceil32(return_data.size)) + 192] = _12969
                                    require _12564 + (32 * _12969) + 32 <= return_data.size
                                    idx = 0
                                    s = (6 * ceil32(return_data.size)) + _12564 + 224
                                    t = (7 * ceil32(return_data.size)) + 224
                                    while idx < _12969:
                                        require mem[s] == mem[s]
                                        mem[t] = mem[s]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(rewardTokenAddress)
                                    staticcall rewardTokenAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _19027 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_19027] == mem[_19027]
                                    if sub_0b4b41bc <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require sub_0b4b41bc
                                    sub_7f94bf16 = mem[_19027] / sub_0b4b41bc
                                    mem[mem[64] + 4] = treasuryAddress
                                    mem[mem[64] + 36] = 0
                                    require ext_code.size(assetAddress)
                                    call assetAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args treasuryAddress, 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _21193 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_21193] == bool(mem[_21193])
                                else:
                                    mem[(6 * ceil32(return_data.size)) + 96] = 3
                                    mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                    mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                    mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                    mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[(6 * ceil32(return_data.size)) + 228] = 0
                                    mem[(6 * ceil32(return_data.size)) + 260] = 0
                                    mem[(6 * ceil32(return_data.size)) + 292] = 160
                                    mem[(6 * ceil32(return_data.size)) + 388] = 3
                                    idx = 0
                                    s = (6 * ceil32(return_data.size)) + 128
                                    t = (6 * ceil32(return_data.size)) + 420
                                    while idx < 3:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                    mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args 0, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = (7 * ceil32(return_data.size)) + 224
                                    require return_data.size >= 32
                                    _12563 = mem[(6 * ceil32(return_data.size)) + 224 len 4], 0
                                    require mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 <= test266151307()
                                    require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                    _12968 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]
                                    require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224] <= test266151307()
                                    require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 32 >= 0
                                    mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256
                                    mem[(7 * ceil32(return_data.size)) + 224] = _12968
                                    require _12563 + (32 * _12968) + 32 <= return_data.size
                                    idx = 0
                                    s = (6 * ceil32(return_data.size)) + _12563 + 256
                                    t = (7 * ceil32(return_data.size)) + 256
                                    while idx < _12968:
                                        require mem[s] == mem[s]
                                        mem[t] = mem[s]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(rewardTokenAddress)
                                    staticcall rewardTokenAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _19026 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_19026] == mem[_19026]
                                    if sub_0b4b41bc <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require sub_0b4b41bc
                                    sub_7f94bf16 = mem[_19026] / sub_0b4b41bc
                                    mem[mem[64] + 4] = treasuryAddress
                                    mem[mem[64] + 36] = 0
                                    require ext_code.size(assetAddress)
                                    call assetAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args treasuryAddress, 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _21192 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_21192] == bool(mem[_21192])
                    else:
                        require ext_call.return_data[0] - totalDeposited
                        if (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / ext_call.return_data[0] - totalDeposited != sub_2f6236be:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not ext_call.return_data[0] - totalDeposited:
                            sub_bf4c8572 = 0
                            mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                            mem[ceil32(return_data.size) + 132] = -1
                            require ext_code.size(sub_b8ab24bdAddress)
                            call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args lendingPoolAddress, -1
                            mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                            mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                            mem[(2 * ceil32(return_data.size)) + 164] = this.address
                            require ext_code.size(lendingPoolAddress)
                            call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                            mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[0]
                            mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                            mem[(4 * ceil32(return_data.size)) + 132] = -1
                            require ext_code.size(assetAddress)
                            call assetAddress.approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args routerAddress, -1
                            mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            if assetAddress == WAVAXAddress:
                                mem[(6 * ceil32(return_data.size)) + 96] = 2
                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                mem[(6 * ceil32(return_data.size)) + 228] = 0
                                mem[(6 * ceil32(return_data.size)) + 260] = 160
                                mem[(6 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (6 * ceil32(return_data.size)) + 128
                                t = (6 * ceil32(return_data.size)) + 388
                                while idx < 2:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (7 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _3061 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                _3196 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                mem[(7 * ceil32(return_data.size)) + 192] = _3196
                                require _3061 + (32 * _3196) + 32 <= return_data.size
                                idx = 0
                                s = (6 * ceil32(return_data.size)) + _3061 + 224
                                t = (7 * ceil32(return_data.size)) + 224
                                while idx < _3196:
                                    require mem[s] == mem[s]
                                    mem[t] = mem[s]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(rewardTokenAddress)
                                staticcall rewardTokenAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _12137 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_12137] == mem[_12137]
                                if sub_0b4b41bc <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require sub_0b4b41bc
                                sub_7f94bf16 = mem[_12137] / sub_0b4b41bc
                                mem[mem[64] + 4] = treasuryAddress
                                mem[mem[64] + 36] = 0
                                require ext_code.size(assetAddress)
                                call assetAddress.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args treasuryAddress, 0
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _14960 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_14960] == bool(mem[_14960])
                            else:
                                if rewardTokenAddress == WAVAXAddress:
                                    mem[(6 * ceil32(return_data.size)) + 96] = 2
                                    mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                    mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                    mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                    mem[(6 * ceil32(return_data.size)) + 228] = 0
                                    mem[(6 * ceil32(return_data.size)) + 260] = 160
                                    mem[(6 * ceil32(return_data.size)) + 356] = 2
                                    idx = 0
                                    s = (6 * ceil32(return_data.size)) + 128
                                    t = (6 * ceil32(return_data.size)) + 388
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                    mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = (7 * ceil32(return_data.size)) + 192
                                    require return_data.size >= 32
                                    _12561 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                    require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                    require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                    _12967 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                    require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                    require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                    mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                    mem[(7 * ceil32(return_data.size)) + 192] = _12967
                                    require _12561 + (32 * _12967) + 32 <= return_data.size
                                    idx = 0
                                    s = (6 * ceil32(return_data.size)) + _12561 + 224
                                    t = (7 * ceil32(return_data.size)) + 224
                                    while idx < _12967:
                                        require mem[s] == mem[s]
                                        mem[t] = mem[s]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(rewardTokenAddress)
                                    staticcall rewardTokenAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _19025 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_19025] == mem[_19025]
                                    if sub_0b4b41bc <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require sub_0b4b41bc
                                    sub_7f94bf16 = mem[_19025] / sub_0b4b41bc
                                    mem[mem[64] + 4] = treasuryAddress
                                    mem[mem[64] + 36] = 0
                                    require ext_code.size(assetAddress)
                                    call assetAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args treasuryAddress, 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _21191 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_21191] == bool(mem[_21191])
                                else:
                                    mem[(6 * ceil32(return_data.size)) + 96] = 3
                                    mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                    mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                    mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                    mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[(6 * ceil32(return_data.size)) + 228] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                    mem[(6 * ceil32(return_data.size)) + 260] = 0
                                    mem[(6 * ceil32(return_data.size)) + 292] = 160
                                    mem[(6 * ceil32(return_data.size)) + 388] = 3
                                    idx = 0
                                    s = (6 * ceil32(return_data.size)) + 128
                                    t = (6 * ceil32(return_data.size)) + 420
                                    while idx < 3:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                    mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = (7 * ceil32(return_data.size)) + 224
                                    require return_data.size >= 32
                                    _12560 = mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                    require mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                    require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                    _12966 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]
                                    require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224] <= test266151307()
                                    require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 32 >= 0
                                    mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256
                                    mem[(7 * ceil32(return_data.size)) + 224] = _12966
                                    require _12560 + (32 * _12966) + 32 <= return_data.size
                                    idx = 0
                                    s = (6 * ceil32(return_data.size)) + _12560 + 256
                                    t = (7 * ceil32(return_data.size)) + 256
                                    while idx < _12966:
                                        require mem[s] == mem[s]
                                        mem[t] = mem[s]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(rewardTokenAddress)
                                    staticcall rewardTokenAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _19024 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_19024] == mem[_19024]
                                    if sub_0b4b41bc <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require sub_0b4b41bc
                                    sub_7f94bf16 = mem[_19024] / sub_0b4b41bc
                                    mem[mem[64] + 4] = treasuryAddress
                                    mem[mem[64] + 36] = 0
                                    require ext_code.size(assetAddress)
                                    call assetAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args treasuryAddress, 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _21190 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_21190] == bool(mem[_21190])
                        else:
                            require ext_call.return_data[0] - totalDeposited
                            if (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / ext_call.return_data[0] - totalDeposited != sub_7e72b29f:
                                revert with 0, 'SafeMath: multiplication overflow'
                            sub_bf4c8572 = (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / 10000
                            mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                            mem[ceil32(return_data.size) + 132] = -1
                            require ext_code.size(sub_b8ab24bdAddress)
                            call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args lendingPoolAddress, -1
                            mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                            mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                            mem[(2 * ceil32(return_data.size)) + 164] = this.address
                            require ext_code.size(lendingPoolAddress)
                            call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                            mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[0]
                            mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                            mem[(4 * ceil32(return_data.size)) + 132] = -1
                            require ext_code.size(assetAddress)
                            call assetAddress.approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args routerAddress, -1
                            mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            if assetAddress == WAVAXAddress:
                                mem[(6 * ceil32(return_data.size)) + 96] = 2
                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                mem[(6 * ceil32(return_data.size)) + 228] = 0
                                mem[(6 * ceil32(return_data.size)) + 260] = 160
                                mem[(6 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (6 * ceil32(return_data.size)) + 128
                                t = (6 * ceil32(return_data.size)) + 388
                                while idx < 2:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (7 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _12556 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                _12963 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                mem[(7 * ceil32(return_data.size)) + 192] = _12963
                                require _12556 + (32 * _12963) + 32 <= return_data.size
                                idx = 0
                                s = (6 * ceil32(return_data.size)) + _12556 + 224
                                t = (7 * ceil32(return_data.size)) + 224
                                while idx < _12963:
                                    require mem[s] == mem[s]
                                    mem[t] = mem[s]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(rewardTokenAddress)
                                staticcall rewardTokenAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _19021 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_19021] == mem[_19021]
                                if sub_0b4b41bc <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require sub_0b4b41bc
                                sub_7f94bf16 = mem[_19021] / sub_0b4b41bc
                                mem[mem[64] + 4] = treasuryAddress
                                mem[mem[64] + 36] = 0
                                require ext_code.size(assetAddress)
                                call assetAddress.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args treasuryAddress, 0
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _21187 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_21187] == bool(mem[_21187])
                            else:
                                if rewardTokenAddress == WAVAXAddress:
                                    mem[(6 * ceil32(return_data.size)) + 96] = 2
                                    mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                    mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                    mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                    mem[(6 * ceil32(return_data.size)) + 228] = 0
                                    mem[(6 * ceil32(return_data.size)) + 260] = 160
                                    mem[(6 * ceil32(return_data.size)) + 356] = 2
                                    idx = 0
                                    s = (6 * ceil32(return_data.size)) + 128
                                    t = (6 * ceil32(return_data.size)) + 388
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                    mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = (7 * ceil32(return_data.size)) + 192
                                    require return_data.size >= 32
                                    _12558 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                    require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                    require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                    _12965 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                    require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                    require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                    mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                    mem[(7 * ceil32(return_data.size)) + 192] = _12965
                                    require _12558 + (32 * _12965) + 32 <= return_data.size
                                    idx = 0
                                    s = (6 * ceil32(return_data.size)) + _12558 + 224
                                    t = (7 * ceil32(return_data.size)) + 224
                                    while idx < _12965:
                                        require mem[s] == mem[s]
                                        mem[t] = mem[s]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(rewardTokenAddress)
                                    staticcall rewardTokenAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _19023 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_19023] == mem[_19023]
                                    if sub_0b4b41bc <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require sub_0b4b41bc
                                    sub_7f94bf16 = mem[_19023] / sub_0b4b41bc
                                    mem[mem[64] + 4] = treasuryAddress
                                    mem[mem[64] + 36] = 0
                                    require ext_code.size(assetAddress)
                                    call assetAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args treasuryAddress, 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _21189 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_21189] == bool(mem[_21189])
                                else:
                                    mem[(6 * ceil32(return_data.size)) + 96] = 3
                                    mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                    mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                    mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                    mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[(6 * ceil32(return_data.size)) + 228] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                    mem[(6 * ceil32(return_data.size)) + 260] = 0
                                    mem[(6 * ceil32(return_data.size)) + 292] = 160
                                    mem[(6 * ceil32(return_data.size)) + 388] = 3
                                    idx = 0
                                    s = (6 * ceil32(return_data.size)) + 128
                                    t = (6 * ceil32(return_data.size)) + 420
                                    while idx < 3:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                    mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = (7 * ceil32(return_data.size)) + 224
                                    require return_data.size >= 32
                                    _12557 = mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                    require mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                    require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                    _12964 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]
                                    require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224] <= test266151307()
                                    require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 32 >= 0
                                    mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256
                                    mem[(7 * ceil32(return_data.size)) + 224] = _12964
                                    require _12557 + (32 * _12964) + 32 <= return_data.size
                                    idx = 0
                                    s = (6 * ceil32(return_data.size)) + _12557 + 256
                                    t = (7 * ceil32(return_data.size)) + 256
                                    while idx < _12964:
                                        require mem[s] == mem[s]
                                        mem[t] = mem[s]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(rewardTokenAddress)
                                    staticcall rewardTokenAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _19022 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_19022] == mem[_19022]
                                    if sub_0b4b41bc <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require sub_0b4b41bc
                                    sub_7f94bf16 = mem[_19022] / sub_0b4b41bc
                                    mem[mem[64] + 4] = treasuryAddress
                                    mem[mem[64] + 36] = 0
                                    require ext_code.size(assetAddress)
                                    call assetAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args treasuryAddress, 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _21188 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_21188] == bool(mem[_21188])
                else:
                    require ext_call.return_data[0] - totalDeposited
                    if (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / ext_call.return_data[0] - totalDeposited != sub_7796ff37:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not ext_call.return_data[0] - totalDeposited:
                        if not ext_call.return_data[0] - totalDeposited:
                            sub_bf4c8572 = 0
                            mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                            mem[ceil32(return_data.size) + 132] = -1
                            require ext_code.size(sub_b8ab24bdAddress)
                            call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args lendingPoolAddress, -1
                            mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                            mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                            mem[(2 * ceil32(return_data.size)) + 164] = this.address
                            require ext_code.size(lendingPoolAddress)
                            call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                            mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[0]
                            mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                            mem[(4 * ceil32(return_data.size)) + 132] = -1
                            require ext_code.size(assetAddress)
                            call assetAddress.approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args routerAddress, -1
                            mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            if assetAddress == WAVAXAddress:
                                mem[(6 * ceil32(return_data.size)) + 96] = 2
                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(6 * ceil32(return_data.size)) + 196] = 0
                                mem[(6 * ceil32(return_data.size)) + 228] = 0
                                mem[(6 * ceil32(return_data.size)) + 260] = 160
                                mem[(6 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (6 * ceil32(return_data.size)) + 128
                                t = (6 * ceil32(return_data.size)) + 388
                                while idx < 2:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (7 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _3060 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                _3193 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                mem[(7 * ceil32(return_data.size)) + 192] = _3193
                                require _3060 + (32 * _3193) + 32 <= return_data.size
                                idx = 0
                                s = (6 * ceil32(return_data.size)) + _3060 + 224
                                t = (7 * ceil32(return_data.size)) + 224
                                while idx < _3193:
                                    require mem[s] == mem[s]
                                    mem[t] = mem[s]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(rewardTokenAddress)
                                staticcall rewardTokenAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _12136 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_12136] == mem[_12136]
                                if sub_0b4b41bc <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require sub_0b4b41bc
                                sub_7f94bf16 = mem[_12136] / sub_0b4b41bc
                                mem[mem[64] + 4] = treasuryAddress
                                mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                require ext_code.size(assetAddress)
                                call assetAddress.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _14954 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_14954] == bool(mem[_14954])
                            else:
                                if rewardTokenAddress == WAVAXAddress:
                                    mem[(6 * ceil32(return_data.size)) + 96] = 2
                                    mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                    mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                    mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[(6 * ceil32(return_data.size)) + 196] = 0
                                    mem[(6 * ceil32(return_data.size)) + 228] = 0
                                    mem[(6 * ceil32(return_data.size)) + 260] = 160
                                    mem[(6 * ceil32(return_data.size)) + 356] = 2
                                    idx = 0
                                    s = (6 * ceil32(return_data.size)) + 128
                                    t = (6 * ceil32(return_data.size)) + 388
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                    mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = (7 * ceil32(return_data.size)) + 192
                                    require return_data.size >= 32
                                    _12555 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                    require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                    require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                    _12962 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                    require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                    require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                    mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                    mem[(7 * ceil32(return_data.size)) + 192] = _12962
                                    require _12555 + (32 * _12962) + 32 <= return_data.size
                                    idx = 0
                                    s = (6 * ceil32(return_data.size)) + _12555 + 224
                                    t = (7 * ceil32(return_data.size)) + 224
                                    while idx < _12962:
                                        require mem[s] == mem[s]
                                        mem[t] = mem[s]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(rewardTokenAddress)
                                    staticcall rewardTokenAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _19020 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_19020] == mem[_19020]
                                    if sub_0b4b41bc <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require sub_0b4b41bc
                                    sub_7f94bf16 = mem[_19020] / sub_0b4b41bc
                                    mem[mem[64] + 4] = treasuryAddress
                                    mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                    require ext_code.size(assetAddress)
                                    call assetAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _21186 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_21186] == bool(mem[_21186])
                                else:
                                    mem[(6 * ceil32(return_data.size)) + 96] = 3
                                    mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                    mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                    mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                    mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[(6 * ceil32(return_data.size)) + 228] = 0
                                    mem[(6 * ceil32(return_data.size)) + 260] = 0
                                    mem[(6 * ceil32(return_data.size)) + 292] = 160
                                    mem[(6 * ceil32(return_data.size)) + 388] = 3
                                    idx = 0
                                    s = (6 * ceil32(return_data.size)) + 128
                                    t = (6 * ceil32(return_data.size)) + 420
                                    while idx < 3:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                    mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args 0, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = (7 * ceil32(return_data.size)) + 224
                                    require return_data.size >= 32
                                    _12554 = mem[(6 * ceil32(return_data.size)) + 224 len 4], 0
                                    require mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 <= test266151307()
                                    require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                    _12961 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]
                                    require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224] <= test266151307()
                                    require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 32 >= 0
                                    mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256
                                    mem[(7 * ceil32(return_data.size)) + 224] = _12961
                                    require _12554 + (32 * _12961) + 32 <= return_data.size
                                    idx = 0
                                    s = (6 * ceil32(return_data.size)) + _12554 + 256
                                    t = (7 * ceil32(return_data.size)) + 256
                                    while idx < _12961:
                                        require mem[s] == mem[s]
                                        mem[t] = mem[s]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(rewardTokenAddress)
                                    staticcall rewardTokenAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _19019 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_19019] == mem[_19019]
                                    if sub_0b4b41bc <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require sub_0b4b41bc
                                    sub_7f94bf16 = mem[_19019] / sub_0b4b41bc
                                    mem[mem[64] + 4] = treasuryAddress
                                    mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                    require ext_code.size(assetAddress)
                                    call assetAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _21185 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_21185] == bool(mem[_21185])
                        else:
                            require ext_call.return_data[0] - totalDeposited
                            if (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / ext_call.return_data[0] - totalDeposited != sub_7e72b29f:
                                revert with 0, 'SafeMath: multiplication overflow'
                            sub_bf4c8572 = (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / 10000
                            mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                            mem[ceil32(return_data.size) + 132] = -1
                            require ext_code.size(sub_b8ab24bdAddress)
                            call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args lendingPoolAddress, -1
                            mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                            mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                            mem[(2 * ceil32(return_data.size)) + 164] = this.address
                            require ext_code.size(lendingPoolAddress)
                            call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                            mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[0]
                            mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                            mem[(4 * ceil32(return_data.size)) + 132] = -1
                            require ext_code.size(assetAddress)
                            call assetAddress.approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args routerAddress, -1
                            mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            if assetAddress == WAVAXAddress:
                                mem[(6 * ceil32(return_data.size)) + 96] = 2
                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(6 * ceil32(return_data.size)) + 196] = 0
                                mem[(6 * ceil32(return_data.size)) + 228] = 0
                                mem[(6 * ceil32(return_data.size)) + 260] = 160
                                mem[(6 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (6 * ceil32(return_data.size)) + 128
                                t = (6 * ceil32(return_data.size)) + 388
                                while idx < 2:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (7 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _12550 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                _12958 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                mem[(7 * ceil32(return_data.size)) + 192] = _12958
                                require _12550 + (32 * _12958) + 32 <= return_data.size
                                idx = 0
                                s = (6 * ceil32(return_data.size)) + _12550 + 224
                                t = (7 * ceil32(return_data.size)) + 224
                                while idx < _12958:
                                    require mem[s] == mem[s]
                                    mem[t] = mem[s]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(rewardTokenAddress)
                                staticcall rewardTokenAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _19016 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_19016] == mem[_19016]
                                if sub_0b4b41bc <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require sub_0b4b41bc
                                sub_7f94bf16 = mem[_19016] / sub_0b4b41bc
                                mem[mem[64] + 4] = treasuryAddress
                                mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                require ext_code.size(assetAddress)
                                call assetAddress.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _21182 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_21182] == bool(mem[_21182])
                            else:
                                if rewardTokenAddress == WAVAXAddress:
                                    mem[(6 * ceil32(return_data.size)) + 96] = 2
                                    mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                    mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                    mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[(6 * ceil32(return_data.size)) + 196] = 0
                                    mem[(6 * ceil32(return_data.size)) + 228] = 0
                                    mem[(6 * ceil32(return_data.size)) + 260] = 160
                                    mem[(6 * ceil32(return_data.size)) + 356] = 2
                                    idx = 0
                                    s = (6 * ceil32(return_data.size)) + 128
                                    t = (6 * ceil32(return_data.size)) + 388
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                    mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = (7 * ceil32(return_data.size)) + 192
                                    require return_data.size >= 32
                                    _12552 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                    require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                    require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                    _12960 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                    require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                    require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                    mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                    mem[(7 * ceil32(return_data.size)) + 192] = _12960
                                    require _12552 + (32 * _12960) + 32 <= return_data.size
                                    idx = 0
                                    s = (6 * ceil32(return_data.size)) + _12552 + 224
                                    t = (7 * ceil32(return_data.size)) + 224
                                    while idx < _12960:
                                        require mem[s] == mem[s]
                                        mem[t] = mem[s]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(rewardTokenAddress)
                                    staticcall rewardTokenAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _19018 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_19018] == mem[_19018]
                                    if sub_0b4b41bc <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require sub_0b4b41bc
                                    sub_7f94bf16 = mem[_19018] / sub_0b4b41bc
                                    mem[mem[64] + 4] = treasuryAddress
                                    mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                    require ext_code.size(assetAddress)
                                    call assetAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _21184 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_21184] == bool(mem[_21184])
                                else:
                                    mem[(6 * ceil32(return_data.size)) + 96] = 3
                                    mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                    mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                    mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                    mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[(6 * ceil32(return_data.size)) + 228] = 0
                                    mem[(6 * ceil32(return_data.size)) + 260] = 0
                                    mem[(6 * ceil32(return_data.size)) + 292] = 160
                                    mem[(6 * ceil32(return_data.size)) + 388] = 3
                                    idx = 0
                                    s = (6 * ceil32(return_data.size)) + 128
                                    t = (6 * ceil32(return_data.size)) + 420
                                    while idx < 3:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                    mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args 0, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = (7 * ceil32(return_data.size)) + 224
                                    require return_data.size >= 32
                                    _12551 = mem[(6 * ceil32(return_data.size)) + 224 len 4], 0
                                    require mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 <= test266151307()
                                    require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                    _12959 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]
                                    require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224] <= test266151307()
                                    require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 32 >= 0
                                    mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256
                                    mem[(7 * ceil32(return_data.size)) + 224] = _12959
                                    require _12551 + (32 * _12959) + 32 <= return_data.size
                                    idx = 0
                                    s = (6 * ceil32(return_data.size)) + _12551 + 256
                                    t = (7 * ceil32(return_data.size)) + 256
                                    while idx < _12959:
                                        require mem[s] == mem[s]
                                        mem[t] = mem[s]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(rewardTokenAddress)
                                    staticcall rewardTokenAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _19017 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_19017] == mem[_19017]
                                    if sub_0b4b41bc <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require sub_0b4b41bc
                                    sub_7f94bf16 = mem[_19017] / sub_0b4b41bc
                                    mem[mem[64] + 4] = treasuryAddress
                                    mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                    require ext_code.size(assetAddress)
                                    call assetAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _21183 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_21183] == bool(mem[_21183])
                    else:
                        require ext_call.return_data[0] - totalDeposited
                        if (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / ext_call.return_data[0] - totalDeposited != sub_2f6236be:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not ext_call.return_data[0] - totalDeposited:
                            sub_bf4c8572 = 0
                            mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                            mem[ceil32(return_data.size) + 132] = -1
                            require ext_code.size(sub_b8ab24bdAddress)
                            call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args lendingPoolAddress, -1
                            mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                            mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                            mem[(2 * ceil32(return_data.size)) + 164] = this.address
                            require ext_code.size(lendingPoolAddress)
                            call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                            mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[0]
                            mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                            mem[(4 * ceil32(return_data.size)) + 132] = -1
                            require ext_code.size(assetAddress)
                            call assetAddress.approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args routerAddress, -1
                            mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            if assetAddress == WAVAXAddress:
                                mem[(6 * ceil32(return_data.size)) + 96] = 2
                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                mem[(6 * ceil32(return_data.size)) + 228] = 0
                                mem[(6 * ceil32(return_data.size)) + 260] = 160
                                mem[(6 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (6 * ceil32(return_data.size)) + 128
                                t = (6 * ceil32(return_data.size)) + 388
                                while idx < 2:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (7 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _12547 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                _12955 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                mem[(7 * ceil32(return_data.size)) + 192] = _12955
                                require _12547 + (32 * _12955) + 32 <= return_data.size
                                idx = 0
                                s = (6 * ceil32(return_data.size)) + _12547 + 224
                                t = (7 * ceil32(return_data.size)) + 224
                                while idx < _12955:
                                    require mem[s] == mem[s]
                                    mem[t] = mem[s]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(rewardTokenAddress)
                                staticcall rewardTokenAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _19013 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_19013] == mem[_19013]
                                if sub_0b4b41bc <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require sub_0b4b41bc
                                sub_7f94bf16 = mem[_19013] / sub_0b4b41bc
                                mem[mem[64] + 4] = treasuryAddress
                                mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                require ext_code.size(assetAddress)
                                call assetAddress.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _21179 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_21179] == bool(mem[_21179])
                            else:
                                if rewardTokenAddress == WAVAXAddress:
                                    mem[(6 * ceil32(return_data.size)) + 96] = 2
                                    mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                    mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                    mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                    mem[(6 * ceil32(return_data.size)) + 228] = 0
                                    mem[(6 * ceil32(return_data.size)) + 260] = 160
                                    mem[(6 * ceil32(return_data.size)) + 356] = 2
                                    idx = 0
                                    s = (6 * ceil32(return_data.size)) + 128
                                    t = (6 * ceil32(return_data.size)) + 388
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                    mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = (7 * ceil32(return_data.size)) + 192
                                    require return_data.size >= 32
                                    _12549 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                    require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                    require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                    _12957 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                    require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                    require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                    mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                    mem[(7 * ceil32(return_data.size)) + 192] = _12957
                                    require _12549 + (32 * _12957) + 32 <= return_data.size
                                    idx = 0
                                    s = (6 * ceil32(return_data.size)) + _12549 + 224
                                    t = (7 * ceil32(return_data.size)) + 224
                                    while idx < _12957:
                                        require mem[s] == mem[s]
                                        mem[t] = mem[s]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(rewardTokenAddress)
                                    staticcall rewardTokenAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _19015 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_19015] == mem[_19015]
                                    if sub_0b4b41bc <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require sub_0b4b41bc
                                    sub_7f94bf16 = mem[_19015] / sub_0b4b41bc
                                    mem[mem[64] + 4] = treasuryAddress
                                    mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                    require ext_code.size(assetAddress)
                                    call assetAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _21181 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_21181] == bool(mem[_21181])
                                else:
                                    mem[(6 * ceil32(return_data.size)) + 96] = 3
                                    mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                    mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                    mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                    mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[(6 * ceil32(return_data.size)) + 228] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                    mem[(6 * ceil32(return_data.size)) + 260] = 0
                                    mem[(6 * ceil32(return_data.size)) + 292] = 160
                                    mem[(6 * ceil32(return_data.size)) + 388] = 3
                                    idx = 0
                                    s = (6 * ceil32(return_data.size)) + 128
                                    t = (6 * ceil32(return_data.size)) + 420
                                    while idx < 3:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                    mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = (7 * ceil32(return_data.size)) + 224
                                    require return_data.size >= 32
                                    _12548 = mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                    require mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                    require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                    _12956 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]
                                    require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224] <= test266151307()
                                    require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 32 >= 0
                                    mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256
                                    mem[(7 * ceil32(return_data.size)) + 224] = _12956
                                    require _12548 + (32 * _12956) + 32 <= return_data.size
                                    idx = 0
                                    s = (6 * ceil32(return_data.size)) + _12548 + 256
                                    t = (7 * ceil32(return_data.size)) + 256
                                    while idx < _12956:
                                        require mem[s] == mem[s]
                                        mem[t] = mem[s]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(rewardTokenAddress)
                                    staticcall rewardTokenAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _19014 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_19014] == mem[_19014]
                                    if sub_0b4b41bc <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require sub_0b4b41bc
                                    sub_7f94bf16 = mem[_19014] / sub_0b4b41bc
                                    mem[mem[64] + 4] = treasuryAddress
                                    mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                    require ext_code.size(assetAddress)
                                    call assetAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _21180 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_21180] == bool(mem[_21180])
                        else:
                            require ext_call.return_data[0] - totalDeposited
                            if (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / ext_call.return_data[0] - totalDeposited != sub_7e72b29f:
                                revert with 0, 'SafeMath: multiplication overflow'
                            sub_bf4c8572 = (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / 10000
                            mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                            mem[ceil32(return_data.size) + 132] = -1
                            require ext_code.size(sub_b8ab24bdAddress)
                            call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args lendingPoolAddress, -1
                            mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                            mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                            mem[(2 * ceil32(return_data.size)) + 164] = this.address
                            require ext_code.size(lendingPoolAddress)
                            call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                            mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[0]
                            mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                            mem[(4 * ceil32(return_data.size)) + 132] = -1
                            require ext_code.size(assetAddress)
                            call assetAddress.approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args routerAddress, -1
                            mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            if assetAddress == WAVAXAddress:
                                mem[(6 * ceil32(return_data.size)) + 96] = 2
                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                mem[(6 * ceil32(return_data.size)) + 228] = 0
                                mem[(6 * ceil32(return_data.size)) + 260] = 160
                                mem[(6 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (6 * ceil32(return_data.size)) + 128
                                t = (6 * ceil32(return_data.size)) + 388
                                while idx < 2:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (7 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _12544 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                _12952 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                mem[(7 * ceil32(return_data.size)) + 192] = _12952
                                require _12544 + (32 * _12952) + 32 <= return_data.size
                                idx = 0
                                s = (6 * ceil32(return_data.size)) + _12544 + 224
                                t = (7 * ceil32(return_data.size)) + 224
                                while idx < _12952:
                                    require mem[s] == mem[s]
                                    mem[t] = mem[s]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(rewardTokenAddress)
                                staticcall rewardTokenAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _19010 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_19010] == mem[_19010]
                                if sub_0b4b41bc <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require sub_0b4b41bc
                                sub_7f94bf16 = mem[_19010] / sub_0b4b41bc
                                mem[mem[64] + 4] = treasuryAddress
                                mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                require ext_code.size(assetAddress)
                                call assetAddress.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _21176 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_21176] == bool(mem[_21176])
                            else:
                                if rewardTokenAddress == WAVAXAddress:
                                    mem[(6 * ceil32(return_data.size)) + 96] = 2
                                    mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                    mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                    mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                    mem[(6 * ceil32(return_data.size)) + 228] = 0
                                    mem[(6 * ceil32(return_data.size)) + 260] = 160
                                    mem[(6 * ceil32(return_data.size)) + 356] = 2
                                    idx = 0
                                    s = (6 * ceil32(return_data.size)) + 128
                                    t = (6 * ceil32(return_data.size)) + 388
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                    mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = (7 * ceil32(return_data.size)) + 192
                                    require return_data.size >= 32
                                    _12546 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                    require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                    require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                    _12954 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                    require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                    require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                    mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                    mem[(7 * ceil32(return_data.size)) + 192] = _12954
                                    require _12546 + (32 * _12954) + 32 <= return_data.size
                                    idx = 0
                                    s = (6 * ceil32(return_data.size)) + _12546 + 224
                                    t = (7 * ceil32(return_data.size)) + 224
                                    while idx < _12954:
                                        require mem[s] == mem[s]
                                        mem[t] = mem[s]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(rewardTokenAddress)
                                    staticcall rewardTokenAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _19012 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_19012] == mem[_19012]
                                    if sub_0b4b41bc <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require sub_0b4b41bc
                                    sub_7f94bf16 = mem[_19012] / sub_0b4b41bc
                                    mem[mem[64] + 4] = treasuryAddress
                                    mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                    require ext_code.size(assetAddress)
                                    call assetAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _21178 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_21178] == bool(mem[_21178])
                                else:
                                    mem[(6 * ceil32(return_data.size)) + 96] = 3
                                    mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                    mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                    mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                    mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[(6 * ceil32(return_data.size)) + 228] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                    mem[(6 * ceil32(return_data.size)) + 260] = 0
                                    mem[(6 * ceil32(return_data.size)) + 292] = 160
                                    mem[(6 * ceil32(return_data.size)) + 388] = 3
                                    idx = 0
                                    s = (6 * ceil32(return_data.size)) + 128
                                    t = (6 * ceil32(return_data.size)) + 420
                                    while idx < 3:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                    mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = (7 * ceil32(return_data.size)) + 224
                                    require return_data.size >= 32
                                    _12545 = mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                    require mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                    require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                    _12953 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]
                                    require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224] <= test266151307()
                                    require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 32 >= 0
                                    mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256
                                    mem[(7 * ceil32(return_data.size)) + 224] = _12953
                                    require _12545 + (32 * _12953) + 32 <= return_data.size
                                    idx = 0
                                    s = (6 * ceil32(return_data.size)) + _12545 + 256
                                    t = (7 * ceil32(return_data.size)) + 256
                                    while idx < _12953:
                                        require mem[s] == mem[s]
                                        mem[t] = mem[s]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(rewardTokenAddress)
                                    staticcall rewardTokenAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _19011 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_19011] == mem[_19011]
                                    if sub_0b4b41bc <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require sub_0b4b41bc
                                    sub_7f94bf16 = mem[_19011] / sub_0b4b41bc
                                    mem[mem[64] + 4] = treasuryAddress
                                    mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                    require ext_code.size(assetAddress)
                                    call assetAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _21177 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_21177] == bool(mem[_21177])
            else:
                if not sub_f12c8e0d + sub_7f94bf16:
                    lastRewardTimestamp = block.timestamp
                    mem[100] = this.address
                    require ext_code.size(sub_b8ab24bdAddress)
                    staticcall sub_b8ab24bdAddress.0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    if not ext_call.return_data[0] - totalDeposited:
                        if not ext_call.return_data[0] - totalDeposited:
                            if not ext_call.return_data[0] - totalDeposited:
                                sub_bf4c8572 = 0
                                mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                mem[ceil32(return_data.size) + 132] = -1
                                require ext_code.size(sub_b8ab24bdAddress)
                                call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args lendingPoolAddress, -1
                                mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                require ext_code.size(lendingPoolAddress)
                                call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                     gas gas_remaining wei
                                    args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[0]
                                mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                mem[(4 * ceil32(return_data.size)) + 132] = -1
                                require ext_code.size(assetAddress)
                                call assetAddress.approve(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args routerAddress, -1
                                mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                if assetAddress == WAVAXAddress:
                                    mem[(6 * ceil32(return_data.size)) + 96] = 2
                                    mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                    mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                    mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[(6 * ceil32(return_data.size)) + 196] = 0
                                    mem[(6 * ceil32(return_data.size)) + 228] = 0
                                    mem[(6 * ceil32(return_data.size)) + 260] = 160
                                    mem[(6 * ceil32(return_data.size)) + 356] = 2
                                    idx = 0
                                    s = (6 * ceil32(return_data.size)) + 128
                                    t = (6 * ceil32(return_data.size)) + 388
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                    mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = (7 * ceil32(return_data.size)) + 192
                                    require return_data.size >= 32
                                    _3094 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                    require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                    require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                    _3237 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                    require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                    require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                    mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                    mem[(7 * ceil32(return_data.size)) + 192] = _3237
                                    require _3094 + (32 * _3237) + 32 <= return_data.size
                                    idx = 0
                                    s = (6 * ceil32(return_data.size)) + _3094 + 224
                                    t = (7 * ceil32(return_data.size)) + 224
                                    while idx < _3237:
                                        require mem[s] == mem[s]
                                        mem[t] = mem[s]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(rewardTokenAddress)
                                    staticcall rewardTokenAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _12142 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_12142] == mem[_12142]
                                    if sub_0b4b41bc <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require sub_0b4b41bc
                                    sub_7f94bf16 = mem[_12142] / sub_0b4b41bc
                                    mem[mem[64] + 4] = treasuryAddress
                                    mem[mem[64] + 36] = 0
                                    require ext_code.size(assetAddress)
                                    call assetAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args treasuryAddress, 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _15302 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_15302] == bool(mem[_15302])
                                else:
                                    if rewardTokenAddress == WAVAXAddress:
                                        mem[(6 * ceil32(return_data.size)) + 96] = 2
                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                        mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                        mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(6 * ceil32(return_data.size)) + 196] = 0
                                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                                        mem[(6 * ceil32(return_data.size)) + 260] = 160
                                        mem[(6 * ceil32(return_data.size)) + 356] = 2
                                        idx = 0
                                        s = (6 * ceil32(return_data.size)) + 128
                                        t = (6 * ceil32(return_data.size)) + 388
                                        while idx < 2:
                                            mem[t] = mem[s + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                        mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (7 * ceil32(return_data.size)) + 192
                                        require return_data.size >= 32
                                        _3095 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                        require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                        _3238 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                        mem[(7 * ceil32(return_data.size)) + 192] = _3238
                                        require _3095 + (32 * _3238) + 32 <= return_data.size
                                        idx = 0
                                        s = (6 * ceil32(return_data.size)) + _3095 + 224
                                        t = (7 * ceil32(return_data.size)) + 224
                                        while idx < _3238:
                                            require mem[s] == mem[s]
                                            mem[t] = mem[s]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(rewardTokenAddress)
                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _12143 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_12143] == mem[_12143]
                                        if sub_0b4b41bc <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require sub_0b4b41bc
                                        sub_7f94bf16 = mem[_12143] / sub_0b4b41bc
                                        mem[mem[64] + 4] = treasuryAddress
                                        mem[mem[64] + 36] = 0
                                        require ext_code.size(assetAddress)
                                        call assetAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args treasuryAddress, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _15304 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_15304] == bool(mem[_15304])
                                    else:
                                        mem[(6 * ceil32(return_data.size)) + 96] = 3
                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                        mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                        mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                        mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                                        mem[(6 * ceil32(return_data.size)) + 260] = 0
                                        mem[(6 * ceil32(return_data.size)) + 292] = 160
                                        mem[(6 * ceil32(return_data.size)) + 388] = 3
                                        idx = 0
                                        s = (6 * ceil32(return_data.size)) + 128
                                        t = (6 * ceil32(return_data.size)) + 420
                                        while idx < 3:
                                            mem[t] = mem[s + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                        mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args 0, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (7 * ceil32(return_data.size)) + 224
                                        require return_data.size >= 32
                                        _12902 = mem[(6 * ceil32(return_data.size)) + 224 len 4], 0
                                        require mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 <= test266151307()
                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                        _13303 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]
                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224] <= test266151307()
                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 32 >= 0
                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256
                                        mem[(7 * ceil32(return_data.size)) + 224] = _13303
                                        require _12902 + (32 * _13303) + 32 <= return_data.size
                                        idx = 0
                                        s = (6 * ceil32(return_data.size)) + _12902 + 256
                                        t = (7 * ceil32(return_data.size)) + 256
                                        while idx < _13303:
                                            require mem[s] == mem[s]
                                            mem[t] = mem[s]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(rewardTokenAddress)
                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _19361 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_19361] == mem[_19361]
                                        if sub_0b4b41bc <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require sub_0b4b41bc
                                        sub_7f94bf16 = mem[_19361] / sub_0b4b41bc
                                        mem[mem[64] + 4] = treasuryAddress
                                        mem[mem[64] + 36] = 0
                                        require ext_code.size(assetAddress)
                                        call assetAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args treasuryAddress, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _21527 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_21527] == bool(mem[_21527])
                            else:
                                require ext_call.return_data[0] - totalDeposited
                                if (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / ext_call.return_data[0] - totalDeposited != sub_7e72b29f:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                sub_bf4c8572 = (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / 10000
                                mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                mem[ceil32(return_data.size) + 132] = -1
                                require ext_code.size(sub_b8ab24bdAddress)
                                call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args lendingPoolAddress, -1
                                mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                require ext_code.size(lendingPoolAddress)
                                call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                     gas gas_remaining wei
                                    args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[0]
                                mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                mem[(4 * ceil32(return_data.size)) + 132] = -1
                                require ext_code.size(assetAddress)
                                call assetAddress.approve(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args routerAddress, -1
                                mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                if assetAddress == WAVAXAddress:
                                    mem[(6 * ceil32(return_data.size)) + 96] = 2
                                    mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                    mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                    mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[(6 * ceil32(return_data.size)) + 196] = 0
                                    mem[(6 * ceil32(return_data.size)) + 228] = 0
                                    mem[(6 * ceil32(return_data.size)) + 260] = 160
                                    mem[(6 * ceil32(return_data.size)) + 356] = 2
                                    idx = 0
                                    s = (6 * ceil32(return_data.size)) + 128
                                    t = (6 * ceil32(return_data.size)) + 388
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                    mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = (7 * ceil32(return_data.size)) + 192
                                    require return_data.size >= 32
                                    _12898 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                    require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                    require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                    _13300 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                    require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                    require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                    mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                    mem[(7 * ceil32(return_data.size)) + 192] = _13300
                                    require _12898 + (32 * _13300) + 32 <= return_data.size
                                    idx = 0
                                    s = (6 * ceil32(return_data.size)) + _12898 + 224
                                    t = (7 * ceil32(return_data.size)) + 224
                                    while idx < _13300:
                                        require mem[s] == mem[s]
                                        mem[t] = mem[s]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(rewardTokenAddress)
                                    staticcall rewardTokenAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _19358 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_19358] == mem[_19358]
                                    if sub_0b4b41bc <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require sub_0b4b41bc
                                    sub_7f94bf16 = mem[_19358] / sub_0b4b41bc
                                    mem[mem[64] + 4] = treasuryAddress
                                    mem[mem[64] + 36] = 0
                                    require ext_code.size(assetAddress)
                                    call assetAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args treasuryAddress, 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _21524 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_21524] == bool(mem[_21524])
                                else:
                                    if rewardTokenAddress == WAVAXAddress:
                                        mem[(6 * ceil32(return_data.size)) + 96] = 2
                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                        mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                        mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(6 * ceil32(return_data.size)) + 196] = 0
                                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                                        mem[(6 * ceil32(return_data.size)) + 260] = 160
                                        mem[(6 * ceil32(return_data.size)) + 356] = 2
                                        idx = 0
                                        s = (6 * ceil32(return_data.size)) + 128
                                        t = (6 * ceil32(return_data.size)) + 388
                                        while idx < 2:
                                            mem[t] = mem[s + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                        mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (7 * ceil32(return_data.size)) + 192
                                        require return_data.size >= 32
                                        _12900 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                        require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                        _13302 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                        mem[(7 * ceil32(return_data.size)) + 192] = _13302
                                        require _12900 + (32 * _13302) + 32 <= return_data.size
                                        idx = 0
                                        s = (6 * ceil32(return_data.size)) + _12900 + 224
                                        t = (7 * ceil32(return_data.size)) + 224
                                        while idx < _13302:
                                            require mem[s] == mem[s]
                                            mem[t] = mem[s]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(rewardTokenAddress)
                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _19360 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_19360] == mem[_19360]
                                        if sub_0b4b41bc <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require sub_0b4b41bc
                                        sub_7f94bf16 = mem[_19360] / sub_0b4b41bc
                                        mem[mem[64] + 4] = treasuryAddress
                                        mem[mem[64] + 36] = 0
                                        require ext_code.size(assetAddress)
                                        call assetAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args treasuryAddress, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _21526 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_21526] == bool(mem[_21526])
                                    else:
                                        mem[(6 * ceil32(return_data.size)) + 96] = 3
                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                        mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                        mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                        mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                                        mem[(6 * ceil32(return_data.size)) + 260] = 0
                                        mem[(6 * ceil32(return_data.size)) + 292] = 160
                                        mem[(6 * ceil32(return_data.size)) + 388] = 3
                                        idx = 0
                                        s = (6 * ceil32(return_data.size)) + 128
                                        t = (6 * ceil32(return_data.size)) + 420
                                        while idx < 3:
                                            mem[t] = mem[s + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                        mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args 0, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (7 * ceil32(return_data.size)) + 224
                                        require return_data.size >= 32
                                        _12899 = mem[(6 * ceil32(return_data.size)) + 224 len 4], 0
                                        require mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 <= test266151307()
                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                        _13301 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]
                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224] <= test266151307()
                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 32 >= 0
                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256
                                        mem[(7 * ceil32(return_data.size)) + 224] = _13301
                                        require _12899 + (32 * _13301) + 32 <= return_data.size
                                        idx = 0
                                        s = (6 * ceil32(return_data.size)) + _12899 + 256
                                        t = (7 * ceil32(return_data.size)) + 256
                                        while idx < _13301:
                                            require mem[s] == mem[s]
                                            mem[t] = mem[s]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(rewardTokenAddress)
                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _19359 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_19359] == mem[_19359]
                                        if sub_0b4b41bc <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require sub_0b4b41bc
                                        sub_7f94bf16 = mem[_19359] / sub_0b4b41bc
                                        mem[mem[64] + 4] = treasuryAddress
                                        mem[mem[64] + 36] = 0
                                        require ext_code.size(assetAddress)
                                        call assetAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args treasuryAddress, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _21525 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_21525] == bool(mem[_21525])
                        else:
                            require ext_call.return_data[0] - totalDeposited
                            if (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / ext_call.return_data[0] - totalDeposited != sub_2f6236be:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not ext_call.return_data[0] - totalDeposited:
                                sub_bf4c8572 = 0
                                mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                mem[ceil32(return_data.size) + 132] = -1
                                require ext_code.size(sub_b8ab24bdAddress)
                                call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args lendingPoolAddress, -1
                                mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                require ext_code.size(lendingPoolAddress)
                                call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                     gas gas_remaining wei
                                    args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[0]
                                mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                mem[(4 * ceil32(return_data.size)) + 132] = -1
                                require ext_code.size(assetAddress)
                                call assetAddress.approve(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args routerAddress, -1
                                mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                if assetAddress == WAVAXAddress:
                                    mem[(6 * ceil32(return_data.size)) + 96] = 2
                                    mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                    mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                    mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                    mem[(6 * ceil32(return_data.size)) + 228] = 0
                                    mem[(6 * ceil32(return_data.size)) + 260] = 160
                                    mem[(6 * ceil32(return_data.size)) + 356] = 2
                                    idx = 0
                                    s = (6 * ceil32(return_data.size)) + 128
                                    t = (6 * ceil32(return_data.size)) + 388
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                    mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = (7 * ceil32(return_data.size)) + 192
                                    require return_data.size >= 32
                                    _12895 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                    require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                    require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                    _13297 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                    require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                    require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                    mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                    mem[(7 * ceil32(return_data.size)) + 192] = _13297
                                    require _12895 + (32 * _13297) + 32 <= return_data.size
                                    idx = 0
                                    s = (6 * ceil32(return_data.size)) + _12895 + 224
                                    t = (7 * ceil32(return_data.size)) + 224
                                    while idx < _13297:
                                        require mem[s] == mem[s]
                                        mem[t] = mem[s]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(rewardTokenAddress)
                                    staticcall rewardTokenAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _19355 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_19355] == mem[_19355]
                                    if sub_0b4b41bc <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require sub_0b4b41bc
                                    sub_7f94bf16 = mem[_19355] / sub_0b4b41bc
                                    mem[mem[64] + 4] = treasuryAddress
                                    mem[mem[64] + 36] = 0
                                    require ext_code.size(assetAddress)
                                    call assetAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args treasuryAddress, 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _21521 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_21521] == bool(mem[_21521])
                                else:
                                    if rewardTokenAddress == WAVAXAddress:
                                        mem[(6 * ceil32(return_data.size)) + 96] = 2
                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                        mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                        mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                                        mem[(6 * ceil32(return_data.size)) + 260] = 160
                                        mem[(6 * ceil32(return_data.size)) + 356] = 2
                                        idx = 0
                                        s = (6 * ceil32(return_data.size)) + 128
                                        t = (6 * ceil32(return_data.size)) + 388
                                        while idx < 2:
                                            mem[t] = mem[s + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                        mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (7 * ceil32(return_data.size)) + 192
                                        require return_data.size >= 32
                                        _12897 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                        require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                        _13299 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                        mem[(7 * ceil32(return_data.size)) + 192] = _13299
                                        require _12897 + (32 * _13299) + 32 <= return_data.size
                                        idx = 0
                                        s = (6 * ceil32(return_data.size)) + _12897 + 224
                                        t = (7 * ceil32(return_data.size)) + 224
                                        while idx < _13299:
                                            require mem[s] == mem[s]
                                            mem[t] = mem[s]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(rewardTokenAddress)
                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _19357 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_19357] == mem[_19357]
                                        if sub_0b4b41bc <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require sub_0b4b41bc
                                        sub_7f94bf16 = mem[_19357] / sub_0b4b41bc
                                        mem[mem[64] + 4] = treasuryAddress
                                        mem[mem[64] + 36] = 0
                                        require ext_code.size(assetAddress)
                                        call assetAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args treasuryAddress, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _21523 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_21523] == bool(mem[_21523])
                                    else:
                                        mem[(6 * ceil32(return_data.size)) + 96] = 3
                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                        mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                        mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                        mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(6 * ceil32(return_data.size)) + 228] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                        mem[(6 * ceil32(return_data.size)) + 260] = 0
                                        mem[(6 * ceil32(return_data.size)) + 292] = 160
                                        mem[(6 * ceil32(return_data.size)) + 388] = 3
                                        idx = 0
                                        s = (6 * ceil32(return_data.size)) + 128
                                        t = (6 * ceil32(return_data.size)) + 420
                                        while idx < 3:
                                            mem[t] = mem[s + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                        mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (7 * ceil32(return_data.size)) + 224
                                        require return_data.size >= 32
                                        _12896 = mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                        require mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                        _13298 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]
                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224] <= test266151307()
                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 32 >= 0
                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256
                                        mem[(7 * ceil32(return_data.size)) + 224] = _13298
                                        require _12896 + (32 * _13298) + 32 <= return_data.size
                                        idx = 0
                                        s = (6 * ceil32(return_data.size)) + _12896 + 256
                                        t = (7 * ceil32(return_data.size)) + 256
                                        while idx < _13298:
                                            require mem[s] == mem[s]
                                            mem[t] = mem[s]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(rewardTokenAddress)
                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _19356 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_19356] == mem[_19356]
                                        if sub_0b4b41bc <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require sub_0b4b41bc
                                        sub_7f94bf16 = mem[_19356] / sub_0b4b41bc
                                        mem[mem[64] + 4] = treasuryAddress
                                        mem[mem[64] + 36] = 0
                                        require ext_code.size(assetAddress)
                                        call assetAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args treasuryAddress, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _21522 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_21522] == bool(mem[_21522])
                            else:
                                require ext_call.return_data[0] - totalDeposited
                                if (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / ext_call.return_data[0] - totalDeposited != sub_7e72b29f:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                sub_bf4c8572 = (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / 10000
                                mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                mem[ceil32(return_data.size) + 132] = -1
                                require ext_code.size(sub_b8ab24bdAddress)
                                call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args lendingPoolAddress, -1
                                mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                require ext_code.size(lendingPoolAddress)
                                call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                     gas gas_remaining wei
                                    args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[0]
                                mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                mem[(4 * ceil32(return_data.size)) + 132] = -1
                                require ext_code.size(assetAddress)
                                call assetAddress.approve(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args routerAddress, -1
                                mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                if assetAddress == WAVAXAddress:
                                    mem[(6 * ceil32(return_data.size)) + 96] = 2
                                    mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                    mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                    mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                    mem[(6 * ceil32(return_data.size)) + 228] = 0
                                    mem[(6 * ceil32(return_data.size)) + 260] = 160
                                    mem[(6 * ceil32(return_data.size)) + 356] = 2
                                    idx = 0
                                    s = (6 * ceil32(return_data.size)) + 128
                                    t = (6 * ceil32(return_data.size)) + 388
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                    mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = (7 * ceil32(return_data.size)) + 192
                                    require return_data.size >= 32
                                    _12892 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                    require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                    require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                    _13294 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                    require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                    require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                    mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                    mem[(7 * ceil32(return_data.size)) + 192] = _13294
                                    require _12892 + (32 * _13294) + 32 <= return_data.size
                                    idx = 0
                                    s = (6 * ceil32(return_data.size)) + _12892 + 224
                                    t = (7 * ceil32(return_data.size)) + 224
                                    while idx < _13294:
                                        require mem[s] == mem[s]
                                        mem[t] = mem[s]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(rewardTokenAddress)
                                    staticcall rewardTokenAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _19352 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_19352] == mem[_19352]
                                    if sub_0b4b41bc <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require sub_0b4b41bc
                                    sub_7f94bf16 = mem[_19352] / sub_0b4b41bc
                                    mem[mem[64] + 4] = treasuryAddress
                                    mem[mem[64] + 36] = 0
                                    require ext_code.size(assetAddress)
                                    call assetAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args treasuryAddress, 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _21518 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_21518] == bool(mem[_21518])
                                else:
                                    if rewardTokenAddress == WAVAXAddress:
                                        mem[(6 * ceil32(return_data.size)) + 96] = 2
                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                        mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                        mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                                        mem[(6 * ceil32(return_data.size)) + 260] = 160
                                        mem[(6 * ceil32(return_data.size)) + 356] = 2
                                        idx = 0
                                        s = (6 * ceil32(return_data.size)) + 128
                                        t = (6 * ceil32(return_data.size)) + 388
                                        while idx < 2:
                                            mem[t] = mem[s + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                        mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (7 * ceil32(return_data.size)) + 192
                                        require return_data.size >= 32
                                        _12894 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                        require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                        _13296 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                        mem[(7 * ceil32(return_data.size)) + 192] = _13296
                                        require _12894 + (32 * _13296) + 32 <= return_data.size
                                        idx = 0
                                        s = (6 * ceil32(return_data.size)) + _12894 + 224
                                        t = (7 * ceil32(return_data.size)) + 224
                                        while idx < _13296:
                                            require mem[s] == mem[s]
                                            mem[t] = mem[s]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(rewardTokenAddress)
                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _19354 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_19354] == mem[_19354]
                                        if sub_0b4b41bc <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require sub_0b4b41bc
                                        sub_7f94bf16 = mem[_19354] / sub_0b4b41bc
                                        mem[mem[64] + 4] = treasuryAddress
                                        mem[mem[64] + 36] = 0
                                        require ext_code.size(assetAddress)
                                        call assetAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args treasuryAddress, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _21520 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_21520] == bool(mem[_21520])
                                    else:
                                        mem[(6 * ceil32(return_data.size)) + 96] = 3
                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                        mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                        mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                        mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(6 * ceil32(return_data.size)) + 228] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                        mem[(6 * ceil32(return_data.size)) + 260] = 0
                                        mem[(6 * ceil32(return_data.size)) + 292] = 160
                                        mem[(6 * ceil32(return_data.size)) + 388] = 3
                                        idx = 0
                                        s = (6 * ceil32(return_data.size)) + 128
                                        t = (6 * ceil32(return_data.size)) + 420
                                        while idx < 3:
                                            mem[t] = mem[s + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                        mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (7 * ceil32(return_data.size)) + 224
                                        require return_data.size >= 32
                                        _12893 = mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                        require mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                        _13295 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]
                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224] <= test266151307()
                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 32 >= 0
                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256
                                        mem[(7 * ceil32(return_data.size)) + 224] = _13295
                                        require _12893 + (32 * _13295) + 32 <= return_data.size
                                        idx = 0
                                        s = (6 * ceil32(return_data.size)) + _12893 + 256
                                        t = (7 * ceil32(return_data.size)) + 256
                                        while idx < _13295:
                                            require mem[s] == mem[s]
                                            mem[t] = mem[s]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(rewardTokenAddress)
                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _19353 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_19353] == mem[_19353]
                                        if sub_0b4b41bc <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require sub_0b4b41bc
                                        sub_7f94bf16 = mem[_19353] / sub_0b4b41bc
                                        mem[mem[64] + 4] = treasuryAddress
                                        mem[mem[64] + 36] = 0
                                        require ext_code.size(assetAddress)
                                        call assetAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args treasuryAddress, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _21519 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_21519] == bool(mem[_21519])
                    else:
                        require ext_call.return_data[0] - totalDeposited
                        if (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / ext_call.return_data[0] - totalDeposited != sub_7796ff37:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not ext_call.return_data[0] - totalDeposited:
                            if not ext_call.return_data[0] - totalDeposited:
                                sub_bf4c8572 = 0
                                mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                mem[ceil32(return_data.size) + 132] = -1
                                require ext_code.size(sub_b8ab24bdAddress)
                                call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args lendingPoolAddress, -1
                                mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                require ext_code.size(lendingPoolAddress)
                                call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                     gas gas_remaining wei
                                    args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[0]
                                mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                mem[(4 * ceil32(return_data.size)) + 132] = -1
                                require ext_code.size(assetAddress)
                                call assetAddress.approve(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args routerAddress, -1
                                mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                if assetAddress == WAVAXAddress:
                                    mem[(6 * ceil32(return_data.size)) + 96] = 2
                                    mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                    mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                    mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[(6 * ceil32(return_data.size)) + 196] = 0
                                    mem[(6 * ceil32(return_data.size)) + 228] = 0
                                    mem[(6 * ceil32(return_data.size)) + 260] = 160
                                    mem[(6 * ceil32(return_data.size)) + 356] = 2
                                    idx = 0
                                    s = (6 * ceil32(return_data.size)) + 128
                                    t = (6 * ceil32(return_data.size)) + 388
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                    mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = (7 * ceil32(return_data.size)) + 192
                                    require return_data.size >= 32
                                    _12889 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                    require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                    require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                    _13291 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                    require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                    require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                    mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                    mem[(7 * ceil32(return_data.size)) + 192] = _13291
                                    require _12889 + (32 * _13291) + 32 <= return_data.size
                                    idx = 0
                                    s = (6 * ceil32(return_data.size)) + _12889 + 224
                                    t = (7 * ceil32(return_data.size)) + 224
                                    while idx < _13291:
                                        require mem[s] == mem[s]
                                        mem[t] = mem[s]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(rewardTokenAddress)
                                    staticcall rewardTokenAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _19349 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_19349] == mem[_19349]
                                    if sub_0b4b41bc <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require sub_0b4b41bc
                                    sub_7f94bf16 = mem[_19349] / sub_0b4b41bc
                                    mem[mem[64] + 4] = treasuryAddress
                                    mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                    require ext_code.size(assetAddress)
                                    call assetAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _21515 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_21515] == bool(mem[_21515])
                                else:
                                    if rewardTokenAddress == WAVAXAddress:
                                        mem[(6 * ceil32(return_data.size)) + 96] = 2
                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                        mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                        mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(6 * ceil32(return_data.size)) + 196] = 0
                                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                                        mem[(6 * ceil32(return_data.size)) + 260] = 160
                                        mem[(6 * ceil32(return_data.size)) + 356] = 2
                                        idx = 0
                                        s = (6 * ceil32(return_data.size)) + 128
                                        t = (6 * ceil32(return_data.size)) + 388
                                        while idx < 2:
                                            mem[t] = mem[s + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                        mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (7 * ceil32(return_data.size)) + 192
                                        require return_data.size >= 32
                                        _12891 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                        require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                        _13293 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                        mem[(7 * ceil32(return_data.size)) + 192] = _13293
                                        require _12891 + (32 * _13293) + 32 <= return_data.size
                                        idx = 0
                                        s = (6 * ceil32(return_data.size)) + _12891 + 224
                                        t = (7 * ceil32(return_data.size)) + 224
                                        while idx < _13293:
                                            require mem[s] == mem[s]
                                            mem[t] = mem[s]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(rewardTokenAddress)
                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _19351 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_19351] == mem[_19351]
                                        if sub_0b4b41bc <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require sub_0b4b41bc
                                        sub_7f94bf16 = mem[_19351] / sub_0b4b41bc
                                        mem[mem[64] + 4] = treasuryAddress
                                        mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                        require ext_code.size(assetAddress)
                                        call assetAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _21517 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_21517] == bool(mem[_21517])
                                    else:
                                        mem[(6 * ceil32(return_data.size)) + 96] = 3
                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                        mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                        mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                        mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                                        mem[(6 * ceil32(return_data.size)) + 260] = 0
                                        mem[(6 * ceil32(return_data.size)) + 292] = 160
                                        mem[(6 * ceil32(return_data.size)) + 388] = 3
                                        idx = 0
                                        s = (6 * ceil32(return_data.size)) + 128
                                        t = (6 * ceil32(return_data.size)) + 420
                                        while idx < 3:
                                            mem[t] = mem[s + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                        mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args 0, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (7 * ceil32(return_data.size)) + 224
                                        require return_data.size >= 32
                                        _12890 = mem[(6 * ceil32(return_data.size)) + 224 len 4], 0
                                        require mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 <= test266151307()
                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                        _13292 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]
                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224] <= test266151307()
                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 32 >= 0
                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256
                                        mem[(7 * ceil32(return_data.size)) + 224] = _13292
                                        require _12890 + (32 * _13292) + 32 <= return_data.size
                                        idx = 0
                                        s = (6 * ceil32(return_data.size)) + _12890 + 256
                                        t = (7 * ceil32(return_data.size)) + 256
                                        while idx < _13292:
                                            require mem[s] == mem[s]
                                            mem[t] = mem[s]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(rewardTokenAddress)
                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _19350 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_19350] == mem[_19350]
                                        if sub_0b4b41bc <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require sub_0b4b41bc
                                        sub_7f94bf16 = mem[_19350] / sub_0b4b41bc
                                        mem[mem[64] + 4] = treasuryAddress
                                        mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                        require ext_code.size(assetAddress)
                                        call assetAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _21516 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_21516] == bool(mem[_21516])
                            else:
                                require ext_call.return_data[0] - totalDeposited
                                if (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / ext_call.return_data[0] - totalDeposited != sub_7e72b29f:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                sub_bf4c8572 = (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / 10000
                                mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                mem[ceil32(return_data.size) + 132] = -1
                                require ext_code.size(sub_b8ab24bdAddress)
                                call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args lendingPoolAddress, -1
                                mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                require ext_code.size(lendingPoolAddress)
                                call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                     gas gas_remaining wei
                                    args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[0]
                                mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                mem[(4 * ceil32(return_data.size)) + 132] = -1
                                require ext_code.size(assetAddress)
                                call assetAddress.approve(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args routerAddress, -1
                                mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                if assetAddress == WAVAXAddress:
                                    mem[(6 * ceil32(return_data.size)) + 96] = 2
                                    mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                    mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                    mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[(6 * ceil32(return_data.size)) + 196] = 0
                                    mem[(6 * ceil32(return_data.size)) + 228] = 0
                                    mem[(6 * ceil32(return_data.size)) + 260] = 160
                                    mem[(6 * ceil32(return_data.size)) + 356] = 2
                                    idx = 0
                                    s = (6 * ceil32(return_data.size)) + 128
                                    t = (6 * ceil32(return_data.size)) + 388
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                    mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = (7 * ceil32(return_data.size)) + 192
                                    require return_data.size >= 32
                                    _12886 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                    require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                    require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                    _13288 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                    require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                    require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                    mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                    mem[(7 * ceil32(return_data.size)) + 192] = _13288
                                    require _12886 + (32 * _13288) + 32 <= return_data.size
                                    idx = 0
                                    s = (6 * ceil32(return_data.size)) + _12886 + 224
                                    t = (7 * ceil32(return_data.size)) + 224
                                    while idx < _13288:
                                        require mem[s] == mem[s]
                                        mem[t] = mem[s]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(rewardTokenAddress)
                                    staticcall rewardTokenAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _19346 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_19346] == mem[_19346]
                                    if sub_0b4b41bc <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require sub_0b4b41bc
                                    sub_7f94bf16 = mem[_19346] / sub_0b4b41bc
                                    mem[mem[64] + 4] = treasuryAddress
                                    mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                    require ext_code.size(assetAddress)
                                    call assetAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _21512 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_21512] == bool(mem[_21512])
                                else:
                                    if rewardTokenAddress == WAVAXAddress:
                                        mem[(6 * ceil32(return_data.size)) + 96] = 2
                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                        mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                        mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(6 * ceil32(return_data.size)) + 196] = 0
                                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                                        mem[(6 * ceil32(return_data.size)) + 260] = 160
                                        mem[(6 * ceil32(return_data.size)) + 356] = 2
                                        idx = 0
                                        s = (6 * ceil32(return_data.size)) + 128
                                        t = (6 * ceil32(return_data.size)) + 388
                                        while idx < 2:
                                            mem[t] = mem[s + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                        mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (7 * ceil32(return_data.size)) + 192
                                        require return_data.size >= 32
                                        _12888 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                        require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                        _13290 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                        mem[(7 * ceil32(return_data.size)) + 192] = _13290
                                        require _12888 + (32 * _13290) + 32 <= return_data.size
                                        idx = 0
                                        s = (6 * ceil32(return_data.size)) + _12888 + 224
                                        t = (7 * ceil32(return_data.size)) + 224
                                        while idx < _13290:
                                            require mem[s] == mem[s]
                                            mem[t] = mem[s]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(rewardTokenAddress)
                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _19348 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_19348] == mem[_19348]
                                        if sub_0b4b41bc <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require sub_0b4b41bc
                                        sub_7f94bf16 = mem[_19348] / sub_0b4b41bc
                                        mem[mem[64] + 4] = treasuryAddress
                                        mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                        require ext_code.size(assetAddress)
                                        call assetAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _21514 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_21514] == bool(mem[_21514])
                                    else:
                                        mem[(6 * ceil32(return_data.size)) + 96] = 3
                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                        mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                        mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                        mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                                        mem[(6 * ceil32(return_data.size)) + 260] = 0
                                        mem[(6 * ceil32(return_data.size)) + 292] = 160
                                        mem[(6 * ceil32(return_data.size)) + 388] = 3
                                        idx = 0
                                        s = (6 * ceil32(return_data.size)) + 128
                                        t = (6 * ceil32(return_data.size)) + 420
                                        while idx < 3:
                                            mem[t] = mem[s + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                        mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args 0, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (7 * ceil32(return_data.size)) + 224
                                        require return_data.size >= 32
                                        _12887 = mem[(6 * ceil32(return_data.size)) + 224 len 4], 0
                                        require mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 <= test266151307()
                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                        _13289 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]
                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224] <= test266151307()
                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 32 >= 0
                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256
                                        mem[(7 * ceil32(return_data.size)) + 224] = _13289
                                        require _12887 + (32 * _13289) + 32 <= return_data.size
                                        idx = 0
                                        s = (6 * ceil32(return_data.size)) + _12887 + 256
                                        t = (7 * ceil32(return_data.size)) + 256
                                        while idx < _13289:
                                            require mem[s] == mem[s]
                                            mem[t] = mem[s]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(rewardTokenAddress)
                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _19347 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_19347] == mem[_19347]
                                        if sub_0b4b41bc <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require sub_0b4b41bc
                                        sub_7f94bf16 = mem[_19347] / sub_0b4b41bc
                                        mem[mem[64] + 4] = treasuryAddress
                                        mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                        require ext_code.size(assetAddress)
                                        call assetAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _21513 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_21513] == bool(mem[_21513])
                        else:
                            require ext_call.return_data[0] - totalDeposited
                            if (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / ext_call.return_data[0] - totalDeposited != sub_2f6236be:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not ext_call.return_data[0] - totalDeposited:
                                sub_bf4c8572 = 0
                                mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                mem[ceil32(return_data.size) + 132] = -1
                                require ext_code.size(sub_b8ab24bdAddress)
                                call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args lendingPoolAddress, -1
                                mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                require ext_code.size(lendingPoolAddress)
                                call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                     gas gas_remaining wei
                                    args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[0]
                                mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                mem[(4 * ceil32(return_data.size)) + 132] = -1
                                require ext_code.size(assetAddress)
                                call assetAddress.approve(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args routerAddress, -1
                                mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                if assetAddress == WAVAXAddress:
                                    mem[(6 * ceil32(return_data.size)) + 96] = 2
                                    mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                    mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                    mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                    mem[(6 * ceil32(return_data.size)) + 228] = 0
                                    mem[(6 * ceil32(return_data.size)) + 260] = 160
                                    mem[(6 * ceil32(return_data.size)) + 356] = 2
                                    idx = 0
                                    s = (6 * ceil32(return_data.size)) + 128
                                    t = (6 * ceil32(return_data.size)) + 388
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                    mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = (7 * ceil32(return_data.size)) + 192
                                    require return_data.size >= 32
                                    _12883 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                    require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                    require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                    _13285 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                    require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                    require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                    mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                    mem[(7 * ceil32(return_data.size)) + 192] = _13285
                                    require _12883 + (32 * _13285) + 32 <= return_data.size
                                    idx = 0
                                    s = (6 * ceil32(return_data.size)) + _12883 + 224
                                    t = (7 * ceil32(return_data.size)) + 224
                                    while idx < _13285:
                                        require mem[s] == mem[s]
                                        mem[t] = mem[s]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(rewardTokenAddress)
                                    staticcall rewardTokenAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _19343 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_19343] == mem[_19343]
                                    if sub_0b4b41bc <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require sub_0b4b41bc
                                    sub_7f94bf16 = mem[_19343] / sub_0b4b41bc
                                    mem[mem[64] + 4] = treasuryAddress
                                    mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                    require ext_code.size(assetAddress)
                                    call assetAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _21509 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_21509] == bool(mem[_21509])
                                else:
                                    if rewardTokenAddress == WAVAXAddress:
                                        mem[(6 * ceil32(return_data.size)) + 96] = 2
                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                        mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                        mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                                        mem[(6 * ceil32(return_data.size)) + 260] = 160
                                        mem[(6 * ceil32(return_data.size)) + 356] = 2
                                        idx = 0
                                        s = (6 * ceil32(return_data.size)) + 128
                                        t = (6 * ceil32(return_data.size)) + 388
                                        while idx < 2:
                                            mem[t] = mem[s + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                        mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (7 * ceil32(return_data.size)) + 192
                                        require return_data.size >= 32
                                        _12885 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                        require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                        _13287 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                        mem[(7 * ceil32(return_data.size)) + 192] = _13287
                                        require _12885 + (32 * _13287) + 32 <= return_data.size
                                        idx = 0
                                        s = (6 * ceil32(return_data.size)) + _12885 + 224
                                        t = (7 * ceil32(return_data.size)) + 224
                                        while idx < _13287:
                                            require mem[s] == mem[s]
                                            mem[t] = mem[s]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(rewardTokenAddress)
                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _19345 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_19345] == mem[_19345]
                                        if sub_0b4b41bc <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require sub_0b4b41bc
                                        sub_7f94bf16 = mem[_19345] / sub_0b4b41bc
                                        mem[mem[64] + 4] = treasuryAddress
                                        mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                        require ext_code.size(assetAddress)
                                        call assetAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _21511 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_21511] == bool(mem[_21511])
                                    else:
                                        mem[(6 * ceil32(return_data.size)) + 96] = 3
                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                        mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                        mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                        mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(6 * ceil32(return_data.size)) + 228] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                        mem[(6 * ceil32(return_data.size)) + 260] = 0
                                        mem[(6 * ceil32(return_data.size)) + 292] = 160
                                        mem[(6 * ceil32(return_data.size)) + 388] = 3
                                        idx = 0
                                        s = (6 * ceil32(return_data.size)) + 128
                                        t = (6 * ceil32(return_data.size)) + 420
                                        while idx < 3:
                                            mem[t] = mem[s + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                        mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (7 * ceil32(return_data.size)) + 224
                                        require return_data.size >= 32
                                        _12884 = mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                        require mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                        _13286 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]
                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224] <= test266151307()
                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 32 >= 0
                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256
                                        mem[(7 * ceil32(return_data.size)) + 224] = _13286
                                        require _12884 + (32 * _13286) + 32 <= return_data.size
                                        idx = 0
                                        s = (6 * ceil32(return_data.size)) + _12884 + 256
                                        t = (7 * ceil32(return_data.size)) + 256
                                        while idx < _13286:
                                            require mem[s] == mem[s]
                                            mem[t] = mem[s]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(rewardTokenAddress)
                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _19344 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_19344] == mem[_19344]
                                        if sub_0b4b41bc <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require sub_0b4b41bc
                                        sub_7f94bf16 = mem[_19344] / sub_0b4b41bc
                                        mem[mem[64] + 4] = treasuryAddress
                                        mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                        require ext_code.size(assetAddress)
                                        call assetAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _21510 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_21510] == bool(mem[_21510])
                            else:
                                require ext_call.return_data[0] - totalDeposited
                                if (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / ext_call.return_data[0] - totalDeposited != sub_7e72b29f:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                sub_bf4c8572 = (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / 10000
                                mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                mem[ceil32(return_data.size) + 132] = -1
                                require ext_code.size(sub_b8ab24bdAddress)
                                call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args lendingPoolAddress, -1
                                mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                require ext_code.size(lendingPoolAddress)
                                call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                     gas gas_remaining wei
                                    args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[0]
                                mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                mem[(4 * ceil32(return_data.size)) + 132] = -1
                                require ext_code.size(assetAddress)
                                call assetAddress.approve(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args routerAddress, -1
                                mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                if assetAddress == WAVAXAddress:
                                    mem[(6 * ceil32(return_data.size)) + 96] = 2
                                    mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                    mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                    mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                    mem[(6 * ceil32(return_data.size)) + 228] = 0
                                    mem[(6 * ceil32(return_data.size)) + 260] = 160
                                    mem[(6 * ceil32(return_data.size)) + 356] = 2
                                    idx = 0
                                    s = (6 * ceil32(return_data.size)) + 128
                                    t = (6 * ceil32(return_data.size)) + 388
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                    mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = (7 * ceil32(return_data.size)) + 192
                                    require return_data.size >= 32
                                    _12880 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                    require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                    require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                    _13282 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                    require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                    require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                    mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                    mem[(7 * ceil32(return_data.size)) + 192] = _13282
                                    require _12880 + (32 * _13282) + 32 <= return_data.size
                                    idx = 0
                                    s = (6 * ceil32(return_data.size)) + _12880 + 224
                                    t = (7 * ceil32(return_data.size)) + 224
                                    while idx < _13282:
                                        require mem[s] == mem[s]
                                        mem[t] = mem[s]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(rewardTokenAddress)
                                    staticcall rewardTokenAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _19340 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_19340] == mem[_19340]
                                    if sub_0b4b41bc <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require sub_0b4b41bc
                                    sub_7f94bf16 = mem[_19340] / sub_0b4b41bc
                                    mem[mem[64] + 4] = treasuryAddress
                                    mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                    require ext_code.size(assetAddress)
                                    call assetAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _21506 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_21506] == bool(mem[_21506])
                                else:
                                    if rewardTokenAddress == WAVAXAddress:
                                        mem[(6 * ceil32(return_data.size)) + 96] = 2
                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                        mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                        mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                                        mem[(6 * ceil32(return_data.size)) + 260] = 160
                                        mem[(6 * ceil32(return_data.size)) + 356] = 2
                                        idx = 0
                                        s = (6 * ceil32(return_data.size)) + 128
                                        t = (6 * ceil32(return_data.size)) + 388
                                        while idx < 2:
                                            mem[t] = mem[s + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                        mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (7 * ceil32(return_data.size)) + 192
                                        require return_data.size >= 32
                                        _12882 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                        require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                        _13284 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                        mem[(7 * ceil32(return_data.size)) + 192] = _13284
                                        require _12882 + (32 * _13284) + 32 <= return_data.size
                                        idx = 0
                                        s = (6 * ceil32(return_data.size)) + _12882 + 224
                                        t = (7 * ceil32(return_data.size)) + 224
                                        while idx < _13284:
                                            require mem[s] == mem[s]
                                            mem[t] = mem[s]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(rewardTokenAddress)
                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _19342 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_19342] == mem[_19342]
                                        if sub_0b4b41bc <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require sub_0b4b41bc
                                        sub_7f94bf16 = mem[_19342] / sub_0b4b41bc
                                        mem[mem[64] + 4] = treasuryAddress
                                        mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                        require ext_code.size(assetAddress)
                                        call assetAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _21508 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_21508] == bool(mem[_21508])
                                    else:
                                        mem[(6 * ceil32(return_data.size)) + 96] = 3
                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                        mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                        mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                        mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(6 * ceil32(return_data.size)) + 228] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                        mem[(6 * ceil32(return_data.size)) + 260] = 0
                                        mem[(6 * ceil32(return_data.size)) + 292] = 160
                                        mem[(6 * ceil32(return_data.size)) + 388] = 3
                                        idx = 0
                                        s = (6 * ceil32(return_data.size)) + 128
                                        t = (6 * ceil32(return_data.size)) + 420
                                        while idx < 3:
                                            mem[t] = mem[s + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                        mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (7 * ceil32(return_data.size)) + 224
                                        require return_data.size >= 32
                                        _12881 = mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                        require mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                        _13283 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]
                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224] <= test266151307()
                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 32 >= 0
                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256
                                        mem[(7 * ceil32(return_data.size)) + 224] = _13283
                                        require _12881 + (32 * _13283) + 32 <= return_data.size
                                        idx = 0
                                        s = (6 * ceil32(return_data.size)) + _12881 + 256
                                        t = (7 * ceil32(return_data.size)) + 256
                                        while idx < _13283:
                                            require mem[s] == mem[s]
                                            mem[t] = mem[s]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(rewardTokenAddress)
                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _19341 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_19341] == mem[_19341]
                                        if sub_0b4b41bc <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require sub_0b4b41bc
                                        sub_7f94bf16 = mem[_19341] / sub_0b4b41bc
                                        mem[mem[64] + 4] = treasuryAddress
                                        mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                        require ext_code.size(assetAddress)
                                        call assetAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _21507 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_21507] == bool(mem[_21507])
                else:
                    if lastRewardTimestamp > block.timestamp:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not block.timestamp - lastRewardTimestamp:
                        require ext_code.size(rewardWalletAddress)
                        call rewardWalletAddress.requestReward(uint256 arg1) with:
                             gas gas_remaining wei
                            args 0
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if totalDeposited <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalDeposited
                        if sub_a9ac33dd + (0 / totalDeposited) < sub_a9ac33dd:
                            revert with 0, 'SafeMath: addition overflow'
                        sub_a9ac33dd += 0 / totalDeposited
                        lastRewardTimestamp = block.timestamp
                        mem[100] = this.address
                        require ext_code.size(sub_b8ab24bdAddress)
                        staticcall sub_b8ab24bdAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        mem[96] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[0]
                        if not ext_call.return_data[0] - totalDeposited:
                            if not ext_call.return_data[0] - totalDeposited:
                                if not ext_call.return_data[0] - totalDeposited:
                                    sub_bf4c8572 = 0
                                    mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                    mem[ceil32(return_data.size) + 132] = -1
                                    require ext_code.size(sub_b8ab24bdAddress)
                                    call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args lendingPoolAddress, -1
                                    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                    mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                    mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                    require ext_code.size(lendingPoolAddress)
                                    call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                         gas gas_remaining wei
                                        args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                    mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                    mem[(4 * ceil32(return_data.size)) + 132] = -1
                                    require ext_code.size(assetAddress)
                                    call assetAddress.approve(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args routerAddress, -1
                                    mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    if assetAddress == WAVAXAddress:
                                        mem[(6 * ceil32(return_data.size)) + 96] = 2
                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                        mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                        mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(6 * ceil32(return_data.size)) + 196] = 0
                                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                                        mem[(6 * ceil32(return_data.size)) + 260] = 160
                                        mem[(6 * ceil32(return_data.size)) + 356] = 2
                                        idx = 0
                                        s = (6 * ceil32(return_data.size)) + 128
                                        t = (6 * ceil32(return_data.size)) + 388
                                        while idx < 2:
                                            mem[t] = mem[s + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                        mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (7 * ceil32(return_data.size)) + 192
                                        require return_data.size >= 32
                                        _12877 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                        require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                        _13279 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                        mem[(7 * ceil32(return_data.size)) + 192] = _13279
                                        require _12877 + (32 * _13279) + 32 <= return_data.size
                                        idx = 0
                                        s = (6 * ceil32(return_data.size)) + _12877 + 224
                                        t = (7 * ceil32(return_data.size)) + 224
                                        while idx < _13279:
                                            require mem[s] == mem[s]
                                            mem[t] = mem[s]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(rewardTokenAddress)
                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _19337 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_19337] == mem[_19337]
                                        if sub_0b4b41bc <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require sub_0b4b41bc
                                        sub_7f94bf16 = mem[_19337] / sub_0b4b41bc
                                        mem[mem[64] + 4] = treasuryAddress
                                        mem[mem[64] + 36] = 0
                                        require ext_code.size(assetAddress)
                                        call assetAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args treasuryAddress, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _21503 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_21503] == bool(mem[_21503])
                                    else:
                                        if rewardTokenAddress == WAVAXAddress:
                                            mem[(6 * ceil32(return_data.size)) + 96] = 2
                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                            mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                            mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[(6 * ceil32(return_data.size)) + 196] = 0
                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                            mem[(6 * ceil32(return_data.size)) + 260] = 160
                                            mem[(6 * ceil32(return_data.size)) + 356] = 2
                                            idx = 0
                                            s = (6 * ceil32(return_data.size)) + 128
                                            t = (6 * ceil32(return_data.size)) + 388
                                            while idx < 2:
                                                mem[t] = mem[s + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                            mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                            require ext_code.size(routerAddress)
                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                 gas gas_remaining wei
                                                args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (7 * ceil32(return_data.size)) + 192
                                            require return_data.size >= 32
                                            _12879 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                            require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                            _13281 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                            mem[(7 * ceil32(return_data.size)) + 192] = _13281
                                            require _12879 + (32 * _13281) + 32 <= return_data.size
                                            idx = 0
                                            s = (6 * ceil32(return_data.size)) + _12879 + 224
                                            t = (7 * ceil32(return_data.size)) + 224
                                            while idx < _13281:
                                                require mem[s] == mem[s]
                                                mem[t] = mem[s]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(rewardTokenAddress)
                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _19339 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_19339] == mem[_19339]
                                            if sub_0b4b41bc <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require sub_0b4b41bc
                                            sub_7f94bf16 = mem[_19339] / sub_0b4b41bc
                                            mem[mem[64] + 4] = treasuryAddress
                                            mem[mem[64] + 36] = 0
                                            require ext_code.size(assetAddress)
                                            call assetAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args treasuryAddress, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _21505 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_21505] == bool(mem[_21505])
                                        else:
                                            mem[(6 * ceil32(return_data.size)) + 96] = 3
                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                            mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                            mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                            mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                            mem[(6 * ceil32(return_data.size)) + 260] = 0
                                            mem[(6 * ceil32(return_data.size)) + 292] = 160
                                            mem[(6 * ceil32(return_data.size)) + 388] = 3
                                            idx = 0
                                            s = (6 * ceil32(return_data.size)) + 128
                                            t = (6 * ceil32(return_data.size)) + 420
                                            while idx < 3:
                                                mem[t] = mem[s + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                            mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                            require ext_code.size(routerAddress)
                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                 gas gas_remaining wei
                                                args 0, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (7 * ceil32(return_data.size)) + 224
                                            require return_data.size >= 32
                                            _12878 = mem[(6 * ceil32(return_data.size)) + 224 len 4], 0
                                            require mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 <= test266151307()
                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                            _13280 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]
                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224] <= test266151307()
                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 32 >= 0
                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256
                                            mem[(7 * ceil32(return_data.size)) + 224] = _13280
                                            require _12878 + (32 * _13280) + 32 <= return_data.size
                                            idx = 0
                                            s = (6 * ceil32(return_data.size)) + _12878 + 256
                                            t = (7 * ceil32(return_data.size)) + 256
                                            while idx < _13280:
                                                require mem[s] == mem[s]
                                                mem[t] = mem[s]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(rewardTokenAddress)
                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _19338 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_19338] == mem[_19338]
                                            if sub_0b4b41bc <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require sub_0b4b41bc
                                            sub_7f94bf16 = mem[_19338] / sub_0b4b41bc
                                            mem[mem[64] + 4] = treasuryAddress
                                            mem[mem[64] + 36] = 0
                                            require ext_code.size(assetAddress)
                                            call assetAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args treasuryAddress, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _21504 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_21504] == bool(mem[_21504])
                                else:
                                    require ext_call.return_data[0] - totalDeposited
                                    if (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / ext_call.return_data[0] - totalDeposited != sub_7e72b29f:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    sub_bf4c8572 = (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / 10000
                                    mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                    mem[ceil32(return_data.size) + 132] = -1
                                    require ext_code.size(sub_b8ab24bdAddress)
                                    call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args lendingPoolAddress, -1
                                    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                    mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                    mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                    require ext_code.size(lendingPoolAddress)
                                    call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                         gas gas_remaining wei
                                        args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                    mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                    mem[(4 * ceil32(return_data.size)) + 132] = -1
                                    require ext_code.size(assetAddress)
                                    call assetAddress.approve(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args routerAddress, -1
                                    mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    if assetAddress == WAVAXAddress:
                                        mem[(6 * ceil32(return_data.size)) + 96] = 2
                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                        mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                        mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(6 * ceil32(return_data.size)) + 196] = 0
                                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                                        mem[(6 * ceil32(return_data.size)) + 260] = 160
                                        mem[(6 * ceil32(return_data.size)) + 356] = 2
                                        idx = 0
                                        s = (6 * ceil32(return_data.size)) + 128
                                        t = (6 * ceil32(return_data.size)) + 388
                                        while idx < 2:
                                            mem[t] = mem[s + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                        mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (7 * ceil32(return_data.size)) + 192
                                        require return_data.size >= 32
                                        _12874 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                        require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                        _13276 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                        mem[(7 * ceil32(return_data.size)) + 192] = _13276
                                        require _12874 + (32 * _13276) + 32 <= return_data.size
                                        idx = 0
                                        s = (6 * ceil32(return_data.size)) + _12874 + 224
                                        t = (7 * ceil32(return_data.size)) + 224
                                        while idx < _13276:
                                            require mem[s] == mem[s]
                                            mem[t] = mem[s]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(rewardTokenAddress)
                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _19334 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_19334] == mem[_19334]
                                        if sub_0b4b41bc <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require sub_0b4b41bc
                                        sub_7f94bf16 = mem[_19334] / sub_0b4b41bc
                                        mem[mem[64] + 4] = treasuryAddress
                                        mem[mem[64] + 36] = 0
                                        require ext_code.size(assetAddress)
                                        call assetAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args treasuryAddress, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _21500 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_21500] == bool(mem[_21500])
                                    else:
                                        if rewardTokenAddress == WAVAXAddress:
                                            mem[(6 * ceil32(return_data.size)) + 96] = 2
                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                            mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                            mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[(6 * ceil32(return_data.size)) + 196] = 0
                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                            mem[(6 * ceil32(return_data.size)) + 260] = 160
                                            mem[(6 * ceil32(return_data.size)) + 356] = 2
                                            idx = 0
                                            s = (6 * ceil32(return_data.size)) + 128
                                            t = (6 * ceil32(return_data.size)) + 388
                                            while idx < 2:
                                                mem[t] = mem[s + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                            mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                            require ext_code.size(routerAddress)
                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                 gas gas_remaining wei
                                                args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (7 * ceil32(return_data.size)) + 192
                                            require return_data.size >= 32
                                            _12876 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                            require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                            _13278 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                            mem[(7 * ceil32(return_data.size)) + 192] = _13278
                                            require _12876 + (32 * _13278) + 32 <= return_data.size
                                            idx = 0
                                            s = (6 * ceil32(return_data.size)) + _12876 + 224
                                            t = (7 * ceil32(return_data.size)) + 224
                                            while idx < _13278:
                                                require mem[s] == mem[s]
                                                mem[t] = mem[s]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(rewardTokenAddress)
                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _19336 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_19336] == mem[_19336]
                                            if sub_0b4b41bc <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require sub_0b4b41bc
                                            sub_7f94bf16 = mem[_19336] / sub_0b4b41bc
                                            mem[mem[64] + 4] = treasuryAddress
                                            mem[mem[64] + 36] = 0
                                            require ext_code.size(assetAddress)
                                            call assetAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args treasuryAddress, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _21502 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_21502] == bool(mem[_21502])
                                        else:
                                            mem[(6 * ceil32(return_data.size)) + 96] = 3
                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                            mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                            mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                            mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                            mem[(6 * ceil32(return_data.size)) + 260] = 0
                                            mem[(6 * ceil32(return_data.size)) + 292] = 160
                                            mem[(6 * ceil32(return_data.size)) + 388] = 3
                                            idx = 0
                                            s = (6 * ceil32(return_data.size)) + 128
                                            t = (6 * ceil32(return_data.size)) + 420
                                            while idx < 3:
                                                mem[t] = mem[s + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                            mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                            require ext_code.size(routerAddress)
                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                 gas gas_remaining wei
                                                args 0, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (7 * ceil32(return_data.size)) + 224
                                            require return_data.size >= 32
                                            _12875 = mem[(6 * ceil32(return_data.size)) + 224 len 4], 0
                                            require mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 <= test266151307()
                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                            _13277 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]
                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224] <= test266151307()
                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 32 >= 0
                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256
                                            mem[(7 * ceil32(return_data.size)) + 224] = _13277
                                            require _12875 + (32 * _13277) + 32 <= return_data.size
                                            idx = 0
                                            s = (6 * ceil32(return_data.size)) + _12875 + 256
                                            t = (7 * ceil32(return_data.size)) + 256
                                            while idx < _13277:
                                                require mem[s] == mem[s]
                                                mem[t] = mem[s]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(rewardTokenAddress)
                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _19335 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_19335] == mem[_19335]
                                            if sub_0b4b41bc <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require sub_0b4b41bc
                                            sub_7f94bf16 = mem[_19335] / sub_0b4b41bc
                                            mem[mem[64] + 4] = treasuryAddress
                                            mem[mem[64] + 36] = 0
                                            require ext_code.size(assetAddress)
                                            call assetAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args treasuryAddress, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _21501 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_21501] == bool(mem[_21501])
                            else:
                                require ext_call.return_data[0] - totalDeposited
                                if (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / ext_call.return_data[0] - totalDeposited != sub_2f6236be:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not ext_call.return_data[0] - totalDeposited:
                                    sub_bf4c8572 = 0
                                    mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                    mem[ceil32(return_data.size) + 132] = -1
                                    require ext_code.size(sub_b8ab24bdAddress)
                                    call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args lendingPoolAddress, -1
                                    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                    mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                    mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                    require ext_code.size(lendingPoolAddress)
                                    call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                         gas gas_remaining wei
                                        args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                    mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                    mem[(4 * ceil32(return_data.size)) + 132] = -1
                                    require ext_code.size(assetAddress)
                                    call assetAddress.approve(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args routerAddress, -1
                                    mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    if assetAddress == WAVAXAddress:
                                        mem[(6 * ceil32(return_data.size)) + 96] = 2
                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                        mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                        mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                                        mem[(6 * ceil32(return_data.size)) + 260] = 160
                                        mem[(6 * ceil32(return_data.size)) + 356] = 2
                                        idx = 0
                                        s = (6 * ceil32(return_data.size)) + 128
                                        t = (6 * ceil32(return_data.size)) + 388
                                        while idx < 2:
                                            mem[t] = mem[s + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                        mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (7 * ceil32(return_data.size)) + 192
                                        require return_data.size >= 32
                                        _12871 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                        require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                        _13273 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                        mem[(7 * ceil32(return_data.size)) + 192] = _13273
                                        require _12871 + (32 * _13273) + 32 <= return_data.size
                                        idx = 0
                                        s = (6 * ceil32(return_data.size)) + _12871 + 224
                                        t = (7 * ceil32(return_data.size)) + 224
                                        while idx < _13273:
                                            require mem[s] == mem[s]
                                            mem[t] = mem[s]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(rewardTokenAddress)
                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _19331 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_19331] == mem[_19331]
                                        if sub_0b4b41bc <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require sub_0b4b41bc
                                        sub_7f94bf16 = mem[_19331] / sub_0b4b41bc
                                        mem[mem[64] + 4] = treasuryAddress
                                        mem[mem[64] + 36] = 0
                                        require ext_code.size(assetAddress)
                                        call assetAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args treasuryAddress, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _21497 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_21497] == bool(mem[_21497])
                                    else:
                                        if rewardTokenAddress == WAVAXAddress:
                                            mem[(6 * ceil32(return_data.size)) + 96] = 2
                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                            mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                            mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                            mem[(6 * ceil32(return_data.size)) + 260] = 160
                                            mem[(6 * ceil32(return_data.size)) + 356] = 2
                                            idx = 0
                                            s = (6 * ceil32(return_data.size)) + 128
                                            t = (6 * ceil32(return_data.size)) + 388
                                            while idx < 2:
                                                mem[t] = mem[s + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                            mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                            require ext_code.size(routerAddress)
                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                 gas gas_remaining wei
                                                args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (7 * ceil32(return_data.size)) + 192
                                            require return_data.size >= 32
                                            _12873 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                            require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                            _13275 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                            mem[(7 * ceil32(return_data.size)) + 192] = _13275
                                            require _12873 + (32 * _13275) + 32 <= return_data.size
                                            idx = 0
                                            s = (6 * ceil32(return_data.size)) + _12873 + 224
                                            t = (7 * ceil32(return_data.size)) + 224
                                            while idx < _13275:
                                                require mem[s] == mem[s]
                                                mem[t] = mem[s]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(rewardTokenAddress)
                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _19333 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_19333] == mem[_19333]
                                            if sub_0b4b41bc <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require sub_0b4b41bc
                                            sub_7f94bf16 = mem[_19333] / sub_0b4b41bc
                                            mem[mem[64] + 4] = treasuryAddress
                                            mem[mem[64] + 36] = 0
                                            require ext_code.size(assetAddress)
                                            call assetAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args treasuryAddress, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _21499 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_21499] == bool(mem[_21499])
                                        else:
                                            mem[(6 * ceil32(return_data.size)) + 96] = 3
                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                            mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                            mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                            mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[(6 * ceil32(return_data.size)) + 228] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                            mem[(6 * ceil32(return_data.size)) + 260] = 0
                                            mem[(6 * ceil32(return_data.size)) + 292] = 160
                                            mem[(6 * ceil32(return_data.size)) + 388] = 3
                                            idx = 0
                                            s = (6 * ceil32(return_data.size)) + 128
                                            t = (6 * ceil32(return_data.size)) + 420
                                            while idx < 3:
                                                mem[t] = mem[s + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                            mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                            require ext_code.size(routerAddress)
                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                 gas gas_remaining wei
                                                args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (7 * ceil32(return_data.size)) + 224
                                            require return_data.size >= 32
                                            _12872 = mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                            require mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                            _13274 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]
                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224] <= test266151307()
                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 32 >= 0
                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256
                                            mem[(7 * ceil32(return_data.size)) + 224] = _13274
                                            require _12872 + (32 * _13274) + 32 <= return_data.size
                                            idx = 0
                                            s = (6 * ceil32(return_data.size)) + _12872 + 256
                                            t = (7 * ceil32(return_data.size)) + 256
                                            while idx < _13274:
                                                require mem[s] == mem[s]
                                                mem[t] = mem[s]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(rewardTokenAddress)
                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _19332 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_19332] == mem[_19332]
                                            if sub_0b4b41bc <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require sub_0b4b41bc
                                            sub_7f94bf16 = mem[_19332] / sub_0b4b41bc
                                            mem[mem[64] + 4] = treasuryAddress
                                            mem[mem[64] + 36] = 0
                                            require ext_code.size(assetAddress)
                                            call assetAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args treasuryAddress, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _21498 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_21498] == bool(mem[_21498])
                                else:
                                    require ext_call.return_data[0] - totalDeposited
                                    if (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / ext_call.return_data[0] - totalDeposited != sub_7e72b29f:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    sub_bf4c8572 = (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / 10000
                                    mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                    mem[ceil32(return_data.size) + 132] = -1
                                    require ext_code.size(sub_b8ab24bdAddress)
                                    call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args lendingPoolAddress, -1
                                    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                    mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                    mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                    require ext_code.size(lendingPoolAddress)
                                    call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                         gas gas_remaining wei
                                        args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                    mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                    mem[(4 * ceil32(return_data.size)) + 132] = -1
                                    require ext_code.size(assetAddress)
                                    call assetAddress.approve(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args routerAddress, -1
                                    mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    if assetAddress == WAVAXAddress:
                                        mem[(6 * ceil32(return_data.size)) + 96] = 2
                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                        mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                        mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                                        mem[(6 * ceil32(return_data.size)) + 260] = 160
                                        mem[(6 * ceil32(return_data.size)) + 356] = 2
                                        idx = 0
                                        s = (6 * ceil32(return_data.size)) + 128
                                        t = (6 * ceil32(return_data.size)) + 388
                                        while idx < 2:
                                            mem[t] = mem[s + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                        mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (7 * ceil32(return_data.size)) + 192
                                        require return_data.size >= 32
                                        _12868 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                        require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                        _13270 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                        mem[(7 * ceil32(return_data.size)) + 192] = _13270
                                        require _12868 + (32 * _13270) + 32 <= return_data.size
                                        idx = 0
                                        s = (6 * ceil32(return_data.size)) + _12868 + 224
                                        t = (7 * ceil32(return_data.size)) + 224
                                        while idx < _13270:
                                            require mem[s] == mem[s]
                                            mem[t] = mem[s]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(rewardTokenAddress)
                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _19328 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_19328] == mem[_19328]
                                        if sub_0b4b41bc <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require sub_0b4b41bc
                                        sub_7f94bf16 = mem[_19328] / sub_0b4b41bc
                                        mem[mem[64] + 4] = treasuryAddress
                                        mem[mem[64] + 36] = 0
                                        require ext_code.size(assetAddress)
                                        call assetAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args treasuryAddress, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _21494 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_21494] == bool(mem[_21494])
                                    else:
                                        if rewardTokenAddress == WAVAXAddress:
                                            mem[(6 * ceil32(return_data.size)) + 96] = 2
                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                            mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                            mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                            mem[(6 * ceil32(return_data.size)) + 260] = 160
                                            mem[(6 * ceil32(return_data.size)) + 356] = 2
                                            idx = 0
                                            s = (6 * ceil32(return_data.size)) + 128
                                            t = (6 * ceil32(return_data.size)) + 388
                                            while idx < 2:
                                                mem[t] = mem[s + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                            mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                            require ext_code.size(routerAddress)
                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                 gas gas_remaining wei
                                                args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (7 * ceil32(return_data.size)) + 192
                                            require return_data.size >= 32
                                            _12870 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                            require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                            _13272 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                            mem[(7 * ceil32(return_data.size)) + 192] = _13272
                                            require _12870 + (32 * _13272) + 32 <= return_data.size
                                            idx = 0
                                            s = (6 * ceil32(return_data.size)) + _12870 + 224
                                            t = (7 * ceil32(return_data.size)) + 224
                                            while idx < _13272:
                                                require mem[s] == mem[s]
                                                mem[t] = mem[s]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(rewardTokenAddress)
                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _19330 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_19330] == mem[_19330]
                                            if sub_0b4b41bc <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require sub_0b4b41bc
                                            sub_7f94bf16 = mem[_19330] / sub_0b4b41bc
                                            mem[mem[64] + 4] = treasuryAddress
                                            mem[mem[64] + 36] = 0
                                            require ext_code.size(assetAddress)
                                            call assetAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args treasuryAddress, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _21496 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_21496] == bool(mem[_21496])
                                        else:
                                            mem[(6 * ceil32(return_data.size)) + 96] = 3
                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                            mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                            mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                            mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[(6 * ceil32(return_data.size)) + 228] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                            mem[(6 * ceil32(return_data.size)) + 260] = 0
                                            mem[(6 * ceil32(return_data.size)) + 292] = 160
                                            mem[(6 * ceil32(return_data.size)) + 388] = 3
                                            idx = 0
                                            s = (6 * ceil32(return_data.size)) + 128
                                            t = (6 * ceil32(return_data.size)) + 420
                                            while idx < 3:
                                                mem[t] = mem[s + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                            mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                            require ext_code.size(routerAddress)
                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                 gas gas_remaining wei
                                                args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (7 * ceil32(return_data.size)) + 224
                                            require return_data.size >= 32
                                            _12869 = mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                            require mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                            _13271 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]
                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224] <= test266151307()
                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 32 >= 0
                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256
                                            mem[(7 * ceil32(return_data.size)) + 224] = _13271
                                            require _12869 + (32 * _13271) + 32 <= return_data.size
                                            idx = 0
                                            s = (6 * ceil32(return_data.size)) + _12869 + 256
                                            t = (7 * ceil32(return_data.size)) + 256
                                            while idx < _13271:
                                                require mem[s] == mem[s]
                                                mem[t] = mem[s]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(rewardTokenAddress)
                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _19329 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_19329] == mem[_19329]
                                            if sub_0b4b41bc <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require sub_0b4b41bc
                                            sub_7f94bf16 = mem[_19329] / sub_0b4b41bc
                                            mem[mem[64] + 4] = treasuryAddress
                                            mem[mem[64] + 36] = 0
                                            require ext_code.size(assetAddress)
                                            call assetAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args treasuryAddress, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _21495 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_21495] == bool(mem[_21495])
                        else:
                            require ext_call.return_data[0] - totalDeposited
                            if (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / ext_call.return_data[0] - totalDeposited != sub_7796ff37:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not ext_call.return_data[0] - totalDeposited:
                                if not ext_call.return_data[0] - totalDeposited:
                                    sub_bf4c8572 = 0
                                    mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                    mem[ceil32(return_data.size) + 132] = -1
                                    require ext_code.size(sub_b8ab24bdAddress)
                                    call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args lendingPoolAddress, -1
                                    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                    mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                    mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                    require ext_code.size(lendingPoolAddress)
                                    call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                         gas gas_remaining wei
                                        args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                    mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                    mem[(4 * ceil32(return_data.size)) + 132] = -1
                                    require ext_code.size(assetAddress)
                                    call assetAddress.approve(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args routerAddress, -1
                                    mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    if assetAddress == WAVAXAddress:
                                        mem[(6 * ceil32(return_data.size)) + 96] = 2
                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                        mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                        mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(6 * ceil32(return_data.size)) + 196] = 0
                                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                                        mem[(6 * ceil32(return_data.size)) + 260] = 160
                                        mem[(6 * ceil32(return_data.size)) + 356] = 2
                                        idx = 0
                                        s = (6 * ceil32(return_data.size)) + 128
                                        t = (6 * ceil32(return_data.size)) + 388
                                        while idx < 2:
                                            mem[t] = mem[s + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                        mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (7 * ceil32(return_data.size)) + 192
                                        require return_data.size >= 32
                                        _12865 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                        require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                        _13267 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                        mem[(7 * ceil32(return_data.size)) + 192] = _13267
                                        require _12865 + (32 * _13267) + 32 <= return_data.size
                                        idx = 0
                                        s = (6 * ceil32(return_data.size)) + _12865 + 224
                                        t = (7 * ceil32(return_data.size)) + 224
                                        while idx < _13267:
                                            require mem[s] == mem[s]
                                            mem[t] = mem[s]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(rewardTokenAddress)
                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _19325 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_19325] == mem[_19325]
                                        if sub_0b4b41bc <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require sub_0b4b41bc
                                        sub_7f94bf16 = mem[_19325] / sub_0b4b41bc
                                        mem[mem[64] + 4] = treasuryAddress
                                        mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                        require ext_code.size(assetAddress)
                                        call assetAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _21491 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_21491] == bool(mem[_21491])
                                    else:
                                        if rewardTokenAddress == WAVAXAddress:
                                            mem[(6 * ceil32(return_data.size)) + 96] = 2
                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                            mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                            mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[(6 * ceil32(return_data.size)) + 196] = 0
                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                            mem[(6 * ceil32(return_data.size)) + 260] = 160
                                            mem[(6 * ceil32(return_data.size)) + 356] = 2
                                            idx = 0
                                            s = (6 * ceil32(return_data.size)) + 128
                                            t = (6 * ceil32(return_data.size)) + 388
                                            while idx < 2:
                                                mem[t] = mem[s + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                            mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                            require ext_code.size(routerAddress)
                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                 gas gas_remaining wei
                                                args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (7 * ceil32(return_data.size)) + 192
                                            require return_data.size >= 32
                                            _12867 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                            require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                            _13269 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                            mem[(7 * ceil32(return_data.size)) + 192] = _13269
                                            require _12867 + (32 * _13269) + 32 <= return_data.size
                                            idx = 0
                                            s = (6 * ceil32(return_data.size)) + _12867 + 224
                                            t = (7 * ceil32(return_data.size)) + 224
                                            while idx < _13269:
                                                require mem[s] == mem[s]
                                                mem[t] = mem[s]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(rewardTokenAddress)
                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _19327 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_19327] == mem[_19327]
                                            if sub_0b4b41bc <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require sub_0b4b41bc
                                            sub_7f94bf16 = mem[_19327] / sub_0b4b41bc
                                            mem[mem[64] + 4] = treasuryAddress
                                            mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                            require ext_code.size(assetAddress)
                                            call assetAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _21493 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_21493] == bool(mem[_21493])
                                        else:
                                            mem[(6 * ceil32(return_data.size)) + 96] = 3
                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                            mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                            mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                            mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                            mem[(6 * ceil32(return_data.size)) + 260] = 0
                                            mem[(6 * ceil32(return_data.size)) + 292] = 160
                                            mem[(6 * ceil32(return_data.size)) + 388] = 3
                                            idx = 0
                                            s = (6 * ceil32(return_data.size)) + 128
                                            t = (6 * ceil32(return_data.size)) + 420
                                            while idx < 3:
                                                mem[t] = mem[s + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                            mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                            require ext_code.size(routerAddress)
                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                 gas gas_remaining wei
                                                args 0, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (7 * ceil32(return_data.size)) + 224
                                            require return_data.size >= 32
                                            _12866 = mem[(6 * ceil32(return_data.size)) + 224 len 4], 0
                                            require mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 <= test266151307()
                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                            _13268 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]
                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224] <= test266151307()
                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 32 >= 0
                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256
                                            mem[(7 * ceil32(return_data.size)) + 224] = _13268
                                            require _12866 + (32 * _13268) + 32 <= return_data.size
                                            idx = 0
                                            s = (6 * ceil32(return_data.size)) + _12866 + 256
                                            t = (7 * ceil32(return_data.size)) + 256
                                            while idx < _13268:
                                                require mem[s] == mem[s]
                                                mem[t] = mem[s]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(rewardTokenAddress)
                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _19326 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_19326] == mem[_19326]
                                            if sub_0b4b41bc <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require sub_0b4b41bc
                                            sub_7f94bf16 = mem[_19326] / sub_0b4b41bc
                                            mem[mem[64] + 4] = treasuryAddress
                                            mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                            require ext_code.size(assetAddress)
                                            call assetAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _21492 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_21492] == bool(mem[_21492])
                                else:
                                    require ext_call.return_data[0] - totalDeposited
                                    if (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / ext_call.return_data[0] - totalDeposited != sub_7e72b29f:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    sub_bf4c8572 = (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / 10000
                                    mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                    mem[ceil32(return_data.size) + 132] = -1
                                    require ext_code.size(sub_b8ab24bdAddress)
                                    call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args lendingPoolAddress, -1
                                    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                    mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                    mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                    require ext_code.size(lendingPoolAddress)
                                    call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                         gas gas_remaining wei
                                        args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                    mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                    mem[(4 * ceil32(return_data.size)) + 132] = -1
                                    require ext_code.size(assetAddress)
                                    call assetAddress.approve(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args routerAddress, -1
                                    mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    if assetAddress == WAVAXAddress:
                                        mem[(6 * ceil32(return_data.size)) + 96] = 2
                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                        mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                        mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(6 * ceil32(return_data.size)) + 196] = 0
                                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                                        mem[(6 * ceil32(return_data.size)) + 260] = 160
                                        mem[(6 * ceil32(return_data.size)) + 356] = 2
                                        idx = 0
                                        s = (6 * ceil32(return_data.size)) + 128
                                        t = (6 * ceil32(return_data.size)) + 388
                                        while idx < 2:
                                            mem[t] = mem[s + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                        mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (7 * ceil32(return_data.size)) + 192
                                        require return_data.size >= 32
                                        _12862 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                        require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                        _13264 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                        mem[(7 * ceil32(return_data.size)) + 192] = _13264
                                        require _12862 + (32 * _13264) + 32 <= return_data.size
                                        idx = 0
                                        s = (6 * ceil32(return_data.size)) + _12862 + 224
                                        t = (7 * ceil32(return_data.size)) + 224
                                        while idx < _13264:
                                            require mem[s] == mem[s]
                                            mem[t] = mem[s]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(rewardTokenAddress)
                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _19322 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_19322] == mem[_19322]
                                        if sub_0b4b41bc <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require sub_0b4b41bc
                                        sub_7f94bf16 = mem[_19322] / sub_0b4b41bc
                                        mem[mem[64] + 4] = treasuryAddress
                                        mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                        require ext_code.size(assetAddress)
                                        call assetAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _21488 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_21488] == bool(mem[_21488])
                                    else:
                                        if rewardTokenAddress == WAVAXAddress:
                                            mem[(6 * ceil32(return_data.size)) + 96] = 2
                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                            mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                            mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[(6 * ceil32(return_data.size)) + 196] = 0
                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                            mem[(6 * ceil32(return_data.size)) + 260] = 160
                                            mem[(6 * ceil32(return_data.size)) + 356] = 2
                                            idx = 0
                                            s = (6 * ceil32(return_data.size)) + 128
                                            t = (6 * ceil32(return_data.size)) + 388
                                            while idx < 2:
                                                mem[t] = mem[s + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                            mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                            require ext_code.size(routerAddress)
                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                 gas gas_remaining wei
                                                args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (7 * ceil32(return_data.size)) + 192
                                            require return_data.size >= 32
                                            _12864 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                            require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                            _13266 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                            mem[(7 * ceil32(return_data.size)) + 192] = _13266
                                            require _12864 + (32 * _13266) + 32 <= return_data.size
                                            idx = 0
                                            s = (6 * ceil32(return_data.size)) + _12864 + 224
                                            t = (7 * ceil32(return_data.size)) + 224
                                            while idx < _13266:
                                                require mem[s] == mem[s]
                                                mem[t] = mem[s]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(rewardTokenAddress)
                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _19324 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_19324] == mem[_19324]
                                            if sub_0b4b41bc <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require sub_0b4b41bc
                                            sub_7f94bf16 = mem[_19324] / sub_0b4b41bc
                                            mem[mem[64] + 4] = treasuryAddress
                                            mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                            require ext_code.size(assetAddress)
                                            call assetAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _21490 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_21490] == bool(mem[_21490])
                                        else:
                                            mem[(6 * ceil32(return_data.size)) + 96] = 3
                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                            mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                            mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                            mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                            mem[(6 * ceil32(return_data.size)) + 260] = 0
                                            mem[(6 * ceil32(return_data.size)) + 292] = 160
                                            mem[(6 * ceil32(return_data.size)) + 388] = 3
                                            idx = 0
                                            s = (6 * ceil32(return_data.size)) + 128
                                            t = (6 * ceil32(return_data.size)) + 420
                                            while idx < 3:
                                                mem[t] = mem[s + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                            mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                            require ext_code.size(routerAddress)
                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                 gas gas_remaining wei
                                                args 0, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (7 * ceil32(return_data.size)) + 224
                                            require return_data.size >= 32
                                            _12863 = mem[(6 * ceil32(return_data.size)) + 224 len 4], 0
                                            require mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 <= test266151307()
                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                            _13265 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]
                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224] <= test266151307()
                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 32 >= 0
                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256
                                            mem[(7 * ceil32(return_data.size)) + 224] = _13265
                                            require _12863 + (32 * _13265) + 32 <= return_data.size
                                            idx = 0
                                            s = (6 * ceil32(return_data.size)) + _12863 + 256
                                            t = (7 * ceil32(return_data.size)) + 256
                                            while idx < _13265:
                                                require mem[s] == mem[s]
                                                mem[t] = mem[s]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(rewardTokenAddress)
                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _19323 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_19323] == mem[_19323]
                                            if sub_0b4b41bc <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require sub_0b4b41bc
                                            sub_7f94bf16 = mem[_19323] / sub_0b4b41bc
                                            mem[mem[64] + 4] = treasuryAddress
                                            mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                            require ext_code.size(assetAddress)
                                            call assetAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _21489 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_21489] == bool(mem[_21489])
                            else:
                                require ext_call.return_data[0] - totalDeposited
                                if (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / ext_call.return_data[0] - totalDeposited != sub_2f6236be:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not ext_call.return_data[0] - totalDeposited:
                                    sub_bf4c8572 = 0
                                    mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                    mem[ceil32(return_data.size) + 132] = -1
                                    require ext_code.size(sub_b8ab24bdAddress)
                                    call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args lendingPoolAddress, -1
                                    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                    mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                    mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                    require ext_code.size(lendingPoolAddress)
                                    call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                         gas gas_remaining wei
                                        args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                    mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                    mem[(4 * ceil32(return_data.size)) + 132] = -1
                                    require ext_code.size(assetAddress)
                                    call assetAddress.approve(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args routerAddress, -1
                                    mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    if assetAddress == WAVAXAddress:
                                        mem[(6 * ceil32(return_data.size)) + 96] = 2
                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                        mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                        mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                                        mem[(6 * ceil32(return_data.size)) + 260] = 160
                                        mem[(6 * ceil32(return_data.size)) + 356] = 2
                                        idx = 0
                                        s = (6 * ceil32(return_data.size)) + 128
                                        t = (6 * ceil32(return_data.size)) + 388
                                        while idx < 2:
                                            mem[t] = mem[s + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                        mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (7 * ceil32(return_data.size)) + 192
                                        require return_data.size >= 32
                                        _12859 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                        require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                        _13261 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                        mem[(7 * ceil32(return_data.size)) + 192] = _13261
                                        require _12859 + (32 * _13261) + 32 <= return_data.size
                                        idx = 0
                                        s = (6 * ceil32(return_data.size)) + _12859 + 224
                                        t = (7 * ceil32(return_data.size)) + 224
                                        while idx < _13261:
                                            require mem[s] == mem[s]
                                            mem[t] = mem[s]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(rewardTokenAddress)
                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _19319 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_19319] == mem[_19319]
                                        if sub_0b4b41bc <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require sub_0b4b41bc
                                        sub_7f94bf16 = mem[_19319] / sub_0b4b41bc
                                        mem[mem[64] + 4] = treasuryAddress
                                        mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                        require ext_code.size(assetAddress)
                                        call assetAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _21485 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_21485] == bool(mem[_21485])
                                    else:
                                        if rewardTokenAddress == WAVAXAddress:
                                            mem[(6 * ceil32(return_data.size)) + 96] = 2
                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                            mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                            mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                            mem[(6 * ceil32(return_data.size)) + 260] = 160
                                            mem[(6 * ceil32(return_data.size)) + 356] = 2
                                            idx = 0
                                            s = (6 * ceil32(return_data.size)) + 128
                                            t = (6 * ceil32(return_data.size)) + 388
                                            while idx < 2:
                                                mem[t] = mem[s + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                            mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                            require ext_code.size(routerAddress)
                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                 gas gas_remaining wei
                                                args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (7 * ceil32(return_data.size)) + 192
                                            require return_data.size >= 32
                                            _12861 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                            require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                            _13263 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                            mem[(7 * ceil32(return_data.size)) + 192] = _13263
                                            require _12861 + (32 * _13263) + 32 <= return_data.size
                                            idx = 0
                                            s = (6 * ceil32(return_data.size)) + _12861 + 224
                                            t = (7 * ceil32(return_data.size)) + 224
                                            while idx < _13263:
                                                require mem[s] == mem[s]
                                                mem[t] = mem[s]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(rewardTokenAddress)
                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _19321 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_19321] == mem[_19321]
                                            if sub_0b4b41bc <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require sub_0b4b41bc
                                            sub_7f94bf16 = mem[_19321] / sub_0b4b41bc
                                            mem[mem[64] + 4] = treasuryAddress
                                            mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                            require ext_code.size(assetAddress)
                                            call assetAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _21487 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_21487] == bool(mem[_21487])
                                        else:
                                            mem[(6 * ceil32(return_data.size)) + 96] = 3
                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                            mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                            mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                            mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[(6 * ceil32(return_data.size)) + 228] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                            mem[(6 * ceil32(return_data.size)) + 260] = 0
                                            mem[(6 * ceil32(return_data.size)) + 292] = 160
                                            mem[(6 * ceil32(return_data.size)) + 388] = 3
                                            idx = 0
                                            s = (6 * ceil32(return_data.size)) + 128
                                            t = (6 * ceil32(return_data.size)) + 420
                                            while idx < 3:
                                                mem[t] = mem[s + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                            mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                            require ext_code.size(routerAddress)
                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                 gas gas_remaining wei
                                                args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (7 * ceil32(return_data.size)) + 224
                                            require return_data.size >= 32
                                            _12860 = mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                            require mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                            _13262 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]
                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224] <= test266151307()
                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 32 >= 0
                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256
                                            mem[(7 * ceil32(return_data.size)) + 224] = _13262
                                            require _12860 + (32 * _13262) + 32 <= return_data.size
                                            idx = 0
                                            s = (6 * ceil32(return_data.size)) + _12860 + 256
                                            t = (7 * ceil32(return_data.size)) + 256
                                            while idx < _13262:
                                                require mem[s] == mem[s]
                                                mem[t] = mem[s]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(rewardTokenAddress)
                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _19320 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_19320] == mem[_19320]
                                            if sub_0b4b41bc <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require sub_0b4b41bc
                                            sub_7f94bf16 = mem[_19320] / sub_0b4b41bc
                                            mem[mem[64] + 4] = treasuryAddress
                                            mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                            require ext_code.size(assetAddress)
                                            call assetAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _21486 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_21486] == bool(mem[_21486])
                                else:
                                    require ext_call.return_data[0] - totalDeposited
                                    if (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / ext_call.return_data[0] - totalDeposited != sub_7e72b29f:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    sub_bf4c8572 = (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / 10000
                                    mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                    mem[ceil32(return_data.size) + 132] = -1
                                    require ext_code.size(sub_b8ab24bdAddress)
                                    call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args lendingPoolAddress, -1
                                    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                    mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                    mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                    require ext_code.size(lendingPoolAddress)
                                    call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                         gas gas_remaining wei
                                        args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                    mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                    mem[(4 * ceil32(return_data.size)) + 132] = -1
                                    require ext_code.size(assetAddress)
                                    call assetAddress.approve(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args routerAddress, -1
                                    mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    if assetAddress == WAVAXAddress:
                                        mem[(6 * ceil32(return_data.size)) + 96] = 2
                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                        mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                        mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                                        mem[(6 * ceil32(return_data.size)) + 260] = 160
                                        mem[(6 * ceil32(return_data.size)) + 356] = 2
                                        idx = 0
                                        s = (6 * ceil32(return_data.size)) + 128
                                        t = (6 * ceil32(return_data.size)) + 388
                                        while idx < 2:
                                            mem[t] = mem[s + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                        mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (7 * ceil32(return_data.size)) + 192
                                        require return_data.size >= 32
                                        _12856 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                        require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                        _13258 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                        mem[(7 * ceil32(return_data.size)) + 192] = _13258
                                        require _12856 + (32 * _13258) + 32 <= return_data.size
                                        idx = 0
                                        s = (6 * ceil32(return_data.size)) + _12856 + 224
                                        t = (7 * ceil32(return_data.size)) + 224
                                        while idx < _13258:
                                            require mem[s] == mem[s]
                                            mem[t] = mem[s]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(rewardTokenAddress)
                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _19316 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_19316] == mem[_19316]
                                        if sub_0b4b41bc <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require sub_0b4b41bc
                                        sub_7f94bf16 = mem[_19316] / sub_0b4b41bc
                                        mem[mem[64] + 4] = treasuryAddress
                                        mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                        require ext_code.size(assetAddress)
                                        call assetAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _21482 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_21482] == bool(mem[_21482])
                                    else:
                                        if rewardTokenAddress == WAVAXAddress:
                                            mem[(6 * ceil32(return_data.size)) + 96] = 2
                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                            mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                            mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                            mem[(6 * ceil32(return_data.size)) + 260] = 160
                                            mem[(6 * ceil32(return_data.size)) + 356] = 2
                                            idx = 0
                                            s = (6 * ceil32(return_data.size)) + 128
                                            t = (6 * ceil32(return_data.size)) + 388
                                            while idx < 2:
                                                mem[t] = mem[s + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                            mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                            require ext_code.size(routerAddress)
                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                 gas gas_remaining wei
                                                args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (7 * ceil32(return_data.size)) + 192
                                            require return_data.size >= 32
                                            _12858 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                            require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                            _13260 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                            mem[(7 * ceil32(return_data.size)) + 192] = _13260
                                            require _12858 + (32 * _13260) + 32 <= return_data.size
                                            idx = 0
                                            s = (6 * ceil32(return_data.size)) + _12858 + 224
                                            t = (7 * ceil32(return_data.size)) + 224
                                            while idx < _13260:
                                                require mem[s] == mem[s]
                                                mem[t] = mem[s]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(rewardTokenAddress)
                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _19318 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_19318] == mem[_19318]
                                            if sub_0b4b41bc <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require sub_0b4b41bc
                                            sub_7f94bf16 = mem[_19318] / sub_0b4b41bc
                                            mem[mem[64] + 4] = treasuryAddress
                                            mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                            require ext_code.size(assetAddress)
                                            call assetAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _21484 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_21484] == bool(mem[_21484])
                                        else:
                                            mem[(6 * ceil32(return_data.size)) + 96] = 3
                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                            mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                            mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                            mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[(6 * ceil32(return_data.size)) + 228] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                            mem[(6 * ceil32(return_data.size)) + 260] = 0
                                            mem[(6 * ceil32(return_data.size)) + 292] = 160
                                            mem[(6 * ceil32(return_data.size)) + 388] = 3
                                            idx = 0
                                            s = (6 * ceil32(return_data.size)) + 128
                                            t = (6 * ceil32(return_data.size)) + 420
                                            while idx < 3:
                                                mem[t] = mem[s + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                            mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                            require ext_code.size(routerAddress)
                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                 gas gas_remaining wei
                                                args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (7 * ceil32(return_data.size)) + 224
                                            require return_data.size >= 32
                                            _12857 = mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                            require mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                            _13259 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]
                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224] <= test266151307()
                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 32 >= 0
                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256
                                            mem[(7 * ceil32(return_data.size)) + 224] = _13259
                                            require _12857 + (32 * _13259) + 32 <= return_data.size
                                            idx = 0
                                            s = (6 * ceil32(return_data.size)) + _12857 + 256
                                            t = (7 * ceil32(return_data.size)) + 256
                                            while idx < _13259:
                                                require mem[s] == mem[s]
                                                mem[t] = mem[s]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(rewardTokenAddress)
                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _19317 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_19317] == mem[_19317]
                                            if sub_0b4b41bc <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require sub_0b4b41bc
                                            sub_7f94bf16 = mem[_19317] / sub_0b4b41bc
                                            mem[mem[64] + 4] = treasuryAddress
                                            mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                            require ext_code.size(assetAddress)
                                            call assetAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _21483 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_21483] == bool(mem[_21483])
                    else:
                        require block.timestamp - lastRewardTimestamp
                        if block.timestamp - lastRewardTimestamp / block.timestamp - lastRewardTimestamp != 1:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
                        if not block.timestamp - lastRewardTimestamp:
                            if not block.timestamp - lastRewardTimestamp:
                                require ext_code.size(rewardWalletAddress)
                                call rewardWalletAddress.requestReward(uint256 arg1) with:
                                     gas gas_remaining wei
                                    args 0
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if totalDeposited <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require totalDeposited
                                if sub_a9ac33dd + (0 / totalDeposited) < sub_a9ac33dd:
                                    revert with 0, 'SafeMath: addition overflow'
                                sub_a9ac33dd += 0 / totalDeposited
                                lastRewardTimestamp = block.timestamp
                                mem[100] = this.address
                                require ext_code.size(sub_b8ab24bdAddress)
                                staticcall sub_b8ab24bdAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[0]
                                if not ext_call.return_data[0] - totalDeposited:
                                    if not ext_call.return_data[0] - totalDeposited:
                                        if not ext_call.return_data[0] - totalDeposited:
                                            sub_bf4c8572 = 0
                                            mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                            mem[ceil32(return_data.size) + 132] = -1
                                            require ext_code.size(sub_b8ab24bdAddress)
                                            call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args lendingPoolAddress, -1
                                            mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                            mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                            mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                            mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                            require ext_code.size(lendingPoolAddress)
                                            call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                 gas gas_remaining wei
                                                args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                            mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_call.return_data[0] == ext_call.return_data[0]
                                            mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                            mem[(4 * ceil32(return_data.size)) + 132] = -1
                                            require ext_code.size(assetAddress)
                                            call assetAddress.approve(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args routerAddress, -1
                                            mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                            if assetAddress == WAVAXAddress:
                                                mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                idx = 0
                                                s = (6 * ceil32(return_data.size)) + 128
                                                t = (6 * ceil32(return_data.size)) + 388
                                                while idx < 2:
                                                    mem[t] = mem[s + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                require ext_code.size(routerAddress)
                                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                     gas gas_remaining wei
                                                    args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (7 * ceil32(return_data.size)) + 192
                                                require return_data.size >= 32
                                                _12853 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                _13255 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                mem[(7 * ceil32(return_data.size)) + 192] = _13255
                                                require _12853 + (32 * _13255) + 32 <= return_data.size
                                                idx = 0
                                                s = (6 * ceil32(return_data.size)) + _12853 + 224
                                                t = (7 * ceil32(return_data.size)) + 224
                                                while idx < _13255:
                                                    require mem[s] == mem[s]
                                                    mem[t] = mem[s]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[mem[64] + 4] = this.address
                                                require ext_code.size(rewardTokenAddress)
                                                staticcall rewardTokenAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args address(this.address)
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _19313 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_19313] == mem[_19313]
                                                if sub_0b4b41bc <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_0b4b41bc
                                                sub_7f94bf16 = mem[_19313] / sub_0b4b41bc
                                                mem[mem[64] + 4] = treasuryAddress
                                                mem[mem[64] + 36] = 0
                                                require ext_code.size(assetAddress)
                                                call assetAddress.0xa9059cbb with:
                                                     gas gas_remaining wei
                                                    args treasuryAddress, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _21479 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_21479] == bool(mem[_21479])
                                            else:
                                                if rewardTokenAddress == WAVAXAddress:
                                                    mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                    mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                    mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                    mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                    mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                    mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                    mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                    idx = 0
                                                    s = (6 * ceil32(return_data.size)) + 128
                                                    t = (6 * ceil32(return_data.size)) + 388
                                                    while idx < 2:
                                                        mem[t] = mem[s + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                    mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (7 * ceil32(return_data.size)) + 192
                                                    require return_data.size >= 32
                                                    _12855 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                    require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                    require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                    _13257 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                    require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                    require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                    mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                    mem[(7 * ceil32(return_data.size)) + 192] = _13257
                                                    require _12855 + (32 * _13257) + 32 <= return_data.size
                                                    idx = 0
                                                    s = (6 * ceil32(return_data.size)) + _12855 + 224
                                                    t = (7 * ceil32(return_data.size)) + 224
                                                    while idx < _13257:
                                                        require mem[s] == mem[s]
                                                        mem[t] = mem[s]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[mem[64] + 4] = this.address
                                                    require ext_code.size(rewardTokenAddress)
                                                    staticcall rewardTokenAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args address(this.address)
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _19315 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_19315] == mem[_19315]
                                                    if sub_0b4b41bc <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require sub_0b4b41bc
                                                    sub_7f94bf16 = mem[_19315] / sub_0b4b41bc
                                                    mem[mem[64] + 4] = treasuryAddress
                                                    mem[mem[64] + 36] = 0
                                                    require ext_code.size(assetAddress)
                                                    call assetAddress.0xa9059cbb with:
                                                         gas gas_remaining wei
                                                        args treasuryAddress, 0
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _21481 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_21481] == bool(mem[_21481])
                                                else:
                                                    mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                    mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                    mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                    mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                    mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                    mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                    mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                    mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                    idx = 0
                                                    s = (6 * ceil32(return_data.size)) + 128
                                                    t = (6 * ceil32(return_data.size)) + 420
                                                    while idx < 3:
                                                        mem[t] = mem[s + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                    mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args 0, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (7 * ceil32(return_data.size)) + 224
                                                    require return_data.size >= 32
                                                    _12854 = mem[(6 * ceil32(return_data.size)) + 224 len 4], 0
                                                    require mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 <= test266151307()
                                                    require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                    _13256 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]
                                                    require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224] <= test266151307()
                                                    require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 32 >= 0
                                                    mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256
                                                    mem[(7 * ceil32(return_data.size)) + 224] = _13256
                                                    require _12854 + (32 * _13256) + 32 <= return_data.size
                                                    idx = 0
                                                    s = (6 * ceil32(return_data.size)) + _12854 + 256
                                                    t = (7 * ceil32(return_data.size)) + 256
                                                    while idx < _13256:
                                                        require mem[s] == mem[s]
                                                        mem[t] = mem[s]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[mem[64] + 4] = this.address
                                                    require ext_code.size(rewardTokenAddress)
                                                    staticcall rewardTokenAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args address(this.address)
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _19314 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_19314] == mem[_19314]
                                                    if sub_0b4b41bc <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require sub_0b4b41bc
                                                    sub_7f94bf16 = mem[_19314] / sub_0b4b41bc
                                                    mem[mem[64] + 4] = treasuryAddress
                                                    mem[mem[64] + 36] = 0
                                                    require ext_code.size(assetAddress)
                                                    call assetAddress.0xa9059cbb with:
                                                         gas gas_remaining wei
                                                        args treasuryAddress, 0
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _21480 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_21480] == bool(mem[_21480])
                                        else:
                                            require ext_call.return_data[0] - totalDeposited
                                            if (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / ext_call.return_data[0] - totalDeposited != sub_7e72b29f:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            sub_bf4c8572 = (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / 10000
                                            mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                            mem[ceil32(return_data.size) + 132] = -1
                                            require ext_code.size(sub_b8ab24bdAddress)
                                            call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args lendingPoolAddress, -1
                                            mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                            mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                            mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                            mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                            require ext_code.size(lendingPoolAddress)
                                            call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                 gas gas_remaining wei
                                                args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                            mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_call.return_data[0] == ext_call.return_data[0]
                                            mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                            mem[(4 * ceil32(return_data.size)) + 132] = -1
                                            require ext_code.size(assetAddress)
                                            call assetAddress.approve(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args routerAddress, -1
                                            mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                            if assetAddress == WAVAXAddress:
                                                mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                idx = 0
                                                s = (6 * ceil32(return_data.size)) + 128
                                                t = (6 * ceil32(return_data.size)) + 388
                                                while idx < 2:
                                                    mem[t] = mem[s + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                require ext_code.size(routerAddress)
                                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                     gas gas_remaining wei
                                                    args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (7 * ceil32(return_data.size)) + 192
                                                require return_data.size >= 32
                                                _12850 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                _13252 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                mem[(7 * ceil32(return_data.size)) + 192] = _13252
                                                require _12850 + (32 * _13252) + 32 <= return_data.size
                                                idx = 0
                                                s = (6 * ceil32(return_data.size)) + _12850 + 224
                                                t = (7 * ceil32(return_data.size)) + 224
                                                while idx < _13252:
                                                    require mem[s] == mem[s]
                                                    mem[t] = mem[s]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[mem[64] + 4] = this.address
                                                require ext_code.size(rewardTokenAddress)
                                                staticcall rewardTokenAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args address(this.address)
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _19310 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_19310] == mem[_19310]
                                                if sub_0b4b41bc <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_0b4b41bc
                                                sub_7f94bf16 = mem[_19310] / sub_0b4b41bc
                                                mem[mem[64] + 4] = treasuryAddress
                                                mem[mem[64] + 36] = 0
                                                require ext_code.size(assetAddress)
                                                call assetAddress.0xa9059cbb with:
                                                     gas gas_remaining wei
                                                    args treasuryAddress, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _21476 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_21476] == bool(mem[_21476])
                                            else:
                                                if rewardTokenAddress == WAVAXAddress:
                                                    mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                    mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                    mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                    mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                    mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                    mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                    mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                    idx = 0
                                                    s = (6 * ceil32(return_data.size)) + 128
                                                    t = (6 * ceil32(return_data.size)) + 388
                                                    while idx < 2:
                                                        mem[t] = mem[s + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                    mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (7 * ceil32(return_data.size)) + 192
                                                    require return_data.size >= 32
                                                    _12852 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                    require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                    require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                    _13254 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                    require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                    require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                    mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                    mem[(7 * ceil32(return_data.size)) + 192] = _13254
                                                    require _12852 + (32 * _13254) + 32 <= return_data.size
                                                    idx = 0
                                                    s = (6 * ceil32(return_data.size)) + _12852 + 224
                                                    t = (7 * ceil32(return_data.size)) + 224
                                                    while idx < _13254:
                                                        require mem[s] == mem[s]
                                                        mem[t] = mem[s]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[mem[64] + 4] = this.address
                                                    require ext_code.size(rewardTokenAddress)
                                                    staticcall rewardTokenAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args address(this.address)
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _19312 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_19312] == mem[_19312]
                                                    if sub_0b4b41bc <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require sub_0b4b41bc
                                                    sub_7f94bf16 = mem[_19312] / sub_0b4b41bc
                                                    mem[mem[64] + 4] = treasuryAddress
                                                    mem[mem[64] + 36] = 0
                                                    require ext_code.size(assetAddress)
                                                    call assetAddress.0xa9059cbb with:
                                                         gas gas_remaining wei
                                                        args treasuryAddress, 0
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _21478 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_21478] == bool(mem[_21478])
                                                else:
                                                    mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                    mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                    mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                    mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                    mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                    mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                    mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                    mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                    idx = 0
                                                    s = (6 * ceil32(return_data.size)) + 128
                                                    t = (6 * ceil32(return_data.size)) + 420
                                                    while idx < 3:
                                                        mem[t] = mem[s + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                    mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args 0, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (7 * ceil32(return_data.size)) + 224
                                                    require return_data.size >= 32
                                                    _12851 = mem[(6 * ceil32(return_data.size)) + 224 len 4], 0
                                                    require mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 <= test266151307()
                                                    require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                    _13253 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]
                                                    require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224] <= test266151307()
                                                    require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 32 >= 0
                                                    mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256
                                                    mem[(7 * ceil32(return_data.size)) + 224] = _13253
                                                    require _12851 + (32 * _13253) + 32 <= return_data.size
                                                    idx = 0
                                                    s = (6 * ceil32(return_data.size)) + _12851 + 256
                                                    t = (7 * ceil32(return_data.size)) + 256
                                                    while idx < _13253:
                                                        require mem[s] == mem[s]
                                                        mem[t] = mem[s]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[mem[64] + 4] = this.address
                                                    require ext_code.size(rewardTokenAddress)
                                                    staticcall rewardTokenAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args address(this.address)
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _19311 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_19311] == mem[_19311]
                                                    if sub_0b4b41bc <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require sub_0b4b41bc
                                                    sub_7f94bf16 = mem[_19311] / sub_0b4b41bc
                                                    mem[mem[64] + 4] = treasuryAddress
                                                    mem[mem[64] + 36] = 0
                                                    require ext_code.size(assetAddress)
                                                    call assetAddress.0xa9059cbb with:
                                                         gas gas_remaining wei
                                                        args treasuryAddress, 0
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _21477 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_21477] == bool(mem[_21477])
                                    else:
                                        require ext_call.return_data[0] - totalDeposited
                                        if (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / ext_call.return_data[0] - totalDeposited != sub_2f6236be:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not ext_call.return_data[0] - totalDeposited:
                                            sub_bf4c8572 = 0
                                            mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                            mem[ceil32(return_data.size) + 132] = -1
                                            require ext_code.size(sub_b8ab24bdAddress)
                                            call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args lendingPoolAddress, -1
                                            mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                            mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                            mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                            mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                            require ext_code.size(lendingPoolAddress)
                                            call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                 gas gas_remaining wei
                                                args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                            mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_call.return_data[0] == ext_call.return_data[0]
                                            mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                            mem[(4 * ceil32(return_data.size)) + 132] = -1
                                            require ext_code.size(assetAddress)
                                            call assetAddress.approve(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args routerAddress, -1
                                            mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                            if assetAddress == WAVAXAddress:
                                                mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                idx = 0
                                                s = (6 * ceil32(return_data.size)) + 128
                                                t = (6 * ceil32(return_data.size)) + 388
                                                while idx < 2:
                                                    mem[t] = mem[s + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                require ext_code.size(routerAddress)
                                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                     gas gas_remaining wei
                                                    args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (7 * ceil32(return_data.size)) + 192
                                                require return_data.size >= 32
                                                _12847 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                _13249 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                mem[(7 * ceil32(return_data.size)) + 192] = _13249
                                                require _12847 + (32 * _13249) + 32 <= return_data.size
                                                idx = 0
                                                s = (6 * ceil32(return_data.size)) + _12847 + 224
                                                t = (7 * ceil32(return_data.size)) + 224
                                                while idx < _13249:
                                                    require mem[s] == mem[s]
                                                    mem[t] = mem[s]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[mem[64] + 4] = this.address
                                                require ext_code.size(rewardTokenAddress)
                                                staticcall rewardTokenAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args address(this.address)
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _19307 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_19307] == mem[_19307]
                                                if sub_0b4b41bc <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_0b4b41bc
                                                sub_7f94bf16 = mem[_19307] / sub_0b4b41bc
                                                mem[mem[64] + 4] = treasuryAddress
                                                mem[mem[64] + 36] = 0
                                                require ext_code.size(assetAddress)
                                                call assetAddress.0xa9059cbb with:
                                                     gas gas_remaining wei
                                                    args treasuryAddress, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _21473 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_21473] == bool(mem[_21473])
                                            else:
                                                if rewardTokenAddress == WAVAXAddress:
                                                    mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                    mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                    mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                    mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                    mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                    mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                    mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                    idx = 0
                                                    s = (6 * ceil32(return_data.size)) + 128
                                                    t = (6 * ceil32(return_data.size)) + 388
                                                    while idx < 2:
                                                        mem[t] = mem[s + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                    mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (7 * ceil32(return_data.size)) + 192
                                                    require return_data.size >= 32
                                                    _12849 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                    require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                    require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                    _13251 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                    require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                    require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                    mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                    mem[(7 * ceil32(return_data.size)) + 192] = _13251
                                                    require _12849 + (32 * _13251) + 32 <= return_data.size
                                                    idx = 0
                                                    s = (6 * ceil32(return_data.size)) + _12849 + 224
                                                    t = (7 * ceil32(return_data.size)) + 224
                                                    while idx < _13251:
                                                        require mem[s] == mem[s]
                                                        mem[t] = mem[s]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[mem[64] + 4] = this.address
                                                    require ext_code.size(rewardTokenAddress)
                                                    staticcall rewardTokenAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args address(this.address)
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _19309 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_19309] == mem[_19309]
                                                    if sub_0b4b41bc <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require sub_0b4b41bc
                                                    sub_7f94bf16 = mem[_19309] / sub_0b4b41bc
                                                    mem[mem[64] + 4] = treasuryAddress
                                                    mem[mem[64] + 36] = 0
                                                    require ext_code.size(assetAddress)
                                                    call assetAddress.0xa9059cbb with:
                                                         gas gas_remaining wei
                                                        args treasuryAddress, 0
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _21475 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_21475] == bool(mem[_21475])
                                                else:
                                                    mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                    mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                    mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                    mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                    mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[(6 * ceil32(return_data.size)) + 228] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                    mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                    mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                    mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                    idx = 0
                                                    s = (6 * ceil32(return_data.size)) + 128
                                                    t = (6 * ceil32(return_data.size)) + 420
                                                    while idx < 3:
                                                        mem[t] = mem[s + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                    mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (7 * ceil32(return_data.size)) + 224
                                                    require return_data.size >= 32
                                                    _12848 = mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                    require mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                    require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                    _13250 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]
                                                    require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224] <= test266151307()
                                                    require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 32 >= 0
                                                    mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256
                                                    mem[(7 * ceil32(return_data.size)) + 224] = _13250
                                                    require _12848 + (32 * _13250) + 32 <= return_data.size
                                                    idx = 0
                                                    s = (6 * ceil32(return_data.size)) + _12848 + 256
                                                    t = (7 * ceil32(return_data.size)) + 256
                                                    while idx < _13250:
                                                        require mem[s] == mem[s]
                                                        mem[t] = mem[s]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[mem[64] + 4] = this.address
                                                    require ext_code.size(rewardTokenAddress)
                                                    staticcall rewardTokenAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args address(this.address)
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _19308 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_19308] == mem[_19308]
                                                    if sub_0b4b41bc <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require sub_0b4b41bc
                                                    sub_7f94bf16 = mem[_19308] / sub_0b4b41bc
                                                    mem[mem[64] + 4] = treasuryAddress
                                                    mem[mem[64] + 36] = 0
                                                    require ext_code.size(assetAddress)
                                                    call assetAddress.0xa9059cbb with:
                                                         gas gas_remaining wei
                                                        args treasuryAddress, 0
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _21474 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_21474] == bool(mem[_21474])
                                        else:
                                            require ext_call.return_data[0] - totalDeposited
                                            if (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / ext_call.return_data[0] - totalDeposited != sub_7e72b29f:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            sub_bf4c8572 = (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / 10000
                                            mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                            mem[ceil32(return_data.size) + 132] = -1
                                            require ext_code.size(sub_b8ab24bdAddress)
                                            call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args lendingPoolAddress, -1
                                            mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                            mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                            mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                            mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                            require ext_code.size(lendingPoolAddress)
                                            call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                 gas gas_remaining wei
                                                args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                            mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_call.return_data[0] == ext_call.return_data[0]
                                            mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                            mem[(4 * ceil32(return_data.size)) + 132] = -1
                                            require ext_code.size(assetAddress)
                                            call assetAddress.approve(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args routerAddress, -1
                                            mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                            if assetAddress == WAVAXAddress:
                                                mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                idx = 0
                                                s = (6 * ceil32(return_data.size)) + 128
                                                t = (6 * ceil32(return_data.size)) + 388
                                                while idx < 2:
                                                    mem[t] = mem[s + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                require ext_code.size(routerAddress)
                                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                     gas gas_remaining wei
                                                    args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (7 * ceil32(return_data.size)) + 192
                                                require return_data.size >= 32
                                                _12844 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                _13246 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                mem[(7 * ceil32(return_data.size)) + 192] = _13246
                                                require _12844 + (32 * _13246) + 32 <= return_data.size
                                                idx = 0
                                                s = (6 * ceil32(return_data.size)) + _12844 + 224
                                                t = (7 * ceil32(return_data.size)) + 224
                                                while idx < _13246:
                                                    require mem[s] == mem[s]
                                                    mem[t] = mem[s]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[mem[64] + 4] = this.address
                                                require ext_code.size(rewardTokenAddress)
                                                staticcall rewardTokenAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args address(this.address)
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _19304 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_19304] == mem[_19304]
                                                if sub_0b4b41bc <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_0b4b41bc
                                                sub_7f94bf16 = mem[_19304] / sub_0b4b41bc
                                                mem[mem[64] + 4] = treasuryAddress
                                                mem[mem[64] + 36] = 0
                                                require ext_code.size(assetAddress)
                                                call assetAddress.0xa9059cbb with:
                                                     gas gas_remaining wei
                                                    args treasuryAddress, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _21470 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_21470] == bool(mem[_21470])
                                            else:
                                                if rewardTokenAddress == WAVAXAddress:
                                                    mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                    mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                    mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                    mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                    mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                    mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                    mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                    idx = 0
                                                    s = (6 * ceil32(return_data.size)) + 128
                                                    t = (6 * ceil32(return_data.size)) + 388
                                                    while idx < 2:
                                                        mem[t] = mem[s + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                    mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (7 * ceil32(return_data.size)) + 192
                                                    require return_data.size >= 32
                                                    _12846 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                    require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                    require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                    _13248 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                    require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                    require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                    mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                    mem[(7 * ceil32(return_data.size)) + 192] = _13248
                                                    require _12846 + (32 * _13248) + 32 <= return_data.size
                                                    idx = 0
                                                    s = (6 * ceil32(return_data.size)) + _12846 + 224
                                                    t = (7 * ceil32(return_data.size)) + 224
                                                    while idx < _13248:
                                                        require mem[s] == mem[s]
                                                        mem[t] = mem[s]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[mem[64] + 4] = this.address
                                                    require ext_code.size(rewardTokenAddress)
                                                    staticcall rewardTokenAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args address(this.address)
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _19306 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_19306] == mem[_19306]
                                                    if sub_0b4b41bc <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require sub_0b4b41bc
                                                    sub_7f94bf16 = mem[_19306] / sub_0b4b41bc
                                                    mem[mem[64] + 4] = treasuryAddress
                                                    mem[mem[64] + 36] = 0
                                                    require ext_code.size(assetAddress)
                                                    call assetAddress.0xa9059cbb with:
                                                         gas gas_remaining wei
                                                        args treasuryAddress, 0
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _21472 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_21472] == bool(mem[_21472])
                                                else:
                                                    mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                    mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                    mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                    mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                    mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[(6 * ceil32(return_data.size)) + 228] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                    mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                    mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                    mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                    idx = 0
                                                    s = (6 * ceil32(return_data.size)) + 128
                                                    t = (6 * ceil32(return_data.size)) + 420
                                                    while idx < 3:
                                                        mem[t] = mem[s + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                    mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (7 * ceil32(return_data.size)) + 224
                                                    require return_data.size >= 32
                                                    _12845 = mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                    require mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                    require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                    _13247 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]
                                                    require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224] <= test266151307()
                                                    require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 32 >= 0
                                                    mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256
                                                    mem[(7 * ceil32(return_data.size)) + 224] = _13247
                                                    require _12845 + (32 * _13247) + 32 <= return_data.size
                                                    idx = 0
                                                    s = (6 * ceil32(return_data.size)) + _12845 + 256
                                                    t = (7 * ceil32(return_data.size)) + 256
                                                    while idx < _13247:
                                                        require mem[s] == mem[s]
                                                        mem[t] = mem[s]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[mem[64] + 4] = this.address
                                                    require ext_code.size(rewardTokenAddress)
                                                    staticcall rewardTokenAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args address(this.address)
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _19305 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_19305] == mem[_19305]
                                                    if sub_0b4b41bc <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require sub_0b4b41bc
                                                    sub_7f94bf16 = mem[_19305] / sub_0b4b41bc
                                                    mem[mem[64] + 4] = treasuryAddress
                                                    mem[mem[64] + 36] = 0
                                                    require ext_code.size(assetAddress)
                                                    call assetAddress.0xa9059cbb with:
                                                         gas gas_remaining wei
                                                        args treasuryAddress, 0
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _21471 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_21471] == bool(mem[_21471])
                                else:
                                    require ext_call.return_data[0] - totalDeposited
                                    if (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / ext_call.return_data[0] - totalDeposited != sub_7796ff37:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not ext_call.return_data[0] - totalDeposited:
                                        if not ext_call.return_data[0] - totalDeposited:
                                            sub_bf4c8572 = 0
                                            mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                            mem[ceil32(return_data.size) + 132] = -1
                                            require ext_code.size(sub_b8ab24bdAddress)
                                            call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args lendingPoolAddress, -1
                                            mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                            mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                            mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                            mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                            require ext_code.size(lendingPoolAddress)
                                            call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                 gas gas_remaining wei
                                                args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                            mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_call.return_data[0] == ext_call.return_data[0]
                                            mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                            mem[(4 * ceil32(return_data.size)) + 132] = -1
                                            require ext_code.size(assetAddress)
                                            call assetAddress.approve(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args routerAddress, -1
                                            mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                            if assetAddress == WAVAXAddress:
                                                mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                idx = 0
                                                s = (6 * ceil32(return_data.size)) + 128
                                                t = (6 * ceil32(return_data.size)) + 388
                                                while idx < 2:
                                                    mem[t] = mem[s + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                require ext_code.size(routerAddress)
                                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                     gas gas_remaining wei
                                                    args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (7 * ceil32(return_data.size)) + 192
                                                require return_data.size >= 32
                                                _12841 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                _13243 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                mem[(7 * ceil32(return_data.size)) + 192] = _13243
                                                require _12841 + (32 * _13243) + 32 <= return_data.size
                                                idx = 0
                                                s = (6 * ceil32(return_data.size)) + _12841 + 224
                                                t = (7 * ceil32(return_data.size)) + 224
                                                while idx < _13243:
                                                    require mem[s] == mem[s]
                                                    mem[t] = mem[s]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[mem[64] + 4] = this.address
                                                require ext_code.size(rewardTokenAddress)
                                                staticcall rewardTokenAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args address(this.address)
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _19301 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_19301] == mem[_19301]
                                                if sub_0b4b41bc <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_0b4b41bc
                                                sub_7f94bf16 = mem[_19301] / sub_0b4b41bc
                                                mem[mem[64] + 4] = treasuryAddress
                                                mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                require ext_code.size(assetAddress)
                                                call assetAddress.0xa9059cbb with:
                                                     gas gas_remaining wei
                                                    args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _21467 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_21467] == bool(mem[_21467])
                                            else:
                                                if rewardTokenAddress == WAVAXAddress:
                                                    mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                    mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                    mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                    mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                    mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                    mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                    mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                    idx = 0
                                                    s = (6 * ceil32(return_data.size)) + 128
                                                    t = (6 * ceil32(return_data.size)) + 388
                                                    while idx < 2:
                                                        mem[t] = mem[s + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                    mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (7 * ceil32(return_data.size)) + 192
                                                    require return_data.size >= 32
                                                    _12843 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                    require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                    require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                    _13245 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                    require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                    require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                    mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                    mem[(7 * ceil32(return_data.size)) + 192] = _13245
                                                    require _12843 + (32 * _13245) + 32 <= return_data.size
                                                    idx = 0
                                                    s = (6 * ceil32(return_data.size)) + _12843 + 224
                                                    t = (7 * ceil32(return_data.size)) + 224
                                                    while idx < _13245:
                                                        require mem[s] == mem[s]
                                                        mem[t] = mem[s]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[mem[64] + 4] = this.address
                                                    require ext_code.size(rewardTokenAddress)
                                                    staticcall rewardTokenAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args address(this.address)
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _19303 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_19303] == mem[_19303]
                                                    if sub_0b4b41bc <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require sub_0b4b41bc
                                                    sub_7f94bf16 = mem[_19303] / sub_0b4b41bc
                                                    mem[mem[64] + 4] = treasuryAddress
                                                    mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                    require ext_code.size(assetAddress)
                                                    call assetAddress.0xa9059cbb with:
                                                         gas gas_remaining wei
                                                        args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _21469 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_21469] == bool(mem[_21469])
                                                else:
                                                    mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                    mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                    mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                    mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                    mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                    mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                    mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                    mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                    idx = 0
                                                    s = (6 * ceil32(return_data.size)) + 128
                                                    t = (6 * ceil32(return_data.size)) + 420
                                                    while idx < 3:
                                                        mem[t] = mem[s + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                    mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args 0, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (7 * ceil32(return_data.size)) + 224
                                                    require return_data.size >= 32
                                                    _12842 = mem[(6 * ceil32(return_data.size)) + 224 len 4], 0
                                                    require mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 <= test266151307()
                                                    require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                    _13244 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]
                                                    require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224] <= test266151307()
                                                    require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 32 >= 0
                                                    mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256
                                                    mem[(7 * ceil32(return_data.size)) + 224] = _13244
                                                    require _12842 + (32 * _13244) + 32 <= return_data.size
                                                    idx = 0
                                                    s = (6 * ceil32(return_data.size)) + _12842 + 256
                                                    t = (7 * ceil32(return_data.size)) + 256
                                                    while idx < _13244:
                                                        require mem[s] == mem[s]
                                                        mem[t] = mem[s]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[mem[64] + 4] = this.address
                                                    require ext_code.size(rewardTokenAddress)
                                                    staticcall rewardTokenAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args address(this.address)
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _19302 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_19302] == mem[_19302]
                                                    if sub_0b4b41bc <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require sub_0b4b41bc
                                                    sub_7f94bf16 = mem[_19302] / sub_0b4b41bc
                                                    mem[mem[64] + 4] = treasuryAddress
                                                    mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                    require ext_code.size(assetAddress)
                                                    call assetAddress.0xa9059cbb with:
                                                         gas gas_remaining wei
                                                        args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _21468 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_21468] == bool(mem[_21468])
                                        else:
                                            require ext_call.return_data[0] - totalDeposited
                                            if (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / ext_call.return_data[0] - totalDeposited != sub_7e72b29f:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            sub_bf4c8572 = (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / 10000
                                            mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                            mem[ceil32(return_data.size) + 132] = -1
                                            require ext_code.size(sub_b8ab24bdAddress)
                                            call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args lendingPoolAddress, -1
                                            mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                            mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                            mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                            mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                            require ext_code.size(lendingPoolAddress)
                                            call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                 gas gas_remaining wei
                                                args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                            mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_call.return_data[0] == ext_call.return_data[0]
                                            mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                            mem[(4 * ceil32(return_data.size)) + 132] = -1
                                            require ext_code.size(assetAddress)
                                            call assetAddress.approve(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args routerAddress, -1
                                            mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                            if assetAddress == WAVAXAddress:
                                                mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                idx = 0
                                                s = (6 * ceil32(return_data.size)) + 128
                                                t = (6 * ceil32(return_data.size)) + 388
                                                while idx < 2:
                                                    mem[t] = mem[s + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                require ext_code.size(routerAddress)
                                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                     gas gas_remaining wei
                                                    args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (7 * ceil32(return_data.size)) + 192
                                                require return_data.size >= 32
                                                _12838 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                _13240 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                mem[(7 * ceil32(return_data.size)) + 192] = _13240
                                                require _12838 + (32 * _13240) + 32 <= return_data.size
                                                idx = 0
                                                s = (6 * ceil32(return_data.size)) + _12838 + 224
                                                t = (7 * ceil32(return_data.size)) + 224
                                                while idx < _13240:
                                                    require mem[s] == mem[s]
                                                    mem[t] = mem[s]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[mem[64] + 4] = this.address
                                                require ext_code.size(rewardTokenAddress)
                                                staticcall rewardTokenAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args address(this.address)
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _19298 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_19298] == mem[_19298]
                                                if sub_0b4b41bc <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_0b4b41bc
                                                sub_7f94bf16 = mem[_19298] / sub_0b4b41bc
                                                mem[mem[64] + 4] = treasuryAddress
                                                mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                require ext_code.size(assetAddress)
                                                call assetAddress.0xa9059cbb with:
                                                     gas gas_remaining wei
                                                    args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _21464 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_21464] == bool(mem[_21464])
                                            else:
                                                if rewardTokenAddress == WAVAXAddress:
                                                    mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                    mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                    mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                    mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                    mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                    mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                    mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                    idx = 0
                                                    s = (6 * ceil32(return_data.size)) + 128
                                                    t = (6 * ceil32(return_data.size)) + 388
                                                    while idx < 2:
                                                        mem[t] = mem[s + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                    mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (7 * ceil32(return_data.size)) + 192
                                                    require return_data.size >= 32
                                                    _12840 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                    require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                    require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                    _13242 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                    require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                    require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                    mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                    mem[(7 * ceil32(return_data.size)) + 192] = _13242
                                                    require _12840 + (32 * _13242) + 32 <= return_data.size
                                                    idx = 0
                                                    s = (6 * ceil32(return_data.size)) + _12840 + 224
                                                    t = (7 * ceil32(return_data.size)) + 224
                                                    while idx < _13242:
                                                        require mem[s] == mem[s]
                                                        mem[t] = mem[s]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[mem[64] + 4] = this.address
                                                    require ext_code.size(rewardTokenAddress)
                                                    staticcall rewardTokenAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args address(this.address)
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _19300 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_19300] == mem[_19300]
                                                    if sub_0b4b41bc <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require sub_0b4b41bc
                                                    sub_7f94bf16 = mem[_19300] / sub_0b4b41bc
                                                    mem[mem[64] + 4] = treasuryAddress
                                                    mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                    require ext_code.size(assetAddress)
                                                    call assetAddress.0xa9059cbb with:
                                                         gas gas_remaining wei
                                                        args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _21466 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_21466] == bool(mem[_21466])
                                                else:
                                                    mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                    mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                    mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                    mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                    mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                    mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                    mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                    mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                    idx = 0
                                                    s = (6 * ceil32(return_data.size)) + 128
                                                    t = (6 * ceil32(return_data.size)) + 420
                                                    while idx < 3:
                                                        mem[t] = mem[s + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                    mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args 0, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (7 * ceil32(return_data.size)) + 224
                                                    require return_data.size >= 32
                                                    _12839 = mem[(6 * ceil32(return_data.size)) + 224 len 4], 0
                                                    require mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 <= test266151307()
                                                    require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                    _13241 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]
                                                    require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224] <= test266151307()
                                                    require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 32 >= 0
                                                    mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256
                                                    mem[(7 * ceil32(return_data.size)) + 224] = _13241
                                                    require _12839 + (32 * _13241) + 32 <= return_data.size
                                                    idx = 0
                                                    s = (6 * ceil32(return_data.size)) + _12839 + 256
                                                    t = (7 * ceil32(return_data.size)) + 256
                                                    while idx < _13241:
                                                        require mem[s] == mem[s]
                                                        mem[t] = mem[s]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[mem[64] + 4] = this.address
                                                    require ext_code.size(rewardTokenAddress)
                                                    staticcall rewardTokenAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args address(this.address)
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _19299 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_19299] == mem[_19299]
                                                    if sub_0b4b41bc <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require sub_0b4b41bc
                                                    sub_7f94bf16 = mem[_19299] / sub_0b4b41bc
                                                    mem[mem[64] + 4] = treasuryAddress
                                                    mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                    require ext_code.size(assetAddress)
                                                    call assetAddress.0xa9059cbb with:
                                                         gas gas_remaining wei
                                                        args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _21465 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_21465] == bool(mem[_21465])
                                    else:
                                        require ext_call.return_data[0] - totalDeposited
                                        if (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / ext_call.return_data[0] - totalDeposited != sub_2f6236be:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not ext_call.return_data[0] - totalDeposited:
                                            sub_bf4c8572 = 0
                                            mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                            mem[ceil32(return_data.size) + 132] = -1
                                            require ext_code.size(sub_b8ab24bdAddress)
                                            call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args lendingPoolAddress, -1
                                            mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                            mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                            mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                            mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                            require ext_code.size(lendingPoolAddress)
                                            call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                 gas gas_remaining wei
                                                args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                            mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_call.return_data[0] == ext_call.return_data[0]
                                            mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                            mem[(4 * ceil32(return_data.size)) + 132] = -1
                                            require ext_code.size(assetAddress)
                                            call assetAddress.approve(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args routerAddress, -1
                                            mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                            if assetAddress == WAVAXAddress:
                                                mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                idx = 0
                                                s = (6 * ceil32(return_data.size)) + 128
                                                t = (6 * ceil32(return_data.size)) + 388
                                                while idx < 2:
                                                    mem[t] = mem[s + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                require ext_code.size(routerAddress)
                                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                     gas gas_remaining wei
                                                    args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (7 * ceil32(return_data.size)) + 192
                                                require return_data.size >= 32
                                                _12835 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                _13237 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                mem[(7 * ceil32(return_data.size)) + 192] = _13237
                                                require _12835 + (32 * _13237) + 32 <= return_data.size
                                                idx = 0
                                                s = (6 * ceil32(return_data.size)) + _12835 + 224
                                                t = (7 * ceil32(return_data.size)) + 224
                                                while idx < _13237:
                                                    require mem[s] == mem[s]
                                                    mem[t] = mem[s]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[mem[64] + 4] = this.address
                                                require ext_code.size(rewardTokenAddress)
                                                staticcall rewardTokenAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args address(this.address)
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _19295 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_19295] == mem[_19295]
                                                if sub_0b4b41bc <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_0b4b41bc
                                                sub_7f94bf16 = mem[_19295] / sub_0b4b41bc
                                                mem[mem[64] + 4] = treasuryAddress
                                                mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                require ext_code.size(assetAddress)
                                                call assetAddress.0xa9059cbb with:
                                                     gas gas_remaining wei
                                                    args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _21461 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_21461] == bool(mem[_21461])
                                            else:
                                                if rewardTokenAddress == WAVAXAddress:
                                                    mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                    mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                    mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                    mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                    mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                    mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                    mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                    idx = 0
                                                    s = (6 * ceil32(return_data.size)) + 128
                                                    t = (6 * ceil32(return_data.size)) + 388
                                                    while idx < 2:
                                                        mem[t] = mem[s + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                    mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (7 * ceil32(return_data.size)) + 192
                                                    require return_data.size >= 32
                                                    _12837 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                    require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                    require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                    _13239 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                    require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                    require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                    mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                    mem[(7 * ceil32(return_data.size)) + 192] = _13239
                                                    require _12837 + (32 * _13239) + 32 <= return_data.size
                                                    idx = 0
                                                    s = (6 * ceil32(return_data.size)) + _12837 + 224
                                                    t = (7 * ceil32(return_data.size)) + 224
                                                    while idx < _13239:
                                                        require mem[s] == mem[s]
                                                        mem[t] = mem[s]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[mem[64] + 4] = this.address
                                                    require ext_code.size(rewardTokenAddress)
                                                    staticcall rewardTokenAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args address(this.address)
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _19297 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_19297] == mem[_19297]
                                                    if sub_0b4b41bc <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require sub_0b4b41bc
                                                    sub_7f94bf16 = mem[_19297] / sub_0b4b41bc
                                                    mem[mem[64] + 4] = treasuryAddress
                                                    mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                    require ext_code.size(assetAddress)
                                                    call assetAddress.0xa9059cbb with:
                                                         gas gas_remaining wei
                                                        args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _21463 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_21463] == bool(mem[_21463])
                                                else:
                                                    mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                    mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                    mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                    mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                    mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[(6 * ceil32(return_data.size)) + 228] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                    mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                    mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                    mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                    idx = 0
                                                    s = (6 * ceil32(return_data.size)) + 128
                                                    t = (6 * ceil32(return_data.size)) + 420
                                                    while idx < 3:
                                                        mem[t] = mem[s + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                    mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (7 * ceil32(return_data.size)) + 224
                                                    require return_data.size >= 32
                                                    _12836 = mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                    require mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                    require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                    _13238 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]
                                                    require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224] <= test266151307()
                                                    require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 32 >= 0
                                                    mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256
                                                    mem[(7 * ceil32(return_data.size)) + 224] = _13238
                                                    require _12836 + (32 * _13238) + 32 <= return_data.size
                                                    idx = 0
                                                    s = (6 * ceil32(return_data.size)) + _12836 + 256
                                                    t = (7 * ceil32(return_data.size)) + 256
                                                    while idx < _13238:
                                                        require mem[s] == mem[s]
                                                        mem[t] = mem[s]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[mem[64] + 4] = this.address
                                                    require ext_code.size(rewardTokenAddress)
                                                    staticcall rewardTokenAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args address(this.address)
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _19296 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_19296] == mem[_19296]
                                                    if sub_0b4b41bc <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require sub_0b4b41bc
                                                    sub_7f94bf16 = mem[_19296] / sub_0b4b41bc
                                                    mem[mem[64] + 4] = treasuryAddress
                                                    mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                    require ext_code.size(assetAddress)
                                                    call assetAddress.0xa9059cbb with:
                                                         gas gas_remaining wei
                                                        args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _21462 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_21462] == bool(mem[_21462])
                                        else:
                                            require ext_call.return_data[0] - totalDeposited
                                            if (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / ext_call.return_data[0] - totalDeposited != sub_7e72b29f:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            sub_bf4c8572 = (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / 10000
                                            mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                            mem[ceil32(return_data.size) + 132] = -1
                                            require ext_code.size(sub_b8ab24bdAddress)
                                            call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args lendingPoolAddress, -1
                                            mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                            mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                            mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                            mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                            require ext_code.size(lendingPoolAddress)
                                            call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                 gas gas_remaining wei
                                                args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                            mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_call.return_data[0] == ext_call.return_data[0]
                                            mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                            mem[(4 * ceil32(return_data.size)) + 132] = -1
                                            require ext_code.size(assetAddress)
                                            call assetAddress.approve(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args routerAddress, -1
                                            mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                            if assetAddress == WAVAXAddress:
                                                mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                idx = 0
                                                s = (6 * ceil32(return_data.size)) + 128
                                                t = (6 * ceil32(return_data.size)) + 388
                                                while idx < 2:
                                                    mem[t] = mem[s + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                require ext_code.size(routerAddress)
                                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                     gas gas_remaining wei
                                                    args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (7 * ceil32(return_data.size)) + 192
                                                require return_data.size >= 32
                                                _12832 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                _13234 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                mem[(7 * ceil32(return_data.size)) + 192] = _13234
                                                require _12832 + (32 * _13234) + 32 <= return_data.size
                                                idx = 0
                                                s = (6 * ceil32(return_data.size)) + _12832 + 224
                                                t = (7 * ceil32(return_data.size)) + 224
                                                while idx < _13234:
                                                    require mem[s] == mem[s]
                                                    mem[t] = mem[s]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[mem[64] + 4] = this.address
                                                require ext_code.size(rewardTokenAddress)
                                                staticcall rewardTokenAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args address(this.address)
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _19292 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_19292] == mem[_19292]
                                                if sub_0b4b41bc <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_0b4b41bc
                                                sub_7f94bf16 = mem[_19292] / sub_0b4b41bc
                                                mem[mem[64] + 4] = treasuryAddress
                                                mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                require ext_code.size(assetAddress)
                                                call assetAddress.0xa9059cbb with:
                                                     gas gas_remaining wei
                                                    args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _21458 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_21458] == bool(mem[_21458])
                                            else:
                                                if rewardTokenAddress == WAVAXAddress:
                                                    mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                    mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                    mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                    mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                    mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                    mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                    mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                    idx = 0
                                                    s = (6 * ceil32(return_data.size)) + 128
                                                    t = (6 * ceil32(return_data.size)) + 388
                                                    while idx < 2:
                                                        mem[t] = mem[s + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                    mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (7 * ceil32(return_data.size)) + 192
                                                    require return_data.size >= 32
                                                    _12834 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                    require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                    require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                    _13236 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                    require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                    require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                    mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                    mem[(7 * ceil32(return_data.size)) + 192] = _13236
                                                    require _12834 + (32 * _13236) + 32 <= return_data.size
                                                    idx = 0
                                                    s = (6 * ceil32(return_data.size)) + _12834 + 224
                                                    t = (7 * ceil32(return_data.size)) + 224
                                                    while idx < _13236:
                                                        require mem[s] == mem[s]
                                                        mem[t] = mem[s]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[mem[64] + 4] = this.address
                                                    require ext_code.size(rewardTokenAddress)
                                                    staticcall rewardTokenAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args address(this.address)
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _19294 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_19294] == mem[_19294]
                                                    if sub_0b4b41bc <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require sub_0b4b41bc
                                                    sub_7f94bf16 = mem[_19294] / sub_0b4b41bc
                                                    mem[mem[64] + 4] = treasuryAddress
                                                    mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                    require ext_code.size(assetAddress)
                                                    call assetAddress.0xa9059cbb with:
                                                         gas gas_remaining wei
                                                        args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _21460 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_21460] == bool(mem[_21460])
                                                else:
                                                    mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                    mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                    mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                    mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                    mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[(6 * ceil32(return_data.size)) + 228] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                    mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                    mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                    mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                    idx = 0
                                                    s = (6 * ceil32(return_data.size)) + 128
                                                    t = (6 * ceil32(return_data.size)) + 420
                                                    while idx < 3:
                                                        mem[t] = mem[s + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                    mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (7 * ceil32(return_data.size)) + 224
                                                    require return_data.size >= 32
                                                    _12833 = mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                    require mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                    require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                    _13235 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]
                                                    require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224] <= test266151307()
                                                    require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 32 >= 0
                                                    mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256
                                                    mem[(7 * ceil32(return_data.size)) + 224] = _13235
                                                    require _12833 + (32 * _13235) + 32 <= return_data.size
                                                    idx = 0
                                                    s = (6 * ceil32(return_data.size)) + _12833 + 256
                                                    t = (7 * ceil32(return_data.size)) + 256
                                                    while idx < _13235:
                                                        require mem[s] == mem[s]
                                                        mem[t] = mem[s]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[mem[64] + 4] = this.address
                                                    require ext_code.size(rewardTokenAddress)
                                                    staticcall rewardTokenAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args address(this.address)
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _19293 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_19293] == mem[_19293]
                                                    if sub_0b4b41bc <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require sub_0b4b41bc
                                                    sub_7f94bf16 = mem[_19293] / sub_0b4b41bc
                                                    mem[mem[64] + 4] = treasuryAddress
                                                    mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                    require ext_code.size(assetAddress)
                                                    call assetAddress.0xa9059cbb with:
                                                         gas gas_remaining wei
                                                        args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _21459 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_21459] == bool(mem[_21459])
                            else:
                                require block.timestamp - lastRewardTimestamp
                                if (block.timestamp * sub_f12c8e0d) - (lastRewardTimestamp * sub_f12c8e0d) / block.timestamp - lastRewardTimestamp != sub_f12c8e0d:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
                                if not (block.timestamp * sub_f12c8e0d) - (lastRewardTimestamp * sub_f12c8e0d):
                                    require ext_code.size(rewardWalletAddress)
                                    call rewardWalletAddress.requestReward(uint256 arg1) with:
                                         gas gas_remaining wei
                                        args 0
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if totalDeposited <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require totalDeposited
                                    if sub_a9ac33dd + (0 / totalDeposited) < sub_a9ac33dd:
                                        revert with 0, 'SafeMath: addition overflow'
                                    sub_a9ac33dd += 0 / totalDeposited
                                    lastRewardTimestamp = block.timestamp
                                    mem[100] = this.address
                                    require ext_code.size(sub_b8ab24bdAddress)
                                    staticcall sub_b8ab24bdAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    if not ext_call.return_data[0] - totalDeposited:
                                        if not ext_call.return_data[0] - totalDeposited:
                                            if not ext_call.return_data[0] - totalDeposited:
                                                sub_bf4c8572 = 0
                                                mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                                mem[ceil32(return_data.size) + 132] = -1
                                                require ext_code.size(sub_b8ab24bdAddress)
                                                call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args lendingPoolAddress, -1
                                                mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                                mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                                mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                                require ext_code.size(lendingPoolAddress)
                                                call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                     gas gas_remaining wei
                                                    args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                                mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == ext_call.return_data[0]
                                                mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                                mem[(4 * ceil32(return_data.size)) + 132] = -1
                                                require ext_code.size(assetAddress)
                                                call assetAddress.approve(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args routerAddress, -1
                                                mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                if assetAddress == WAVAXAddress:
                                                    mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                    mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                    mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                    mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                    mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                    mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                    mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                    idx = 0
                                                    s = (6 * ceil32(return_data.size)) + 128
                                                    t = (6 * ceil32(return_data.size)) + 388
                                                    while idx < 2:
                                                        mem[t] = mem[s + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                    mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (7 * ceil32(return_data.size)) + 192
                                                    require return_data.size >= 32
                                                    _12829 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                    require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                    require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                    _13231 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                    require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                    require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                    mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                    mem[(7 * ceil32(return_data.size)) + 192] = _13231
                                                    require _12829 + (32 * _13231) + 32 <= return_data.size
                                                    idx = 0
                                                    s = (6 * ceil32(return_data.size)) + _12829 + 224
                                                    t = (7 * ceil32(return_data.size)) + 224
                                                    while idx < _13231:
                                                        require mem[s] == mem[s]
                                                        mem[t] = mem[s]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[mem[64] + 4] = this.address
                                                    require ext_code.size(rewardTokenAddress)
                                                    staticcall rewardTokenAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args address(this.address)
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _19289 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_19289] == mem[_19289]
                                                    if sub_0b4b41bc <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require sub_0b4b41bc
                                                    sub_7f94bf16 = mem[_19289] / sub_0b4b41bc
                                                    mem[mem[64] + 4] = treasuryAddress
                                                    mem[mem[64] + 36] = 0
                                                    require ext_code.size(assetAddress)
                                                    call assetAddress.0xa9059cbb with:
                                                         gas gas_remaining wei
                                                        args treasuryAddress, 0
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _21455 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_21455] == bool(mem[_21455])
                                                else:
                                                    if rewardTokenAddress == WAVAXAddress:
                                                        mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                        mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                        mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                        mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                        mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + 128
                                                        t = (6 * ceil32(return_data.size)) + 388
                                                        while idx < 2:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                        mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                        require ext_code.size(routerAddress)
                                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = (7 * ceil32(return_data.size)) + 192
                                                        require return_data.size >= 32
                                                        _12831 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                        require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                        _13233 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                        mem[(7 * ceil32(return_data.size)) + 192] = _13233
                                                        require _12831 + (32 * _13233) + 32 <= return_data.size
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + _12831 + 224
                                                        t = (7 * ceil32(return_data.size)) + 224
                                                        while idx < _13233:
                                                            require mem[s] == mem[s]
                                                            mem[t] = mem[s]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[mem[64] + 4] = this.address
                                                        require ext_code.size(rewardTokenAddress)
                                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args address(this.address)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _19291 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_19291] == mem[_19291]
                                                        if sub_0b4b41bc <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require sub_0b4b41bc
                                                        sub_7f94bf16 = mem[_19291] / sub_0b4b41bc
                                                        mem[mem[64] + 4] = treasuryAddress
                                                        mem[mem[64] + 36] = 0
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args treasuryAddress, 0
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _21457 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_21457] == bool(mem[_21457])
                                                    else:
                                                        mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                        mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                        mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                        mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                        mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + 128
                                                        t = (6 * ceil32(return_data.size)) + 420
                                                        while idx < 3:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                        mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                        require ext_code.size(routerAddress)
                                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args 0, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = (7 * ceil32(return_data.size)) + 224
                                                        require return_data.size >= 32
                                                        _12830 = mem[(6 * ceil32(return_data.size)) + 224 len 4], 0
                                                        require mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 <= test266151307()
                                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                        _13232 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]
                                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224] <= test266151307()
                                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 32 >= 0
                                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256
                                                        mem[(7 * ceil32(return_data.size)) + 224] = _13232
                                                        require _12830 + (32 * _13232) + 32 <= return_data.size
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + _12830 + 256
                                                        t = (7 * ceil32(return_data.size)) + 256
                                                        while idx < _13232:
                                                            require mem[s] == mem[s]
                                                            mem[t] = mem[s]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[mem[64] + 4] = this.address
                                                        require ext_code.size(rewardTokenAddress)
                                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args address(this.address)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _19290 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_19290] == mem[_19290]
                                                        if sub_0b4b41bc <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require sub_0b4b41bc
                                                        sub_7f94bf16 = mem[_19290] / sub_0b4b41bc
                                                        mem[mem[64] + 4] = treasuryAddress
                                                        mem[mem[64] + 36] = 0
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args treasuryAddress, 0
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _21456 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_21456] == bool(mem[_21456])
                                            else:
                                                require ext_call.return_data[0] - totalDeposited
                                                if (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / ext_call.return_data[0] - totalDeposited != sub_7e72b29f:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                sub_bf4c8572 = (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / 10000
                                                mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                                mem[ceil32(return_data.size) + 132] = -1
                                                require ext_code.size(sub_b8ab24bdAddress)
                                                call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args lendingPoolAddress, -1
                                                mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                                mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                                mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                                require ext_code.size(lendingPoolAddress)
                                                call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                     gas gas_remaining wei
                                                    args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                                mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == ext_call.return_data[0]
                                                mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                                mem[(4 * ceil32(return_data.size)) + 132] = -1
                                                require ext_code.size(assetAddress)
                                                call assetAddress.approve(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args routerAddress, -1
                                                mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                if assetAddress == WAVAXAddress:
                                                    mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                    mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                    mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                    mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                    mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                    mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                    mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                    idx = 0
                                                    s = (6 * ceil32(return_data.size)) + 128
                                                    t = (6 * ceil32(return_data.size)) + 388
                                                    while idx < 2:
                                                        mem[t] = mem[s + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                    mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (7 * ceil32(return_data.size)) + 192
                                                    require return_data.size >= 32
                                                    _12826 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                    require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                    require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                    _13228 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                    require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                    require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                    mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                    mem[(7 * ceil32(return_data.size)) + 192] = _13228
                                                    require _12826 + (32 * _13228) + 32 <= return_data.size
                                                    idx = 0
                                                    s = (6 * ceil32(return_data.size)) + _12826 + 224
                                                    t = (7 * ceil32(return_data.size)) + 224
                                                    while idx < _13228:
                                                        require mem[s] == mem[s]
                                                        mem[t] = mem[s]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[mem[64] + 4] = this.address
                                                    require ext_code.size(rewardTokenAddress)
                                                    staticcall rewardTokenAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args address(this.address)
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _19286 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_19286] == mem[_19286]
                                                    if sub_0b4b41bc <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require sub_0b4b41bc
                                                    sub_7f94bf16 = mem[_19286] / sub_0b4b41bc
                                                    mem[mem[64] + 4] = treasuryAddress
                                                    mem[mem[64] + 36] = 0
                                                    require ext_code.size(assetAddress)
                                                    call assetAddress.0xa9059cbb with:
                                                         gas gas_remaining wei
                                                        args treasuryAddress, 0
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _21452 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_21452] == bool(mem[_21452])
                                                else:
                                                    if rewardTokenAddress == WAVAXAddress:
                                                        mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                        mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                        mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                        mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                        mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + 128
                                                        t = (6 * ceil32(return_data.size)) + 388
                                                        while idx < 2:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                        mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                        require ext_code.size(routerAddress)
                                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = (7 * ceil32(return_data.size)) + 192
                                                        require return_data.size >= 32
                                                        _12828 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                        require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                        _13230 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                        mem[(7 * ceil32(return_data.size)) + 192] = _13230
                                                        require _12828 + (32 * _13230) + 32 <= return_data.size
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + _12828 + 224
                                                        t = (7 * ceil32(return_data.size)) + 224
                                                        while idx < _13230:
                                                            require mem[s] == mem[s]
                                                            mem[t] = mem[s]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[mem[64] + 4] = this.address
                                                        require ext_code.size(rewardTokenAddress)
                                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args address(this.address)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _19288 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_19288] == mem[_19288]
                                                        if sub_0b4b41bc <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require sub_0b4b41bc
                                                        sub_7f94bf16 = mem[_19288] / sub_0b4b41bc
                                                        mem[mem[64] + 4] = treasuryAddress
                                                        mem[mem[64] + 36] = 0
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args treasuryAddress, 0
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _21454 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_21454] == bool(mem[_21454])
                                                    else:
                                                        mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                        mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                        mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                        mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                        mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + 128
                                                        t = (6 * ceil32(return_data.size)) + 420
                                                        while idx < 3:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                        mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                        require ext_code.size(routerAddress)
                                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args 0, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = (7 * ceil32(return_data.size)) + 224
                                                        require return_data.size >= 32
                                                        _12827 = mem[(6 * ceil32(return_data.size)) + 224 len 4], 0
                                                        require mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 <= test266151307()
                                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                        _13229 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]
                                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224] <= test266151307()
                                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 32 >= 0
                                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256
                                                        mem[(7 * ceil32(return_data.size)) + 224] = _13229
                                                        require _12827 + (32 * _13229) + 32 <= return_data.size
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + _12827 + 256
                                                        t = (7 * ceil32(return_data.size)) + 256
                                                        while idx < _13229:
                                                            require mem[s] == mem[s]
                                                            mem[t] = mem[s]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[mem[64] + 4] = this.address
                                                        require ext_code.size(rewardTokenAddress)
                                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args address(this.address)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _19287 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_19287] == mem[_19287]
                                                        if sub_0b4b41bc <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require sub_0b4b41bc
                                                        sub_7f94bf16 = mem[_19287] / sub_0b4b41bc
                                                        mem[mem[64] + 4] = treasuryAddress
                                                        mem[mem[64] + 36] = 0
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args treasuryAddress, 0
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _21453 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_21453] == bool(mem[_21453])
                                        else:
                                            require ext_call.return_data[0] - totalDeposited
                                            if (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / ext_call.return_data[0] - totalDeposited != sub_2f6236be:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not ext_call.return_data[0] - totalDeposited:
                                                sub_bf4c8572 = 0
                                                mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                                mem[ceil32(return_data.size) + 132] = -1
                                                require ext_code.size(sub_b8ab24bdAddress)
                                                call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args lendingPoolAddress, -1
                                                mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                                mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                                mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                                require ext_code.size(lendingPoolAddress)
                                                call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                     gas gas_remaining wei
                                                    args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                                mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == ext_call.return_data[0]
                                                mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                                mem[(4 * ceil32(return_data.size)) + 132] = -1
                                                require ext_code.size(assetAddress)
                                                call assetAddress.approve(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args routerAddress, -1
                                                mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                if assetAddress == WAVAXAddress:
                                                    mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                    mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                    mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                    mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                    mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                    mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                    mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                    idx = 0
                                                    s = (6 * ceil32(return_data.size)) + 128
                                                    t = (6 * ceil32(return_data.size)) + 388
                                                    while idx < 2:
                                                        mem[t] = mem[s + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                    mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (7 * ceil32(return_data.size)) + 192
                                                    require return_data.size >= 32
                                                    _12823 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                    require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                    require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                    _13225 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                    require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                    require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                    mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                    mem[(7 * ceil32(return_data.size)) + 192] = _13225
                                                    require _12823 + (32 * _13225) + 32 <= return_data.size
                                                    idx = 0
                                                    s = (6 * ceil32(return_data.size)) + _12823 + 224
                                                    t = (7 * ceil32(return_data.size)) + 224
                                                    while idx < _13225:
                                                        require mem[s] == mem[s]
                                                        mem[t] = mem[s]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[mem[64] + 4] = this.address
                                                    require ext_code.size(rewardTokenAddress)
                                                    staticcall rewardTokenAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args address(this.address)
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _19283 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_19283] == mem[_19283]
                                                    if sub_0b4b41bc <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require sub_0b4b41bc
                                                    sub_7f94bf16 = mem[_19283] / sub_0b4b41bc
                                                    mem[mem[64] + 4] = treasuryAddress
                                                    mem[mem[64] + 36] = 0
                                                    require ext_code.size(assetAddress)
                                                    call assetAddress.0xa9059cbb with:
                                                         gas gas_remaining wei
                                                        args treasuryAddress, 0
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _21449 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_21449] == bool(mem[_21449])
                                                else:
                                                    if rewardTokenAddress == WAVAXAddress:
                                                        mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                        mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                        mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                        mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                        mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + 128
                                                        t = (6 * ceil32(return_data.size)) + 388
                                                        while idx < 2:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                        mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                        require ext_code.size(routerAddress)
                                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = (7 * ceil32(return_data.size)) + 192
                                                        require return_data.size >= 32
                                                        _12825 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                        require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                        _13227 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                        mem[(7 * ceil32(return_data.size)) + 192] = _13227
                                                        require _12825 + (32 * _13227) + 32 <= return_data.size
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + _12825 + 224
                                                        t = (7 * ceil32(return_data.size)) + 224
                                                        while idx < _13227:
                                                            require mem[s] == mem[s]
                                                            mem[t] = mem[s]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[mem[64] + 4] = this.address
                                                        require ext_code.size(rewardTokenAddress)
                                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args address(this.address)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _19285 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_19285] == mem[_19285]
                                                        if sub_0b4b41bc <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require sub_0b4b41bc
                                                        sub_7f94bf16 = mem[_19285] / sub_0b4b41bc
                                                        mem[mem[64] + 4] = treasuryAddress
                                                        mem[mem[64] + 36] = 0
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args treasuryAddress, 0
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _21451 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_21451] == bool(mem[_21451])
                                                    else:
                                                        mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                        mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                        mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                        mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                        mem[(6 * ceil32(return_data.size)) + 228] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                        mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                        mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + 128
                                                        t = (6 * ceil32(return_data.size)) + 420
                                                        while idx < 3:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                        mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                        require ext_code.size(routerAddress)
                                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = (7 * ceil32(return_data.size)) + 224
                                                        require return_data.size >= 32
                                                        _12824 = mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                        require mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                        _13226 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]
                                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224] <= test266151307()
                                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 32 >= 0
                                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256
                                                        mem[(7 * ceil32(return_data.size)) + 224] = _13226
                                                        require _12824 + (32 * _13226) + 32 <= return_data.size
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + _12824 + 256
                                                        t = (7 * ceil32(return_data.size)) + 256
                                                        while idx < _13226:
                                                            require mem[s] == mem[s]
                                                            mem[t] = mem[s]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[mem[64] + 4] = this.address
                                                        require ext_code.size(rewardTokenAddress)
                                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args address(this.address)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _19284 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_19284] == mem[_19284]
                                                        if sub_0b4b41bc <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require sub_0b4b41bc
                                                        sub_7f94bf16 = mem[_19284] / sub_0b4b41bc
                                                        mem[mem[64] + 4] = treasuryAddress
                                                        mem[mem[64] + 36] = 0
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args treasuryAddress, 0
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _21450 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_21450] == bool(mem[_21450])
                                            else:
                                                require ext_call.return_data[0] - totalDeposited
                                                if (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / ext_call.return_data[0] - totalDeposited != sub_7e72b29f:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                sub_bf4c8572 = (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / 10000
                                                mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                                mem[ceil32(return_data.size) + 132] = -1
                                                require ext_code.size(sub_b8ab24bdAddress)
                                                call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args lendingPoolAddress, -1
                                                mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                                mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                                mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                                require ext_code.size(lendingPoolAddress)
                                                call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                     gas gas_remaining wei
                                                    args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                                mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == ext_call.return_data[0]
                                                mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                                mem[(4 * ceil32(return_data.size)) + 132] = -1
                                                require ext_code.size(assetAddress)
                                                call assetAddress.approve(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args routerAddress, -1
                                                mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                if assetAddress == WAVAXAddress:
                                                    mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                    mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                    mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                    mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                    mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                    mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                    mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                    idx = 0
                                                    s = (6 * ceil32(return_data.size)) + 128
                                                    t = (6 * ceil32(return_data.size)) + 388
                                                    while idx < 2:
                                                        mem[t] = mem[s + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                    mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (7 * ceil32(return_data.size)) + 192
                                                    require return_data.size >= 32
                                                    _12820 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                    require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                    require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                    _13222 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                    require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                    require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                    mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                    mem[(7 * ceil32(return_data.size)) + 192] = _13222
                                                    require _12820 + (32 * _13222) + 32 <= return_data.size
                                                    idx = 0
                                                    s = (6 * ceil32(return_data.size)) + _12820 + 224
                                                    t = (7 * ceil32(return_data.size)) + 224
                                                    while idx < _13222:
                                                        require mem[s] == mem[s]
                                                        mem[t] = mem[s]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[mem[64] + 4] = this.address
                                                    require ext_code.size(rewardTokenAddress)
                                                    staticcall rewardTokenAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args address(this.address)
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _19280 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_19280] == mem[_19280]
                                                    if sub_0b4b41bc <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require sub_0b4b41bc
                                                    sub_7f94bf16 = mem[_19280] / sub_0b4b41bc
                                                    mem[mem[64] + 4] = treasuryAddress
                                                    mem[mem[64] + 36] = 0
                                                    require ext_code.size(assetAddress)
                                                    call assetAddress.0xa9059cbb with:
                                                         gas gas_remaining wei
                                                        args treasuryAddress, 0
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _21446 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_21446] == bool(mem[_21446])
                                                else:
                                                    if rewardTokenAddress == WAVAXAddress:
                                                        mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                        mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                        mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                        mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                        mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + 128
                                                        t = (6 * ceil32(return_data.size)) + 388
                                                        while idx < 2:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                        mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                        require ext_code.size(routerAddress)
                                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = (7 * ceil32(return_data.size)) + 192
                                                        require return_data.size >= 32
                                                        _12822 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                        require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                        _13224 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                        mem[(7 * ceil32(return_data.size)) + 192] = _13224
                                                        require _12822 + (32 * _13224) + 32 <= return_data.size
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + _12822 + 224
                                                        t = (7 * ceil32(return_data.size)) + 224
                                                        while idx < _13224:
                                                            require mem[s] == mem[s]
                                                            mem[t] = mem[s]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[mem[64] + 4] = this.address
                                                        require ext_code.size(rewardTokenAddress)
                                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args address(this.address)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _19282 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_19282] == mem[_19282]
                                                        if sub_0b4b41bc <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require sub_0b4b41bc
                                                        sub_7f94bf16 = mem[_19282] / sub_0b4b41bc
                                                        mem[mem[64] + 4] = treasuryAddress
                                                        mem[mem[64] + 36] = 0
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args treasuryAddress, 0
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _21448 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_21448] == bool(mem[_21448])
                                                    else:
                                                        mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                        mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                        mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                        mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                        mem[(6 * ceil32(return_data.size)) + 228] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                        mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                        mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + 128
                                                        t = (6 * ceil32(return_data.size)) + 420
                                                        while idx < 3:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                        mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                        require ext_code.size(routerAddress)
                                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = (7 * ceil32(return_data.size)) + 224
                                                        require return_data.size >= 32
                                                        _12821 = mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                        require mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                        _13223 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]
                                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224] <= test266151307()
                                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 32 >= 0
                                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256
                                                        mem[(7 * ceil32(return_data.size)) + 224] = _13223
                                                        require _12821 + (32 * _13223) + 32 <= return_data.size
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + _12821 + 256
                                                        t = (7 * ceil32(return_data.size)) + 256
                                                        while idx < _13223:
                                                            require mem[s] == mem[s]
                                                            mem[t] = mem[s]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[mem[64] + 4] = this.address
                                                        require ext_code.size(rewardTokenAddress)
                                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args address(this.address)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _19281 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_19281] == mem[_19281]
                                                        if sub_0b4b41bc <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require sub_0b4b41bc
                                                        sub_7f94bf16 = mem[_19281] / sub_0b4b41bc
                                                        mem[mem[64] + 4] = treasuryAddress
                                                        mem[mem[64] + 36] = 0
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args treasuryAddress, 0
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _21447 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_21447] == bool(mem[_21447])
                                    else:
                                        require ext_call.return_data[0] - totalDeposited
                                        if (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / ext_call.return_data[0] - totalDeposited != sub_7796ff37:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not ext_call.return_data[0] - totalDeposited:
                                            if not ext_call.return_data[0] - totalDeposited:
                                                sub_bf4c8572 = 0
                                                mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                                mem[ceil32(return_data.size) + 132] = -1
                                                require ext_code.size(sub_b8ab24bdAddress)
                                                call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args lendingPoolAddress, -1
                                                mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                                mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                                mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                                require ext_code.size(lendingPoolAddress)
                                                call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                     gas gas_remaining wei
                                                    args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                                mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == ext_call.return_data[0]
                                                mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                                mem[(4 * ceil32(return_data.size)) + 132] = -1
                                                require ext_code.size(assetAddress)
                                                call assetAddress.approve(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args routerAddress, -1
                                                mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                if assetAddress == WAVAXAddress:
                                                    mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                    mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                    mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                    mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                    mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                    mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                    mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                    idx = 0
                                                    s = (6 * ceil32(return_data.size)) + 128
                                                    t = (6 * ceil32(return_data.size)) + 388
                                                    while idx < 2:
                                                        mem[t] = mem[s + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                    mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (7 * ceil32(return_data.size)) + 192
                                                    require return_data.size >= 32
                                                    _12817 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                    require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                    require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                    _13219 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                    require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                    require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                    mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                    mem[(7 * ceil32(return_data.size)) + 192] = _13219
                                                    require _12817 + (32 * _13219) + 32 <= return_data.size
                                                    idx = 0
                                                    s = (6 * ceil32(return_data.size)) + _12817 + 224
                                                    t = (7 * ceil32(return_data.size)) + 224
                                                    while idx < _13219:
                                                        require mem[s] == mem[s]
                                                        mem[t] = mem[s]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[mem[64] + 4] = this.address
                                                    require ext_code.size(rewardTokenAddress)
                                                    staticcall rewardTokenAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args address(this.address)
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _19277 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_19277] == mem[_19277]
                                                    if sub_0b4b41bc <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require sub_0b4b41bc
                                                    sub_7f94bf16 = mem[_19277] / sub_0b4b41bc
                                                    mem[mem[64] + 4] = treasuryAddress
                                                    mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                    require ext_code.size(assetAddress)
                                                    call assetAddress.0xa9059cbb with:
                                                         gas gas_remaining wei
                                                        args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _21443 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_21443] == bool(mem[_21443])
                                                else:
                                                    if rewardTokenAddress == WAVAXAddress:
                                                        mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                        mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                        mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                        mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                        mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + 128
                                                        t = (6 * ceil32(return_data.size)) + 388
                                                        while idx < 2:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                        mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                        require ext_code.size(routerAddress)
                                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = (7 * ceil32(return_data.size)) + 192
                                                        require return_data.size >= 32
                                                        _12819 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                        require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                        _13221 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                        mem[(7 * ceil32(return_data.size)) + 192] = _13221
                                                        require _12819 + (32 * _13221) + 32 <= return_data.size
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + _12819 + 224
                                                        t = (7 * ceil32(return_data.size)) + 224
                                                        while idx < _13221:
                                                            require mem[s] == mem[s]
                                                            mem[t] = mem[s]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[mem[64] + 4] = this.address
                                                        require ext_code.size(rewardTokenAddress)
                                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args address(this.address)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _19279 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_19279] == mem[_19279]
                                                        if sub_0b4b41bc <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require sub_0b4b41bc
                                                        sub_7f94bf16 = mem[_19279] / sub_0b4b41bc
                                                        mem[mem[64] + 4] = treasuryAddress
                                                        mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _21445 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_21445] == bool(mem[_21445])
                                                    else:
                                                        mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                        mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                        mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                        mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                        mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + 128
                                                        t = (6 * ceil32(return_data.size)) + 420
                                                        while idx < 3:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                        mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                        require ext_code.size(routerAddress)
                                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args 0, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = (7 * ceil32(return_data.size)) + 224
                                                        require return_data.size >= 32
                                                        _12818 = mem[(6 * ceil32(return_data.size)) + 224 len 4], 0
                                                        require mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 <= test266151307()
                                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                        _13220 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]
                                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224] <= test266151307()
                                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 32 >= 0
                                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256
                                                        mem[(7 * ceil32(return_data.size)) + 224] = _13220
                                                        require _12818 + (32 * _13220) + 32 <= return_data.size
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + _12818 + 256
                                                        t = (7 * ceil32(return_data.size)) + 256
                                                        while idx < _13220:
                                                            require mem[s] == mem[s]
                                                            mem[t] = mem[s]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[mem[64] + 4] = this.address
                                                        require ext_code.size(rewardTokenAddress)
                                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args address(this.address)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _19278 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_19278] == mem[_19278]
                                                        if sub_0b4b41bc <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require sub_0b4b41bc
                                                        sub_7f94bf16 = mem[_19278] / sub_0b4b41bc
                                                        mem[mem[64] + 4] = treasuryAddress
                                                        mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _21444 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_21444] == bool(mem[_21444])
                                            else:
                                                require ext_call.return_data[0] - totalDeposited
                                                if (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / ext_call.return_data[0] - totalDeposited != sub_7e72b29f:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                sub_bf4c8572 = (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / 10000
                                                mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                                mem[ceil32(return_data.size) + 132] = -1
                                                require ext_code.size(sub_b8ab24bdAddress)
                                                call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args lendingPoolAddress, -1
                                                mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                                mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                                mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                                require ext_code.size(lendingPoolAddress)
                                                call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                     gas gas_remaining wei
                                                    args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                                mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == ext_call.return_data[0]
                                                mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                                mem[(4 * ceil32(return_data.size)) + 132] = -1
                                                require ext_code.size(assetAddress)
                                                call assetAddress.approve(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args routerAddress, -1
                                                mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                if assetAddress == WAVAXAddress:
                                                    mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                    mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                    mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                    mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                    mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                    mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                    mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                    idx = 0
                                                    s = (6 * ceil32(return_data.size)) + 128
                                                    t = (6 * ceil32(return_data.size)) + 388
                                                    while idx < 2:
                                                        mem[t] = mem[s + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                    mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (7 * ceil32(return_data.size)) + 192
                                                    require return_data.size >= 32
                                                    _12814 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                    require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                    require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                    _13216 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                    require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                    require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                    mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                    mem[(7 * ceil32(return_data.size)) + 192] = _13216
                                                    require _12814 + (32 * _13216) + 32 <= return_data.size
                                                    idx = 0
                                                    s = (6 * ceil32(return_data.size)) + _12814 + 224
                                                    t = (7 * ceil32(return_data.size)) + 224
                                                    while idx < _13216:
                                                        require mem[s] == mem[s]
                                                        mem[t] = mem[s]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[mem[64] + 4] = this.address
                                                    require ext_code.size(rewardTokenAddress)
                                                    staticcall rewardTokenAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args address(this.address)
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _19274 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_19274] == mem[_19274]
                                                    if sub_0b4b41bc <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require sub_0b4b41bc
                                                    sub_7f94bf16 = mem[_19274] / sub_0b4b41bc
                                                    mem[mem[64] + 4] = treasuryAddress
                                                    mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                    require ext_code.size(assetAddress)
                                                    call assetAddress.0xa9059cbb with:
                                                         gas gas_remaining wei
                                                        args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _21440 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_21440] == bool(mem[_21440])
                                                else:
                                                    if rewardTokenAddress == WAVAXAddress:
                                                        mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                        mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                        mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                        mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                        mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + 128
                                                        t = (6 * ceil32(return_data.size)) + 388
                                                        while idx < 2:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                        mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                        require ext_code.size(routerAddress)
                                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = (7 * ceil32(return_data.size)) + 192
                                                        require return_data.size >= 32
                                                        _12816 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                        require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                        _13218 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                        mem[(7 * ceil32(return_data.size)) + 192] = _13218
                                                        require _12816 + (32 * _13218) + 32 <= return_data.size
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + _12816 + 224
                                                        t = (7 * ceil32(return_data.size)) + 224
                                                        while idx < _13218:
                                                            require mem[s] == mem[s]
                                                            mem[t] = mem[s]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[mem[64] + 4] = this.address
                                                        require ext_code.size(rewardTokenAddress)
                                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args address(this.address)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _19276 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_19276] == mem[_19276]
                                                        if sub_0b4b41bc <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require sub_0b4b41bc
                                                        sub_7f94bf16 = mem[_19276] / sub_0b4b41bc
                                                        mem[mem[64] + 4] = treasuryAddress
                                                        mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _21442 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_21442] == bool(mem[_21442])
                                                    else:
                                                        mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                        mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                        mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                        mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                        mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + 128
                                                        t = (6 * ceil32(return_data.size)) + 420
                                                        while idx < 3:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                        mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                        require ext_code.size(routerAddress)
                                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args 0, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = (7 * ceil32(return_data.size)) + 224
                                                        require return_data.size >= 32
                                                        _12815 = mem[(6 * ceil32(return_data.size)) + 224 len 4], 0
                                                        require mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 <= test266151307()
                                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                        _13217 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]
                                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224] <= test266151307()
                                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 32 >= 0
                                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256
                                                        mem[(7 * ceil32(return_data.size)) + 224] = _13217
                                                        require _12815 + (32 * _13217) + 32 <= return_data.size
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + _12815 + 256
                                                        t = (7 * ceil32(return_data.size)) + 256
                                                        while idx < _13217:
                                                            require mem[s] == mem[s]
                                                            mem[t] = mem[s]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[mem[64] + 4] = this.address
                                                        require ext_code.size(rewardTokenAddress)
                                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args address(this.address)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _19275 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_19275] == mem[_19275]
                                                        if sub_0b4b41bc <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require sub_0b4b41bc
                                                        sub_7f94bf16 = mem[_19275] / sub_0b4b41bc
                                                        mem[mem[64] + 4] = treasuryAddress
                                                        mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _21441 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_21441] == bool(mem[_21441])
                                        else:
                                            require ext_call.return_data[0] - totalDeposited
                                            if (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / ext_call.return_data[0] - totalDeposited != sub_2f6236be:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not ext_call.return_data[0] - totalDeposited:
                                                sub_bf4c8572 = 0
                                                mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                                mem[ceil32(return_data.size) + 132] = -1
                                                require ext_code.size(sub_b8ab24bdAddress)
                                                call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args lendingPoolAddress, -1
                                                mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                                mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                                mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                                require ext_code.size(lendingPoolAddress)
                                                call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                     gas gas_remaining wei
                                                    args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                                mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == ext_call.return_data[0]
                                                mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                                mem[(4 * ceil32(return_data.size)) + 132] = -1
                                                require ext_code.size(assetAddress)
                                                call assetAddress.approve(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args routerAddress, -1
                                                mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                if assetAddress == WAVAXAddress:
                                                    mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                    mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                    mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                    mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                    mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                    mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                    mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                    idx = 0
                                                    s = (6 * ceil32(return_data.size)) + 128
                                                    t = (6 * ceil32(return_data.size)) + 388
                                                    while idx < 2:
                                                        mem[t] = mem[s + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                    mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (7 * ceil32(return_data.size)) + 192
                                                    require return_data.size >= 32
                                                    _12811 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                    require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                    require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                    _13213 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                    require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                    require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                    mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                    mem[(7 * ceil32(return_data.size)) + 192] = _13213
                                                    require _12811 + (32 * _13213) + 32 <= return_data.size
                                                    idx = 0
                                                    s = (6 * ceil32(return_data.size)) + _12811 + 224
                                                    t = (7 * ceil32(return_data.size)) + 224
                                                    while idx < _13213:
                                                        require mem[s] == mem[s]
                                                        mem[t] = mem[s]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[mem[64] + 4] = this.address
                                                    require ext_code.size(rewardTokenAddress)
                                                    staticcall rewardTokenAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args address(this.address)
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _19271 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_19271] == mem[_19271]
                                                    if sub_0b4b41bc <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require sub_0b4b41bc
                                                    sub_7f94bf16 = mem[_19271] / sub_0b4b41bc
                                                    mem[mem[64] + 4] = treasuryAddress
                                                    mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                    require ext_code.size(assetAddress)
                                                    call assetAddress.0xa9059cbb with:
                                                         gas gas_remaining wei
                                                        args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _21437 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_21437] == bool(mem[_21437])
                                                else:
                                                    if rewardTokenAddress == WAVAXAddress:
                                                        mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                        mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                        mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                        mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                        mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + 128
                                                        t = (6 * ceil32(return_data.size)) + 388
                                                        while idx < 2:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                        mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                        require ext_code.size(routerAddress)
                                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = (7 * ceil32(return_data.size)) + 192
                                                        require return_data.size >= 32
                                                        _12813 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                        require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                        _13215 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                        mem[(7 * ceil32(return_data.size)) + 192] = _13215
                                                        require _12813 + (32 * _13215) + 32 <= return_data.size
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + _12813 + 224
                                                        t = (7 * ceil32(return_data.size)) + 224
                                                        while idx < _13215:
                                                            require mem[s] == mem[s]
                                                            mem[t] = mem[s]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[mem[64] + 4] = this.address
                                                        require ext_code.size(rewardTokenAddress)
                                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args address(this.address)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _19273 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_19273] == mem[_19273]
                                                        if sub_0b4b41bc <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require sub_0b4b41bc
                                                        sub_7f94bf16 = mem[_19273] / sub_0b4b41bc
                                                        mem[mem[64] + 4] = treasuryAddress
                                                        mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _21439 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_21439] == bool(mem[_21439])
                                                    else:
                                                        mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                        mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                        mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                        mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                        mem[(6 * ceil32(return_data.size)) + 228] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                        mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                        mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + 128
                                                        t = (6 * ceil32(return_data.size)) + 420
                                                        while idx < 3:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                        mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                        require ext_code.size(routerAddress)
                                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = (7 * ceil32(return_data.size)) + 224
                                                        require return_data.size >= 32
                                                        _12812 = mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                        require mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                        _13214 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]
                                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224] <= test266151307()
                                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 32 >= 0
                                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256
                                                        mem[(7 * ceil32(return_data.size)) + 224] = _13214
                                                        require _12812 + (32 * _13214) + 32 <= return_data.size
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + _12812 + 256
                                                        t = (7 * ceil32(return_data.size)) + 256
                                                        while idx < _13214:
                                                            require mem[s] == mem[s]
                                                            mem[t] = mem[s]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[mem[64] + 4] = this.address
                                                        require ext_code.size(rewardTokenAddress)
                                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args address(this.address)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _19272 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_19272] == mem[_19272]
                                                        if sub_0b4b41bc <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require sub_0b4b41bc
                                                        sub_7f94bf16 = mem[_19272] / sub_0b4b41bc
                                                        mem[mem[64] + 4] = treasuryAddress
                                                        mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _21438 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_21438] == bool(mem[_21438])
                                            else:
                                                require ext_call.return_data[0] - totalDeposited
                                                if (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / ext_call.return_data[0] - totalDeposited != sub_7e72b29f:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                sub_bf4c8572 = (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / 10000
                                                mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                                mem[ceil32(return_data.size) + 132] = -1
                                                require ext_code.size(sub_b8ab24bdAddress)
                                                call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args lendingPoolAddress, -1
                                                mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                                mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                                mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                                require ext_code.size(lendingPoolAddress)
                                                call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                     gas gas_remaining wei
                                                    args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                                mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == ext_call.return_data[0]
                                                mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                                mem[(4 * ceil32(return_data.size)) + 132] = -1
                                                require ext_code.size(assetAddress)
                                                call assetAddress.approve(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args routerAddress, -1
                                                mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                if assetAddress == WAVAXAddress:
                                                    mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                    mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                    mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                    mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                    mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                    mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                    mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                    idx = 0
                                                    s = (6 * ceil32(return_data.size)) + 128
                                                    t = (6 * ceil32(return_data.size)) + 388
                                                    while idx < 2:
                                                        mem[t] = mem[s + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                    mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (7 * ceil32(return_data.size)) + 192
                                                    require return_data.size >= 32
                                                    _12808 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                    require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                    require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                    _13210 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                    require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                    require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                    mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                    mem[(7 * ceil32(return_data.size)) + 192] = _13210
                                                    require _12808 + (32 * _13210) + 32 <= return_data.size
                                                    idx = 0
                                                    s = (6 * ceil32(return_data.size)) + _12808 + 224
                                                    t = (7 * ceil32(return_data.size)) + 224
                                                    while idx < _13210:
                                                        require mem[s] == mem[s]
                                                        mem[t] = mem[s]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[mem[64] + 4] = this.address
                                                    require ext_code.size(rewardTokenAddress)
                                                    staticcall rewardTokenAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args address(this.address)
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _19268 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_19268] == mem[_19268]
                                                    if sub_0b4b41bc <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require sub_0b4b41bc
                                                    sub_7f94bf16 = mem[_19268] / sub_0b4b41bc
                                                    mem[mem[64] + 4] = treasuryAddress
                                                    mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                    require ext_code.size(assetAddress)
                                                    call assetAddress.0xa9059cbb with:
                                                         gas gas_remaining wei
                                                        args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _21434 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_21434] == bool(mem[_21434])
                                                else:
                                                    if rewardTokenAddress == WAVAXAddress:
                                                        mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                        mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                        mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                        mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                        mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + 128
                                                        t = (6 * ceil32(return_data.size)) + 388
                                                        while idx < 2:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                        mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                        require ext_code.size(routerAddress)
                                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = (7 * ceil32(return_data.size)) + 192
                                                        require return_data.size >= 32
                                                        _12810 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                        require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                        _13212 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                        mem[(7 * ceil32(return_data.size)) + 192] = _13212
                                                        require _12810 + (32 * _13212) + 32 <= return_data.size
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + _12810 + 224
                                                        t = (7 * ceil32(return_data.size)) + 224
                                                        while idx < _13212:
                                                            require mem[s] == mem[s]
                                                            mem[t] = mem[s]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[mem[64] + 4] = this.address
                                                        require ext_code.size(rewardTokenAddress)
                                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args address(this.address)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _19270 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_19270] == mem[_19270]
                                                        if sub_0b4b41bc <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require sub_0b4b41bc
                                                        sub_7f94bf16 = mem[_19270] / sub_0b4b41bc
                                                        mem[mem[64] + 4] = treasuryAddress
                                                        mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _21436 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_21436] == bool(mem[_21436])
                                                    else:
                                                        mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                        mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                        mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                        mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                        mem[(6 * ceil32(return_data.size)) + 228] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                        mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                        mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + 128
                                                        t = (6 * ceil32(return_data.size)) + 420
                                                        while idx < 3:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                        mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                        require ext_code.size(routerAddress)
                                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = (7 * ceil32(return_data.size)) + 224
                                                        require return_data.size >= 32
                                                        _12809 = mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                        require mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                        _13211 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]
                                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224] <= test266151307()
                                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 32 >= 0
                                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256
                                                        mem[(7 * ceil32(return_data.size)) + 224] = _13211
                                                        require _12809 + (32 * _13211) + 32 <= return_data.size
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + _12809 + 256
                                                        t = (7 * ceil32(return_data.size)) + 256
                                                        while idx < _13211:
                                                            require mem[s] == mem[s]
                                                            mem[t] = mem[s]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[mem[64] + 4] = this.address
                                                        require ext_code.size(rewardTokenAddress)
                                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args address(this.address)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _19269 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_19269] == mem[_19269]
                                                        if sub_0b4b41bc <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require sub_0b4b41bc
                                                        sub_7f94bf16 = mem[_19269] / sub_0b4b41bc
                                                        mem[mem[64] + 4] = treasuryAddress
                                                        mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _21435 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_21435] == bool(mem[_21435])
                                else:
                                    require (block.timestamp * sub_f12c8e0d) - (lastRewardTimestamp * sub_f12c8e0d)
                                    if (block.timestamp * sub_f12c8e0d) - (lastRewardTimestamp * sub_f12c8e0d) / (block.timestamp * sub_f12c8e0d) - (lastRewardTimestamp * sub_f12c8e0d) != 1:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
                                    require ext_code.size(rewardWalletAddress)
                                    call rewardWalletAddress.requestReward(uint256 arg1) with:
                                         gas gas_remaining wei
                                        args ((block.timestamp * sub_f12c8e0d) - (lastRewardTimestamp * sub_f12c8e0d))
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if totalDeposited <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require totalDeposited
                                    if sub_a9ac33dd + (0 / totalDeposited) < sub_a9ac33dd:
                                        revert with 0, 'SafeMath: addition overflow'
                                    sub_a9ac33dd += 0 / totalDeposited
                                    lastRewardTimestamp = block.timestamp
                                    mem[100] = this.address
                                    require ext_code.size(sub_b8ab24bdAddress)
                                    staticcall sub_b8ab24bdAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    if not ext_call.return_data[0] - totalDeposited:
                                        if not ext_call.return_data[0] - totalDeposited:
                                            if not ext_call.return_data[0] - totalDeposited:
                                                sub_bf4c8572 = 0
                                                mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                                mem[ceil32(return_data.size) + 132] = -1
                                                require ext_code.size(sub_b8ab24bdAddress)
                                                call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args lendingPoolAddress, -1
                                                mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                                mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                                mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                                require ext_code.size(lendingPoolAddress)
                                                call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                     gas gas_remaining wei
                                                    args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                                mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == ext_call.return_data[0]
                                                mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                                mem[(4 * ceil32(return_data.size)) + 132] = -1
                                                require ext_code.size(assetAddress)
                                                call assetAddress.approve(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args routerAddress, -1
                                                mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                if assetAddress == WAVAXAddress:
                                                    mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                    mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                    mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                    mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                    mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                    mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                    mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                    idx = 0
                                                    s = (6 * ceil32(return_data.size)) + 128
                                                    t = (6 * ceil32(return_data.size)) + 388
                                                    while idx < 2:
                                                        mem[t] = mem[s + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                    mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (7 * ceil32(return_data.size)) + 192
                                                    require return_data.size >= 32
                                                    _12805 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                    require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                    require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                    _13207 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                    require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                    require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                    mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                    mem[(7 * ceil32(return_data.size)) + 192] = _13207
                                                    require _12805 + (32 * _13207) + 32 <= return_data.size
                                                    idx = 0
                                                    s = (6 * ceil32(return_data.size)) + _12805 + 224
                                                    t = (7 * ceil32(return_data.size)) + 224
                                                    while idx < _13207:
                                                        require mem[s] == mem[s]
                                                        mem[t] = mem[s]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[mem[64] + 4] = this.address
                                                    require ext_code.size(rewardTokenAddress)
                                                    staticcall rewardTokenAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args address(this.address)
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _19265 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_19265] == mem[_19265]
                                                    if sub_0b4b41bc <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require sub_0b4b41bc
                                                    sub_7f94bf16 = mem[_19265] / sub_0b4b41bc
                                                    mem[mem[64] + 4] = treasuryAddress
                                                    mem[mem[64] + 36] = 0
                                                    require ext_code.size(assetAddress)
                                                    call assetAddress.0xa9059cbb with:
                                                         gas gas_remaining wei
                                                        args treasuryAddress, 0
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _21431 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_21431] == bool(mem[_21431])
                                                else:
                                                    if rewardTokenAddress == WAVAXAddress:
                                                        mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                        mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                        mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                        mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                        mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + 128
                                                        t = (6 * ceil32(return_data.size)) + 388
                                                        while idx < 2:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                        mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                        require ext_code.size(routerAddress)
                                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = (7 * ceil32(return_data.size)) + 192
                                                        require return_data.size >= 32
                                                        _12807 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                        require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                        _13209 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                        mem[(7 * ceil32(return_data.size)) + 192] = _13209
                                                        require _12807 + (32 * _13209) + 32 <= return_data.size
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + _12807 + 224
                                                        t = (7 * ceil32(return_data.size)) + 224
                                                        while idx < _13209:
                                                            require mem[s] == mem[s]
                                                            mem[t] = mem[s]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[mem[64] + 4] = this.address
                                                        require ext_code.size(rewardTokenAddress)
                                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args address(this.address)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _19267 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_19267] == mem[_19267]
                                                        if sub_0b4b41bc <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require sub_0b4b41bc
                                                        sub_7f94bf16 = mem[_19267] / sub_0b4b41bc
                                                        mem[mem[64] + 4] = treasuryAddress
                                                        mem[mem[64] + 36] = 0
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args treasuryAddress, 0
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _21433 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_21433] == bool(mem[_21433])
                                                    else:
                                                        mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                        mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                        mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                        mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                        mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + 128
                                                        t = (6 * ceil32(return_data.size)) + 420
                                                        while idx < 3:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                        mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                        require ext_code.size(routerAddress)
                                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args 0, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = (7 * ceil32(return_data.size)) + 224
                                                        require return_data.size >= 32
                                                        _12806 = mem[(6 * ceil32(return_data.size)) + 224 len 4], 0
                                                        require mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 <= test266151307()
                                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                        _13208 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]
                                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224] <= test266151307()
                                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 32 >= 0
                                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256
                                                        mem[(7 * ceil32(return_data.size)) + 224] = _13208
                                                        require _12806 + (32 * _13208) + 32 <= return_data.size
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + _12806 + 256
                                                        t = (7 * ceil32(return_data.size)) + 256
                                                        while idx < _13208:
                                                            require mem[s] == mem[s]
                                                            mem[t] = mem[s]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[mem[64] + 4] = this.address
                                                        require ext_code.size(rewardTokenAddress)
                                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args address(this.address)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _19266 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_19266] == mem[_19266]
                                                        if sub_0b4b41bc <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require sub_0b4b41bc
                                                        sub_7f94bf16 = mem[_19266] / sub_0b4b41bc
                                                        mem[mem[64] + 4] = treasuryAddress
                                                        mem[mem[64] + 36] = 0
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args treasuryAddress, 0
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _21432 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_21432] == bool(mem[_21432])
                                            else:
                                                require ext_call.return_data[0] - totalDeposited
                                                if (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / ext_call.return_data[0] - totalDeposited != sub_7e72b29f:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                sub_bf4c8572 = (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / 10000
                                                mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                                mem[ceil32(return_data.size) + 132] = -1
                                                require ext_code.size(sub_b8ab24bdAddress)
                                                call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args lendingPoolAddress, -1
                                                mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                                mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                                mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                                require ext_code.size(lendingPoolAddress)
                                                call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                     gas gas_remaining wei
                                                    args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                                mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == ext_call.return_data[0]
                                                mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                                mem[(4 * ceil32(return_data.size)) + 132] = -1
                                                require ext_code.size(assetAddress)
                                                call assetAddress.approve(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args routerAddress, -1
                                                mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                if assetAddress == WAVAXAddress:
                                                    mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                    mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                    mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                    mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                    mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                    mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                    mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                    idx = 0
                                                    s = (6 * ceil32(return_data.size)) + 128
                                                    t = (6 * ceil32(return_data.size)) + 388
                                                    while idx < 2:
                                                        mem[t] = mem[s + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                    mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (7 * ceil32(return_data.size)) + 192
                                                    require return_data.size >= 32
                                                    _12802 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                    require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                    require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                    _13204 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                    require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                    require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                    mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                    mem[(7 * ceil32(return_data.size)) + 192] = _13204
                                                    require _12802 + (32 * _13204) + 32 <= return_data.size
                                                    idx = 0
                                                    s = (6 * ceil32(return_data.size)) + _12802 + 224
                                                    t = (7 * ceil32(return_data.size)) + 224
                                                    while idx < _13204:
                                                        require mem[s] == mem[s]
                                                        mem[t] = mem[s]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[mem[64] + 4] = this.address
                                                    require ext_code.size(rewardTokenAddress)
                                                    staticcall rewardTokenAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args address(this.address)
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _19262 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_19262] == mem[_19262]
                                                    if sub_0b4b41bc <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require sub_0b4b41bc
                                                    sub_7f94bf16 = mem[_19262] / sub_0b4b41bc
                                                    mem[mem[64] + 4] = treasuryAddress
                                                    mem[mem[64] + 36] = 0
                                                    require ext_code.size(assetAddress)
                                                    call assetAddress.0xa9059cbb with:
                                                         gas gas_remaining wei
                                                        args treasuryAddress, 0
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _21428 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_21428] == bool(mem[_21428])
                                                else:
                                                    if rewardTokenAddress == WAVAXAddress:
                                                        mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                        mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                        mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                        mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                        mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + 128
                                                        t = (6 * ceil32(return_data.size)) + 388
                                                        while idx < 2:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                        mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                        require ext_code.size(routerAddress)
                                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = (7 * ceil32(return_data.size)) + 192
                                                        require return_data.size >= 32
                                                        _12804 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                        require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                        _13206 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                        mem[(7 * ceil32(return_data.size)) + 192] = _13206
                                                        require _12804 + (32 * _13206) + 32 <= return_data.size
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + _12804 + 224
                                                        t = (7 * ceil32(return_data.size)) + 224
                                                        while idx < _13206:
                                                            require mem[s] == mem[s]
                                                            mem[t] = mem[s]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[mem[64] + 4] = this.address
                                                        require ext_code.size(rewardTokenAddress)
                                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args address(this.address)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _19264 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_19264] == mem[_19264]
                                                        if sub_0b4b41bc <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require sub_0b4b41bc
                                                        sub_7f94bf16 = mem[_19264] / sub_0b4b41bc
                                                        mem[mem[64] + 4] = treasuryAddress
                                                        mem[mem[64] + 36] = 0
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args treasuryAddress, 0
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _21430 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_21430] == bool(mem[_21430])
                                                    else:
                                                        mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                        mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                        mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                        mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                        mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + 128
                                                        t = (6 * ceil32(return_data.size)) + 420
                                                        while idx < 3:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                        mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                        require ext_code.size(routerAddress)
                                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args 0, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = (7 * ceil32(return_data.size)) + 224
                                                        require return_data.size >= 32
                                                        _12803 = mem[(6 * ceil32(return_data.size)) + 224 len 4], 0
                                                        require mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 <= test266151307()
                                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                        _13205 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]
                                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224] <= test266151307()
                                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 32 >= 0
                                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256
                                                        mem[(7 * ceil32(return_data.size)) + 224] = _13205
                                                        require _12803 + (32 * _13205) + 32 <= return_data.size
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + _12803 + 256
                                                        t = (7 * ceil32(return_data.size)) + 256
                                                        while idx < _13205:
                                                            require mem[s] == mem[s]
                                                            mem[t] = mem[s]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[mem[64] + 4] = this.address
                                                        require ext_code.size(rewardTokenAddress)
                                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args address(this.address)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _19263 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_19263] == mem[_19263]
                                                        if sub_0b4b41bc <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require sub_0b4b41bc
                                                        sub_7f94bf16 = mem[_19263] / sub_0b4b41bc
                                                        mem[mem[64] + 4] = treasuryAddress
                                                        mem[mem[64] + 36] = 0
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args treasuryAddress, 0
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _21429 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_21429] == bool(mem[_21429])
                                        else:
                                            require ext_call.return_data[0] - totalDeposited
                                            if (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / ext_call.return_data[0] - totalDeposited != sub_2f6236be:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not ext_call.return_data[0] - totalDeposited:
                                                sub_bf4c8572 = 0
                                                mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                                mem[ceil32(return_data.size) + 132] = -1
                                                require ext_code.size(sub_b8ab24bdAddress)
                                                call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args lendingPoolAddress, -1
                                                mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                                mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                                mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                                require ext_code.size(lendingPoolAddress)
                                                call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                     gas gas_remaining wei
                                                    args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                                mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == ext_call.return_data[0]
                                                mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                                mem[(4 * ceil32(return_data.size)) + 132] = -1
                                                require ext_code.size(assetAddress)
                                                call assetAddress.approve(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args routerAddress, -1
                                                mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                if assetAddress == WAVAXAddress:
                                                    mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                    mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                    mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                    mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                    mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                    mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                    mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                    idx = 0
                                                    s = (6 * ceil32(return_data.size)) + 128
                                                    t = (6 * ceil32(return_data.size)) + 388
                                                    while idx < 2:
                                                        mem[t] = mem[s + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                    mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (7 * ceil32(return_data.size)) + 192
                                                    require return_data.size >= 32
                                                    _12799 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                    require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                    require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                    _13201 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                    require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                    require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                    mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                    mem[(7 * ceil32(return_data.size)) + 192] = _13201
                                                    require _12799 + (32 * _13201) + 32 <= return_data.size
                                                    idx = 0
                                                    s = (6 * ceil32(return_data.size)) + _12799 + 224
                                                    t = (7 * ceil32(return_data.size)) + 224
                                                    while idx < _13201:
                                                        require mem[s] == mem[s]
                                                        mem[t] = mem[s]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[mem[64] + 4] = this.address
                                                    require ext_code.size(rewardTokenAddress)
                                                    staticcall rewardTokenAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args address(this.address)
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _19259 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_19259] == mem[_19259]
                                                    if sub_0b4b41bc <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require sub_0b4b41bc
                                                    sub_7f94bf16 = mem[_19259] / sub_0b4b41bc
                                                    mem[mem[64] + 4] = treasuryAddress
                                                    mem[mem[64] + 36] = 0
                                                    require ext_code.size(assetAddress)
                                                    call assetAddress.0xa9059cbb with:
                                                         gas gas_remaining wei
                                                        args treasuryAddress, 0
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _21425 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_21425] == bool(mem[_21425])
                                                else:
                                                    if rewardTokenAddress == WAVAXAddress:
                                                        mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                        mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                        mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                        mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                        mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + 128
                                                        t = (6 * ceil32(return_data.size)) + 388
                                                        while idx < 2:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                        mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                        require ext_code.size(routerAddress)
                                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = (7 * ceil32(return_data.size)) + 192
                                                        require return_data.size >= 32
                                                        _12801 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                        require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                        _13203 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                        mem[(7 * ceil32(return_data.size)) + 192] = _13203
                                                        require _12801 + (32 * _13203) + 32 <= return_data.size
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + _12801 + 224
                                                        t = (7 * ceil32(return_data.size)) + 224
                                                        while idx < _13203:
                                                            require mem[s] == mem[s]
                                                            mem[t] = mem[s]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[mem[64] + 4] = this.address
                                                        require ext_code.size(rewardTokenAddress)
                                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args address(this.address)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _19261 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_19261] == mem[_19261]
                                                        if sub_0b4b41bc <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require sub_0b4b41bc
                                                        sub_7f94bf16 = mem[_19261] / sub_0b4b41bc
                                                        mem[mem[64] + 4] = treasuryAddress
                                                        mem[mem[64] + 36] = 0
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args treasuryAddress, 0
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _21427 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_21427] == bool(mem[_21427])
                                                    else:
                                                        mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                        mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                        mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                        mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                        mem[(6 * ceil32(return_data.size)) + 228] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                        mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                        mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + 128
                                                        t = (6 * ceil32(return_data.size)) + 420
                                                        while idx < 3:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                        mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                        require ext_code.size(routerAddress)
                                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = (7 * ceil32(return_data.size)) + 224
                                                        require return_data.size >= 32
                                                        _12800 = mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                        require mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                        _13202 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]
                                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224] <= test266151307()
                                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 32 >= 0
                                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256
                                                        mem[(7 * ceil32(return_data.size)) + 224] = _13202
                                                        require _12800 + (32 * _13202) + 32 <= return_data.size
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + _12800 + 256
                                                        t = (7 * ceil32(return_data.size)) + 256
                                                        while idx < _13202:
                                                            require mem[s] == mem[s]
                                                            mem[t] = mem[s]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[mem[64] + 4] = this.address
                                                        require ext_code.size(rewardTokenAddress)
                                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args address(this.address)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _19260 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_19260] == mem[_19260]
                                                        if sub_0b4b41bc <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require sub_0b4b41bc
                                                        sub_7f94bf16 = mem[_19260] / sub_0b4b41bc
                                                        mem[mem[64] + 4] = treasuryAddress
                                                        mem[mem[64] + 36] = 0
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args treasuryAddress, 0
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _21426 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_21426] == bool(mem[_21426])
                                            else:
                                                require ext_call.return_data[0] - totalDeposited
                                                if (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / ext_call.return_data[0] - totalDeposited != sub_7e72b29f:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                sub_bf4c8572 = (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / 10000
                                                mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                                mem[ceil32(return_data.size) + 132] = -1
                                                require ext_code.size(sub_b8ab24bdAddress)
                                                call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args lendingPoolAddress, -1
                                                mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                                mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                                mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                                require ext_code.size(lendingPoolAddress)
                                                call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                     gas gas_remaining wei
                                                    args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                                mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == ext_call.return_data[0]
                                                mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                                mem[(4 * ceil32(return_data.size)) + 132] = -1
                                                require ext_code.size(assetAddress)
                                                call assetAddress.approve(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args routerAddress, -1
                                                mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                if assetAddress == WAVAXAddress:
                                                    mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                    mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                    mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                    mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                    mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                    mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                    mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                    idx = 0
                                                    s = (6 * ceil32(return_data.size)) + 128
                                                    t = (6 * ceil32(return_data.size)) + 388
                                                    while idx < 2:
                                                        mem[t] = mem[s + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                    mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (7 * ceil32(return_data.size)) + 192
                                                    require return_data.size >= 32
                                                    _12796 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                    require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                    require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                    _13198 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                    require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                    require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                    mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                    mem[(7 * ceil32(return_data.size)) + 192] = _13198
                                                    require _12796 + (32 * _13198) + 32 <= return_data.size
                                                    idx = 0
                                                    s = (6 * ceil32(return_data.size)) + _12796 + 224
                                                    t = (7 * ceil32(return_data.size)) + 224
                                                    while idx < _13198:
                                                        require mem[s] == mem[s]
                                                        mem[t] = mem[s]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[mem[64] + 4] = this.address
                                                    require ext_code.size(rewardTokenAddress)
                                                    staticcall rewardTokenAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args address(this.address)
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _19256 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_19256] == mem[_19256]
                                                    if sub_0b4b41bc <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require sub_0b4b41bc
                                                    sub_7f94bf16 = mem[_19256] / sub_0b4b41bc
                                                    mem[mem[64] + 4] = treasuryAddress
                                                    mem[mem[64] + 36] = 0
                                                    require ext_code.size(assetAddress)
                                                    call assetAddress.0xa9059cbb with:
                                                         gas gas_remaining wei
                                                        args treasuryAddress, 0
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _21422 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_21422] == bool(mem[_21422])
                                                else:
                                                    if rewardTokenAddress == WAVAXAddress:
                                                        mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                        mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                        mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                        mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                        mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + 128
                                                        t = (6 * ceil32(return_data.size)) + 388
                                                        while idx < 2:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                        mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                        require ext_code.size(routerAddress)
                                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = (7 * ceil32(return_data.size)) + 192
                                                        require return_data.size >= 32
                                                        _12798 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                        require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                        _13200 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                        mem[(7 * ceil32(return_data.size)) + 192] = _13200
                                                        require _12798 + (32 * _13200) + 32 <= return_data.size
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + _12798 + 224
                                                        t = (7 * ceil32(return_data.size)) + 224
                                                        while idx < _13200:
                                                            require mem[s] == mem[s]
                                                            mem[t] = mem[s]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[mem[64] + 4] = this.address
                                                        require ext_code.size(rewardTokenAddress)
                                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args address(this.address)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _19258 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_19258] == mem[_19258]
                                                        if sub_0b4b41bc <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require sub_0b4b41bc
                                                        sub_7f94bf16 = mem[_19258] / sub_0b4b41bc
                                                        mem[mem[64] + 4] = treasuryAddress
                                                        mem[mem[64] + 36] = 0
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args treasuryAddress, 0
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _21424 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_21424] == bool(mem[_21424])
                                                    else:
                                                        mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                        mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                        mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                        mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                        mem[(6 * ceil32(return_data.size)) + 228] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                        mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                        mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + 128
                                                        t = (6 * ceil32(return_data.size)) + 420
                                                        while idx < 3:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                        mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                        require ext_code.size(routerAddress)
                                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = (7 * ceil32(return_data.size)) + 224
                                                        require return_data.size >= 32
                                                        _12797 = mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                        require mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                        _13199 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]
                                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224] <= test266151307()
                                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 32 >= 0
                                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256
                                                        mem[(7 * ceil32(return_data.size)) + 224] = _13199
                                                        require _12797 + (32 * _13199) + 32 <= return_data.size
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + _12797 + 256
                                                        t = (7 * ceil32(return_data.size)) + 256
                                                        while idx < _13199:
                                                            require mem[s] == mem[s]
                                                            mem[t] = mem[s]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[mem[64] + 4] = this.address
                                                        require ext_code.size(rewardTokenAddress)
                                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args address(this.address)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _19257 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_19257] == mem[_19257]
                                                        if sub_0b4b41bc <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require sub_0b4b41bc
                                                        sub_7f94bf16 = mem[_19257] / sub_0b4b41bc
                                                        mem[mem[64] + 4] = treasuryAddress
                                                        mem[mem[64] + 36] = 0
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args treasuryAddress, 0
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _21423 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_21423] == bool(mem[_21423])
                                    else:
                                        require ext_call.return_data[0] - totalDeposited
                                        if (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / ext_call.return_data[0] - totalDeposited != sub_7796ff37:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not ext_call.return_data[0] - totalDeposited:
                                            if not ext_call.return_data[0] - totalDeposited:
                                                sub_bf4c8572 = 0
                                                mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                                mem[ceil32(return_data.size) + 132] = -1
                                                require ext_code.size(sub_b8ab24bdAddress)
                                                call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args lendingPoolAddress, -1
                                                mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                                mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                                mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                                require ext_code.size(lendingPoolAddress)
                                                call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                     gas gas_remaining wei
                                                    args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                                mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == ext_call.return_data[0]
                                                mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                                mem[(4 * ceil32(return_data.size)) + 132] = -1
                                                require ext_code.size(assetAddress)
                                                call assetAddress.approve(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args routerAddress, -1
                                                mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                if assetAddress == WAVAXAddress:
                                                    mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                    mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                    mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                    mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                    mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                    mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                    mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                    idx = 0
                                                    s = (6 * ceil32(return_data.size)) + 128
                                                    t = (6 * ceil32(return_data.size)) + 388
                                                    while idx < 2:
                                                        mem[t] = mem[s + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                    mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (7 * ceil32(return_data.size)) + 192
                                                    require return_data.size >= 32
                                                    _12793 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                    require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                    require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                    _13195 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                    require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                    require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                    mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                    mem[(7 * ceil32(return_data.size)) + 192] = _13195
                                                    require _12793 + (32 * _13195) + 32 <= return_data.size
                                                    idx = 0
                                                    s = (6 * ceil32(return_data.size)) + _12793 + 224
                                                    t = (7 * ceil32(return_data.size)) + 224
                                                    while idx < _13195:
                                                        require mem[s] == mem[s]
                                                        mem[t] = mem[s]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[mem[64] + 4] = this.address
                                                    require ext_code.size(rewardTokenAddress)
                                                    staticcall rewardTokenAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args address(this.address)
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _19253 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_19253] == mem[_19253]
                                                    if sub_0b4b41bc <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require sub_0b4b41bc
                                                    sub_7f94bf16 = mem[_19253] / sub_0b4b41bc
                                                    mem[mem[64] + 4] = treasuryAddress
                                                    mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                    require ext_code.size(assetAddress)
                                                    call assetAddress.0xa9059cbb with:
                                                         gas gas_remaining wei
                                                        args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _21419 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_21419] == bool(mem[_21419])
                                                else:
                                                    if rewardTokenAddress == WAVAXAddress:
                                                        mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                        mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                        mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                        mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                        mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + 128
                                                        t = (6 * ceil32(return_data.size)) + 388
                                                        while idx < 2:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                        mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                        require ext_code.size(routerAddress)
                                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = (7 * ceil32(return_data.size)) + 192
                                                        require return_data.size >= 32
                                                        _12795 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                        require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                        _13197 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                        mem[(7 * ceil32(return_data.size)) + 192] = _13197
                                                        require _12795 + (32 * _13197) + 32 <= return_data.size
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + _12795 + 224
                                                        t = (7 * ceil32(return_data.size)) + 224
                                                        while idx < _13197:
                                                            require mem[s] == mem[s]
                                                            mem[t] = mem[s]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[mem[64] + 4] = this.address
                                                        require ext_code.size(rewardTokenAddress)
                                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args address(this.address)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _19255 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_19255] == mem[_19255]
                                                        if sub_0b4b41bc <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require sub_0b4b41bc
                                                        sub_7f94bf16 = mem[_19255] / sub_0b4b41bc
                                                        mem[mem[64] + 4] = treasuryAddress
                                                        mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _21421 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_21421] == bool(mem[_21421])
                                                    else:
                                                        mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                        mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                        mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                        mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                        mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + 128
                                                        t = (6 * ceil32(return_data.size)) + 420
                                                        while idx < 3:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                        mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                        require ext_code.size(routerAddress)
                                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args 0, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = (7 * ceil32(return_data.size)) + 224
                                                        require return_data.size >= 32
                                                        _12794 = mem[(6 * ceil32(return_data.size)) + 224 len 4], 0
                                                        require mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 <= test266151307()
                                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                        _13196 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]
                                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224] <= test266151307()
                                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 32 >= 0
                                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256
                                                        mem[(7 * ceil32(return_data.size)) + 224] = _13196
                                                        require _12794 + (32 * _13196) + 32 <= return_data.size
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + _12794 + 256
                                                        t = (7 * ceil32(return_data.size)) + 256
                                                        while idx < _13196:
                                                            require mem[s] == mem[s]
                                                            mem[t] = mem[s]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[mem[64] + 4] = this.address
                                                        require ext_code.size(rewardTokenAddress)
                                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args address(this.address)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _19254 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_19254] == mem[_19254]
                                                        if sub_0b4b41bc <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require sub_0b4b41bc
                                                        sub_7f94bf16 = mem[_19254] / sub_0b4b41bc
                                                        mem[mem[64] + 4] = treasuryAddress
                                                        mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _21420 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_21420] == bool(mem[_21420])
                                            else:
                                                require ext_call.return_data[0] - totalDeposited
                                                if (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / ext_call.return_data[0] - totalDeposited != sub_7e72b29f:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                sub_bf4c8572 = (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / 10000
                                                mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                                mem[ceil32(return_data.size) + 132] = -1
                                                require ext_code.size(sub_b8ab24bdAddress)
                                                call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args lendingPoolAddress, -1
                                                mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                                mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                                mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                                require ext_code.size(lendingPoolAddress)
                                                call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                     gas gas_remaining wei
                                                    args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                                mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == ext_call.return_data[0]
                                                mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                                mem[(4 * ceil32(return_data.size)) + 132] = -1
                                                require ext_code.size(assetAddress)
                                                call assetAddress.approve(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args routerAddress, -1
                                                mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                if assetAddress == WAVAXAddress:
                                                    mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                    mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                    mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                    mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                    mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                    mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                    mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                    idx = 0
                                                    s = (6 * ceil32(return_data.size)) + 128
                                                    t = (6 * ceil32(return_data.size)) + 388
                                                    while idx < 2:
                                                        mem[t] = mem[s + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                    mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (7 * ceil32(return_data.size)) + 192
                                                    require return_data.size >= 32
                                                    _12790 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                    require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                    require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                    _13192 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                    require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                    require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                    mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                    mem[(7 * ceil32(return_data.size)) + 192] = _13192
                                                    require _12790 + (32 * _13192) + 32 <= return_data.size
                                                    idx = 0
                                                    s = (6 * ceil32(return_data.size)) + _12790 + 224
                                                    t = (7 * ceil32(return_data.size)) + 224
                                                    while idx < _13192:
                                                        require mem[s] == mem[s]
                                                        mem[t] = mem[s]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[mem[64] + 4] = this.address
                                                    require ext_code.size(rewardTokenAddress)
                                                    staticcall rewardTokenAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args address(this.address)
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _19250 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_19250] == mem[_19250]
                                                    if sub_0b4b41bc <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require sub_0b4b41bc
                                                    sub_7f94bf16 = mem[_19250] / sub_0b4b41bc
                                                    mem[mem[64] + 4] = treasuryAddress
                                                    mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                    require ext_code.size(assetAddress)
                                                    call assetAddress.0xa9059cbb with:
                                                         gas gas_remaining wei
                                                        args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _21416 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_21416] == bool(mem[_21416])
                                                else:
                                                    if rewardTokenAddress == WAVAXAddress:
                                                        mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                        mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                        mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                        mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                        mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + 128
                                                        t = (6 * ceil32(return_data.size)) + 388
                                                        while idx < 2:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                        mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                        require ext_code.size(routerAddress)
                                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = (7 * ceil32(return_data.size)) + 192
                                                        require return_data.size >= 32
                                                        _12792 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                        require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                        _13194 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                        mem[(7 * ceil32(return_data.size)) + 192] = _13194
                                                        require _12792 + (32 * _13194) + 32 <= return_data.size
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + _12792 + 224
                                                        t = (7 * ceil32(return_data.size)) + 224
                                                        while idx < _13194:
                                                            require mem[s] == mem[s]
                                                            mem[t] = mem[s]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[mem[64] + 4] = this.address
                                                        require ext_code.size(rewardTokenAddress)
                                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args address(this.address)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _19252 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_19252] == mem[_19252]
                                                        if sub_0b4b41bc <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require sub_0b4b41bc
                                                        sub_7f94bf16 = mem[_19252] / sub_0b4b41bc
                                                        mem[mem[64] + 4] = treasuryAddress
                                                        mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _21418 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_21418] == bool(mem[_21418])
                                                    else:
                                                        mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                        mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                        mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                        mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                        mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + 128
                                                        t = (6 * ceil32(return_data.size)) + 420
                                                        while idx < 3:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                        mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                        require ext_code.size(routerAddress)
                                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args 0, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = (7 * ceil32(return_data.size)) + 224
                                                        require return_data.size >= 32
                                                        _12791 = mem[(6 * ceil32(return_data.size)) + 224 len 4], 0
                                                        require mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 <= test266151307()
                                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                        _13193 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]
                                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224] <= test266151307()
                                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 32 >= 0
                                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256
                                                        mem[(7 * ceil32(return_data.size)) + 224] = _13193
                                                        require _12791 + (32 * _13193) + 32 <= return_data.size
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + _12791 + 256
                                                        t = (7 * ceil32(return_data.size)) + 256
                                                        while idx < _13193:
                                                            require mem[s] == mem[s]
                                                            mem[t] = mem[s]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[mem[64] + 4] = this.address
                                                        require ext_code.size(rewardTokenAddress)
                                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args address(this.address)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _19251 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_19251] == mem[_19251]
                                                        if sub_0b4b41bc <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require sub_0b4b41bc
                                                        sub_7f94bf16 = mem[_19251] / sub_0b4b41bc
                                                        mem[mem[64] + 4] = treasuryAddress
                                                        mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _21417 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_21417] == bool(mem[_21417])
                                        else:
                                            require ext_call.return_data[0] - totalDeposited
                                            if (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / ext_call.return_data[0] - totalDeposited != sub_2f6236be:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not ext_call.return_data[0] - totalDeposited:
                                                sub_bf4c8572 = 0
                                                mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                                mem[ceil32(return_data.size) + 132] = -1
                                                require ext_code.size(sub_b8ab24bdAddress)
                                                call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args lendingPoolAddress, -1
                                                mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                                mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                                mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                                require ext_code.size(lendingPoolAddress)
                                                call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                     gas gas_remaining wei
                                                    args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                                mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == ext_call.return_data[0]
                                                mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                                mem[(4 * ceil32(return_data.size)) + 132] = -1
                                                require ext_code.size(assetAddress)
                                                call assetAddress.approve(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args routerAddress, -1
                                                mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                if assetAddress == WAVAXAddress:
                                                    mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                    mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                    mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                    mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                    mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                    mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                    mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                    idx = 0
                                                    s = (6 * ceil32(return_data.size)) + 128
                                                    t = (6 * ceil32(return_data.size)) + 388
                                                    while idx < 2:
                                                        mem[t] = mem[s + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                    mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (7 * ceil32(return_data.size)) + 192
                                                    require return_data.size >= 32
                                                    _12787 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                    require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                    require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                    _13189 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                    require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                    require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                    mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                    mem[(7 * ceil32(return_data.size)) + 192] = _13189
                                                    require _12787 + (32 * _13189) + 32 <= return_data.size
                                                    idx = 0
                                                    s = (6 * ceil32(return_data.size)) + _12787 + 224
                                                    t = (7 * ceil32(return_data.size)) + 224
                                                    while idx < _13189:
                                                        require mem[s] == mem[s]
                                                        mem[t] = mem[s]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[mem[64] + 4] = this.address
                                                    require ext_code.size(rewardTokenAddress)
                                                    staticcall rewardTokenAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args address(this.address)
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _19247 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_19247] == mem[_19247]
                                                    if sub_0b4b41bc <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require sub_0b4b41bc
                                                    sub_7f94bf16 = mem[_19247] / sub_0b4b41bc
                                                    mem[mem[64] + 4] = treasuryAddress
                                                    mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                    require ext_code.size(assetAddress)
                                                    call assetAddress.0xa9059cbb with:
                                                         gas gas_remaining wei
                                                        args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _21413 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_21413] == bool(mem[_21413])
                                                else:
                                                    if rewardTokenAddress == WAVAXAddress:
                                                        mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                        mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                        mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                        mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                        mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + 128
                                                        t = (6 * ceil32(return_data.size)) + 388
                                                        while idx < 2:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                        mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                        require ext_code.size(routerAddress)
                                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = (7 * ceil32(return_data.size)) + 192
                                                        require return_data.size >= 32
                                                        _12789 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                        require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                        _13191 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                        mem[(7 * ceil32(return_data.size)) + 192] = _13191
                                                        require _12789 + (32 * _13191) + 32 <= return_data.size
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + _12789 + 224
                                                        t = (7 * ceil32(return_data.size)) + 224
                                                        while idx < _13191:
                                                            require mem[s] == mem[s]
                                                            mem[t] = mem[s]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[mem[64] + 4] = this.address
                                                        require ext_code.size(rewardTokenAddress)
                                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args address(this.address)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _19249 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_19249] == mem[_19249]
                                                        if sub_0b4b41bc <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require sub_0b4b41bc
                                                        sub_7f94bf16 = mem[_19249] / sub_0b4b41bc
                                                        mem[mem[64] + 4] = treasuryAddress
                                                        mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _21415 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_21415] == bool(mem[_21415])
                                                    else:
                                                        mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                        mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                        mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                        mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                        mem[(6 * ceil32(return_data.size)) + 228] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                        mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                        mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + 128
                                                        t = (6 * ceil32(return_data.size)) + 420
                                                        while idx < 3:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                        mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                        require ext_code.size(routerAddress)
                                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = (7 * ceil32(return_data.size)) + 224
                                                        require return_data.size >= 32
                                                        _12788 = mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                        require mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                        _13190 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]
                                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224] <= test266151307()
                                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 32 >= 0
                                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256
                                                        mem[(7 * ceil32(return_data.size)) + 224] = _13190
                                                        require _12788 + (32 * _13190) + 32 <= return_data.size
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + _12788 + 256
                                                        t = (7 * ceil32(return_data.size)) + 256
                                                        while idx < _13190:
                                                            require mem[s] == mem[s]
                                                            mem[t] = mem[s]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[mem[64] + 4] = this.address
                                                        require ext_code.size(rewardTokenAddress)
                                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args address(this.address)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _19248 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_19248] == mem[_19248]
                                                        if sub_0b4b41bc <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require sub_0b4b41bc
                                                        sub_7f94bf16 = mem[_19248] / sub_0b4b41bc
                                                        mem[mem[64] + 4] = treasuryAddress
                                                        mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _21414 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_21414] == bool(mem[_21414])
                                            else:
                                                require ext_call.return_data[0] - totalDeposited
                                                if (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / ext_call.return_data[0] - totalDeposited != sub_7e72b29f:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                sub_bf4c8572 = (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / 10000
                                                mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                                mem[ceil32(return_data.size) + 132] = -1
                                                require ext_code.size(sub_b8ab24bdAddress)
                                                call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args lendingPoolAddress, -1
                                                mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                                mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                                mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                                require ext_code.size(lendingPoolAddress)
                                                call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                     gas gas_remaining wei
                                                    args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                                mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == ext_call.return_data[0]
                                                mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                                mem[(4 * ceil32(return_data.size)) + 132] = -1
                                                require ext_code.size(assetAddress)
                                                call assetAddress.approve(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args routerAddress, -1
                                                mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                if assetAddress == WAVAXAddress:
                                                    mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                    mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                    mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                    mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                    mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                    mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                    mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                    idx = 0
                                                    s = (6 * ceil32(return_data.size)) + 128
                                                    t = (6 * ceil32(return_data.size)) + 388
                                                    while idx < 2:
                                                        mem[t] = mem[s + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                    mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (7 * ceil32(return_data.size)) + 192
                                                    require return_data.size >= 32
                                                    _12784 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                    require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                    require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                    _13186 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                    require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                    require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                    mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                    mem[(7 * ceil32(return_data.size)) + 192] = _13186
                                                    require _12784 + (32 * _13186) + 32 <= return_data.size
                                                    idx = 0
                                                    s = (6 * ceil32(return_data.size)) + _12784 + 224
                                                    t = (7 * ceil32(return_data.size)) + 224
                                                    while idx < _13186:
                                                        require mem[s] == mem[s]
                                                        mem[t] = mem[s]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[mem[64] + 4] = this.address
                                                    require ext_code.size(rewardTokenAddress)
                                                    staticcall rewardTokenAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args address(this.address)
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _19244 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_19244] == mem[_19244]
                                                    if sub_0b4b41bc <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require sub_0b4b41bc
                                                    sub_7f94bf16 = mem[_19244] / sub_0b4b41bc
                                                    mem[mem[64] + 4] = treasuryAddress
                                                    mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                    require ext_code.size(assetAddress)
                                                    call assetAddress.0xa9059cbb with:
                                                         gas gas_remaining wei
                                                        args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _21410 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_21410] == bool(mem[_21410])
                                                else:
                                                    if rewardTokenAddress == WAVAXAddress:
                                                        mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                        mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                        mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                        mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                        mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + 128
                                                        t = (6 * ceil32(return_data.size)) + 388
                                                        while idx < 2:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                        mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                        require ext_code.size(routerAddress)
                                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = (7 * ceil32(return_data.size)) + 192
                                                        require return_data.size >= 32
                                                        _12786 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                        require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                        _13188 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                        mem[(7 * ceil32(return_data.size)) + 192] = _13188
                                                        require _12786 + (32 * _13188) + 32 <= return_data.size
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + _12786 + 224
                                                        t = (7 * ceil32(return_data.size)) + 224
                                                        while idx < _13188:
                                                            require mem[s] == mem[s]
                                                            mem[t] = mem[s]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[mem[64] + 4] = this.address
                                                        require ext_code.size(rewardTokenAddress)
                                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args address(this.address)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _19246 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_19246] == mem[_19246]
                                                        if sub_0b4b41bc <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require sub_0b4b41bc
                                                        sub_7f94bf16 = mem[_19246] / sub_0b4b41bc
                                                        mem[mem[64] + 4] = treasuryAddress
                                                        mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _21412 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_21412] == bool(mem[_21412])
                                                    else:
                                                        mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                        mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                        mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                        mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                        mem[(6 * ceil32(return_data.size)) + 228] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                        mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                        mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + 128
                                                        t = (6 * ceil32(return_data.size)) + 420
                                                        while idx < 3:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                        mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                        require ext_code.size(routerAddress)
                                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = (7 * ceil32(return_data.size)) + 224
                                                        require return_data.size >= 32
                                                        _12785 = mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                        require mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                        _13187 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]
                                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224] <= test266151307()
                                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 32 >= 0
                                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256
                                                        mem[(7 * ceil32(return_data.size)) + 224] = _13187
                                                        require _12785 + (32 * _13187) + 32 <= return_data.size
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + _12785 + 256
                                                        t = (7 * ceil32(return_data.size)) + 256
                                                        while idx < _13187:
                                                            require mem[s] == mem[s]
                                                            mem[t] = mem[s]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[mem[64] + 4] = this.address
                                                        require ext_code.size(rewardTokenAddress)
                                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args address(this.address)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _19245 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_19245] == mem[_19245]
                                                        if sub_0b4b41bc <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require sub_0b4b41bc
                                                        sub_7f94bf16 = mem[_19245] / sub_0b4b41bc
                                                        mem[mem[64] + 4] = treasuryAddress
                                                        mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _21411 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_21411] == bool(mem[_21411])
                        else:
                            require block.timestamp - lastRewardTimestamp
                            if (sub_f12c8e0d * block.timestamp) + (sub_7f94bf16 * block.timestamp) - (sub_f12c8e0d * lastRewardTimestamp) - (sub_7f94bf16 * lastRewardTimestamp) / block.timestamp - lastRewardTimestamp != sub_f12c8e0d + sub_7f94bf16:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
                            if not (sub_f12c8e0d * block.timestamp) + (sub_7f94bf16 * block.timestamp) - (sub_f12c8e0d * lastRewardTimestamp) - (sub_7f94bf16 * lastRewardTimestamp):
                                if not block.timestamp - lastRewardTimestamp:
                                    require ext_code.size(rewardWalletAddress)
                                    call rewardWalletAddress.requestReward(uint256 arg1) with:
                                         gas gas_remaining wei
                                        args 0
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if totalDeposited <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require totalDeposited
                                    if sub_a9ac33dd + (0 / totalDeposited) < sub_a9ac33dd:
                                        revert with 0, 'SafeMath: addition overflow'
                                    sub_a9ac33dd += 0 / totalDeposited
                                    lastRewardTimestamp = block.timestamp
                                    mem[100] = this.address
                                    require ext_code.size(sub_b8ab24bdAddress)
                                    staticcall sub_b8ab24bdAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    if not ext_call.return_data[0] - totalDeposited:
                                        if not ext_call.return_data[0] - totalDeposited:
                                            if not ext_call.return_data[0] - totalDeposited:
                                                sub_bf4c8572 = 0
                                                mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                                mem[ceil32(return_data.size) + 132] = -1
                                                require ext_code.size(sub_b8ab24bdAddress)
                                                call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args lendingPoolAddress, -1
                                                mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                                mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                                mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                                require ext_code.size(lendingPoolAddress)
                                                call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                     gas gas_remaining wei
                                                    args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                                mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == ext_call.return_data[0]
                                                mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                                mem[(4 * ceil32(return_data.size)) + 132] = -1
                                                require ext_code.size(assetAddress)
                                                call assetAddress.approve(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args routerAddress, -1
                                                mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                if assetAddress == WAVAXAddress:
                                                    mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                    mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                    mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                    mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                    mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                    mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                    mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                    idx = 0
                                                    s = (6 * ceil32(return_data.size)) + 128
                                                    t = (6 * ceil32(return_data.size)) + 388
                                                    while idx < 2:
                                                        mem[t] = mem[s + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                    mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (7 * ceil32(return_data.size)) + 192
                                                    require return_data.size >= 32
                                                    _12781 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                    require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                    require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                    _13183 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                    require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                    require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                    mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                    mem[(7 * ceil32(return_data.size)) + 192] = _13183
                                                    require _12781 + (32 * _13183) + 32 <= return_data.size
                                                    idx = 0
                                                    s = (6 * ceil32(return_data.size)) + _12781 + 224
                                                    t = (7 * ceil32(return_data.size)) + 224
                                                    while idx < _13183:
                                                        require mem[s] == mem[s]
                                                        mem[t] = mem[s]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[mem[64] + 4] = this.address
                                                    require ext_code.size(rewardTokenAddress)
                                                    staticcall rewardTokenAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args address(this.address)
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _19241 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_19241] == mem[_19241]
                                                    if sub_0b4b41bc <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require sub_0b4b41bc
                                                    sub_7f94bf16 = mem[_19241] / sub_0b4b41bc
                                                    mem[mem[64] + 4] = treasuryAddress
                                                    mem[mem[64] + 36] = 0
                                                    require ext_code.size(assetAddress)
                                                    call assetAddress.0xa9059cbb with:
                                                         gas gas_remaining wei
                                                        args treasuryAddress, 0
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _21407 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_21407] == bool(mem[_21407])
                                                else:
                                                    if rewardTokenAddress == WAVAXAddress:
                                                        mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                        mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                        mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                        mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                        mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + 128
                                                        t = (6 * ceil32(return_data.size)) + 388
                                                        while idx < 2:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                        mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                        require ext_code.size(routerAddress)
                                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = (7 * ceil32(return_data.size)) + 192
                                                        require return_data.size >= 32
                                                        _12783 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                        require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                        _13185 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                        mem[(7 * ceil32(return_data.size)) + 192] = _13185
                                                        require _12783 + (32 * _13185) + 32 <= return_data.size
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + _12783 + 224
                                                        t = (7 * ceil32(return_data.size)) + 224
                                                        while idx < _13185:
                                                            require mem[s] == mem[s]
                                                            mem[t] = mem[s]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[mem[64] + 4] = this.address
                                                        require ext_code.size(rewardTokenAddress)
                                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args address(this.address)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _19243 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_19243] == mem[_19243]
                                                        if sub_0b4b41bc <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require sub_0b4b41bc
                                                        sub_7f94bf16 = mem[_19243] / sub_0b4b41bc
                                                        mem[mem[64] + 4] = treasuryAddress
                                                        mem[mem[64] + 36] = 0
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args treasuryAddress, 0
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _21409 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_21409] == bool(mem[_21409])
                                                    else:
                                                        mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                        mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                        mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                        mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                        mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + 128
                                                        t = (6 * ceil32(return_data.size)) + 420
                                                        while idx < 3:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                        mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                        require ext_code.size(routerAddress)
                                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args 0, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = (7 * ceil32(return_data.size)) + 224
                                                        require return_data.size >= 32
                                                        _12782 = mem[(6 * ceil32(return_data.size)) + 224 len 4], 0
                                                        require mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 <= test266151307()
                                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                        _13184 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]
                                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224] <= test266151307()
                                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 32 >= 0
                                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256
                                                        mem[(7 * ceil32(return_data.size)) + 224] = _13184
                                                        require _12782 + (32 * _13184) + 32 <= return_data.size
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + _12782 + 256
                                                        t = (7 * ceil32(return_data.size)) + 256
                                                        while idx < _13184:
                                                            require mem[s] == mem[s]
                                                            mem[t] = mem[s]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[mem[64] + 4] = this.address
                                                        require ext_code.size(rewardTokenAddress)
                                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args address(this.address)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _19242 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_19242] == mem[_19242]
                                                        if sub_0b4b41bc <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require sub_0b4b41bc
                                                        sub_7f94bf16 = mem[_19242] / sub_0b4b41bc
                                                        mem[mem[64] + 4] = treasuryAddress
                                                        mem[mem[64] + 36] = 0
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args treasuryAddress, 0
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _21408 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_21408] == bool(mem[_21408])
                                            else:
                                                require ext_call.return_data[0] - totalDeposited
                                                if (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / ext_call.return_data[0] - totalDeposited != sub_7e72b29f:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                sub_bf4c8572 = (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / 10000
                                                mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                                mem[ceil32(return_data.size) + 132] = -1
                                                require ext_code.size(sub_b8ab24bdAddress)
                                                call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args lendingPoolAddress, -1
                                                mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                                mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                                mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                                require ext_code.size(lendingPoolAddress)
                                                call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                     gas gas_remaining wei
                                                    args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                                mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == ext_call.return_data[0]
                                                mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                                mem[(4 * ceil32(return_data.size)) + 132] = -1
                                                require ext_code.size(assetAddress)
                                                call assetAddress.approve(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args routerAddress, -1
                                                mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                if assetAddress == WAVAXAddress:
                                                    mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                    mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                    mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                    mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                    mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                    mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                    mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                    idx = 0
                                                    s = (6 * ceil32(return_data.size)) + 128
                                                    t = (6 * ceil32(return_data.size)) + 388
                                                    while idx < 2:
                                                        mem[t] = mem[s + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                    mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (7 * ceil32(return_data.size)) + 192
                                                    require return_data.size >= 32
                                                    _12778 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                    require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                    require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                    _13180 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                    require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                    require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                    mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                    mem[(7 * ceil32(return_data.size)) + 192] = _13180
                                                    require _12778 + (32 * _13180) + 32 <= return_data.size
                                                    idx = 0
                                                    s = (6 * ceil32(return_data.size)) + _12778 + 224
                                                    t = (7 * ceil32(return_data.size)) + 224
                                                    while idx < _13180:
                                                        require mem[s] == mem[s]
                                                        mem[t] = mem[s]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[mem[64] + 4] = this.address
                                                    require ext_code.size(rewardTokenAddress)
                                                    staticcall rewardTokenAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args address(this.address)
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _19238 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_19238] == mem[_19238]
                                                    if sub_0b4b41bc <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require sub_0b4b41bc
                                                    sub_7f94bf16 = mem[_19238] / sub_0b4b41bc
                                                    mem[mem[64] + 4] = treasuryAddress
                                                    mem[mem[64] + 36] = 0
                                                    require ext_code.size(assetAddress)
                                                    call assetAddress.0xa9059cbb with:
                                                         gas gas_remaining wei
                                                        args treasuryAddress, 0
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _21404 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_21404] == bool(mem[_21404])
                                                else:
                                                    if rewardTokenAddress == WAVAXAddress:
                                                        mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                        mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                        mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                        mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                        mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + 128
                                                        t = (6 * ceil32(return_data.size)) + 388
                                                        while idx < 2:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                        mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                        require ext_code.size(routerAddress)
                                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = (7 * ceil32(return_data.size)) + 192
                                                        require return_data.size >= 32
                                                        _12780 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                        require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                        _13182 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                        mem[(7 * ceil32(return_data.size)) + 192] = _13182
                                                        require _12780 + (32 * _13182) + 32 <= return_data.size
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + _12780 + 224
                                                        t = (7 * ceil32(return_data.size)) + 224
                                                        while idx < _13182:
                                                            require mem[s] == mem[s]
                                                            mem[t] = mem[s]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[mem[64] + 4] = this.address
                                                        require ext_code.size(rewardTokenAddress)
                                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args address(this.address)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _19240 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_19240] == mem[_19240]
                                                        if sub_0b4b41bc <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require sub_0b4b41bc
                                                        sub_7f94bf16 = mem[_19240] / sub_0b4b41bc
                                                        mem[mem[64] + 4] = treasuryAddress
                                                        mem[mem[64] + 36] = 0
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args treasuryAddress, 0
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _21406 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_21406] == bool(mem[_21406])
                                                    else:
                                                        mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                        mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                        mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                        mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                        mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + 128
                                                        t = (6 * ceil32(return_data.size)) + 420
                                                        while idx < 3:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                        mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                        require ext_code.size(routerAddress)
                                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args 0, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = (7 * ceil32(return_data.size)) + 224
                                                        require return_data.size >= 32
                                                        _12779 = mem[(6 * ceil32(return_data.size)) + 224 len 4], 0
                                                        require mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 <= test266151307()
                                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                        _13181 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]
                                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224] <= test266151307()
                                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 32 >= 0
                                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256
                                                        mem[(7 * ceil32(return_data.size)) + 224] = _13181
                                                        require _12779 + (32 * _13181) + 32 <= return_data.size
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + _12779 + 256
                                                        t = (7 * ceil32(return_data.size)) + 256
                                                        while idx < _13181:
                                                            require mem[s] == mem[s]
                                                            mem[t] = mem[s]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[mem[64] + 4] = this.address
                                                        require ext_code.size(rewardTokenAddress)
                                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args address(this.address)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _19239 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_19239] == mem[_19239]
                                                        if sub_0b4b41bc <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require sub_0b4b41bc
                                                        sub_7f94bf16 = mem[_19239] / sub_0b4b41bc
                                                        mem[mem[64] + 4] = treasuryAddress
                                                        mem[mem[64] + 36] = 0
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args treasuryAddress, 0
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _21405 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_21405] == bool(mem[_21405])
                                        else:
                                            require ext_call.return_data[0] - totalDeposited
                                            if (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / ext_call.return_data[0] - totalDeposited != sub_2f6236be:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not ext_call.return_data[0] - totalDeposited:
                                                sub_bf4c8572 = 0
                                                mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                                mem[ceil32(return_data.size) + 132] = -1
                                                require ext_code.size(sub_b8ab24bdAddress)
                                                call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args lendingPoolAddress, -1
                                                mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                                mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                                mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                                require ext_code.size(lendingPoolAddress)
                                                call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                     gas gas_remaining wei
                                                    args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                                mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == ext_call.return_data[0]
                                                mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                                mem[(4 * ceil32(return_data.size)) + 132] = -1
                                                require ext_code.size(assetAddress)
                                                call assetAddress.approve(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args routerAddress, -1
                                                mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                if assetAddress == WAVAXAddress:
                                                    mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                    mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                    mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                    mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                    mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                    mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                    mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                    idx = 0
                                                    s = (6 * ceil32(return_data.size)) + 128
                                                    t = (6 * ceil32(return_data.size)) + 388
                                                    while idx < 2:
                                                        mem[t] = mem[s + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                    mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (7 * ceil32(return_data.size)) + 192
                                                    require return_data.size >= 32
                                                    _12775 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                    require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                    require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                    _13177 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                    require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                    require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                    mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                    mem[(7 * ceil32(return_data.size)) + 192] = _13177
                                                    require _12775 + (32 * _13177) + 32 <= return_data.size
                                                    idx = 0
                                                    s = (6 * ceil32(return_data.size)) + _12775 + 224
                                                    t = (7 * ceil32(return_data.size)) + 224
                                                    while idx < _13177:
                                                        require mem[s] == mem[s]
                                                        mem[t] = mem[s]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[mem[64] + 4] = this.address
                                                    require ext_code.size(rewardTokenAddress)
                                                    staticcall rewardTokenAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args address(this.address)
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _19235 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_19235] == mem[_19235]
                                                    if sub_0b4b41bc <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require sub_0b4b41bc
                                                    sub_7f94bf16 = mem[_19235] / sub_0b4b41bc
                                                    mem[mem[64] + 4] = treasuryAddress
                                                    mem[mem[64] + 36] = 0
                                                    require ext_code.size(assetAddress)
                                                    call assetAddress.0xa9059cbb with:
                                                         gas gas_remaining wei
                                                        args treasuryAddress, 0
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _21401 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_21401] == bool(mem[_21401])
                                                else:
                                                    if rewardTokenAddress == WAVAXAddress:
                                                        mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                        mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                        mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                        mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                        mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + 128
                                                        t = (6 * ceil32(return_data.size)) + 388
                                                        while idx < 2:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                        mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                        require ext_code.size(routerAddress)
                                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = (7 * ceil32(return_data.size)) + 192
                                                        require return_data.size >= 32
                                                        _12777 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                        require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                        _13179 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                        mem[(7 * ceil32(return_data.size)) + 192] = _13179
                                                        require _12777 + (32 * _13179) + 32 <= return_data.size
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + _12777 + 224
                                                        t = (7 * ceil32(return_data.size)) + 224
                                                        while idx < _13179:
                                                            require mem[s] == mem[s]
                                                            mem[t] = mem[s]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[mem[64] + 4] = this.address
                                                        require ext_code.size(rewardTokenAddress)
                                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args address(this.address)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _19237 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_19237] == mem[_19237]
                                                        if sub_0b4b41bc <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require sub_0b4b41bc
                                                        sub_7f94bf16 = mem[_19237] / sub_0b4b41bc
                                                        mem[mem[64] + 4] = treasuryAddress
                                                        mem[mem[64] + 36] = 0
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args treasuryAddress, 0
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _21403 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_21403] == bool(mem[_21403])
                                                    else:
                                                        mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                        mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                        mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                        mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                        mem[(6 * ceil32(return_data.size)) + 228] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                        mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                        mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + 128
                                                        t = (6 * ceil32(return_data.size)) + 420
                                                        while idx < 3:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                        mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                        require ext_code.size(routerAddress)
                                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = (7 * ceil32(return_data.size)) + 224
                                                        require return_data.size >= 32
                                                        _12776 = mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                        require mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                        _13178 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]
                                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224] <= test266151307()
                                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 32 >= 0
                                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256
                                                        mem[(7 * ceil32(return_data.size)) + 224] = _13178
                                                        require _12776 + (32 * _13178) + 32 <= return_data.size
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + _12776 + 256
                                                        t = (7 * ceil32(return_data.size)) + 256
                                                        while idx < _13178:
                                                            require mem[s] == mem[s]
                                                            mem[t] = mem[s]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[mem[64] + 4] = this.address
                                                        require ext_code.size(rewardTokenAddress)
                                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args address(this.address)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _19236 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_19236] == mem[_19236]
                                                        if sub_0b4b41bc <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require sub_0b4b41bc
                                                        sub_7f94bf16 = mem[_19236] / sub_0b4b41bc
                                                        mem[mem[64] + 4] = treasuryAddress
                                                        mem[mem[64] + 36] = 0
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args treasuryAddress, 0
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _21402 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_21402] == bool(mem[_21402])
                                            else:
                                                require ext_call.return_data[0] - totalDeposited
                                                if (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / ext_call.return_data[0] - totalDeposited != sub_7e72b29f:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                sub_bf4c8572 = (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / 10000
                                                mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                                mem[ceil32(return_data.size) + 132] = -1
                                                require ext_code.size(sub_b8ab24bdAddress)
                                                call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args lendingPoolAddress, -1
                                                mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                                mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                                mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                                require ext_code.size(lendingPoolAddress)
                                                call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                     gas gas_remaining wei
                                                    args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                                mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == ext_call.return_data[0]
                                                mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                                mem[(4 * ceil32(return_data.size)) + 132] = -1
                                                require ext_code.size(assetAddress)
                                                call assetAddress.approve(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args routerAddress, -1
                                                mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                if assetAddress == WAVAXAddress:
                                                    mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                    mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                    mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                    mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                    mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                    mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                    mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                    idx = 0
                                                    s = (6 * ceil32(return_data.size)) + 128
                                                    t = (6 * ceil32(return_data.size)) + 388
                                                    while idx < 2:
                                                        mem[t] = mem[s + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                    mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (7 * ceil32(return_data.size)) + 192
                                                    require return_data.size >= 32
                                                    _12772 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                    require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                    require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                    _13174 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                    require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                    require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                    mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                    mem[(7 * ceil32(return_data.size)) + 192] = _13174
                                                    require _12772 + (32 * _13174) + 32 <= return_data.size
                                                    idx = 0
                                                    s = (6 * ceil32(return_data.size)) + _12772 + 224
                                                    t = (7 * ceil32(return_data.size)) + 224
                                                    while idx < _13174:
                                                        require mem[s] == mem[s]
                                                        mem[t] = mem[s]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[mem[64] + 4] = this.address
                                                    require ext_code.size(rewardTokenAddress)
                                                    staticcall rewardTokenAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args address(this.address)
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _19232 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_19232] == mem[_19232]
                                                    if sub_0b4b41bc <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require sub_0b4b41bc
                                                    sub_7f94bf16 = mem[_19232] / sub_0b4b41bc
                                                    mem[mem[64] + 4] = treasuryAddress
                                                    mem[mem[64] + 36] = 0
                                                    require ext_code.size(assetAddress)
                                                    call assetAddress.0xa9059cbb with:
                                                         gas gas_remaining wei
                                                        args treasuryAddress, 0
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _21398 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_21398] == bool(mem[_21398])
                                                else:
                                                    if rewardTokenAddress == WAVAXAddress:
                                                        mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                        mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                        mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                        mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                        mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + 128
                                                        t = (6 * ceil32(return_data.size)) + 388
                                                        while idx < 2:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                        mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                        require ext_code.size(routerAddress)
                                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = (7 * ceil32(return_data.size)) + 192
                                                        require return_data.size >= 32
                                                        _12774 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                        require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                        _13176 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                        mem[(7 * ceil32(return_data.size)) + 192] = _13176
                                                        require _12774 + (32 * _13176) + 32 <= return_data.size
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + _12774 + 224
                                                        t = (7 * ceil32(return_data.size)) + 224
                                                        while idx < _13176:
                                                            require mem[s] == mem[s]
                                                            mem[t] = mem[s]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[mem[64] + 4] = this.address
                                                        require ext_code.size(rewardTokenAddress)
                                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args address(this.address)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _19234 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_19234] == mem[_19234]
                                                        if sub_0b4b41bc <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require sub_0b4b41bc
                                                        sub_7f94bf16 = mem[_19234] / sub_0b4b41bc
                                                        mem[mem[64] + 4] = treasuryAddress
                                                        mem[mem[64] + 36] = 0
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args treasuryAddress, 0
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _21400 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_21400] == bool(mem[_21400])
                                                    else:
                                                        mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                        mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                        mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                        mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                        mem[(6 * ceil32(return_data.size)) + 228] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                        mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                        mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + 128
                                                        t = (6 * ceil32(return_data.size)) + 420
                                                        while idx < 3:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                        mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                        require ext_code.size(routerAddress)
                                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = (7 * ceil32(return_data.size)) + 224
                                                        require return_data.size >= 32
                                                        _12773 = mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                        require mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                        _13175 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]
                                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224] <= test266151307()
                                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 32 >= 0
                                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256
                                                        mem[(7 * ceil32(return_data.size)) + 224] = _13175
                                                        require _12773 + (32 * _13175) + 32 <= return_data.size
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + _12773 + 256
                                                        t = (7 * ceil32(return_data.size)) + 256
                                                        while idx < _13175:
                                                            require mem[s] == mem[s]
                                                            mem[t] = mem[s]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[mem[64] + 4] = this.address
                                                        require ext_code.size(rewardTokenAddress)
                                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args address(this.address)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _19233 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_19233] == mem[_19233]
                                                        if sub_0b4b41bc <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require sub_0b4b41bc
                                                        sub_7f94bf16 = mem[_19233] / sub_0b4b41bc
                                                        mem[mem[64] + 4] = treasuryAddress
                                                        mem[mem[64] + 36] = 0
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args treasuryAddress, 0
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _21399 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_21399] == bool(mem[_21399])
                                    else:
                                        require ext_call.return_data[0] - totalDeposited
                                        if (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / ext_call.return_data[0] - totalDeposited != sub_7796ff37:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not ext_call.return_data[0] - totalDeposited:
                                            if not ext_call.return_data[0] - totalDeposited:
                                                sub_bf4c8572 = 0
                                                mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                                mem[ceil32(return_data.size) + 132] = -1
                                                require ext_code.size(sub_b8ab24bdAddress)
                                                call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args lendingPoolAddress, -1
                                                mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                                mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                                mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                                require ext_code.size(lendingPoolAddress)
                                                call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                     gas gas_remaining wei
                                                    args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                                mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == ext_call.return_data[0]
                                                mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                                mem[(4 * ceil32(return_data.size)) + 132] = -1
                                                require ext_code.size(assetAddress)
                                                call assetAddress.approve(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args routerAddress, -1
                                                mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                if assetAddress == WAVAXAddress:
                                                    mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                    mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                    mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                    mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                    mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                    mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                    mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                    idx = 0
                                                    s = (6 * ceil32(return_data.size)) + 128
                                                    t = (6 * ceil32(return_data.size)) + 388
                                                    while idx < 2:
                                                        mem[t] = mem[s + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                    mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (7 * ceil32(return_data.size)) + 192
                                                    require return_data.size >= 32
                                                    _12769 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                    require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                    require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                    _13171 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                    require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                    require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                    mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                    mem[(7 * ceil32(return_data.size)) + 192] = _13171
                                                    require _12769 + (32 * _13171) + 32 <= return_data.size
                                                    idx = 0
                                                    s = (6 * ceil32(return_data.size)) + _12769 + 224
                                                    t = (7 * ceil32(return_data.size)) + 224
                                                    while idx < _13171:
                                                        require mem[s] == mem[s]
                                                        mem[t] = mem[s]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[mem[64] + 4] = this.address
                                                    require ext_code.size(rewardTokenAddress)
                                                    staticcall rewardTokenAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args address(this.address)
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _19229 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_19229] == mem[_19229]
                                                    if sub_0b4b41bc <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require sub_0b4b41bc
                                                    sub_7f94bf16 = mem[_19229] / sub_0b4b41bc
                                                    mem[mem[64] + 4] = treasuryAddress
                                                    mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                    require ext_code.size(assetAddress)
                                                    call assetAddress.0xa9059cbb with:
                                                         gas gas_remaining wei
                                                        args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _21395 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_21395] == bool(mem[_21395])
                                                else:
                                                    if rewardTokenAddress == WAVAXAddress:
                                                        mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                        mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                        mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                        mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                        mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + 128
                                                        t = (6 * ceil32(return_data.size)) + 388
                                                        while idx < 2:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                        mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                        require ext_code.size(routerAddress)
                                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = (7 * ceil32(return_data.size)) + 192
                                                        require return_data.size >= 32
                                                        _12771 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                        require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                        _13173 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                        mem[(7 * ceil32(return_data.size)) + 192] = _13173
                                                        require _12771 + (32 * _13173) + 32 <= return_data.size
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + _12771 + 224
                                                        t = (7 * ceil32(return_data.size)) + 224
                                                        while idx < _13173:
                                                            require mem[s] == mem[s]
                                                            mem[t] = mem[s]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[mem[64] + 4] = this.address
                                                        require ext_code.size(rewardTokenAddress)
                                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args address(this.address)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _19231 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_19231] == mem[_19231]
                                                        if sub_0b4b41bc <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require sub_0b4b41bc
                                                        sub_7f94bf16 = mem[_19231] / sub_0b4b41bc
                                                        mem[mem[64] + 4] = treasuryAddress
                                                        mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _21397 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_21397] == bool(mem[_21397])
                                                    else:
                                                        mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                        mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                        mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                        mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                        mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + 128
                                                        t = (6 * ceil32(return_data.size)) + 420
                                                        while idx < 3:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                        mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                        require ext_code.size(routerAddress)
                                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args 0, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = (7 * ceil32(return_data.size)) + 224
                                                        require return_data.size >= 32
                                                        _12770 = mem[(6 * ceil32(return_data.size)) + 224 len 4], 0
                                                        require mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 <= test266151307()
                                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                        _13172 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]
                                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224] <= test266151307()
                                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 32 >= 0
                                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256
                                                        mem[(7 * ceil32(return_data.size)) + 224] = _13172
                                                        require _12770 + (32 * _13172) + 32 <= return_data.size
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + _12770 + 256
                                                        t = (7 * ceil32(return_data.size)) + 256
                                                        while idx < _13172:
                                                            require mem[s] == mem[s]
                                                            mem[t] = mem[s]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[mem[64] + 4] = this.address
                                                        require ext_code.size(rewardTokenAddress)
                                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args address(this.address)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _19230 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_19230] == mem[_19230]
                                                        if sub_0b4b41bc <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require sub_0b4b41bc
                                                        sub_7f94bf16 = mem[_19230] / sub_0b4b41bc
                                                        mem[mem[64] + 4] = treasuryAddress
                                                        mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _21396 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_21396] == bool(mem[_21396])
                                            else:
                                                require ext_call.return_data[0] - totalDeposited
                                                if (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / ext_call.return_data[0] - totalDeposited != sub_7e72b29f:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                sub_bf4c8572 = (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / 10000
                                                mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                                mem[ceil32(return_data.size) + 132] = -1
                                                require ext_code.size(sub_b8ab24bdAddress)
                                                call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args lendingPoolAddress, -1
                                                mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                                mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                                mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                                require ext_code.size(lendingPoolAddress)
                                                call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                     gas gas_remaining wei
                                                    args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                                mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == ext_call.return_data[0]
                                                mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                                mem[(4 * ceil32(return_data.size)) + 132] = -1
                                                require ext_code.size(assetAddress)
                                                call assetAddress.approve(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args routerAddress, -1
                                                mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                if assetAddress == WAVAXAddress:
                                                    mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                    mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                    mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                    mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                    mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                    mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                    mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                    idx = 0
                                                    s = (6 * ceil32(return_data.size)) + 128
                                                    t = (6 * ceil32(return_data.size)) + 388
                                                    while idx < 2:
                                                        mem[t] = mem[s + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                    mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (7 * ceil32(return_data.size)) + 192
                                                    require return_data.size >= 32
                                                    _12766 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                    require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                    require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                    _13168 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                    require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                    require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                    mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                    mem[(7 * ceil32(return_data.size)) + 192] = _13168
                                                    require _12766 + (32 * _13168) + 32 <= return_data.size
                                                    idx = 0
                                                    s = (6 * ceil32(return_data.size)) + _12766 + 224
                                                    t = (7 * ceil32(return_data.size)) + 224
                                                    while idx < _13168:
                                                        require mem[s] == mem[s]
                                                        mem[t] = mem[s]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[mem[64] + 4] = this.address
                                                    require ext_code.size(rewardTokenAddress)
                                                    staticcall rewardTokenAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args address(this.address)
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _19226 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_19226] == mem[_19226]
                                                    if sub_0b4b41bc <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require sub_0b4b41bc
                                                    sub_7f94bf16 = mem[_19226] / sub_0b4b41bc
                                                    mem[mem[64] + 4] = treasuryAddress
                                                    mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                    require ext_code.size(assetAddress)
                                                    call assetAddress.0xa9059cbb with:
                                                         gas gas_remaining wei
                                                        args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _21392 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_21392] == bool(mem[_21392])
                                                else:
                                                    if rewardTokenAddress == WAVAXAddress:
                                                        mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                        mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                        mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                        mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                        mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + 128
                                                        t = (6 * ceil32(return_data.size)) + 388
                                                        while idx < 2:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                        mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                        require ext_code.size(routerAddress)
                                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = (7 * ceil32(return_data.size)) + 192
                                                        require return_data.size >= 32
                                                        _12768 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                        require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                        _13170 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                        mem[(7 * ceil32(return_data.size)) + 192] = _13170
                                                        require _12768 + (32 * _13170) + 32 <= return_data.size
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + _12768 + 224
                                                        t = (7 * ceil32(return_data.size)) + 224
                                                        while idx < _13170:
                                                            require mem[s] == mem[s]
                                                            mem[t] = mem[s]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[mem[64] + 4] = this.address
                                                        require ext_code.size(rewardTokenAddress)
                                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args address(this.address)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _19228 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_19228] == mem[_19228]
                                                        if sub_0b4b41bc <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require sub_0b4b41bc
                                                        sub_7f94bf16 = mem[_19228] / sub_0b4b41bc
                                                        mem[mem[64] + 4] = treasuryAddress
                                                        mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _21394 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_21394] == bool(mem[_21394])
                                                    else:
                                                        mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                        mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                        mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                        mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                        mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + 128
                                                        t = (6 * ceil32(return_data.size)) + 420
                                                        while idx < 3:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                        mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                        require ext_code.size(routerAddress)
                                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args 0, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = (7 * ceil32(return_data.size)) + 224
                                                        require return_data.size >= 32
                                                        _12767 = mem[(6 * ceil32(return_data.size)) + 224 len 4], 0
                                                        require mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 <= test266151307()
                                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                        _13169 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]
                                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224] <= test266151307()
                                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 32 >= 0
                                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256
                                                        mem[(7 * ceil32(return_data.size)) + 224] = _13169
                                                        require _12767 + (32 * _13169) + 32 <= return_data.size
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + _12767 + 256
                                                        t = (7 * ceil32(return_data.size)) + 256
                                                        while idx < _13169:
                                                            require mem[s] == mem[s]
                                                            mem[t] = mem[s]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[mem[64] + 4] = this.address
                                                        require ext_code.size(rewardTokenAddress)
                                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args address(this.address)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _19227 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_19227] == mem[_19227]
                                                        if sub_0b4b41bc <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require sub_0b4b41bc
                                                        sub_7f94bf16 = mem[_19227] / sub_0b4b41bc
                                                        mem[mem[64] + 4] = treasuryAddress
                                                        mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _21393 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_21393] == bool(mem[_21393])
                                        else:
                                            require ext_call.return_data[0] - totalDeposited
                                            if (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / ext_call.return_data[0] - totalDeposited != sub_2f6236be:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not ext_call.return_data[0] - totalDeposited:
                                                sub_bf4c8572 = 0
                                                mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                                mem[ceil32(return_data.size) + 132] = -1
                                                require ext_code.size(sub_b8ab24bdAddress)
                                                call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args lendingPoolAddress, -1
                                                mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                                mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                                mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                                require ext_code.size(lendingPoolAddress)
                                                call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                     gas gas_remaining wei
                                                    args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                                mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == ext_call.return_data[0]
                                                mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                                mem[(4 * ceil32(return_data.size)) + 132] = -1
                                                require ext_code.size(assetAddress)
                                                call assetAddress.approve(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args routerAddress, -1
                                                mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                if assetAddress == WAVAXAddress:
                                                    mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                    mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                    mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                    mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                    mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                    mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                    mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                    idx = 0
                                                    s = (6 * ceil32(return_data.size)) + 128
                                                    t = (6 * ceil32(return_data.size)) + 388
                                                    while idx < 2:
                                                        mem[t] = mem[s + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                    mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (7 * ceil32(return_data.size)) + 192
                                                    require return_data.size >= 32
                                                    _12763 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                    require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                    require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                    _13165 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                    require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                    require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                    mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                    mem[(7 * ceil32(return_data.size)) + 192] = _13165
                                                    require _12763 + (32 * _13165) + 32 <= return_data.size
                                                    idx = 0
                                                    s = (6 * ceil32(return_data.size)) + _12763 + 224
                                                    t = (7 * ceil32(return_data.size)) + 224
                                                    while idx < _13165:
                                                        require mem[s] == mem[s]
                                                        mem[t] = mem[s]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[mem[64] + 4] = this.address
                                                    require ext_code.size(rewardTokenAddress)
                                                    staticcall rewardTokenAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args address(this.address)
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _19223 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_19223] == mem[_19223]
                                                    if sub_0b4b41bc <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require sub_0b4b41bc
                                                    sub_7f94bf16 = mem[_19223] / sub_0b4b41bc
                                                    mem[mem[64] + 4] = treasuryAddress
                                                    mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                    require ext_code.size(assetAddress)
                                                    call assetAddress.0xa9059cbb with:
                                                         gas gas_remaining wei
                                                        args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _21389 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_21389] == bool(mem[_21389])
                                                else:
                                                    if rewardTokenAddress == WAVAXAddress:
                                                        mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                        mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                        mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                        mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                        mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + 128
                                                        t = (6 * ceil32(return_data.size)) + 388
                                                        while idx < 2:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                        mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                        require ext_code.size(routerAddress)
                                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = (7 * ceil32(return_data.size)) + 192
                                                        require return_data.size >= 32
                                                        _12765 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                        require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                        _13167 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                        mem[(7 * ceil32(return_data.size)) + 192] = _13167
                                                        require _12765 + (32 * _13167) + 32 <= return_data.size
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + _12765 + 224
                                                        t = (7 * ceil32(return_data.size)) + 224
                                                        while idx < _13167:
                                                            require mem[s] == mem[s]
                                                            mem[t] = mem[s]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[mem[64] + 4] = this.address
                                                        require ext_code.size(rewardTokenAddress)
                                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args address(this.address)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _19225 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_19225] == mem[_19225]
                                                        if sub_0b4b41bc <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require sub_0b4b41bc
                                                        sub_7f94bf16 = mem[_19225] / sub_0b4b41bc
                                                        mem[mem[64] + 4] = treasuryAddress
                                                        mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _21391 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_21391] == bool(mem[_21391])
                                                    else:
                                                        mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                        mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                        mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                        mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                        mem[(6 * ceil32(return_data.size)) + 228] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                        mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                        mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + 128
                                                        t = (6 * ceil32(return_data.size)) + 420
                                                        while idx < 3:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                        mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                        require ext_code.size(routerAddress)
                                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = (7 * ceil32(return_data.size)) + 224
                                                        require return_data.size >= 32
                                                        _12764 = mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                        require mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                        _13166 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]
                                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224] <= test266151307()
                                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 32 >= 0
                                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256
                                                        mem[(7 * ceil32(return_data.size)) + 224] = _13166
                                                        require _12764 + (32 * _13166) + 32 <= return_data.size
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + _12764 + 256
                                                        t = (7 * ceil32(return_data.size)) + 256
                                                        while idx < _13166:
                                                            require mem[s] == mem[s]
                                                            mem[t] = mem[s]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[mem[64] + 4] = this.address
                                                        require ext_code.size(rewardTokenAddress)
                                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args address(this.address)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _19224 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_19224] == mem[_19224]
                                                        if sub_0b4b41bc <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require sub_0b4b41bc
                                                        sub_7f94bf16 = mem[_19224] / sub_0b4b41bc
                                                        mem[mem[64] + 4] = treasuryAddress
                                                        mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _21390 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_21390] == bool(mem[_21390])
                                            else:
                                                require ext_call.return_data[0] - totalDeposited
                                                if (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / ext_call.return_data[0] - totalDeposited != sub_7e72b29f:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                sub_bf4c8572 = (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / 10000
                                                mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                                mem[ceil32(return_data.size) + 132] = -1
                                                require ext_code.size(sub_b8ab24bdAddress)
                                                call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args lendingPoolAddress, -1
                                                mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                                mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                                mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                                require ext_code.size(lendingPoolAddress)
                                                call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                     gas gas_remaining wei
                                                    args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                                mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == ext_call.return_data[0]
                                                mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                                mem[(4 * ceil32(return_data.size)) + 132] = -1
                                                require ext_code.size(assetAddress)
                                                call assetAddress.approve(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args routerAddress, -1
                                                mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                if assetAddress == WAVAXAddress:
                                                    mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                    mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                    mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                    mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                    mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                    mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                    mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                    idx = 0
                                                    s = (6 * ceil32(return_data.size)) + 128
                                                    t = (6 * ceil32(return_data.size)) + 388
                                                    while idx < 2:
                                                        mem[t] = mem[s + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                    mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (7 * ceil32(return_data.size)) + 192
                                                    require return_data.size >= 32
                                                    _12760 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                    require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                    require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                    _13162 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                    require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                    require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                    mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                    mem[(7 * ceil32(return_data.size)) + 192] = _13162
                                                    require _12760 + (32 * _13162) + 32 <= return_data.size
                                                    idx = 0
                                                    s = (6 * ceil32(return_data.size)) + _12760 + 224
                                                    t = (7 * ceil32(return_data.size)) + 224
                                                    while idx < _13162:
                                                        require mem[s] == mem[s]
                                                        mem[t] = mem[s]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[mem[64] + 4] = this.address
                                                    require ext_code.size(rewardTokenAddress)
                                                    staticcall rewardTokenAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args address(this.address)
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _19220 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_19220] == mem[_19220]
                                                    if sub_0b4b41bc <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require sub_0b4b41bc
                                                    sub_7f94bf16 = mem[_19220] / sub_0b4b41bc
                                                    mem[mem[64] + 4] = treasuryAddress
                                                    mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                    require ext_code.size(assetAddress)
                                                    call assetAddress.0xa9059cbb with:
                                                         gas gas_remaining wei
                                                        args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _21386 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_21386] == bool(mem[_21386])
                                                else:
                                                    if rewardTokenAddress == WAVAXAddress:
                                                        mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                        mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                        mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                        mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                        mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + 128
                                                        t = (6 * ceil32(return_data.size)) + 388
                                                        while idx < 2:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                        mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                        require ext_code.size(routerAddress)
                                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = (7 * ceil32(return_data.size)) + 192
                                                        require return_data.size >= 32
                                                        _12762 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                        require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                        _13164 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                        mem[(7 * ceil32(return_data.size)) + 192] = _13164
                                                        require _12762 + (32 * _13164) + 32 <= return_data.size
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + _12762 + 224
                                                        t = (7 * ceil32(return_data.size)) + 224
                                                        while idx < _13164:
                                                            require mem[s] == mem[s]
                                                            mem[t] = mem[s]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[mem[64] + 4] = this.address
                                                        require ext_code.size(rewardTokenAddress)
                                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args address(this.address)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _19222 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_19222] == mem[_19222]
                                                        if sub_0b4b41bc <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require sub_0b4b41bc
                                                        sub_7f94bf16 = mem[_19222] / sub_0b4b41bc
                                                        mem[mem[64] + 4] = treasuryAddress
                                                        mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _21388 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_21388] == bool(mem[_21388])
                                                    else:
                                                        mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                        mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                        mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                        mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                        mem[(6 * ceil32(return_data.size)) + 228] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                        mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                        mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + 128
                                                        t = (6 * ceil32(return_data.size)) + 420
                                                        while idx < 3:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                        mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                        require ext_code.size(routerAddress)
                                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = (7 * ceil32(return_data.size)) + 224
                                                        require return_data.size >= 32
                                                        _12761 = mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                        require mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                        _13163 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]
                                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224] <= test266151307()
                                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 32 >= 0
                                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256
                                                        mem[(7 * ceil32(return_data.size)) + 224] = _13163
                                                        require _12761 + (32 * _13163) + 32 <= return_data.size
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + _12761 + 256
                                                        t = (7 * ceil32(return_data.size)) + 256
                                                        while idx < _13163:
                                                            require mem[s] == mem[s]
                                                            mem[t] = mem[s]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[mem[64] + 4] = this.address
                                                        require ext_code.size(rewardTokenAddress)
                                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args address(this.address)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _19221 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_19221] == mem[_19221]
                                                        if sub_0b4b41bc <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require sub_0b4b41bc
                                                        sub_7f94bf16 = mem[_19221] / sub_0b4b41bc
                                                        mem[mem[64] + 4] = treasuryAddress
                                                        mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _21387 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_21387] == bool(mem[_21387])
                                else:
                                    require block.timestamp - lastRewardTimestamp
                                    if (block.timestamp * sub_f12c8e0d) - (lastRewardTimestamp * sub_f12c8e0d) / block.timestamp - lastRewardTimestamp != sub_f12c8e0d:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
                                    if not (block.timestamp * sub_f12c8e0d) - (lastRewardTimestamp * sub_f12c8e0d):
                                        require ext_code.size(rewardWalletAddress)
                                        call rewardWalletAddress.requestReward(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if totalDeposited <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalDeposited
                                        if sub_a9ac33dd + (0 / totalDeposited) < sub_a9ac33dd:
                                            revert with 0, 'SafeMath: addition overflow'
                                        sub_a9ac33dd += 0 / totalDeposited
                                        lastRewardTimestamp = block.timestamp
                                        mem[100] = this.address
                                        require ext_code.size(sub_b8ab24bdAddress)
                                        staticcall sub_b8ab24bdAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[96] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == ext_call.return_data[0]
                                        if not ext_call.return_data[0] - totalDeposited:
                                            if not ext_call.return_data[0] - totalDeposited:
                                                if not ext_call.return_data[0] - totalDeposited:
                                                    sub_bf4c8572 = 0
                                                    mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                                    mem[ceil32(return_data.size) + 132] = -1
                                                    require ext_code.size(sub_b8ab24bdAddress)
                                                    call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args lendingPoolAddress, -1
                                                    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                    mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                                    mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                                    mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                                    require ext_code.size(lendingPoolAddress)
                                                    call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                         gas gas_remaining wei
                                                        args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                                    mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                                    mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                                    mem[(4 * ceil32(return_data.size)) + 132] = -1
                                                    require ext_code.size(assetAddress)
                                                    call assetAddress.approve(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args routerAddress, -1
                                                    mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                    if assetAddress == WAVAXAddress:
                                                        mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                        mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                        mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                        mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                        mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + 128
                                                        t = (6 * ceil32(return_data.size)) + 388
                                                        while idx < 2:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                        mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                        require ext_code.size(routerAddress)
                                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = (7 * ceil32(return_data.size)) + 192
                                                        require return_data.size >= 32
                                                        _12757 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                        require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                        _13159 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                        mem[(7 * ceil32(return_data.size)) + 192] = _13159
                                                        require _12757 + (32 * _13159) + 32 <= return_data.size
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + _12757 + 224
                                                        t = (7 * ceil32(return_data.size)) + 224
                                                        while idx < _13159:
                                                            require mem[s] == mem[s]
                                                            mem[t] = mem[s]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[mem[64] + 4] = this.address
                                                        require ext_code.size(rewardTokenAddress)
                                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args address(this.address)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _19217 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_19217] == mem[_19217]
                                                        if sub_0b4b41bc <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require sub_0b4b41bc
                                                        sub_7f94bf16 = mem[_19217] / sub_0b4b41bc
                                                        mem[mem[64] + 4] = treasuryAddress
                                                        mem[mem[64] + 36] = 0
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args treasuryAddress, 0
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _21383 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_21383] == bool(mem[_21383])
                                                    else:
                                                        if rewardTokenAddress == WAVAXAddress:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 388
                                                            while idx < 2:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 192
                                                            require return_data.size >= 32
                                                            _12759 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                            require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                            _13161 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                            mem[(7 * ceil32(return_data.size)) + 192] = _13161
                                                            require _12759 + (32 * _13161) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12759 + 224
                                                            t = (7 * ceil32(return_data.size)) + 224
                                                            while idx < _13161:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19219 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19219] == mem[_19219]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19219] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = 0
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, 0
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21385 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21385] == bool(mem[_21385])
                                                        else:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 420
                                                            while idx < 3:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args 0, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 224
                                                            require return_data.size >= 32
                                                            _12758 = mem[(6 * ceil32(return_data.size)) + 224 len 4], 0
                                                            require mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                            _13160 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256
                                                            mem[(7 * ceil32(return_data.size)) + 224] = _13160
                                                            require _12758 + (32 * _13160) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12758 + 256
                                                            t = (7 * ceil32(return_data.size)) + 256
                                                            while idx < _13160:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19218 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19218] == mem[_19218]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19218] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = 0
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, 0
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21384 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21384] == bool(mem[_21384])
                                                else:
                                                    require ext_call.return_data[0] - totalDeposited
                                                    if (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / ext_call.return_data[0] - totalDeposited != sub_7e72b29f:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    sub_bf4c8572 = (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / 10000
                                                    mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                                    mem[ceil32(return_data.size) + 132] = -1
                                                    require ext_code.size(sub_b8ab24bdAddress)
                                                    call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args lendingPoolAddress, -1
                                                    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                    mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                                    mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                                    mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                                    require ext_code.size(lendingPoolAddress)
                                                    call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                         gas gas_remaining wei
                                                        args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                                    mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                                    mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                                    mem[(4 * ceil32(return_data.size)) + 132] = -1
                                                    require ext_code.size(assetAddress)
                                                    call assetAddress.approve(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args routerAddress, -1
                                                    mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                    if assetAddress == WAVAXAddress:
                                                        mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                        mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                        mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                        mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                        mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + 128
                                                        t = (6 * ceil32(return_data.size)) + 388
                                                        while idx < 2:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                        mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                        require ext_code.size(routerAddress)
                                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = (7 * ceil32(return_data.size)) + 192
                                                        require return_data.size >= 32
                                                        _12754 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                        require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                        _13156 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                        mem[(7 * ceil32(return_data.size)) + 192] = _13156
                                                        require _12754 + (32 * _13156) + 32 <= return_data.size
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + _12754 + 224
                                                        t = (7 * ceil32(return_data.size)) + 224
                                                        while idx < _13156:
                                                            require mem[s] == mem[s]
                                                            mem[t] = mem[s]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[mem[64] + 4] = this.address
                                                        require ext_code.size(rewardTokenAddress)
                                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args address(this.address)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _19214 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_19214] == mem[_19214]
                                                        if sub_0b4b41bc <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require sub_0b4b41bc
                                                        sub_7f94bf16 = mem[_19214] / sub_0b4b41bc
                                                        mem[mem[64] + 4] = treasuryAddress
                                                        mem[mem[64] + 36] = 0
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args treasuryAddress, 0
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _21380 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_21380] == bool(mem[_21380])
                                                    else:
                                                        if rewardTokenAddress == WAVAXAddress:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 388
                                                            while idx < 2:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 192
                                                            require return_data.size >= 32
                                                            _12756 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                            require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                            _13158 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                            mem[(7 * ceil32(return_data.size)) + 192] = _13158
                                                            require _12756 + (32 * _13158) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12756 + 224
                                                            t = (7 * ceil32(return_data.size)) + 224
                                                            while idx < _13158:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19216 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19216] == mem[_19216]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19216] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = 0
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, 0
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21382 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21382] == bool(mem[_21382])
                                                        else:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 420
                                                            while idx < 3:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args 0, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 224
                                                            require return_data.size >= 32
                                                            _12755 = mem[(6 * ceil32(return_data.size)) + 224 len 4], 0
                                                            require mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                            _13157 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256
                                                            mem[(7 * ceil32(return_data.size)) + 224] = _13157
                                                            require _12755 + (32 * _13157) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12755 + 256
                                                            t = (7 * ceil32(return_data.size)) + 256
                                                            while idx < _13157:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19215 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19215] == mem[_19215]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19215] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = 0
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, 0
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21381 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21381] == bool(mem[_21381])
                                            else:
                                                require ext_call.return_data[0] - totalDeposited
                                                if (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / ext_call.return_data[0] - totalDeposited != sub_2f6236be:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not ext_call.return_data[0] - totalDeposited:
                                                    sub_bf4c8572 = 0
                                                    mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                                    mem[ceil32(return_data.size) + 132] = -1
                                                    require ext_code.size(sub_b8ab24bdAddress)
                                                    call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args lendingPoolAddress, -1
                                                    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                    mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                                    mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                                    mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                                    require ext_code.size(lendingPoolAddress)
                                                    call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                         gas gas_remaining wei
                                                        args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                                    mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                                    mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                                    mem[(4 * ceil32(return_data.size)) + 132] = -1
                                                    require ext_code.size(assetAddress)
                                                    call assetAddress.approve(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args routerAddress, -1
                                                    mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                    if assetAddress == WAVAXAddress:
                                                        mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                        mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                        mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                        mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                        mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + 128
                                                        t = (6 * ceil32(return_data.size)) + 388
                                                        while idx < 2:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                        mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                        require ext_code.size(routerAddress)
                                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = (7 * ceil32(return_data.size)) + 192
                                                        require return_data.size >= 32
                                                        _12751 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                        require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                        _13153 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                        mem[(7 * ceil32(return_data.size)) + 192] = _13153
                                                        require _12751 + (32 * _13153) + 32 <= return_data.size
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + _12751 + 224
                                                        t = (7 * ceil32(return_data.size)) + 224
                                                        while idx < _13153:
                                                            require mem[s] == mem[s]
                                                            mem[t] = mem[s]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[mem[64] + 4] = this.address
                                                        require ext_code.size(rewardTokenAddress)
                                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args address(this.address)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _19211 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_19211] == mem[_19211]
                                                        if sub_0b4b41bc <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require sub_0b4b41bc
                                                        sub_7f94bf16 = mem[_19211] / sub_0b4b41bc
                                                        mem[mem[64] + 4] = treasuryAddress
                                                        mem[mem[64] + 36] = 0
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args treasuryAddress, 0
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _21377 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_21377] == bool(mem[_21377])
                                                    else:
                                                        if rewardTokenAddress == WAVAXAddress:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 388
                                                            while idx < 2:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 192
                                                            require return_data.size >= 32
                                                            _12753 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                            require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                            _13155 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                            mem[(7 * ceil32(return_data.size)) + 192] = _13155
                                                            require _12753 + (32 * _13155) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12753 + 224
                                                            t = (7 * ceil32(return_data.size)) + 224
                                                            while idx < _13155:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19213 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19213] == mem[_19213]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19213] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = 0
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, 0
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21379 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21379] == bool(mem[_21379])
                                                        else:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 228] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 420
                                                            while idx < 3:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 224
                                                            require return_data.size >= 32
                                                            _12752 = mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                            require mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                            _13154 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256
                                                            mem[(7 * ceil32(return_data.size)) + 224] = _13154
                                                            require _12752 + (32 * _13154) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12752 + 256
                                                            t = (7 * ceil32(return_data.size)) + 256
                                                            while idx < _13154:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19212 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19212] == mem[_19212]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19212] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = 0
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, 0
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21378 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21378] == bool(mem[_21378])
                                                else:
                                                    require ext_call.return_data[0] - totalDeposited
                                                    if (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / ext_call.return_data[0] - totalDeposited != sub_7e72b29f:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    sub_bf4c8572 = (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / 10000
                                                    mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                                    mem[ceil32(return_data.size) + 132] = -1
                                                    require ext_code.size(sub_b8ab24bdAddress)
                                                    call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args lendingPoolAddress, -1
                                                    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                    mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                                    mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                                    mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                                    require ext_code.size(lendingPoolAddress)
                                                    call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                         gas gas_remaining wei
                                                        args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                                    mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                                    mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                                    mem[(4 * ceil32(return_data.size)) + 132] = -1
                                                    require ext_code.size(assetAddress)
                                                    call assetAddress.approve(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args routerAddress, -1
                                                    mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                    if assetAddress == WAVAXAddress:
                                                        mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                        mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                        mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                        mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                        mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + 128
                                                        t = (6 * ceil32(return_data.size)) + 388
                                                        while idx < 2:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                        mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                        require ext_code.size(routerAddress)
                                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = (7 * ceil32(return_data.size)) + 192
                                                        require return_data.size >= 32
                                                        _12748 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                        require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                        _13150 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                        mem[(7 * ceil32(return_data.size)) + 192] = _13150
                                                        require _12748 + (32 * _13150) + 32 <= return_data.size
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + _12748 + 224
                                                        t = (7 * ceil32(return_data.size)) + 224
                                                        while idx < _13150:
                                                            require mem[s] == mem[s]
                                                            mem[t] = mem[s]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[mem[64] + 4] = this.address
                                                        require ext_code.size(rewardTokenAddress)
                                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args address(this.address)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _19208 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_19208] == mem[_19208]
                                                        if sub_0b4b41bc <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require sub_0b4b41bc
                                                        sub_7f94bf16 = mem[_19208] / sub_0b4b41bc
                                                        mem[mem[64] + 4] = treasuryAddress
                                                        mem[mem[64] + 36] = 0
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args treasuryAddress, 0
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _21374 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_21374] == bool(mem[_21374])
                                                    else:
                                                        if rewardTokenAddress == WAVAXAddress:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 388
                                                            while idx < 2:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 192
                                                            require return_data.size >= 32
                                                            _12750 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                            require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                            _13152 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                            mem[(7 * ceil32(return_data.size)) + 192] = _13152
                                                            require _12750 + (32 * _13152) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12750 + 224
                                                            t = (7 * ceil32(return_data.size)) + 224
                                                            while idx < _13152:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19210 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19210] == mem[_19210]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19210] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = 0
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, 0
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21376 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21376] == bool(mem[_21376])
                                                        else:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 228] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 420
                                                            while idx < 3:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 224
                                                            require return_data.size >= 32
                                                            _12749 = mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                            require mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                            _13151 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256
                                                            mem[(7 * ceil32(return_data.size)) + 224] = _13151
                                                            require _12749 + (32 * _13151) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12749 + 256
                                                            t = (7 * ceil32(return_data.size)) + 256
                                                            while idx < _13151:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19209 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19209] == mem[_19209]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19209] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = 0
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, 0
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21375 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21375] == bool(mem[_21375])
                                        else:
                                            require ext_call.return_data[0] - totalDeposited
                                            if (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / ext_call.return_data[0] - totalDeposited != sub_7796ff37:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not ext_call.return_data[0] - totalDeposited:
                                                if not ext_call.return_data[0] - totalDeposited:
                                                    sub_bf4c8572 = 0
                                                    mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                                    mem[ceil32(return_data.size) + 132] = -1
                                                    require ext_code.size(sub_b8ab24bdAddress)
                                                    call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args lendingPoolAddress, -1
                                                    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                    mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                                    mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                                    mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                                    require ext_code.size(lendingPoolAddress)
                                                    call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                         gas gas_remaining wei
                                                        args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                                    mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                                    mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                                    mem[(4 * ceil32(return_data.size)) + 132] = -1
                                                    require ext_code.size(assetAddress)
                                                    call assetAddress.approve(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args routerAddress, -1
                                                    mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                    if assetAddress == WAVAXAddress:
                                                        mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                        mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                        mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                        mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                        mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + 128
                                                        t = (6 * ceil32(return_data.size)) + 388
                                                        while idx < 2:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                        mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                        require ext_code.size(routerAddress)
                                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = (7 * ceil32(return_data.size)) + 192
                                                        require return_data.size >= 32
                                                        _12745 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                        require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                        _13147 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                        mem[(7 * ceil32(return_data.size)) + 192] = _13147
                                                        require _12745 + (32 * _13147) + 32 <= return_data.size
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + _12745 + 224
                                                        t = (7 * ceil32(return_data.size)) + 224
                                                        while idx < _13147:
                                                            require mem[s] == mem[s]
                                                            mem[t] = mem[s]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[mem[64] + 4] = this.address
                                                        require ext_code.size(rewardTokenAddress)
                                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args address(this.address)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _19205 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_19205] == mem[_19205]
                                                        if sub_0b4b41bc <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require sub_0b4b41bc
                                                        sub_7f94bf16 = mem[_19205] / sub_0b4b41bc
                                                        mem[mem[64] + 4] = treasuryAddress
                                                        mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _21371 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_21371] == bool(mem[_21371])
                                                    else:
                                                        if rewardTokenAddress == WAVAXAddress:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 388
                                                            while idx < 2:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 192
                                                            require return_data.size >= 32
                                                            _12747 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                            require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                            _13149 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                            mem[(7 * ceil32(return_data.size)) + 192] = _13149
                                                            require _12747 + (32 * _13149) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12747 + 224
                                                            t = (7 * ceil32(return_data.size)) + 224
                                                            while idx < _13149:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19207 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19207] == mem[_19207]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19207] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21373 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21373] == bool(mem[_21373])
                                                        else:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 420
                                                            while idx < 3:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args 0, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 224
                                                            require return_data.size >= 32
                                                            _12746 = mem[(6 * ceil32(return_data.size)) + 224 len 4], 0
                                                            require mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                            _13148 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256
                                                            mem[(7 * ceil32(return_data.size)) + 224] = _13148
                                                            require _12746 + (32 * _13148) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12746 + 256
                                                            t = (7 * ceil32(return_data.size)) + 256
                                                            while idx < _13148:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19206 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19206] == mem[_19206]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19206] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21372 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21372] == bool(mem[_21372])
                                                else:
                                                    require ext_call.return_data[0] - totalDeposited
                                                    if (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / ext_call.return_data[0] - totalDeposited != sub_7e72b29f:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    sub_bf4c8572 = (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / 10000
                                                    mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                                    mem[ceil32(return_data.size) + 132] = -1
                                                    require ext_code.size(sub_b8ab24bdAddress)
                                                    call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args lendingPoolAddress, -1
                                                    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                    mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                                    mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                                    mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                                    require ext_code.size(lendingPoolAddress)
                                                    call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                         gas gas_remaining wei
                                                        args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                                    mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                                    mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                                    mem[(4 * ceil32(return_data.size)) + 132] = -1
                                                    require ext_code.size(assetAddress)
                                                    call assetAddress.approve(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args routerAddress, -1
                                                    mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                    if assetAddress == WAVAXAddress:
                                                        mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                        mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                        mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                        mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                        mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + 128
                                                        t = (6 * ceil32(return_data.size)) + 388
                                                        while idx < 2:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                        mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                        require ext_code.size(routerAddress)
                                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = (7 * ceil32(return_data.size)) + 192
                                                        require return_data.size >= 32
                                                        _12742 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                        require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                        _13144 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                        mem[(7 * ceil32(return_data.size)) + 192] = _13144
                                                        require _12742 + (32 * _13144) + 32 <= return_data.size
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + _12742 + 224
                                                        t = (7 * ceil32(return_data.size)) + 224
                                                        while idx < _13144:
                                                            require mem[s] == mem[s]
                                                            mem[t] = mem[s]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[mem[64] + 4] = this.address
                                                        require ext_code.size(rewardTokenAddress)
                                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args address(this.address)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _19202 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_19202] == mem[_19202]
                                                        if sub_0b4b41bc <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require sub_0b4b41bc
                                                        sub_7f94bf16 = mem[_19202] / sub_0b4b41bc
                                                        mem[mem[64] + 4] = treasuryAddress
                                                        mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _21368 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_21368] == bool(mem[_21368])
                                                    else:
                                                        if rewardTokenAddress == WAVAXAddress:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 388
                                                            while idx < 2:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 192
                                                            require return_data.size >= 32
                                                            _12744 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                            require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                            _13146 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                            mem[(7 * ceil32(return_data.size)) + 192] = _13146
                                                            require _12744 + (32 * _13146) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12744 + 224
                                                            t = (7 * ceil32(return_data.size)) + 224
                                                            while idx < _13146:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19204 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19204] == mem[_19204]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19204] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21370 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21370] == bool(mem[_21370])
                                                        else:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 420
                                                            while idx < 3:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args 0, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 224
                                                            require return_data.size >= 32
                                                            _12743 = mem[(6 * ceil32(return_data.size)) + 224 len 4], 0
                                                            require mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                            _13145 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256
                                                            mem[(7 * ceil32(return_data.size)) + 224] = _13145
                                                            require _12743 + (32 * _13145) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12743 + 256
                                                            t = (7 * ceil32(return_data.size)) + 256
                                                            while idx < _13145:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19203 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19203] == mem[_19203]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19203] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21369 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21369] == bool(mem[_21369])
                                            else:
                                                require ext_call.return_data[0] - totalDeposited
                                                if (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / ext_call.return_data[0] - totalDeposited != sub_2f6236be:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not ext_call.return_data[0] - totalDeposited:
                                                    sub_bf4c8572 = 0
                                                    mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                                    mem[ceil32(return_data.size) + 132] = -1
                                                    require ext_code.size(sub_b8ab24bdAddress)
                                                    call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args lendingPoolAddress, -1
                                                    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                    mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                                    mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                                    mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                                    require ext_code.size(lendingPoolAddress)
                                                    call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                         gas gas_remaining wei
                                                        args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                                    mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                                    mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                                    mem[(4 * ceil32(return_data.size)) + 132] = -1
                                                    require ext_code.size(assetAddress)
                                                    call assetAddress.approve(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args routerAddress, -1
                                                    mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                    if assetAddress == WAVAXAddress:
                                                        mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                        mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                        mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                        mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                        mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + 128
                                                        t = (6 * ceil32(return_data.size)) + 388
                                                        while idx < 2:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                        mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                        require ext_code.size(routerAddress)
                                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = (7 * ceil32(return_data.size)) + 192
                                                        require return_data.size >= 32
                                                        _12739 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                        require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                        _13141 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                        mem[(7 * ceil32(return_data.size)) + 192] = _13141
                                                        require _12739 + (32 * _13141) + 32 <= return_data.size
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + _12739 + 224
                                                        t = (7 * ceil32(return_data.size)) + 224
                                                        while idx < _13141:
                                                            require mem[s] == mem[s]
                                                            mem[t] = mem[s]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[mem[64] + 4] = this.address
                                                        require ext_code.size(rewardTokenAddress)
                                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args address(this.address)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _19199 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_19199] == mem[_19199]
                                                        if sub_0b4b41bc <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require sub_0b4b41bc
                                                        sub_7f94bf16 = mem[_19199] / sub_0b4b41bc
                                                        mem[mem[64] + 4] = treasuryAddress
                                                        mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _21365 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_21365] == bool(mem[_21365])
                                                    else:
                                                        if rewardTokenAddress == WAVAXAddress:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 388
                                                            while idx < 2:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 192
                                                            require return_data.size >= 32
                                                            _12741 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                            require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                            _13143 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                            mem[(7 * ceil32(return_data.size)) + 192] = _13143
                                                            require _12741 + (32 * _13143) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12741 + 224
                                                            t = (7 * ceil32(return_data.size)) + 224
                                                            while idx < _13143:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19201 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19201] == mem[_19201]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19201] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21367 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21367] == bool(mem[_21367])
                                                        else:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 228] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 420
                                                            while idx < 3:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 224
                                                            require return_data.size >= 32
                                                            _12740 = mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                            require mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                            _13142 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256
                                                            mem[(7 * ceil32(return_data.size)) + 224] = _13142
                                                            require _12740 + (32 * _13142) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12740 + 256
                                                            t = (7 * ceil32(return_data.size)) + 256
                                                            while idx < _13142:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19200 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19200] == mem[_19200]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19200] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21366 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21366] == bool(mem[_21366])
                                                else:
                                                    require ext_call.return_data[0] - totalDeposited
                                                    if (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / ext_call.return_data[0] - totalDeposited != sub_7e72b29f:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    sub_bf4c8572 = (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / 10000
                                                    mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                                    mem[ceil32(return_data.size) + 132] = -1
                                                    require ext_code.size(sub_b8ab24bdAddress)
                                                    call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args lendingPoolAddress, -1
                                                    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                    mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                                    mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                                    mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                                    require ext_code.size(lendingPoolAddress)
                                                    call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                         gas gas_remaining wei
                                                        args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                                    mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                                    mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                                    mem[(4 * ceil32(return_data.size)) + 132] = -1
                                                    require ext_code.size(assetAddress)
                                                    call assetAddress.approve(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args routerAddress, -1
                                                    mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                    if assetAddress == WAVAXAddress:
                                                        mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                        mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                        mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                        mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                        mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + 128
                                                        t = (6 * ceil32(return_data.size)) + 388
                                                        while idx < 2:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                        mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                        require ext_code.size(routerAddress)
                                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = (7 * ceil32(return_data.size)) + 192
                                                        require return_data.size >= 32
                                                        _12736 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                        require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                        _13138 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                        mem[(7 * ceil32(return_data.size)) + 192] = _13138
                                                        require _12736 + (32 * _13138) + 32 <= return_data.size
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + _12736 + 224
                                                        t = (7 * ceil32(return_data.size)) + 224
                                                        while idx < _13138:
                                                            require mem[s] == mem[s]
                                                            mem[t] = mem[s]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[mem[64] + 4] = this.address
                                                        require ext_code.size(rewardTokenAddress)
                                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args address(this.address)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _19196 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_19196] == mem[_19196]
                                                        if sub_0b4b41bc <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require sub_0b4b41bc
                                                        sub_7f94bf16 = mem[_19196] / sub_0b4b41bc
                                                        mem[mem[64] + 4] = treasuryAddress
                                                        mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _21362 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_21362] == bool(mem[_21362])
                                                    else:
                                                        if rewardTokenAddress == WAVAXAddress:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 388
                                                            while idx < 2:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 192
                                                            require return_data.size >= 32
                                                            _12738 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                            require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                            _13140 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                            mem[(7 * ceil32(return_data.size)) + 192] = _13140
                                                            require _12738 + (32 * _13140) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12738 + 224
                                                            t = (7 * ceil32(return_data.size)) + 224
                                                            while idx < _13140:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19198 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19198] == mem[_19198]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19198] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21364 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21364] == bool(mem[_21364])
                                                        else:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 228] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 420
                                                            while idx < 3:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 224
                                                            require return_data.size >= 32
                                                            _12737 = mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                            require mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                            _13139 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256
                                                            mem[(7 * ceil32(return_data.size)) + 224] = _13139
                                                            require _12737 + (32 * _13139) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12737 + 256
                                                            t = (7 * ceil32(return_data.size)) + 256
                                                            while idx < _13139:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19197 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19197] == mem[_19197]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19197] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21363 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21363] == bool(mem[_21363])
                                    else:
                                        require (block.timestamp * sub_f12c8e0d) - (lastRewardTimestamp * sub_f12c8e0d)
                                        if (block.timestamp * sub_f12c8e0d) - (lastRewardTimestamp * sub_f12c8e0d) / (block.timestamp * sub_f12c8e0d) - (lastRewardTimestamp * sub_f12c8e0d) != 1:
                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
                                        require ext_code.size(rewardWalletAddress)
                                        call rewardWalletAddress.requestReward(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args ((block.timestamp * sub_f12c8e0d) - (lastRewardTimestamp * sub_f12c8e0d))
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if totalDeposited <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalDeposited
                                        if sub_a9ac33dd + (0 / totalDeposited) < sub_a9ac33dd:
                                            revert with 0, 'SafeMath: addition overflow'
                                        sub_a9ac33dd += 0 / totalDeposited
                                        lastRewardTimestamp = block.timestamp
                                        mem[100] = this.address
                                        require ext_code.size(sub_b8ab24bdAddress)
                                        staticcall sub_b8ab24bdAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[96] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == ext_call.return_data[0]
                                        if not ext_call.return_data[0] - totalDeposited:
                                            if not ext_call.return_data[0] - totalDeposited:
                                                if not ext_call.return_data[0] - totalDeposited:
                                                    sub_bf4c8572 = 0
                                                    mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                                    mem[ceil32(return_data.size) + 132] = -1
                                                    require ext_code.size(sub_b8ab24bdAddress)
                                                    call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args lendingPoolAddress, -1
                                                    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                    mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                                    mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                                    mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                                    require ext_code.size(lendingPoolAddress)
                                                    call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                         gas gas_remaining wei
                                                        args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                                    mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                                    mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                                    mem[(4 * ceil32(return_data.size)) + 132] = -1
                                                    require ext_code.size(assetAddress)
                                                    call assetAddress.approve(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args routerAddress, -1
                                                    mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                    if assetAddress == WAVAXAddress:
                                                        mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                        mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                        mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                        mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                        mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + 128
                                                        t = (6 * ceil32(return_data.size)) + 388
                                                        while idx < 2:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                        mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                        require ext_code.size(routerAddress)
                                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = (7 * ceil32(return_data.size)) + 192
                                                        require return_data.size >= 32
                                                        _12733 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                        require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                        _13135 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                        mem[(7 * ceil32(return_data.size)) + 192] = _13135
                                                        require _12733 + (32 * _13135) + 32 <= return_data.size
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + _12733 + 224
                                                        t = (7 * ceil32(return_data.size)) + 224
                                                        while idx < _13135:
                                                            require mem[s] == mem[s]
                                                            mem[t] = mem[s]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[mem[64] + 4] = this.address
                                                        require ext_code.size(rewardTokenAddress)
                                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args address(this.address)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _19193 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_19193] == mem[_19193]
                                                        if sub_0b4b41bc <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require sub_0b4b41bc
                                                        sub_7f94bf16 = mem[_19193] / sub_0b4b41bc
                                                        mem[mem[64] + 4] = treasuryAddress
                                                        mem[mem[64] + 36] = 0
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args treasuryAddress, 0
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _21359 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_21359] == bool(mem[_21359])
                                                    else:
                                                        if rewardTokenAddress == WAVAXAddress:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 388
                                                            while idx < 2:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 192
                                                            require return_data.size >= 32
                                                            _12735 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                            require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                            _13137 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                            mem[(7 * ceil32(return_data.size)) + 192] = _13137
                                                            require _12735 + (32 * _13137) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12735 + 224
                                                            t = (7 * ceil32(return_data.size)) + 224
                                                            while idx < _13137:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19195 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19195] == mem[_19195]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19195] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = 0
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, 0
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21361 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21361] == bool(mem[_21361])
                                                        else:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 420
                                                            while idx < 3:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args 0, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 224
                                                            require return_data.size >= 32
                                                            _12734 = mem[(6 * ceil32(return_data.size)) + 224 len 4], 0
                                                            require mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                            _13136 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256
                                                            mem[(7 * ceil32(return_data.size)) + 224] = _13136
                                                            require _12734 + (32 * _13136) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12734 + 256
                                                            t = (7 * ceil32(return_data.size)) + 256
                                                            while idx < _13136:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19194 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19194] == mem[_19194]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19194] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = 0
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, 0
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21360 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21360] == bool(mem[_21360])
                                                else:
                                                    require ext_call.return_data[0] - totalDeposited
                                                    if (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / ext_call.return_data[0] - totalDeposited != sub_7e72b29f:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    sub_bf4c8572 = (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / 10000
                                                    mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                                    mem[ceil32(return_data.size) + 132] = -1
                                                    require ext_code.size(sub_b8ab24bdAddress)
                                                    call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args lendingPoolAddress, -1
                                                    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                    mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                                    mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                                    mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                                    require ext_code.size(lendingPoolAddress)
                                                    call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                         gas gas_remaining wei
                                                        args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                                    mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                                    mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                                    mem[(4 * ceil32(return_data.size)) + 132] = -1
                                                    require ext_code.size(assetAddress)
                                                    call assetAddress.approve(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args routerAddress, -1
                                                    mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                    if assetAddress == WAVAXAddress:
                                                        mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                        mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                        mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                        mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                        mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + 128
                                                        t = (6 * ceil32(return_data.size)) + 388
                                                        while idx < 2:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                        mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                        require ext_code.size(routerAddress)
                                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = (7 * ceil32(return_data.size)) + 192
                                                        require return_data.size >= 32
                                                        _12730 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                        require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                        _13132 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                        mem[(7 * ceil32(return_data.size)) + 192] = _13132
                                                        require _12730 + (32 * _13132) + 32 <= return_data.size
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + _12730 + 224
                                                        t = (7 * ceil32(return_data.size)) + 224
                                                        while idx < _13132:
                                                            require mem[s] == mem[s]
                                                            mem[t] = mem[s]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[mem[64] + 4] = this.address
                                                        require ext_code.size(rewardTokenAddress)
                                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args address(this.address)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _19190 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_19190] == mem[_19190]
                                                        if sub_0b4b41bc <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require sub_0b4b41bc
                                                        sub_7f94bf16 = mem[_19190] / sub_0b4b41bc
                                                        mem[mem[64] + 4] = treasuryAddress
                                                        mem[mem[64] + 36] = 0
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args treasuryAddress, 0
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _21356 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_21356] == bool(mem[_21356])
                                                    else:
                                                        if rewardTokenAddress == WAVAXAddress:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 388
                                                            while idx < 2:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 192
                                                            require return_data.size >= 32
                                                            _12732 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                            require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                            _13134 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                            mem[(7 * ceil32(return_data.size)) + 192] = _13134
                                                            require _12732 + (32 * _13134) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12732 + 224
                                                            t = (7 * ceil32(return_data.size)) + 224
                                                            while idx < _13134:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19192 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19192] == mem[_19192]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19192] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = 0
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, 0
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21358 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21358] == bool(mem[_21358])
                                                        else:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 420
                                                            while idx < 3:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args 0, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 224
                                                            require return_data.size >= 32
                                                            _12731 = mem[(6 * ceil32(return_data.size)) + 224 len 4], 0
                                                            require mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                            _13133 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256
                                                            mem[(7 * ceil32(return_data.size)) + 224] = _13133
                                                            require _12731 + (32 * _13133) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12731 + 256
                                                            t = (7 * ceil32(return_data.size)) + 256
                                                            while idx < _13133:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19191 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19191] == mem[_19191]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19191] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = 0
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, 0
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21357 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21357] == bool(mem[_21357])
                                            else:
                                                require ext_call.return_data[0] - totalDeposited
                                                if (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / ext_call.return_data[0] - totalDeposited != sub_2f6236be:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not ext_call.return_data[0] - totalDeposited:
                                                    sub_bf4c8572 = 0
                                                    mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                                    mem[ceil32(return_data.size) + 132] = -1
                                                    require ext_code.size(sub_b8ab24bdAddress)
                                                    call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args lendingPoolAddress, -1
                                                    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                    mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                                    mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                                    mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                                    require ext_code.size(lendingPoolAddress)
                                                    call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                         gas gas_remaining wei
                                                        args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                                    mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                                    mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                                    mem[(4 * ceil32(return_data.size)) + 132] = -1
                                                    require ext_code.size(assetAddress)
                                                    call assetAddress.approve(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args routerAddress, -1
                                                    mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                    if assetAddress == WAVAXAddress:
                                                        mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                        mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                        mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                        mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                        mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + 128
                                                        t = (6 * ceil32(return_data.size)) + 388
                                                        while idx < 2:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                        mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                        require ext_code.size(routerAddress)
                                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = (7 * ceil32(return_data.size)) + 192
                                                        require return_data.size >= 32
                                                        _12727 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                        require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                        _13129 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                        mem[(7 * ceil32(return_data.size)) + 192] = _13129
                                                        require _12727 + (32 * _13129) + 32 <= return_data.size
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + _12727 + 224
                                                        t = (7 * ceil32(return_data.size)) + 224
                                                        while idx < _13129:
                                                            require mem[s] == mem[s]
                                                            mem[t] = mem[s]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[mem[64] + 4] = this.address
                                                        require ext_code.size(rewardTokenAddress)
                                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args address(this.address)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _19187 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_19187] == mem[_19187]
                                                        if sub_0b4b41bc <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require sub_0b4b41bc
                                                        sub_7f94bf16 = mem[_19187] / sub_0b4b41bc
                                                        mem[mem[64] + 4] = treasuryAddress
                                                        mem[mem[64] + 36] = 0
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args treasuryAddress, 0
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _21353 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_21353] == bool(mem[_21353])
                                                    else:
                                                        if rewardTokenAddress == WAVAXAddress:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 388
                                                            while idx < 2:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 192
                                                            require return_data.size >= 32
                                                            _12729 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                            require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                            _13131 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                            mem[(7 * ceil32(return_data.size)) + 192] = _13131
                                                            require _12729 + (32 * _13131) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12729 + 224
                                                            t = (7 * ceil32(return_data.size)) + 224
                                                            while idx < _13131:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19189 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19189] == mem[_19189]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19189] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = 0
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, 0
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21355 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21355] == bool(mem[_21355])
                                                        else:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 228] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 420
                                                            while idx < 3:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 224
                                                            require return_data.size >= 32
                                                            _12728 = mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                            require mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                            _13130 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256
                                                            mem[(7 * ceil32(return_data.size)) + 224] = _13130
                                                            require _12728 + (32 * _13130) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12728 + 256
                                                            t = (7 * ceil32(return_data.size)) + 256
                                                            while idx < _13130:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19188 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19188] == mem[_19188]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19188] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = 0
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, 0
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21354 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21354] == bool(mem[_21354])
                                                else:
                                                    require ext_call.return_data[0] - totalDeposited
                                                    if (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / ext_call.return_data[0] - totalDeposited != sub_7e72b29f:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    sub_bf4c8572 = (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / 10000
                                                    mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                                    mem[ceil32(return_data.size) + 132] = -1
                                                    require ext_code.size(sub_b8ab24bdAddress)
                                                    call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args lendingPoolAddress, -1
                                                    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                    mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                                    mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                                    mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                                    require ext_code.size(lendingPoolAddress)
                                                    call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                         gas gas_remaining wei
                                                        args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                                    mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                                    mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                                    mem[(4 * ceil32(return_data.size)) + 132] = -1
                                                    require ext_code.size(assetAddress)
                                                    call assetAddress.approve(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args routerAddress, -1
                                                    mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                    if assetAddress == WAVAXAddress:
                                                        mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                        mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                        mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                        mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                        mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + 128
                                                        t = (6 * ceil32(return_data.size)) + 388
                                                        while idx < 2:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                        mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                        require ext_code.size(routerAddress)
                                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = (7 * ceil32(return_data.size)) + 192
                                                        require return_data.size >= 32
                                                        _12724 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                        require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                        _13126 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                        mem[(7 * ceil32(return_data.size)) + 192] = _13126
                                                        require _12724 + (32 * _13126) + 32 <= return_data.size
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + _12724 + 224
                                                        t = (7 * ceil32(return_data.size)) + 224
                                                        while idx < _13126:
                                                            require mem[s] == mem[s]
                                                            mem[t] = mem[s]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[mem[64] + 4] = this.address
                                                        require ext_code.size(rewardTokenAddress)
                                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args address(this.address)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _19184 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_19184] == mem[_19184]
                                                        if sub_0b4b41bc <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require sub_0b4b41bc
                                                        sub_7f94bf16 = mem[_19184] / sub_0b4b41bc
                                                        mem[mem[64] + 4] = treasuryAddress
                                                        mem[mem[64] + 36] = 0
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args treasuryAddress, 0
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _21350 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_21350] == bool(mem[_21350])
                                                    else:
                                                        if rewardTokenAddress == WAVAXAddress:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 388
                                                            while idx < 2:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 192
                                                            require return_data.size >= 32
                                                            _12726 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                            require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                            _13128 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                            mem[(7 * ceil32(return_data.size)) + 192] = _13128
                                                            require _12726 + (32 * _13128) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12726 + 224
                                                            t = (7 * ceil32(return_data.size)) + 224
                                                            while idx < _13128:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19186 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19186] == mem[_19186]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19186] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = 0
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, 0
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21352 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21352] == bool(mem[_21352])
                                                        else:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 228] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 420
                                                            while idx < 3:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 224
                                                            require return_data.size >= 32
                                                            _12725 = mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                            require mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                            _13127 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256
                                                            mem[(7 * ceil32(return_data.size)) + 224] = _13127
                                                            require _12725 + (32 * _13127) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12725 + 256
                                                            t = (7 * ceil32(return_data.size)) + 256
                                                            while idx < _13127:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19185 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19185] == mem[_19185]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19185] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = 0
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, 0
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21351 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21351] == bool(mem[_21351])
                                        else:
                                            require ext_call.return_data[0] - totalDeposited
                                            if (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / ext_call.return_data[0] - totalDeposited != sub_7796ff37:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not ext_call.return_data[0] - totalDeposited:
                                                if not ext_call.return_data[0] - totalDeposited:
                                                    sub_bf4c8572 = 0
                                                    mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                                    mem[ceil32(return_data.size) + 132] = -1
                                                    require ext_code.size(sub_b8ab24bdAddress)
                                                    call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args lendingPoolAddress, -1
                                                    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                    mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                                    mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                                    mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                                    require ext_code.size(lendingPoolAddress)
                                                    call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                         gas gas_remaining wei
                                                        args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                                    mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                                    mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                                    mem[(4 * ceil32(return_data.size)) + 132] = -1
                                                    require ext_code.size(assetAddress)
                                                    call assetAddress.approve(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args routerAddress, -1
                                                    mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                    if assetAddress == WAVAXAddress:
                                                        mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                        mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                        mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                        mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                        mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + 128
                                                        t = (6 * ceil32(return_data.size)) + 388
                                                        while idx < 2:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                        mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                        require ext_code.size(routerAddress)
                                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = (7 * ceil32(return_data.size)) + 192
                                                        require return_data.size >= 32
                                                        _12721 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                        require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                        _13123 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                        mem[(7 * ceil32(return_data.size)) + 192] = _13123
                                                        require _12721 + (32 * _13123) + 32 <= return_data.size
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + _12721 + 224
                                                        t = (7 * ceil32(return_data.size)) + 224
                                                        while idx < _13123:
                                                            require mem[s] == mem[s]
                                                            mem[t] = mem[s]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[mem[64] + 4] = this.address
                                                        require ext_code.size(rewardTokenAddress)
                                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args address(this.address)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _19181 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_19181] == mem[_19181]
                                                        if sub_0b4b41bc <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require sub_0b4b41bc
                                                        sub_7f94bf16 = mem[_19181] / sub_0b4b41bc
                                                        mem[mem[64] + 4] = treasuryAddress
                                                        mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _21347 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_21347] == bool(mem[_21347])
                                                    else:
                                                        if rewardTokenAddress == WAVAXAddress:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 388
                                                            while idx < 2:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 192
                                                            require return_data.size >= 32
                                                            _12723 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                            require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                            _13125 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                            mem[(7 * ceil32(return_data.size)) + 192] = _13125
                                                            require _12723 + (32 * _13125) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12723 + 224
                                                            t = (7 * ceil32(return_data.size)) + 224
                                                            while idx < _13125:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19183 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19183] == mem[_19183]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19183] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21349 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21349] == bool(mem[_21349])
                                                        else:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 420
                                                            while idx < 3:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args 0, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 224
                                                            require return_data.size >= 32
                                                            _12722 = mem[(6 * ceil32(return_data.size)) + 224 len 4], 0
                                                            require mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                            _13124 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256
                                                            mem[(7 * ceil32(return_data.size)) + 224] = _13124
                                                            require _12722 + (32 * _13124) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12722 + 256
                                                            t = (7 * ceil32(return_data.size)) + 256
                                                            while idx < _13124:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19182 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19182] == mem[_19182]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19182] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21348 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21348] == bool(mem[_21348])
                                                else:
                                                    require ext_call.return_data[0] - totalDeposited
                                                    if (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / ext_call.return_data[0] - totalDeposited != sub_7e72b29f:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    sub_bf4c8572 = (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / 10000
                                                    mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                                    mem[ceil32(return_data.size) + 132] = -1
                                                    require ext_code.size(sub_b8ab24bdAddress)
                                                    call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args lendingPoolAddress, -1
                                                    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                    mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                                    mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                                    mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                                    require ext_code.size(lendingPoolAddress)
                                                    call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                         gas gas_remaining wei
                                                        args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                                    mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                                    mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                                    mem[(4 * ceil32(return_data.size)) + 132] = -1
                                                    require ext_code.size(assetAddress)
                                                    call assetAddress.approve(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args routerAddress, -1
                                                    mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                    if assetAddress == WAVAXAddress:
                                                        mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                        mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                        mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                        mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                        mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + 128
                                                        t = (6 * ceil32(return_data.size)) + 388
                                                        while idx < 2:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                        mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                        require ext_code.size(routerAddress)
                                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = (7 * ceil32(return_data.size)) + 192
                                                        require return_data.size >= 32
                                                        _12718 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                        require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                        _13120 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                        mem[(7 * ceil32(return_data.size)) + 192] = _13120
                                                        require _12718 + (32 * _13120) + 32 <= return_data.size
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + _12718 + 224
                                                        t = (7 * ceil32(return_data.size)) + 224
                                                        while idx < _13120:
                                                            require mem[s] == mem[s]
                                                            mem[t] = mem[s]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[mem[64] + 4] = this.address
                                                        require ext_code.size(rewardTokenAddress)
                                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args address(this.address)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _19178 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_19178] == mem[_19178]
                                                        if sub_0b4b41bc <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require sub_0b4b41bc
                                                        sub_7f94bf16 = mem[_19178] / sub_0b4b41bc
                                                        mem[mem[64] + 4] = treasuryAddress
                                                        mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _21344 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_21344] == bool(mem[_21344])
                                                    else:
                                                        if rewardTokenAddress == WAVAXAddress:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 388
                                                            while idx < 2:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 192
                                                            require return_data.size >= 32
                                                            _12720 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                            require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                            _13122 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                            mem[(7 * ceil32(return_data.size)) + 192] = _13122
                                                            require _12720 + (32 * _13122) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12720 + 224
                                                            t = (7 * ceil32(return_data.size)) + 224
                                                            while idx < _13122:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19180 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19180] == mem[_19180]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19180] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21346 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21346] == bool(mem[_21346])
                                                        else:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 420
                                                            while idx < 3:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args 0, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 224
                                                            require return_data.size >= 32
                                                            _12719 = mem[(6 * ceil32(return_data.size)) + 224 len 4], 0
                                                            require mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                            _13121 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256
                                                            mem[(7 * ceil32(return_data.size)) + 224] = _13121
                                                            require _12719 + (32 * _13121) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12719 + 256
                                                            t = (7 * ceil32(return_data.size)) + 256
                                                            while idx < _13121:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19179 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19179] == mem[_19179]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19179] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21345 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21345] == bool(mem[_21345])
                                            else:
                                                require ext_call.return_data[0] - totalDeposited
                                                if (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / ext_call.return_data[0] - totalDeposited != sub_2f6236be:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not ext_call.return_data[0] - totalDeposited:
                                                    sub_bf4c8572 = 0
                                                    mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                                    mem[ceil32(return_data.size) + 132] = -1
                                                    require ext_code.size(sub_b8ab24bdAddress)
                                                    call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args lendingPoolAddress, -1
                                                    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                    mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                                    mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                                    mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                                    require ext_code.size(lendingPoolAddress)
                                                    call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                         gas gas_remaining wei
                                                        args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                                    mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                                    mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                                    mem[(4 * ceil32(return_data.size)) + 132] = -1
                                                    require ext_code.size(assetAddress)
                                                    call assetAddress.approve(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args routerAddress, -1
                                                    mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                    if assetAddress == WAVAXAddress:
                                                        mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                        mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                        mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                        mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                        mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + 128
                                                        t = (6 * ceil32(return_data.size)) + 388
                                                        while idx < 2:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                        mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                        require ext_code.size(routerAddress)
                                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = (7 * ceil32(return_data.size)) + 192
                                                        require return_data.size >= 32
                                                        _12715 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                        require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                        _13117 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                        mem[(7 * ceil32(return_data.size)) + 192] = _13117
                                                        require _12715 + (32 * _13117) + 32 <= return_data.size
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + _12715 + 224
                                                        t = (7 * ceil32(return_data.size)) + 224
                                                        while idx < _13117:
                                                            require mem[s] == mem[s]
                                                            mem[t] = mem[s]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[mem[64] + 4] = this.address
                                                        require ext_code.size(rewardTokenAddress)
                                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args address(this.address)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _19175 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_19175] == mem[_19175]
                                                        if sub_0b4b41bc <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require sub_0b4b41bc
                                                        sub_7f94bf16 = mem[_19175] / sub_0b4b41bc
                                                        mem[mem[64] + 4] = treasuryAddress
                                                        mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _21341 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_21341] == bool(mem[_21341])
                                                    else:
                                                        if rewardTokenAddress == WAVAXAddress:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 388
                                                            while idx < 2:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 192
                                                            require return_data.size >= 32
                                                            _12717 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                            require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                            _13119 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                            mem[(7 * ceil32(return_data.size)) + 192] = _13119
                                                            require _12717 + (32 * _13119) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12717 + 224
                                                            t = (7 * ceil32(return_data.size)) + 224
                                                            while idx < _13119:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19177 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19177] == mem[_19177]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19177] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21343 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21343] == bool(mem[_21343])
                                                        else:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 228] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 420
                                                            while idx < 3:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 224
                                                            require return_data.size >= 32
                                                            _12716 = mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                            require mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                            _13118 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256
                                                            mem[(7 * ceil32(return_data.size)) + 224] = _13118
                                                            require _12716 + (32 * _13118) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12716 + 256
                                                            t = (7 * ceil32(return_data.size)) + 256
                                                            while idx < _13118:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19176 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19176] == mem[_19176]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19176] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21342 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21342] == bool(mem[_21342])
                                                else:
                                                    require ext_call.return_data[0] - totalDeposited
                                                    if (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / ext_call.return_data[0] - totalDeposited != sub_7e72b29f:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    sub_bf4c8572 = (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / 10000
                                                    mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                                    mem[ceil32(return_data.size) + 132] = -1
                                                    require ext_code.size(sub_b8ab24bdAddress)
                                                    call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args lendingPoolAddress, -1
                                                    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                    mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                                    mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                                    mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                                    require ext_code.size(lendingPoolAddress)
                                                    call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                         gas gas_remaining wei
                                                        args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                                    mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                                    mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                                    mem[(4 * ceil32(return_data.size)) + 132] = -1
                                                    require ext_code.size(assetAddress)
                                                    call assetAddress.approve(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args routerAddress, -1
                                                    mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                    if assetAddress == WAVAXAddress:
                                                        mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                        mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                        mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                        mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                        mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + 128
                                                        t = (6 * ceil32(return_data.size)) + 388
                                                        while idx < 2:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                        mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                        require ext_code.size(routerAddress)
                                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = (7 * ceil32(return_data.size)) + 192
                                                        require return_data.size >= 32
                                                        _12712 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                        require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                        _13114 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                        mem[(7 * ceil32(return_data.size)) + 192] = _13114
                                                        require _12712 + (32 * _13114) + 32 <= return_data.size
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + _12712 + 224
                                                        t = (7 * ceil32(return_data.size)) + 224
                                                        while idx < _13114:
                                                            require mem[s] == mem[s]
                                                            mem[t] = mem[s]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[mem[64] + 4] = this.address
                                                        require ext_code.size(rewardTokenAddress)
                                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args address(this.address)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _19172 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_19172] == mem[_19172]
                                                        if sub_0b4b41bc <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require sub_0b4b41bc
                                                        sub_7f94bf16 = mem[_19172] / sub_0b4b41bc
                                                        mem[mem[64] + 4] = treasuryAddress
                                                        mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _21338 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_21338] == bool(mem[_21338])
                                                    else:
                                                        if rewardTokenAddress == WAVAXAddress:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 388
                                                            while idx < 2:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 192
                                                            require return_data.size >= 32
                                                            _12714 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                            require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                            _13116 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                            mem[(7 * ceil32(return_data.size)) + 192] = _13116
                                                            require _12714 + (32 * _13116) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12714 + 224
                                                            t = (7 * ceil32(return_data.size)) + 224
                                                            while idx < _13116:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19174 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19174] == mem[_19174]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19174] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21340 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21340] == bool(mem[_21340])
                                                        else:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 228] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 420
                                                            while idx < 3:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 224
                                                            require return_data.size >= 32
                                                            _12713 = mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                            require mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                            _13115 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256
                                                            mem[(7 * ceil32(return_data.size)) + 224] = _13115
                                                            require _12713 + (32 * _13115) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12713 + 256
                                                            t = (7 * ceil32(return_data.size)) + 256
                                                            while idx < _13115:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19173 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19173] == mem[_19173]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19173] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21339 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21339] == bool(mem[_21339])
                            else:
                                require (sub_f12c8e0d * block.timestamp) + (sub_7f94bf16 * block.timestamp) - (sub_f12c8e0d * lastRewardTimestamp) - (sub_7f94bf16 * lastRewardTimestamp)
                                if (sub_f12c8e0d * block.timestamp) + (sub_7f94bf16 * block.timestamp) - (sub_f12c8e0d * lastRewardTimestamp) - (sub_7f94bf16 * lastRewardTimestamp) / (sub_f12c8e0d * block.timestamp) + (sub_7f94bf16 * block.timestamp) - (sub_f12c8e0d * lastRewardTimestamp) - (sub_7f94bf16 * lastRewardTimestamp) != 1:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
                                if not block.timestamp - lastRewardTimestamp:
                                    require ext_code.size(rewardWalletAddress)
                                    call rewardWalletAddress.requestReward(uint256 arg1) with:
                                         gas gas_remaining wei
                                        args 0
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not (sub_f12c8e0d * block.timestamp) + (sub_7f94bf16 * block.timestamp) - (sub_f12c8e0d * lastRewardTimestamp) - (sub_7f94bf16 * lastRewardTimestamp):
                                        if totalDeposited <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalDeposited
                                        if sub_a9ac33dd + (0 / totalDeposited) < sub_a9ac33dd:
                                            revert with 0, 'SafeMath: addition overflow'
                                        sub_a9ac33dd += 0 / totalDeposited
                                        lastRewardTimestamp = block.timestamp
                                        mem[100] = this.address
                                        require ext_code.size(sub_b8ab24bdAddress)
                                        staticcall sub_b8ab24bdAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[96] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == ext_call.return_data[0]
                                        if not ext_call.return_data[0] - totalDeposited:
                                            if not ext_call.return_data[0] - totalDeposited:
                                                if not ext_call.return_data[0] - totalDeposited:
                                                    sub_bf4c8572 = 0
                                                    mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                                    mem[ceil32(return_data.size) + 132] = -1
                                                    require ext_code.size(sub_b8ab24bdAddress)
                                                    call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args lendingPoolAddress, -1
                                                    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                    mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                                    mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                                    mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                                    require ext_code.size(lendingPoolAddress)
                                                    call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                         gas gas_remaining wei
                                                        args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                                    mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                                    mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                                    mem[(4 * ceil32(return_data.size)) + 132] = -1
                                                    require ext_code.size(assetAddress)
                                                    call assetAddress.approve(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args routerAddress, -1
                                                    mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                    if assetAddress == WAVAXAddress:
                                                        mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                        mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                        mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                        mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                        mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + 128
                                                        t = (6 * ceil32(return_data.size)) + 388
                                                        while idx < 2:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                        mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                        require ext_code.size(routerAddress)
                                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = (7 * ceil32(return_data.size)) + 192
                                                        require return_data.size >= 32
                                                        _12709 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                        require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                        _13111 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                        mem[(7 * ceil32(return_data.size)) + 192] = _13111
                                                        require _12709 + (32 * _13111) + 32 <= return_data.size
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + _12709 + 224
                                                        t = (7 * ceil32(return_data.size)) + 224
                                                        while idx < _13111:
                                                            require mem[s] == mem[s]
                                                            mem[t] = mem[s]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[mem[64] + 4] = this.address
                                                        require ext_code.size(rewardTokenAddress)
                                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args address(this.address)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _19169 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_19169] == mem[_19169]
                                                        if sub_0b4b41bc <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require sub_0b4b41bc
                                                        sub_7f94bf16 = mem[_19169] / sub_0b4b41bc
                                                        mem[mem[64] + 4] = treasuryAddress
                                                        mem[mem[64] + 36] = 0
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args treasuryAddress, 0
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _21335 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_21335] == bool(mem[_21335])
                                                    else:
                                                        if rewardTokenAddress == WAVAXAddress:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 388
                                                            while idx < 2:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 192
                                                            require return_data.size >= 32
                                                            _12711 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                            require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                            _13113 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                            mem[(7 * ceil32(return_data.size)) + 192] = _13113
                                                            require _12711 + (32 * _13113) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12711 + 224
                                                            t = (7 * ceil32(return_data.size)) + 224
                                                            while idx < _13113:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19171 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19171] == mem[_19171]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19171] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = 0
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, 0
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21337 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21337] == bool(mem[_21337])
                                                        else:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 420
                                                            while idx < 3:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args 0, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 224
                                                            require return_data.size >= 32
                                                            _12710 = mem[(6 * ceil32(return_data.size)) + 224 len 4], 0
                                                            require mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                            _13112 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256
                                                            mem[(7 * ceil32(return_data.size)) + 224] = _13112
                                                            require _12710 + (32 * _13112) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12710 + 256
                                                            t = (7 * ceil32(return_data.size)) + 256
                                                            while idx < _13112:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19170 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19170] == mem[_19170]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19170] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = 0
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, 0
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21336 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21336] == bool(mem[_21336])
                                                else:
                                                    require ext_call.return_data[0] - totalDeposited
                                                    if (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / ext_call.return_data[0] - totalDeposited != sub_7e72b29f:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    sub_bf4c8572 = (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / 10000
                                                    mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                                    mem[ceil32(return_data.size) + 132] = -1
                                                    require ext_code.size(sub_b8ab24bdAddress)
                                                    call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args lendingPoolAddress, -1
                                                    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                    mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                                    mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                                    mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                                    require ext_code.size(lendingPoolAddress)
                                                    call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                         gas gas_remaining wei
                                                        args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                                    mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                                    mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                                    mem[(4 * ceil32(return_data.size)) + 132] = -1
                                                    require ext_code.size(assetAddress)
                                                    call assetAddress.approve(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args routerAddress, -1
                                                    mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                    if assetAddress == WAVAXAddress:
                                                        mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                        mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                        mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                        mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                        mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + 128
                                                        t = (6 * ceil32(return_data.size)) + 388
                                                        while idx < 2:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                        mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                        require ext_code.size(routerAddress)
                                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = (7 * ceil32(return_data.size)) + 192
                                                        require return_data.size >= 32
                                                        _12706 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                        require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                        _13108 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                        mem[(7 * ceil32(return_data.size)) + 192] = _13108
                                                        require _12706 + (32 * _13108) + 32 <= return_data.size
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + _12706 + 224
                                                        t = (7 * ceil32(return_data.size)) + 224
                                                        while idx < _13108:
                                                            require mem[s] == mem[s]
                                                            mem[t] = mem[s]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[mem[64] + 4] = this.address
                                                        require ext_code.size(rewardTokenAddress)
                                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args address(this.address)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _19166 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_19166] == mem[_19166]
                                                        if sub_0b4b41bc <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require sub_0b4b41bc
                                                        sub_7f94bf16 = mem[_19166] / sub_0b4b41bc
                                                        mem[mem[64] + 4] = treasuryAddress
                                                        mem[mem[64] + 36] = 0
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args treasuryAddress, 0
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _21332 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_21332] == bool(mem[_21332])
                                                    else:
                                                        if rewardTokenAddress == WAVAXAddress:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 388
                                                            while idx < 2:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 192
                                                            require return_data.size >= 32
                                                            _12708 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                            require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                            _13110 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                            mem[(7 * ceil32(return_data.size)) + 192] = _13110
                                                            require _12708 + (32 * _13110) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12708 + 224
                                                            t = (7 * ceil32(return_data.size)) + 224
                                                            while idx < _13110:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19168 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19168] == mem[_19168]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19168] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = 0
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, 0
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21334 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21334] == bool(mem[_21334])
                                                        else:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 420
                                                            while idx < 3:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args 0, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 224
                                                            require return_data.size >= 32
                                                            _12707 = mem[(6 * ceil32(return_data.size)) + 224 len 4], 0
                                                            require mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                            _13109 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256
                                                            mem[(7 * ceil32(return_data.size)) + 224] = _13109
                                                            require _12707 + (32 * _13109) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12707 + 256
                                                            t = (7 * ceil32(return_data.size)) + 256
                                                            while idx < _13109:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19167 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19167] == mem[_19167]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19167] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = 0
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, 0
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21333 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21333] == bool(mem[_21333])
                                            else:
                                                require ext_call.return_data[0] - totalDeposited
                                                if (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / ext_call.return_data[0] - totalDeposited != sub_2f6236be:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not ext_call.return_data[0] - totalDeposited:
                                                    sub_bf4c8572 = 0
                                                    mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                                    mem[ceil32(return_data.size) + 132] = -1
                                                    require ext_code.size(sub_b8ab24bdAddress)
                                                    call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args lendingPoolAddress, -1
                                                    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                    mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                                    mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                                    mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                                    require ext_code.size(lendingPoolAddress)
                                                    call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                         gas gas_remaining wei
                                                        args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                                    mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                                    mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                                    mem[(4 * ceil32(return_data.size)) + 132] = -1
                                                    require ext_code.size(assetAddress)
                                                    call assetAddress.approve(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args routerAddress, -1
                                                    mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                    if assetAddress == WAVAXAddress:
                                                        mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                        mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                        mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                        mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                        mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + 128
                                                        t = (6 * ceil32(return_data.size)) + 388
                                                        while idx < 2:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                        mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                        require ext_code.size(routerAddress)
                                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = (7 * ceil32(return_data.size)) + 192
                                                        require return_data.size >= 32
                                                        _12703 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                        require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                        _13105 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                        mem[(7 * ceil32(return_data.size)) + 192] = _13105
                                                        require _12703 + (32 * _13105) + 32 <= return_data.size
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + _12703 + 224
                                                        t = (7 * ceil32(return_data.size)) + 224
                                                        while idx < _13105:
                                                            require mem[s] == mem[s]
                                                            mem[t] = mem[s]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[mem[64] + 4] = this.address
                                                        require ext_code.size(rewardTokenAddress)
                                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args address(this.address)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _19163 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_19163] == mem[_19163]
                                                        if sub_0b4b41bc <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require sub_0b4b41bc
                                                        sub_7f94bf16 = mem[_19163] / sub_0b4b41bc
                                                        mem[mem[64] + 4] = treasuryAddress
                                                        mem[mem[64] + 36] = 0
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args treasuryAddress, 0
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _21329 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_21329] == bool(mem[_21329])
                                                    else:
                                                        if rewardTokenAddress == WAVAXAddress:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 388
                                                            while idx < 2:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 192
                                                            require return_data.size >= 32
                                                            _12705 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                            require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                            _13107 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                            mem[(7 * ceil32(return_data.size)) + 192] = _13107
                                                            require _12705 + (32 * _13107) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12705 + 224
                                                            t = (7 * ceil32(return_data.size)) + 224
                                                            while idx < _13107:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19165 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19165] == mem[_19165]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19165] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = 0
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, 0
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21331 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21331] == bool(mem[_21331])
                                                        else:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 228] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 420
                                                            while idx < 3:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 224
                                                            require return_data.size >= 32
                                                            _12704 = mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                            require mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                            _13106 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256
                                                            mem[(7 * ceil32(return_data.size)) + 224] = _13106
                                                            require _12704 + (32 * _13106) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12704 + 256
                                                            t = (7 * ceil32(return_data.size)) + 256
                                                            while idx < _13106:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19164 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19164] == mem[_19164]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19164] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = 0
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, 0
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21330 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21330] == bool(mem[_21330])
                                                else:
                                                    require ext_call.return_data[0] - totalDeposited
                                                    if (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / ext_call.return_data[0] - totalDeposited != sub_7e72b29f:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    sub_bf4c8572 = (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / 10000
                                                    mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                                    mem[ceil32(return_data.size) + 132] = -1
                                                    require ext_code.size(sub_b8ab24bdAddress)
                                                    call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args lendingPoolAddress, -1
                                                    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                    mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                                    mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                                    mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                                    require ext_code.size(lendingPoolAddress)
                                                    call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                         gas gas_remaining wei
                                                        args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                                    mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                                    mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                                    mem[(4 * ceil32(return_data.size)) + 132] = -1
                                                    require ext_code.size(assetAddress)
                                                    call assetAddress.approve(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args routerAddress, -1
                                                    mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                    if assetAddress == WAVAXAddress:
                                                        mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                        mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                        mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                        mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                        mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + 128
                                                        t = (6 * ceil32(return_data.size)) + 388
                                                        while idx < 2:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                        mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                        require ext_code.size(routerAddress)
                                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = (7 * ceil32(return_data.size)) + 192
                                                        require return_data.size >= 32
                                                        _12700 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                        require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                        _13102 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                        mem[(7 * ceil32(return_data.size)) + 192] = _13102
                                                        require _12700 + (32 * _13102) + 32 <= return_data.size
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + _12700 + 224
                                                        t = (7 * ceil32(return_data.size)) + 224
                                                        while idx < _13102:
                                                            require mem[s] == mem[s]
                                                            mem[t] = mem[s]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[mem[64] + 4] = this.address
                                                        require ext_code.size(rewardTokenAddress)
                                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args address(this.address)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _19160 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_19160] == mem[_19160]
                                                        if sub_0b4b41bc <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require sub_0b4b41bc
                                                        sub_7f94bf16 = mem[_19160] / sub_0b4b41bc
                                                        mem[mem[64] + 4] = treasuryAddress
                                                        mem[mem[64] + 36] = 0
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args treasuryAddress, 0
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _21326 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_21326] == bool(mem[_21326])
                                                    else:
                                                        if rewardTokenAddress == WAVAXAddress:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 388
                                                            while idx < 2:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 192
                                                            require return_data.size >= 32
                                                            _12702 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                            require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                            _13104 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                            mem[(7 * ceil32(return_data.size)) + 192] = _13104
                                                            require _12702 + (32 * _13104) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12702 + 224
                                                            t = (7 * ceil32(return_data.size)) + 224
                                                            while idx < _13104:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19162 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19162] == mem[_19162]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19162] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = 0
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, 0
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21328 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21328] == bool(mem[_21328])
                                                        else:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 228] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 420
                                                            while idx < 3:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 224
                                                            require return_data.size >= 32
                                                            _12701 = mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                            require mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                            _13103 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256
                                                            mem[(7 * ceil32(return_data.size)) + 224] = _13103
                                                            require _12701 + (32 * _13103) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12701 + 256
                                                            t = (7 * ceil32(return_data.size)) + 256
                                                            while idx < _13103:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19161 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19161] == mem[_19161]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19161] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = 0
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, 0
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21327 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21327] == bool(mem[_21327])
                                        else:
                                            require ext_call.return_data[0] - totalDeposited
                                            if (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / ext_call.return_data[0] - totalDeposited != sub_7796ff37:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not ext_call.return_data[0] - totalDeposited:
                                                if not ext_call.return_data[0] - totalDeposited:
                                                    sub_bf4c8572 = 0
                                                    mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                                    mem[ceil32(return_data.size) + 132] = -1
                                                    require ext_code.size(sub_b8ab24bdAddress)
                                                    call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args lendingPoolAddress, -1
                                                    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                    mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                                    mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                                    mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                                    require ext_code.size(lendingPoolAddress)
                                                    call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                         gas gas_remaining wei
                                                        args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                                    mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                                    mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                                    mem[(4 * ceil32(return_data.size)) + 132] = -1
                                                    require ext_code.size(assetAddress)
                                                    call assetAddress.approve(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args routerAddress, -1
                                                    mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                    if assetAddress == WAVAXAddress:
                                                        mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                        mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                        mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                        mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                        mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + 128
                                                        t = (6 * ceil32(return_data.size)) + 388
                                                        while idx < 2:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                        mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                        require ext_code.size(routerAddress)
                                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = (7 * ceil32(return_data.size)) + 192
                                                        require return_data.size >= 32
                                                        _12697 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                        require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                        _13099 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                        mem[(7 * ceil32(return_data.size)) + 192] = _13099
                                                        require _12697 + (32 * _13099) + 32 <= return_data.size
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + _12697 + 224
                                                        t = (7 * ceil32(return_data.size)) + 224
                                                        while idx < _13099:
                                                            require mem[s] == mem[s]
                                                            mem[t] = mem[s]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[mem[64] + 4] = this.address
                                                        require ext_code.size(rewardTokenAddress)
                                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args address(this.address)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _19157 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_19157] == mem[_19157]
                                                        if sub_0b4b41bc <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require sub_0b4b41bc
                                                        sub_7f94bf16 = mem[_19157] / sub_0b4b41bc
                                                        mem[mem[64] + 4] = treasuryAddress
                                                        mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _21323 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_21323] == bool(mem[_21323])
                                                    else:
                                                        if rewardTokenAddress == WAVAXAddress:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 388
                                                            while idx < 2:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 192
                                                            require return_data.size >= 32
                                                            _12699 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                            require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                            _13101 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                            mem[(7 * ceil32(return_data.size)) + 192] = _13101
                                                            require _12699 + (32 * _13101) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12699 + 224
                                                            t = (7 * ceil32(return_data.size)) + 224
                                                            while idx < _13101:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19159 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19159] == mem[_19159]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19159] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21325 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21325] == bool(mem[_21325])
                                                        else:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 420
                                                            while idx < 3:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args 0, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 224
                                                            require return_data.size >= 32
                                                            _12698 = mem[(6 * ceil32(return_data.size)) + 224 len 4], 0
                                                            require mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                            _13100 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256
                                                            mem[(7 * ceil32(return_data.size)) + 224] = _13100
                                                            require _12698 + (32 * _13100) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12698 + 256
                                                            t = (7 * ceil32(return_data.size)) + 256
                                                            while idx < _13100:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19158 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19158] == mem[_19158]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19158] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21324 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21324] == bool(mem[_21324])
                                                else:
                                                    require ext_call.return_data[0] - totalDeposited
                                                    if (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / ext_call.return_data[0] - totalDeposited != sub_7e72b29f:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    sub_bf4c8572 = (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / 10000
                                                    mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                                    mem[ceil32(return_data.size) + 132] = -1
                                                    require ext_code.size(sub_b8ab24bdAddress)
                                                    call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args lendingPoolAddress, -1
                                                    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                    mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                                    mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                                    mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                                    require ext_code.size(lendingPoolAddress)
                                                    call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                         gas gas_remaining wei
                                                        args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                                    mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                                    mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                                    mem[(4 * ceil32(return_data.size)) + 132] = -1
                                                    require ext_code.size(assetAddress)
                                                    call assetAddress.approve(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args routerAddress, -1
                                                    mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                    if assetAddress == WAVAXAddress:
                                                        mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                        mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                        mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                        mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                        mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + 128
                                                        t = (6 * ceil32(return_data.size)) + 388
                                                        while idx < 2:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                        mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                        require ext_code.size(routerAddress)
                                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = (7 * ceil32(return_data.size)) + 192
                                                        require return_data.size >= 32
                                                        _12694 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                        require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                        _13096 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                        mem[(7 * ceil32(return_data.size)) + 192] = _13096
                                                        require _12694 + (32 * _13096) + 32 <= return_data.size
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + _12694 + 224
                                                        t = (7 * ceil32(return_data.size)) + 224
                                                        while idx < _13096:
                                                            require mem[s] == mem[s]
                                                            mem[t] = mem[s]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[mem[64] + 4] = this.address
                                                        require ext_code.size(rewardTokenAddress)
                                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args address(this.address)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _19154 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_19154] == mem[_19154]
                                                        if sub_0b4b41bc <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require sub_0b4b41bc
                                                        sub_7f94bf16 = mem[_19154] / sub_0b4b41bc
                                                        mem[mem[64] + 4] = treasuryAddress
                                                        mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _21320 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_21320] == bool(mem[_21320])
                                                    else:
                                                        if rewardTokenAddress == WAVAXAddress:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 388
                                                            while idx < 2:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 192
                                                            require return_data.size >= 32
                                                            _12696 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                            require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                            _13098 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                            mem[(7 * ceil32(return_data.size)) + 192] = _13098
                                                            require _12696 + (32 * _13098) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12696 + 224
                                                            t = (7 * ceil32(return_data.size)) + 224
                                                            while idx < _13098:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19156 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19156] == mem[_19156]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19156] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21322 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21322] == bool(mem[_21322])
                                                        else:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 420
                                                            while idx < 3:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args 0, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 224
                                                            require return_data.size >= 32
                                                            _12695 = mem[(6 * ceil32(return_data.size)) + 224 len 4], 0
                                                            require mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                            _13097 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256
                                                            mem[(7 * ceil32(return_data.size)) + 224] = _13097
                                                            require _12695 + (32 * _13097) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12695 + 256
                                                            t = (7 * ceil32(return_data.size)) + 256
                                                            while idx < _13097:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19155 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19155] == mem[_19155]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19155] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21321 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21321] == bool(mem[_21321])
                                            else:
                                                require ext_call.return_data[0] - totalDeposited
                                                if (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / ext_call.return_data[0] - totalDeposited != sub_2f6236be:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not ext_call.return_data[0] - totalDeposited:
                                                    sub_bf4c8572 = 0
                                                    mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                                    mem[ceil32(return_data.size) + 132] = -1
                                                    require ext_code.size(sub_b8ab24bdAddress)
                                                    call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args lendingPoolAddress, -1
                                                    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                    mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                                    mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                                    mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                                    require ext_code.size(lendingPoolAddress)
                                                    call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                         gas gas_remaining wei
                                                        args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                                    mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                                    mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                                    mem[(4 * ceil32(return_data.size)) + 132] = -1
                                                    require ext_code.size(assetAddress)
                                                    call assetAddress.approve(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args routerAddress, -1
                                                    mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                    if assetAddress == WAVAXAddress:
                                                        mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                        mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                        mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                        mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                        mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + 128
                                                        t = (6 * ceil32(return_data.size)) + 388
                                                        while idx < 2:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                        mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                        require ext_code.size(routerAddress)
                                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = (7 * ceil32(return_data.size)) + 192
                                                        require return_data.size >= 32
                                                        _12691 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                        require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                        _13093 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                        mem[(7 * ceil32(return_data.size)) + 192] = _13093
                                                        require _12691 + (32 * _13093) + 32 <= return_data.size
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + _12691 + 224
                                                        t = (7 * ceil32(return_data.size)) + 224
                                                        while idx < _13093:
                                                            require mem[s] == mem[s]
                                                            mem[t] = mem[s]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[mem[64] + 4] = this.address
                                                        require ext_code.size(rewardTokenAddress)
                                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args address(this.address)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _19151 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_19151] == mem[_19151]
                                                        if sub_0b4b41bc <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require sub_0b4b41bc
                                                        sub_7f94bf16 = mem[_19151] / sub_0b4b41bc
                                                        mem[mem[64] + 4] = treasuryAddress
                                                        mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _21317 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_21317] == bool(mem[_21317])
                                                    else:
                                                        if rewardTokenAddress == WAVAXAddress:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 388
                                                            while idx < 2:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 192
                                                            require return_data.size >= 32
                                                            _12693 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                            require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                            _13095 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                            mem[(7 * ceil32(return_data.size)) + 192] = _13095
                                                            require _12693 + (32 * _13095) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12693 + 224
                                                            t = (7 * ceil32(return_data.size)) + 224
                                                            while idx < _13095:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19153 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19153] == mem[_19153]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19153] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21319 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21319] == bool(mem[_21319])
                                                        else:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 228] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 420
                                                            while idx < 3:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 224
                                                            require return_data.size >= 32
                                                            _12692 = mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                            require mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                            _13094 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256
                                                            mem[(7 * ceil32(return_data.size)) + 224] = _13094
                                                            require _12692 + (32 * _13094) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12692 + 256
                                                            t = (7 * ceil32(return_data.size)) + 256
                                                            while idx < _13094:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19152 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19152] == mem[_19152]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19152] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21318 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21318] == bool(mem[_21318])
                                                else:
                                                    require ext_call.return_data[0] - totalDeposited
                                                    if (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / ext_call.return_data[0] - totalDeposited != sub_7e72b29f:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    sub_bf4c8572 = (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / 10000
                                                    mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                                    mem[ceil32(return_data.size) + 132] = -1
                                                    require ext_code.size(sub_b8ab24bdAddress)
                                                    call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args lendingPoolAddress, -1
                                                    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                    mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                                    mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                                    mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                                    require ext_code.size(lendingPoolAddress)
                                                    call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                         gas gas_remaining wei
                                                        args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                                    mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                                    mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                                    mem[(4 * ceil32(return_data.size)) + 132] = -1
                                                    require ext_code.size(assetAddress)
                                                    call assetAddress.approve(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args routerAddress, -1
                                                    mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                    if assetAddress == WAVAXAddress:
                                                        mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                        mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                        mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                        mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                        mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + 128
                                                        t = (6 * ceil32(return_data.size)) + 388
                                                        while idx < 2:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                        mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                        require ext_code.size(routerAddress)
                                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = (7 * ceil32(return_data.size)) + 192
                                                        require return_data.size >= 32
                                                        _12688 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                        require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                        _13090 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                        mem[(7 * ceil32(return_data.size)) + 192] = _13090
                                                        require _12688 + (32 * _13090) + 32 <= return_data.size
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + _12688 + 224
                                                        t = (7 * ceil32(return_data.size)) + 224
                                                        while idx < _13090:
                                                            require mem[s] == mem[s]
                                                            mem[t] = mem[s]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[mem[64] + 4] = this.address
                                                        require ext_code.size(rewardTokenAddress)
                                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args address(this.address)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _19148 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_19148] == mem[_19148]
                                                        if sub_0b4b41bc <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require sub_0b4b41bc
                                                        sub_7f94bf16 = mem[_19148] / sub_0b4b41bc
                                                        mem[mem[64] + 4] = treasuryAddress
                                                        mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _21314 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_21314] == bool(mem[_21314])
                                                    else:
                                                        if rewardTokenAddress == WAVAXAddress:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 388
                                                            while idx < 2:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 192
                                                            require return_data.size >= 32
                                                            _12690 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                            require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                            _13092 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                            mem[(7 * ceil32(return_data.size)) + 192] = _13092
                                                            require _12690 + (32 * _13092) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12690 + 224
                                                            t = (7 * ceil32(return_data.size)) + 224
                                                            while idx < _13092:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19150 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19150] == mem[_19150]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19150] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21316 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21316] == bool(mem[_21316])
                                                        else:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 228] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 420
                                                            while idx < 3:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 224
                                                            require return_data.size >= 32
                                                            _12689 = mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                            require mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                            _13091 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256
                                                            mem[(7 * ceil32(return_data.size)) + 224] = _13091
                                                            require _12689 + (32 * _13091) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12689 + 256
                                                            t = (7 * ceil32(return_data.size)) + 256
                                                            while idx < _13091:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19149 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19149] == mem[_19149]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19149] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21315 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21315] == bool(mem[_21315])
                                    else:
                                        require (sub_f12c8e0d * block.timestamp) + (sub_7f94bf16 * block.timestamp) - (sub_f12c8e0d * lastRewardTimestamp) - (sub_7f94bf16 * lastRewardTimestamp)
                                        if (10^12 * sub_f12c8e0d * block.timestamp) + (10^12 * sub_7f94bf16 * block.timestamp) - (10^12 * sub_f12c8e0d * lastRewardTimestamp) - (10^12 * sub_7f94bf16 * lastRewardTimestamp) / (sub_f12c8e0d * block.timestamp) + (sub_7f94bf16 * block.timestamp) - (sub_f12c8e0d * lastRewardTimestamp) - (sub_7f94bf16 * lastRewardTimestamp) != 10^12:
                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
                                        if totalDeposited <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalDeposited
                                        if sub_a9ac33dd + ((10^12 * sub_f12c8e0d * block.timestamp) + (10^12 * sub_7f94bf16 * block.timestamp) - (10^12 * sub_f12c8e0d * lastRewardTimestamp) - (10^12 * sub_7f94bf16 * lastRewardTimestamp) / totalDeposited) < sub_a9ac33dd:
                                            revert with 0, 'SafeMath: addition overflow'
                                        sub_a9ac33dd += (10^12 * sub_f12c8e0d * block.timestamp) + (10^12 * sub_7f94bf16 * block.timestamp) - (10^12 * sub_f12c8e0d * lastRewardTimestamp) - (10^12 * sub_7f94bf16 * lastRewardTimestamp) / totalDeposited
                                        lastRewardTimestamp = block.timestamp
                                        mem[100] = this.address
                                        require ext_code.size(sub_b8ab24bdAddress)
                                        staticcall sub_b8ab24bdAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[96] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == ext_call.return_data[0]
                                        if not ext_call.return_data[0] - totalDeposited:
                                            if not ext_call.return_data[0] - totalDeposited:
                                                if not ext_call.return_data[0] - totalDeposited:
                                                    sub_bf4c8572 = 0
                                                    mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                                    mem[ceil32(return_data.size) + 132] = -1
                                                    require ext_code.size(sub_b8ab24bdAddress)
                                                    call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args lendingPoolAddress, -1
                                                    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                    mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                                    mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                                    mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                                    require ext_code.size(lendingPoolAddress)
                                                    call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                         gas gas_remaining wei
                                                        args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                                    mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                                    mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                                    mem[(4 * ceil32(return_data.size)) + 132] = -1
                                                    require ext_code.size(assetAddress)
                                                    call assetAddress.approve(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args routerAddress, -1
                                                    mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                    if assetAddress == WAVAXAddress:
                                                        mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                        mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                        mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                        mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                        mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + 128
                                                        t = (6 * ceil32(return_data.size)) + 388
                                                        while idx < 2:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                        mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                        require ext_code.size(routerAddress)
                                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = (7 * ceil32(return_data.size)) + 192
                                                        require return_data.size >= 32
                                                        _12685 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                        require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                        _13087 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                        mem[(7 * ceil32(return_data.size)) + 192] = _13087
                                                        require _12685 + (32 * _13087) + 32 <= return_data.size
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + _12685 + 224
                                                        t = (7 * ceil32(return_data.size)) + 224
                                                        while idx < _13087:
                                                            require mem[s] == mem[s]
                                                            mem[t] = mem[s]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[mem[64] + 4] = this.address
                                                        require ext_code.size(rewardTokenAddress)
                                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args address(this.address)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _19145 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_19145] == mem[_19145]
                                                        if sub_0b4b41bc <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require sub_0b4b41bc
                                                        sub_7f94bf16 = mem[_19145] / sub_0b4b41bc
                                                        mem[mem[64] + 4] = treasuryAddress
                                                        mem[mem[64] + 36] = 0
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args treasuryAddress, 0
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _21311 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_21311] == bool(mem[_21311])
                                                    else:
                                                        if rewardTokenAddress == WAVAXAddress:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 388
                                                            while idx < 2:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 192
                                                            require return_data.size >= 32
                                                            _12687 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                            require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                            _13089 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                            mem[(7 * ceil32(return_data.size)) + 192] = _13089
                                                            require _12687 + (32 * _13089) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12687 + 224
                                                            t = (7 * ceil32(return_data.size)) + 224
                                                            while idx < _13089:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19147 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19147] == mem[_19147]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19147] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = 0
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, 0
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21313 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21313] == bool(mem[_21313])
                                                        else:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 420
                                                            while idx < 3:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args 0, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 224
                                                            require return_data.size >= 32
                                                            _12686 = mem[(6 * ceil32(return_data.size)) + 224 len 4], 0
                                                            require mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                            _13088 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256
                                                            mem[(7 * ceil32(return_data.size)) + 224] = _13088
                                                            require _12686 + (32 * _13088) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12686 + 256
                                                            t = (7 * ceil32(return_data.size)) + 256
                                                            while idx < _13088:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19146 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19146] == mem[_19146]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19146] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = 0
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, 0
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21312 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21312] == bool(mem[_21312])
                                                else:
                                                    require ext_call.return_data[0] - totalDeposited
                                                    if (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / ext_call.return_data[0] - totalDeposited != sub_7e72b29f:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    sub_bf4c8572 = (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / 10000
                                                    mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                                    mem[ceil32(return_data.size) + 132] = -1
                                                    require ext_code.size(sub_b8ab24bdAddress)
                                                    call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args lendingPoolAddress, -1
                                                    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                    mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                                    mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                                    mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                                    require ext_code.size(lendingPoolAddress)
                                                    call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                         gas gas_remaining wei
                                                        args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                                    mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                                    mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                                    mem[(4 * ceil32(return_data.size)) + 132] = -1
                                                    require ext_code.size(assetAddress)
                                                    call assetAddress.approve(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args routerAddress, -1
                                                    mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                    if assetAddress == WAVAXAddress:
                                                        mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                        mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                        mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                        mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                        mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + 128
                                                        t = (6 * ceil32(return_data.size)) + 388
                                                        while idx < 2:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                        mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                        require ext_code.size(routerAddress)
                                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = (7 * ceil32(return_data.size)) + 192
                                                        require return_data.size >= 32
                                                        _12682 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                        require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                        _13084 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                        mem[(7 * ceil32(return_data.size)) + 192] = _13084
                                                        require _12682 + (32 * _13084) + 32 <= return_data.size
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + _12682 + 224
                                                        t = (7 * ceil32(return_data.size)) + 224
                                                        while idx < _13084:
                                                            require mem[s] == mem[s]
                                                            mem[t] = mem[s]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[mem[64] + 4] = this.address
                                                        require ext_code.size(rewardTokenAddress)
                                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args address(this.address)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _19142 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_19142] == mem[_19142]
                                                        if sub_0b4b41bc <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require sub_0b4b41bc
                                                        sub_7f94bf16 = mem[_19142] / sub_0b4b41bc
                                                        mem[mem[64] + 4] = treasuryAddress
                                                        mem[mem[64] + 36] = 0
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args treasuryAddress, 0
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _21308 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_21308] == bool(mem[_21308])
                                                    else:
                                                        if rewardTokenAddress == WAVAXAddress:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 388
                                                            while idx < 2:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 192
                                                            require return_data.size >= 32
                                                            _12684 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                            require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                            _13086 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                            mem[(7 * ceil32(return_data.size)) + 192] = _13086
                                                            require _12684 + (32 * _13086) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12684 + 224
                                                            t = (7 * ceil32(return_data.size)) + 224
                                                            while idx < _13086:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19144 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19144] == mem[_19144]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19144] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = 0
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, 0
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21310 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21310] == bool(mem[_21310])
                                                        else:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 420
                                                            while idx < 3:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args 0, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 224
                                                            require return_data.size >= 32
                                                            _12683 = mem[(6 * ceil32(return_data.size)) + 224 len 4], 0
                                                            require mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                            _13085 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256
                                                            mem[(7 * ceil32(return_data.size)) + 224] = _13085
                                                            require _12683 + (32 * _13085) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12683 + 256
                                                            t = (7 * ceil32(return_data.size)) + 256
                                                            while idx < _13085:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19143 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19143] == mem[_19143]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19143] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = 0
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, 0
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21309 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21309] == bool(mem[_21309])
                                            else:
                                                require ext_call.return_data[0] - totalDeposited
                                                if (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / ext_call.return_data[0] - totalDeposited != sub_2f6236be:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not ext_call.return_data[0] - totalDeposited:
                                                    sub_bf4c8572 = 0
                                                    mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                                    mem[ceil32(return_data.size) + 132] = -1
                                                    require ext_code.size(sub_b8ab24bdAddress)
                                                    call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args lendingPoolAddress, -1
                                                    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                    mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                                    mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                                    mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                                    require ext_code.size(lendingPoolAddress)
                                                    call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                         gas gas_remaining wei
                                                        args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                                    mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                                    mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                                    mem[(4 * ceil32(return_data.size)) + 132] = -1
                                                    require ext_code.size(assetAddress)
                                                    call assetAddress.approve(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args routerAddress, -1
                                                    mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                    if assetAddress == WAVAXAddress:
                                                        mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                        mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                        mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                        mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                        mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + 128
                                                        t = (6 * ceil32(return_data.size)) + 388
                                                        while idx < 2:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                        mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                        require ext_code.size(routerAddress)
                                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = (7 * ceil32(return_data.size)) + 192
                                                        require return_data.size >= 32
                                                        _12679 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                        require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                        _13081 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                        mem[(7 * ceil32(return_data.size)) + 192] = _13081
                                                        require _12679 + (32 * _13081) + 32 <= return_data.size
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + _12679 + 224
                                                        t = (7 * ceil32(return_data.size)) + 224
                                                        while idx < _13081:
                                                            require mem[s] == mem[s]
                                                            mem[t] = mem[s]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[mem[64] + 4] = this.address
                                                        require ext_code.size(rewardTokenAddress)
                                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args address(this.address)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _19139 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_19139] == mem[_19139]
                                                        if sub_0b4b41bc <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require sub_0b4b41bc
                                                        sub_7f94bf16 = mem[_19139] / sub_0b4b41bc
                                                        mem[mem[64] + 4] = treasuryAddress
                                                        mem[mem[64] + 36] = 0
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args treasuryAddress, 0
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _21305 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_21305] == bool(mem[_21305])
                                                    else:
                                                        if rewardTokenAddress == WAVAXAddress:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 388
                                                            while idx < 2:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 192
                                                            require return_data.size >= 32
                                                            _12681 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                            require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                            _13083 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                            mem[(7 * ceil32(return_data.size)) + 192] = _13083
                                                            require _12681 + (32 * _13083) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12681 + 224
                                                            t = (7 * ceil32(return_data.size)) + 224
                                                            while idx < _13083:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19141 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19141] == mem[_19141]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19141] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = 0
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, 0
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21307 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21307] == bool(mem[_21307])
                                                        else:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 228] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 420
                                                            while idx < 3:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 224
                                                            require return_data.size >= 32
                                                            _12680 = mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                            require mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                            _13082 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256
                                                            mem[(7 * ceil32(return_data.size)) + 224] = _13082
                                                            require _12680 + (32 * _13082) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12680 + 256
                                                            t = (7 * ceil32(return_data.size)) + 256
                                                            while idx < _13082:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19140 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19140] == mem[_19140]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19140] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = 0
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, 0
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21306 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21306] == bool(mem[_21306])
                                                else:
                                                    require ext_call.return_data[0] - totalDeposited
                                                    if (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / ext_call.return_data[0] - totalDeposited != sub_7e72b29f:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    sub_bf4c8572 = (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / 10000
                                                    mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                                    mem[ceil32(return_data.size) + 132] = -1
                                                    require ext_code.size(sub_b8ab24bdAddress)
                                                    call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args lendingPoolAddress, -1
                                                    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                    mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                                    mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                                    mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                                    require ext_code.size(lendingPoolAddress)
                                                    call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                         gas gas_remaining wei
                                                        args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                                    mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                                    mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                                    mem[(4 * ceil32(return_data.size)) + 132] = -1
                                                    require ext_code.size(assetAddress)
                                                    call assetAddress.approve(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args routerAddress, -1
                                                    mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                    if assetAddress == WAVAXAddress:
                                                        mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                        mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                        mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                        mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                        mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + 128
                                                        t = (6 * ceil32(return_data.size)) + 388
                                                        while idx < 2:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                        mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                        require ext_code.size(routerAddress)
                                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = (7 * ceil32(return_data.size)) + 192
                                                        require return_data.size >= 32
                                                        _12676 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                        require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                        _13078 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                        mem[(7 * ceil32(return_data.size)) + 192] = _13078
                                                        require _12676 + (32 * _13078) + 32 <= return_data.size
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + _12676 + 224
                                                        t = (7 * ceil32(return_data.size)) + 224
                                                        while idx < _13078:
                                                            require mem[s] == mem[s]
                                                            mem[t] = mem[s]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[mem[64] + 4] = this.address
                                                        require ext_code.size(rewardTokenAddress)
                                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args address(this.address)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _19136 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_19136] == mem[_19136]
                                                        if sub_0b4b41bc <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require sub_0b4b41bc
                                                        sub_7f94bf16 = mem[_19136] / sub_0b4b41bc
                                                        mem[mem[64] + 4] = treasuryAddress
                                                        mem[mem[64] + 36] = 0
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args treasuryAddress, 0
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _21302 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_21302] == bool(mem[_21302])
                                                    else:
                                                        if rewardTokenAddress == WAVAXAddress:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 388
                                                            while idx < 2:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 192
                                                            require return_data.size >= 32
                                                            _12678 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                            require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                            _13080 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                            mem[(7 * ceil32(return_data.size)) + 192] = _13080
                                                            require _12678 + (32 * _13080) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12678 + 224
                                                            t = (7 * ceil32(return_data.size)) + 224
                                                            while idx < _13080:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19138 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19138] == mem[_19138]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19138] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = 0
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, 0
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21304 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21304] == bool(mem[_21304])
                                                        else:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 228] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 420
                                                            while idx < 3:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 224
                                                            require return_data.size >= 32
                                                            _12677 = mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                            require mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                            _13079 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256
                                                            mem[(7 * ceil32(return_data.size)) + 224] = _13079
                                                            require _12677 + (32 * _13079) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12677 + 256
                                                            t = (7 * ceil32(return_data.size)) + 256
                                                            while idx < _13079:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19137 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19137] == mem[_19137]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19137] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = 0
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, 0
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21303 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21303] == bool(mem[_21303])
                                        else:
                                            require ext_call.return_data[0] - totalDeposited
                                            if (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / ext_call.return_data[0] - totalDeposited != sub_7796ff37:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not ext_call.return_data[0] - totalDeposited:
                                                if not ext_call.return_data[0] - totalDeposited:
                                                    sub_bf4c8572 = 0
                                                    mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                                    mem[ceil32(return_data.size) + 132] = -1
                                                    require ext_code.size(sub_b8ab24bdAddress)
                                                    call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args lendingPoolAddress, -1
                                                    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                    mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                                    mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                                    mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                                    require ext_code.size(lendingPoolAddress)
                                                    call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                         gas gas_remaining wei
                                                        args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                                    mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                                    mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                                    mem[(4 * ceil32(return_data.size)) + 132] = -1
                                                    require ext_code.size(assetAddress)
                                                    call assetAddress.approve(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args routerAddress, -1
                                                    mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                    if assetAddress == WAVAXAddress:
                                                        mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                        mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                        mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                        mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                        mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + 128
                                                        t = (6 * ceil32(return_data.size)) + 388
                                                        while idx < 2:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                        mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                        require ext_code.size(routerAddress)
                                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = (7 * ceil32(return_data.size)) + 192
                                                        require return_data.size >= 32
                                                        _12673 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                        require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                        _13075 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                        mem[(7 * ceil32(return_data.size)) + 192] = _13075
                                                        require _12673 + (32 * _13075) + 32 <= return_data.size
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + _12673 + 224
                                                        t = (7 * ceil32(return_data.size)) + 224
                                                        while idx < _13075:
                                                            require mem[s] == mem[s]
                                                            mem[t] = mem[s]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[mem[64] + 4] = this.address
                                                        require ext_code.size(rewardTokenAddress)
                                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args address(this.address)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _19133 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_19133] == mem[_19133]
                                                        if sub_0b4b41bc <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require sub_0b4b41bc
                                                        sub_7f94bf16 = mem[_19133] / sub_0b4b41bc
                                                        mem[mem[64] + 4] = treasuryAddress
                                                        mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _21299 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_21299] == bool(mem[_21299])
                                                    else:
                                                        if rewardTokenAddress == WAVAXAddress:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 388
                                                            while idx < 2:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 192
                                                            require return_data.size >= 32
                                                            _12675 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                            require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                            _13077 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                            mem[(7 * ceil32(return_data.size)) + 192] = _13077
                                                            require _12675 + (32 * _13077) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12675 + 224
                                                            t = (7 * ceil32(return_data.size)) + 224
                                                            while idx < _13077:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19135 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19135] == mem[_19135]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19135] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21301 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21301] == bool(mem[_21301])
                                                        else:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 420
                                                            while idx < 3:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args 0, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 224
                                                            require return_data.size >= 32
                                                            _12674 = mem[(6 * ceil32(return_data.size)) + 224 len 4], 0
                                                            require mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                            _13076 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256
                                                            mem[(7 * ceil32(return_data.size)) + 224] = _13076
                                                            require _12674 + (32 * _13076) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12674 + 256
                                                            t = (7 * ceil32(return_data.size)) + 256
                                                            while idx < _13076:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19134 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19134] == mem[_19134]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19134] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21300 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21300] == bool(mem[_21300])
                                                else:
                                                    require ext_call.return_data[0] - totalDeposited
                                                    if (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / ext_call.return_data[0] - totalDeposited != sub_7e72b29f:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    sub_bf4c8572 = (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / 10000
                                                    mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                                    mem[ceil32(return_data.size) + 132] = -1
                                                    require ext_code.size(sub_b8ab24bdAddress)
                                                    call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args lendingPoolAddress, -1
                                                    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                    mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                                    mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                                    mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                                    require ext_code.size(lendingPoolAddress)
                                                    call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                         gas gas_remaining wei
                                                        args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                                    mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                                    mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                                    mem[(4 * ceil32(return_data.size)) + 132] = -1
                                                    require ext_code.size(assetAddress)
                                                    call assetAddress.approve(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args routerAddress, -1
                                                    mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                    if assetAddress == WAVAXAddress:
                                                        mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                        mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                        mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                        mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                        mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + 128
                                                        t = (6 * ceil32(return_data.size)) + 388
                                                        while idx < 2:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                        mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                        require ext_code.size(routerAddress)
                                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = (7 * ceil32(return_data.size)) + 192
                                                        require return_data.size >= 32
                                                        _12670 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                        require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                        _13072 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                        mem[(7 * ceil32(return_data.size)) + 192] = _13072
                                                        require _12670 + (32 * _13072) + 32 <= return_data.size
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + _12670 + 224
                                                        t = (7 * ceil32(return_data.size)) + 224
                                                        while idx < _13072:
                                                            require mem[s] == mem[s]
                                                            mem[t] = mem[s]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[mem[64] + 4] = this.address
                                                        require ext_code.size(rewardTokenAddress)
                                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args address(this.address)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _19130 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_19130] == mem[_19130]
                                                        if sub_0b4b41bc <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require sub_0b4b41bc
                                                        sub_7f94bf16 = mem[_19130] / sub_0b4b41bc
                                                        mem[mem[64] + 4] = treasuryAddress
                                                        mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _21296 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_21296] == bool(mem[_21296])
                                                    else:
                                                        if rewardTokenAddress == WAVAXAddress:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 388
                                                            while idx < 2:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 192
                                                            require return_data.size >= 32
                                                            _12672 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                            require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                            _13074 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                            mem[(7 * ceil32(return_data.size)) + 192] = _13074
                                                            require _12672 + (32 * _13074) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12672 + 224
                                                            t = (7 * ceil32(return_data.size)) + 224
                                                            while idx < _13074:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19132 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19132] == mem[_19132]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19132] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21298 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21298] == bool(mem[_21298])
                                                        else:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 420
                                                            while idx < 3:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args 0, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 224
                                                            require return_data.size >= 32
                                                            _12671 = mem[(6 * ceil32(return_data.size)) + 224 len 4], 0
                                                            require mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                            _13073 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256
                                                            mem[(7 * ceil32(return_data.size)) + 224] = _13073
                                                            require _12671 + (32 * _13073) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12671 + 256
                                                            t = (7 * ceil32(return_data.size)) + 256
                                                            while idx < _13073:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19131 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19131] == mem[_19131]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19131] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21297 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21297] == bool(mem[_21297])
                                            else:
                                                require ext_call.return_data[0] - totalDeposited
                                                if (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / ext_call.return_data[0] - totalDeposited != sub_2f6236be:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not ext_call.return_data[0] - totalDeposited:
                                                    sub_bf4c8572 = 0
                                                    mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                                    mem[ceil32(return_data.size) + 132] = -1
                                                    require ext_code.size(sub_b8ab24bdAddress)
                                                    call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args lendingPoolAddress, -1
                                                    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                    mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                                    mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                                    mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                                    require ext_code.size(lendingPoolAddress)
                                                    call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                         gas gas_remaining wei
                                                        args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                                    mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                                    mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                                    mem[(4 * ceil32(return_data.size)) + 132] = -1
                                                    require ext_code.size(assetAddress)
                                                    call assetAddress.approve(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args routerAddress, -1
                                                    mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                    if assetAddress == WAVAXAddress:
                                                        mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                        mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                        mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                        mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                        mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + 128
                                                        t = (6 * ceil32(return_data.size)) + 388
                                                        while idx < 2:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                        mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                        require ext_code.size(routerAddress)
                                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = (7 * ceil32(return_data.size)) + 192
                                                        require return_data.size >= 32
                                                        _12667 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                        require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                        _13069 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                        mem[(7 * ceil32(return_data.size)) + 192] = _13069
                                                        require _12667 + (32 * _13069) + 32 <= return_data.size
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + _12667 + 224
                                                        t = (7 * ceil32(return_data.size)) + 224
                                                        while idx < _13069:
                                                            require mem[s] == mem[s]
                                                            mem[t] = mem[s]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[mem[64] + 4] = this.address
                                                        require ext_code.size(rewardTokenAddress)
                                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args address(this.address)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _19127 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_19127] == mem[_19127]
                                                        if sub_0b4b41bc <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require sub_0b4b41bc
                                                        sub_7f94bf16 = mem[_19127] / sub_0b4b41bc
                                                        mem[mem[64] + 4] = treasuryAddress
                                                        mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _21293 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_21293] == bool(mem[_21293])
                                                    else:
                                                        if rewardTokenAddress == WAVAXAddress:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 388
                                                            while idx < 2:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 192
                                                            require return_data.size >= 32
                                                            _12669 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                            require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                            _13071 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                            mem[(7 * ceil32(return_data.size)) + 192] = _13071
                                                            require _12669 + (32 * _13071) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12669 + 224
                                                            t = (7 * ceil32(return_data.size)) + 224
                                                            while idx < _13071:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19129 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19129] == mem[_19129]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19129] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21295 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21295] == bool(mem[_21295])
                                                        else:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 228] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 420
                                                            while idx < 3:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 224
                                                            require return_data.size >= 32
                                                            _12668 = mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                            require mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                            _13070 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256
                                                            mem[(7 * ceil32(return_data.size)) + 224] = _13070
                                                            require _12668 + (32 * _13070) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12668 + 256
                                                            t = (7 * ceil32(return_data.size)) + 256
                                                            while idx < _13070:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19128 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19128] == mem[_19128]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19128] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21294 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21294] == bool(mem[_21294])
                                                else:
                                                    require ext_call.return_data[0] - totalDeposited
                                                    if (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / ext_call.return_data[0] - totalDeposited != sub_7e72b29f:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    sub_bf4c8572 = (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / 10000
                                                    mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                                    mem[ceil32(return_data.size) + 132] = -1
                                                    require ext_code.size(sub_b8ab24bdAddress)
                                                    call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args lendingPoolAddress, -1
                                                    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                    mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                                    mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                                    mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                                    require ext_code.size(lendingPoolAddress)
                                                    call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                         gas gas_remaining wei
                                                        args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                                    mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                                    mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                                    mem[(4 * ceil32(return_data.size)) + 132] = -1
                                                    require ext_code.size(assetAddress)
                                                    call assetAddress.approve(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args routerAddress, -1
                                                    mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                    if assetAddress == WAVAXAddress:
                                                        mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                        mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                        mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                        mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                        mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                        mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                        mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                        mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + 128
                                                        t = (6 * ceil32(return_data.size)) + 388
                                                        while idx < 2:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                        mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                        require ext_code.size(routerAddress)
                                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = (7 * ceil32(return_data.size)) + 192
                                                        require return_data.size >= 32
                                                        _12664 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                        require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                        require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                        _13066 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                        require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                        require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                        mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                        mem[(7 * ceil32(return_data.size)) + 192] = _13066
                                                        require _12664 + (32 * _13066) + 32 <= return_data.size
                                                        idx = 0
                                                        s = (6 * ceil32(return_data.size)) + _12664 + 224
                                                        t = (7 * ceil32(return_data.size)) + 224
                                                        while idx < _13066:
                                                            require mem[s] == mem[s]
                                                            mem[t] = mem[s]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[mem[64] + 4] = this.address
                                                        require ext_code.size(rewardTokenAddress)
                                                        staticcall rewardTokenAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args address(this.address)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _19124 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_19124] == mem[_19124]
                                                        if sub_0b4b41bc <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require sub_0b4b41bc
                                                        sub_7f94bf16 = mem[_19124] / sub_0b4b41bc
                                                        mem[mem[64] + 4] = treasuryAddress
                                                        mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _21290 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_21290] == bool(mem[_21290])
                                                    else:
                                                        if rewardTokenAddress == WAVAXAddress:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 388
                                                            while idx < 2:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 192
                                                            require return_data.size >= 32
                                                            _12666 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                            require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                            _13068 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                            mem[(7 * ceil32(return_data.size)) + 192] = _13068
                                                            require _12666 + (32 * _13068) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12666 + 224
                                                            t = (7 * ceil32(return_data.size)) + 224
                                                            while idx < _13068:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19126 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19126] == mem[_19126]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19126] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21292 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21292] == bool(mem[_21292])
                                                        else:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 228] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 420
                                                            while idx < 3:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 224
                                                            require return_data.size >= 32
                                                            _12665 = mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                            require mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                            _13067 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256
                                                            mem[(7 * ceil32(return_data.size)) + 224] = _13067
                                                            require _12665 + (32 * _13067) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12665 + 256
                                                            t = (7 * ceil32(return_data.size)) + 256
                                                            while idx < _13067:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19125 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19125] == mem[_19125]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19125] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21291 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21291] == bool(mem[_21291])
                                else:
                                    require block.timestamp - lastRewardTimestamp
                                    if (block.timestamp * sub_f12c8e0d) - (lastRewardTimestamp * sub_f12c8e0d) / block.timestamp - lastRewardTimestamp != sub_f12c8e0d:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
                                    if not (block.timestamp * sub_f12c8e0d) - (lastRewardTimestamp * sub_f12c8e0d):
                                        require ext_code.size(rewardWalletAddress)
                                        call rewardWalletAddress.requestReward(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not (sub_f12c8e0d * block.timestamp) + (sub_7f94bf16 * block.timestamp) - (sub_f12c8e0d * lastRewardTimestamp) - (sub_7f94bf16 * lastRewardTimestamp):
                                            if totalDeposited <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalDeposited
                                            if sub_a9ac33dd + (0 / totalDeposited) < sub_a9ac33dd:
                                                revert with 0, 'SafeMath: addition overflow'
                                            sub_a9ac33dd += 0 / totalDeposited
                                            lastRewardTimestamp = block.timestamp
                                            mem[100] = this.address
                                            require ext_code.size(sub_b8ab24bdAddress)
                                            staticcall sub_b8ab24bdAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            mem[96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_call.return_data[0] == ext_call.return_data[0]
                                            if not ext_call.return_data[0] - totalDeposited:
                                                if not ext_call.return_data[0] - totalDeposited:
                                                    if not ext_call.return_data[0] - totalDeposited:
                                                        sub_bf4c8572 = 0
                                                        mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                                        mem[ceil32(return_data.size) + 132] = -1
                                                        require ext_code.size(sub_b8ab24bdAddress)
                                                        call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args lendingPoolAddress, -1
                                                        mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                        mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                                        mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                                        mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                                        require ext_code.size(lendingPoolAddress)
                                                        call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                             gas gas_remaining wei
                                                            args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                                        mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == ext_call.return_data[0]
                                                        mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                                        mem[(4 * ceil32(return_data.size)) + 132] = -1
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.approve(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args routerAddress, -1
                                                        mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                        if assetAddress == WAVAXAddress:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 388
                                                            while idx < 2:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 192
                                                            require return_data.size >= 32
                                                            _12661 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                            require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                            _13063 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                            mem[(7 * ceil32(return_data.size)) + 192] = _13063
                                                            require _12661 + (32 * _13063) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12661 + 224
                                                            t = (7 * ceil32(return_data.size)) + 224
                                                            while idx < _13063:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19121 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19121] == mem[_19121]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19121] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = 0
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, 0
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21287 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21287] == bool(mem[_21287])
                                                        else:
                                                            if rewardTokenAddress == WAVAXAddress:
                                                                mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                                mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                                mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                                mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + 128
                                                                t = (6 * ceil32(return_data.size)) + 388
                                                                while idx < 2:
                                                                    mem[t] = mem[s + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                                mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                                require ext_code.size(routerAddress)
                                                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = (7 * ceil32(return_data.size)) + 192
                                                                require return_data.size >= 32
                                                                _12663 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                                require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                                _13065 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                                mem[(7 * ceil32(return_data.size)) + 192] = _13065
                                                                require _12663 + (32 * _13065) + 32 <= return_data.size
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + _12663 + 224
                                                                t = (7 * ceil32(return_data.size)) + 224
                                                                while idx < _13065:
                                                                    require mem[s] == mem[s]
                                                                    mem[t] = mem[s]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[mem[64] + 4] = this.address
                                                                require ext_code.size(rewardTokenAddress)
                                                                staticcall rewardTokenAddress.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args address(this.address)
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _19123 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_19123] == mem[_19123]
                                                                if sub_0b4b41bc <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require sub_0b4b41bc
                                                                sub_7f94bf16 = mem[_19123] / sub_0b4b41bc
                                                                mem[mem[64] + 4] = treasuryAddress
                                                                mem[mem[64] + 36] = 0
                                                                require ext_code.size(assetAddress)
                                                                call assetAddress.0xa9059cbb with:
                                                                     gas gas_remaining wei
                                                                    args treasuryAddress, 0
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _21289 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_21289] == bool(mem[_21289])
                                                            else:
                                                                mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                                mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                                mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                                mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                                mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + 128
                                                                t = (6 * ceil32(return_data.size)) + 420
                                                                while idx < 3:
                                                                    mem[t] = mem[s + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                                mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                                require ext_code.size(routerAddress)
                                                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args 0, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = (7 * ceil32(return_data.size)) + 224
                                                                require return_data.size >= 32
                                                                _12662 = mem[(6 * ceil32(return_data.size)) + 224 len 4], 0
                                                                require mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 <= test266151307()
                                                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                                _13064 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]
                                                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224] <= test266151307()
                                                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 32 >= 0
                                                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256
                                                                mem[(7 * ceil32(return_data.size)) + 224] = _13064
                                                                require _12662 + (32 * _13064) + 32 <= return_data.size
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + _12662 + 256
                                                                t = (7 * ceil32(return_data.size)) + 256
                                                                while idx < _13064:
                                                                    require mem[s] == mem[s]
                                                                    mem[t] = mem[s]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[mem[64] + 4] = this.address
                                                                require ext_code.size(rewardTokenAddress)
                                                                staticcall rewardTokenAddress.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args address(this.address)
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _19122 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_19122] == mem[_19122]
                                                                if sub_0b4b41bc <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require sub_0b4b41bc
                                                                sub_7f94bf16 = mem[_19122] / sub_0b4b41bc
                                                                mem[mem[64] + 4] = treasuryAddress
                                                                mem[mem[64] + 36] = 0
                                                                require ext_code.size(assetAddress)
                                                                call assetAddress.0xa9059cbb with:
                                                                     gas gas_remaining wei
                                                                    args treasuryAddress, 0
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _21288 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_21288] == bool(mem[_21288])
                                                    else:
                                                        require ext_call.return_data[0] - totalDeposited
                                                        if (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / ext_call.return_data[0] - totalDeposited != sub_7e72b29f:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        sub_bf4c8572 = (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / 10000
                                                        mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                                        mem[ceil32(return_data.size) + 132] = -1
                                                        require ext_code.size(sub_b8ab24bdAddress)
                                                        call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args lendingPoolAddress, -1
                                                        mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                        mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                                        mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                                        mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                                        require ext_code.size(lendingPoolAddress)
                                                        call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                             gas gas_remaining wei
                                                            args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                                        mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == ext_call.return_data[0]
                                                        mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                                        mem[(4 * ceil32(return_data.size)) + 132] = -1
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.approve(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args routerAddress, -1
                                                        mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                        if assetAddress == WAVAXAddress:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 388
                                                            while idx < 2:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 192
                                                            require return_data.size >= 32
                                                            _12658 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                            require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                            _13060 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                            mem[(7 * ceil32(return_data.size)) + 192] = _13060
                                                            require _12658 + (32 * _13060) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12658 + 224
                                                            t = (7 * ceil32(return_data.size)) + 224
                                                            while idx < _13060:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19118 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19118] == mem[_19118]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19118] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = 0
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, 0
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21284 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21284] == bool(mem[_21284])
                                                        else:
                                                            if rewardTokenAddress == WAVAXAddress:
                                                                mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                                mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                                mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                                mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + 128
                                                                t = (6 * ceil32(return_data.size)) + 388
                                                                while idx < 2:
                                                                    mem[t] = mem[s + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                                mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                                require ext_code.size(routerAddress)
                                                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = (7 * ceil32(return_data.size)) + 192
                                                                require return_data.size >= 32
                                                                _12660 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                                require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                                _13062 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                                mem[(7 * ceil32(return_data.size)) + 192] = _13062
                                                                require _12660 + (32 * _13062) + 32 <= return_data.size
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + _12660 + 224
                                                                t = (7 * ceil32(return_data.size)) + 224
                                                                while idx < _13062:
                                                                    require mem[s] == mem[s]
                                                                    mem[t] = mem[s]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[mem[64] + 4] = this.address
                                                                require ext_code.size(rewardTokenAddress)
                                                                staticcall rewardTokenAddress.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args address(this.address)
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _19120 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_19120] == mem[_19120]
                                                                if sub_0b4b41bc <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require sub_0b4b41bc
                                                                sub_7f94bf16 = mem[_19120] / sub_0b4b41bc
                                                                mem[mem[64] + 4] = treasuryAddress
                                                                mem[mem[64] + 36] = 0
                                                                require ext_code.size(assetAddress)
                                                                call assetAddress.0xa9059cbb with:
                                                                     gas gas_remaining wei
                                                                    args treasuryAddress, 0
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _21286 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_21286] == bool(mem[_21286])
                                                            else:
                                                                mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                                mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                                mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                                mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                                mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + 128
                                                                t = (6 * ceil32(return_data.size)) + 420
                                                                while idx < 3:
                                                                    mem[t] = mem[s + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                                mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                                require ext_code.size(routerAddress)
                                                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args 0, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = (7 * ceil32(return_data.size)) + 224
                                                                require return_data.size >= 32
                                                                _12659 = mem[(6 * ceil32(return_data.size)) + 224 len 4], 0
                                                                require mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 <= test266151307()
                                                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                                _13061 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]
                                                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224] <= test266151307()
                                                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 32 >= 0
                                                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256
                                                                mem[(7 * ceil32(return_data.size)) + 224] = _13061
                                                                require _12659 + (32 * _13061) + 32 <= return_data.size
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + _12659 + 256
                                                                t = (7 * ceil32(return_data.size)) + 256
                                                                while idx < _13061:
                                                                    require mem[s] == mem[s]
                                                                    mem[t] = mem[s]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[mem[64] + 4] = this.address
                                                                require ext_code.size(rewardTokenAddress)
                                                                staticcall rewardTokenAddress.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args address(this.address)
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _19119 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_19119] == mem[_19119]
                                                                if sub_0b4b41bc <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require sub_0b4b41bc
                                                                sub_7f94bf16 = mem[_19119] / sub_0b4b41bc
                                                                mem[mem[64] + 4] = treasuryAddress
                                                                mem[mem[64] + 36] = 0
                                                                require ext_code.size(assetAddress)
                                                                call assetAddress.0xa9059cbb with:
                                                                     gas gas_remaining wei
                                                                    args treasuryAddress, 0
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _21285 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_21285] == bool(mem[_21285])
                                                else:
                                                    require ext_call.return_data[0] - totalDeposited
                                                    if (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / ext_call.return_data[0] - totalDeposited != sub_2f6236be:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not ext_call.return_data[0] - totalDeposited:
                                                        sub_bf4c8572 = 0
                                                        mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                                        mem[ceil32(return_data.size) + 132] = -1
                                                        require ext_code.size(sub_b8ab24bdAddress)
                                                        call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args lendingPoolAddress, -1
                                                        mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                        mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                                        mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                                        mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                                        require ext_code.size(lendingPoolAddress)
                                                        call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                             gas gas_remaining wei
                                                            args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                                        mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == ext_call.return_data[0]
                                                        mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                                        mem[(4 * ceil32(return_data.size)) + 132] = -1
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.approve(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args routerAddress, -1
                                                        mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                        if assetAddress == WAVAXAddress:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 388
                                                            while idx < 2:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 192
                                                            require return_data.size >= 32
                                                            _12655 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                            require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                            _13057 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                            mem[(7 * ceil32(return_data.size)) + 192] = _13057
                                                            require _12655 + (32 * _13057) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12655 + 224
                                                            t = (7 * ceil32(return_data.size)) + 224
                                                            while idx < _13057:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19115 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19115] == mem[_19115]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19115] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = 0
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, 0
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21281 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21281] == bool(mem[_21281])
                                                        else:
                                                            if rewardTokenAddress == WAVAXAddress:
                                                                mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                                mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                                mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                                mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                                mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + 128
                                                                t = (6 * ceil32(return_data.size)) + 388
                                                                while idx < 2:
                                                                    mem[t] = mem[s + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                                mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                                require ext_code.size(routerAddress)
                                                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = (7 * ceil32(return_data.size)) + 192
                                                                require return_data.size >= 32
                                                                _12657 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                                require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                                _13059 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                                mem[(7 * ceil32(return_data.size)) + 192] = _13059
                                                                require _12657 + (32 * _13059) + 32 <= return_data.size
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + _12657 + 224
                                                                t = (7 * ceil32(return_data.size)) + 224
                                                                while idx < _13059:
                                                                    require mem[s] == mem[s]
                                                                    mem[t] = mem[s]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[mem[64] + 4] = this.address
                                                                require ext_code.size(rewardTokenAddress)
                                                                staticcall rewardTokenAddress.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args address(this.address)
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _19117 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_19117] == mem[_19117]
                                                                if sub_0b4b41bc <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require sub_0b4b41bc
                                                                sub_7f94bf16 = mem[_19117] / sub_0b4b41bc
                                                                mem[mem[64] + 4] = treasuryAddress
                                                                mem[mem[64] + 36] = 0
                                                                require ext_code.size(assetAddress)
                                                                call assetAddress.0xa9059cbb with:
                                                                     gas gas_remaining wei
                                                                    args treasuryAddress, 0
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _21283 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_21283] == bool(mem[_21283])
                                                            else:
                                                                mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                                mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                                mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                                mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[(6 * ceil32(return_data.size)) + 228] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                                mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                                mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + 128
                                                                t = (6 * ceil32(return_data.size)) + 420
                                                                while idx < 3:
                                                                    mem[t] = mem[s + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                                mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                                require ext_code.size(routerAddress)
                                                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = (7 * ceil32(return_data.size)) + 224
                                                                require return_data.size >= 32
                                                                _12656 = mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                                require mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                                _13058 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]
                                                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224] <= test266151307()
                                                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 32 >= 0
                                                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256
                                                                mem[(7 * ceil32(return_data.size)) + 224] = _13058
                                                                require _12656 + (32 * _13058) + 32 <= return_data.size
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + _12656 + 256
                                                                t = (7 * ceil32(return_data.size)) + 256
                                                                while idx < _13058:
                                                                    require mem[s] == mem[s]
                                                                    mem[t] = mem[s]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[mem[64] + 4] = this.address
                                                                require ext_code.size(rewardTokenAddress)
                                                                staticcall rewardTokenAddress.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args address(this.address)
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _19116 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_19116] == mem[_19116]
                                                                if sub_0b4b41bc <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require sub_0b4b41bc
                                                                sub_7f94bf16 = mem[_19116] / sub_0b4b41bc
                                                                mem[mem[64] + 4] = treasuryAddress
                                                                mem[mem[64] + 36] = 0
                                                                require ext_code.size(assetAddress)
                                                                call assetAddress.0xa9059cbb with:
                                                                     gas gas_remaining wei
                                                                    args treasuryAddress, 0
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _21282 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_21282] == bool(mem[_21282])
                                                    else:
                                                        require ext_call.return_data[0] - totalDeposited
                                                        if (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / ext_call.return_data[0] - totalDeposited != sub_7e72b29f:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        sub_bf4c8572 = (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / 10000
                                                        mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                                        mem[ceil32(return_data.size) + 132] = -1
                                                        require ext_code.size(sub_b8ab24bdAddress)
                                                        call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args lendingPoolAddress, -1
                                                        mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                        mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                                        mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                                        mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                                        require ext_code.size(lendingPoolAddress)
                                                        call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                             gas gas_remaining wei
                                                            args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                                        mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == ext_call.return_data[0]
                                                        mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                                        mem[(4 * ceil32(return_data.size)) + 132] = -1
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.approve(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args routerAddress, -1
                                                        mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                        if assetAddress == WAVAXAddress:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 388
                                                            while idx < 2:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 192
                                                            require return_data.size >= 32
                                                            _12652 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                            require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                            _13054 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                            mem[(7 * ceil32(return_data.size)) + 192] = _13054
                                                            require _12652 + (32 * _13054) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12652 + 224
                                                            t = (7 * ceil32(return_data.size)) + 224
                                                            while idx < _13054:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19112 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19112] == mem[_19112]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19112] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = 0
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, 0
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21278 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21278] == bool(mem[_21278])
                                                        else:
                                                            if rewardTokenAddress == WAVAXAddress:
                                                                mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                                mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                                mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                                mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                                mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + 128
                                                                t = (6 * ceil32(return_data.size)) + 388
                                                                while idx < 2:
                                                                    mem[t] = mem[s + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                                mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                                require ext_code.size(routerAddress)
                                                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = (7 * ceil32(return_data.size)) + 192
                                                                require return_data.size >= 32
                                                                _12654 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                                require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                                _13056 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                                mem[(7 * ceil32(return_data.size)) + 192] = _13056
                                                                require _12654 + (32 * _13056) + 32 <= return_data.size
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + _12654 + 224
                                                                t = (7 * ceil32(return_data.size)) + 224
                                                                while idx < _13056:
                                                                    require mem[s] == mem[s]
                                                                    mem[t] = mem[s]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[mem[64] + 4] = this.address
                                                                require ext_code.size(rewardTokenAddress)
                                                                staticcall rewardTokenAddress.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args address(this.address)
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _19114 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_19114] == mem[_19114]
                                                                if sub_0b4b41bc <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require sub_0b4b41bc
                                                                sub_7f94bf16 = mem[_19114] / sub_0b4b41bc
                                                                mem[mem[64] + 4] = treasuryAddress
                                                                mem[mem[64] + 36] = 0
                                                                require ext_code.size(assetAddress)
                                                                call assetAddress.0xa9059cbb with:
                                                                     gas gas_remaining wei
                                                                    args treasuryAddress, 0
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _21280 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_21280] == bool(mem[_21280])
                                                            else:
                                                                mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                                mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                                mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                                mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[(6 * ceil32(return_data.size)) + 228] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                                mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                                mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + 128
                                                                t = (6 * ceil32(return_data.size)) + 420
                                                                while idx < 3:
                                                                    mem[t] = mem[s + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                                mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                                require ext_code.size(routerAddress)
                                                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = (7 * ceil32(return_data.size)) + 224
                                                                require return_data.size >= 32
                                                                _12653 = mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                                require mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                                _13055 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]
                                                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224] <= test266151307()
                                                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 32 >= 0
                                                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256
                                                                mem[(7 * ceil32(return_data.size)) + 224] = _13055
                                                                require _12653 + (32 * _13055) + 32 <= return_data.size
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + _12653 + 256
                                                                t = (7 * ceil32(return_data.size)) + 256
                                                                while idx < _13055:
                                                                    require mem[s] == mem[s]
                                                                    mem[t] = mem[s]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[mem[64] + 4] = this.address
                                                                require ext_code.size(rewardTokenAddress)
                                                                staticcall rewardTokenAddress.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args address(this.address)
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _19113 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_19113] == mem[_19113]
                                                                if sub_0b4b41bc <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require sub_0b4b41bc
                                                                sub_7f94bf16 = mem[_19113] / sub_0b4b41bc
                                                                mem[mem[64] + 4] = treasuryAddress
                                                                mem[mem[64] + 36] = 0
                                                                require ext_code.size(assetAddress)
                                                                call assetAddress.0xa9059cbb with:
                                                                     gas gas_remaining wei
                                                                    args treasuryAddress, 0
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _21279 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_21279] == bool(mem[_21279])
                                            else:
                                                require ext_call.return_data[0] - totalDeposited
                                                if (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / ext_call.return_data[0] - totalDeposited != sub_7796ff37:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not ext_call.return_data[0] - totalDeposited:
                                                    if not ext_call.return_data[0] - totalDeposited:
                                                        sub_bf4c8572 = 0
                                                        mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                                        mem[ceil32(return_data.size) + 132] = -1
                                                        require ext_code.size(sub_b8ab24bdAddress)
                                                        call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args lendingPoolAddress, -1
                                                        mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                        mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                                        mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                                        mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                                        require ext_code.size(lendingPoolAddress)
                                                        call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                             gas gas_remaining wei
                                                            args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                                        mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == ext_call.return_data[0]
                                                        mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                                        mem[(4 * ceil32(return_data.size)) + 132] = -1
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.approve(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args routerAddress, -1
                                                        mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                        if assetAddress == WAVAXAddress:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 388
                                                            while idx < 2:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 192
                                                            require return_data.size >= 32
                                                            _12649 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                            require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                            _13051 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                            mem[(7 * ceil32(return_data.size)) + 192] = _13051
                                                            require _12649 + (32 * _13051) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12649 + 224
                                                            t = (7 * ceil32(return_data.size)) + 224
                                                            while idx < _13051:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19109 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19109] == mem[_19109]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19109] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21275 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21275] == bool(mem[_21275])
                                                        else:
                                                            if rewardTokenAddress == WAVAXAddress:
                                                                mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                                mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                                mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                                mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + 128
                                                                t = (6 * ceil32(return_data.size)) + 388
                                                                while idx < 2:
                                                                    mem[t] = mem[s + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                                mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                                require ext_code.size(routerAddress)
                                                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = (7 * ceil32(return_data.size)) + 192
                                                                require return_data.size >= 32
                                                                _12651 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                                require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                                _13053 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                                mem[(7 * ceil32(return_data.size)) + 192] = _13053
                                                                require _12651 + (32 * _13053) + 32 <= return_data.size
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + _12651 + 224
                                                                t = (7 * ceil32(return_data.size)) + 224
                                                                while idx < _13053:
                                                                    require mem[s] == mem[s]
                                                                    mem[t] = mem[s]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[mem[64] + 4] = this.address
                                                                require ext_code.size(rewardTokenAddress)
                                                                staticcall rewardTokenAddress.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args address(this.address)
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _19111 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_19111] == mem[_19111]
                                                                if sub_0b4b41bc <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require sub_0b4b41bc
                                                                sub_7f94bf16 = mem[_19111] / sub_0b4b41bc
                                                                mem[mem[64] + 4] = treasuryAddress
                                                                mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                                require ext_code.size(assetAddress)
                                                                call assetAddress.0xa9059cbb with:
                                                                     gas gas_remaining wei
                                                                    args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _21277 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_21277] == bool(mem[_21277])
                                                            else:
                                                                mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                                mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                                mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                                mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                                mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + 128
                                                                t = (6 * ceil32(return_data.size)) + 420
                                                                while idx < 3:
                                                                    mem[t] = mem[s + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                                mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                                require ext_code.size(routerAddress)
                                                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args 0, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = (7 * ceil32(return_data.size)) + 224
                                                                require return_data.size >= 32
                                                                _12650 = mem[(6 * ceil32(return_data.size)) + 224 len 4], 0
                                                                require mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 <= test266151307()
                                                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                                _13052 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]
                                                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224] <= test266151307()
                                                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 32 >= 0
                                                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256
                                                                mem[(7 * ceil32(return_data.size)) + 224] = _13052
                                                                require _12650 + (32 * _13052) + 32 <= return_data.size
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + _12650 + 256
                                                                t = (7 * ceil32(return_data.size)) + 256
                                                                while idx < _13052:
                                                                    require mem[s] == mem[s]
                                                                    mem[t] = mem[s]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[mem[64] + 4] = this.address
                                                                require ext_code.size(rewardTokenAddress)
                                                                staticcall rewardTokenAddress.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args address(this.address)
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _19110 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_19110] == mem[_19110]
                                                                if sub_0b4b41bc <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require sub_0b4b41bc
                                                                sub_7f94bf16 = mem[_19110] / sub_0b4b41bc
                                                                mem[mem[64] + 4] = treasuryAddress
                                                                mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                                require ext_code.size(assetAddress)
                                                                call assetAddress.0xa9059cbb with:
                                                                     gas gas_remaining wei
                                                                    args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _21276 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_21276] == bool(mem[_21276])
                                                    else:
                                                        require ext_call.return_data[0] - totalDeposited
                                                        if (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / ext_call.return_data[0] - totalDeposited != sub_7e72b29f:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        sub_bf4c8572 = (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / 10000
                                                        mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                                        mem[ceil32(return_data.size) + 132] = -1
                                                        require ext_code.size(sub_b8ab24bdAddress)
                                                        call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args lendingPoolAddress, -1
                                                        mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                        mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                                        mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                                        mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                                        require ext_code.size(lendingPoolAddress)
                                                        call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                             gas gas_remaining wei
                                                            args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                                        mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == ext_call.return_data[0]
                                                        mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                                        mem[(4 * ceil32(return_data.size)) + 132] = -1
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.approve(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args routerAddress, -1
                                                        mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                        if assetAddress == WAVAXAddress:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 388
                                                            while idx < 2:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 192
                                                            require return_data.size >= 32
                                                            _12646 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                            require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                            _13048 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                            mem[(7 * ceil32(return_data.size)) + 192] = _13048
                                                            require _12646 + (32 * _13048) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12646 + 224
                                                            t = (7 * ceil32(return_data.size)) + 224
                                                            while idx < _13048:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19106 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19106] == mem[_19106]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19106] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21272 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21272] == bool(mem[_21272])
                                                        else:
                                                            if rewardTokenAddress == WAVAXAddress:
                                                                mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                                mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                                mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                                mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + 128
                                                                t = (6 * ceil32(return_data.size)) + 388
                                                                while idx < 2:
                                                                    mem[t] = mem[s + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                                mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                                require ext_code.size(routerAddress)
                                                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = (7 * ceil32(return_data.size)) + 192
                                                                require return_data.size >= 32
                                                                _12648 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                                require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                                _13050 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                                mem[(7 * ceil32(return_data.size)) + 192] = _13050
                                                                require _12648 + (32 * _13050) + 32 <= return_data.size
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + _12648 + 224
                                                                t = (7 * ceil32(return_data.size)) + 224
                                                                while idx < _13050:
                                                                    require mem[s] == mem[s]
                                                                    mem[t] = mem[s]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[mem[64] + 4] = this.address
                                                                require ext_code.size(rewardTokenAddress)
                                                                staticcall rewardTokenAddress.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args address(this.address)
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _19108 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_19108] == mem[_19108]
                                                                if sub_0b4b41bc <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require sub_0b4b41bc
                                                                sub_7f94bf16 = mem[_19108] / sub_0b4b41bc
                                                                mem[mem[64] + 4] = treasuryAddress
                                                                mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                                require ext_code.size(assetAddress)
                                                                call assetAddress.0xa9059cbb with:
                                                                     gas gas_remaining wei
                                                                    args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _21274 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_21274] == bool(mem[_21274])
                                                            else:
                                                                mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                                mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                                mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                                mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                                mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + 128
                                                                t = (6 * ceil32(return_data.size)) + 420
                                                                while idx < 3:
                                                                    mem[t] = mem[s + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                                mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                                require ext_code.size(routerAddress)
                                                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args 0, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = (7 * ceil32(return_data.size)) + 224
                                                                require return_data.size >= 32
                                                                _12647 = mem[(6 * ceil32(return_data.size)) + 224 len 4], 0
                                                                require mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 <= test266151307()
                                                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                                _13049 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]
                                                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224] <= test266151307()
                                                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 32 >= 0
                                                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256
                                                                mem[(7 * ceil32(return_data.size)) + 224] = _13049
                                                                require _12647 + (32 * _13049) + 32 <= return_data.size
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + _12647 + 256
                                                                t = (7 * ceil32(return_data.size)) + 256
                                                                while idx < _13049:
                                                                    require mem[s] == mem[s]
                                                                    mem[t] = mem[s]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[mem[64] + 4] = this.address
                                                                require ext_code.size(rewardTokenAddress)
                                                                staticcall rewardTokenAddress.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args address(this.address)
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _19107 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_19107] == mem[_19107]
                                                                if sub_0b4b41bc <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require sub_0b4b41bc
                                                                sub_7f94bf16 = mem[_19107] / sub_0b4b41bc
                                                                mem[mem[64] + 4] = treasuryAddress
                                                                mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                                require ext_code.size(assetAddress)
                                                                call assetAddress.0xa9059cbb with:
                                                                     gas gas_remaining wei
                                                                    args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _21273 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_21273] == bool(mem[_21273])
                                                else:
                                                    require ext_call.return_data[0] - totalDeposited
                                                    if (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / ext_call.return_data[0] - totalDeposited != sub_2f6236be:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not ext_call.return_data[0] - totalDeposited:
                                                        sub_bf4c8572 = 0
                                                        mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                                        mem[ceil32(return_data.size) + 132] = -1
                                                        require ext_code.size(sub_b8ab24bdAddress)
                                                        call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args lendingPoolAddress, -1
                                                        mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                        mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                                        mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                                        mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                                        require ext_code.size(lendingPoolAddress)
                                                        call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                             gas gas_remaining wei
                                                            args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                                        mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == ext_call.return_data[0]
                                                        mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                                        mem[(4 * ceil32(return_data.size)) + 132] = -1
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.approve(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args routerAddress, -1
                                                        mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                        if assetAddress == WAVAXAddress:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 388
                                                            while idx < 2:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 192
                                                            require return_data.size >= 32
                                                            _12643 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                            require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                            _13045 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                            mem[(7 * ceil32(return_data.size)) + 192] = _13045
                                                            require _12643 + (32 * _13045) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12643 + 224
                                                            t = (7 * ceil32(return_data.size)) + 224
                                                            while idx < _13045:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19103 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19103] == mem[_19103]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19103] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21269 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21269] == bool(mem[_21269])
                                                        else:
                                                            if rewardTokenAddress == WAVAXAddress:
                                                                mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                                mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                                mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                                mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                                mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + 128
                                                                t = (6 * ceil32(return_data.size)) + 388
                                                                while idx < 2:
                                                                    mem[t] = mem[s + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                                mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                                require ext_code.size(routerAddress)
                                                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = (7 * ceil32(return_data.size)) + 192
                                                                require return_data.size >= 32
                                                                _12645 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                                require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                                _13047 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                                mem[(7 * ceil32(return_data.size)) + 192] = _13047
                                                                require _12645 + (32 * _13047) + 32 <= return_data.size
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + _12645 + 224
                                                                t = (7 * ceil32(return_data.size)) + 224
                                                                while idx < _13047:
                                                                    require mem[s] == mem[s]
                                                                    mem[t] = mem[s]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[mem[64] + 4] = this.address
                                                                require ext_code.size(rewardTokenAddress)
                                                                staticcall rewardTokenAddress.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args address(this.address)
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _19105 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_19105] == mem[_19105]
                                                                if sub_0b4b41bc <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require sub_0b4b41bc
                                                                sub_7f94bf16 = mem[_19105] / sub_0b4b41bc
                                                                mem[mem[64] + 4] = treasuryAddress
                                                                mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                                require ext_code.size(assetAddress)
                                                                call assetAddress.0xa9059cbb with:
                                                                     gas gas_remaining wei
                                                                    args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _21271 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_21271] == bool(mem[_21271])
                                                            else:
                                                                mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                                mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                                mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                                mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[(6 * ceil32(return_data.size)) + 228] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                                mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                                mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + 128
                                                                t = (6 * ceil32(return_data.size)) + 420
                                                                while idx < 3:
                                                                    mem[t] = mem[s + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                                mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                                require ext_code.size(routerAddress)
                                                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = (7 * ceil32(return_data.size)) + 224
                                                                require return_data.size >= 32
                                                                _12644 = mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                                require mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                                _13046 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]
                                                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224] <= test266151307()
                                                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 32 >= 0
                                                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256
                                                                mem[(7 * ceil32(return_data.size)) + 224] = _13046
                                                                require _12644 + (32 * _13046) + 32 <= return_data.size
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + _12644 + 256
                                                                t = (7 * ceil32(return_data.size)) + 256
                                                                while idx < _13046:
                                                                    require mem[s] == mem[s]
                                                                    mem[t] = mem[s]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[mem[64] + 4] = this.address
                                                                require ext_code.size(rewardTokenAddress)
                                                                staticcall rewardTokenAddress.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args address(this.address)
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _19104 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_19104] == mem[_19104]
                                                                if sub_0b4b41bc <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require sub_0b4b41bc
                                                                sub_7f94bf16 = mem[_19104] / sub_0b4b41bc
                                                                mem[mem[64] + 4] = treasuryAddress
                                                                mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                                require ext_code.size(assetAddress)
                                                                call assetAddress.0xa9059cbb with:
                                                                     gas gas_remaining wei
                                                                    args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _21270 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_21270] == bool(mem[_21270])
                                                    else:
                                                        require ext_call.return_data[0] - totalDeposited
                                                        if (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / ext_call.return_data[0] - totalDeposited != sub_7e72b29f:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        sub_bf4c8572 = (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / 10000
                                                        mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                                        mem[ceil32(return_data.size) + 132] = -1
                                                        require ext_code.size(sub_b8ab24bdAddress)
                                                        call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args lendingPoolAddress, -1
                                                        mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                        mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                                        mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                                        mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                                        require ext_code.size(lendingPoolAddress)
                                                        call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                             gas gas_remaining wei
                                                            args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                                        mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == ext_call.return_data[0]
                                                        mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                                        mem[(4 * ceil32(return_data.size)) + 132] = -1
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.approve(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args routerAddress, -1
                                                        mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                        if assetAddress == WAVAXAddress:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 388
                                                            while idx < 2:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 192
                                                            require return_data.size >= 32
                                                            _12640 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                            require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                            _13042 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                            mem[(7 * ceil32(return_data.size)) + 192] = _13042
                                                            require _12640 + (32 * _13042) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12640 + 224
                                                            t = (7 * ceil32(return_data.size)) + 224
                                                            while idx < _13042:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19100 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19100] == mem[_19100]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19100] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21266 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21266] == bool(mem[_21266])
                                                        else:
                                                            if rewardTokenAddress == WAVAXAddress:
                                                                mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                                mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                                mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                                mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                                mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + 128
                                                                t = (6 * ceil32(return_data.size)) + 388
                                                                while idx < 2:
                                                                    mem[t] = mem[s + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                                mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                                require ext_code.size(routerAddress)
                                                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = (7 * ceil32(return_data.size)) + 192
                                                                require return_data.size >= 32
                                                                _12642 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                                require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                                _13044 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                                mem[(7 * ceil32(return_data.size)) + 192] = _13044
                                                                require _12642 + (32 * _13044) + 32 <= return_data.size
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + _12642 + 224
                                                                t = (7 * ceil32(return_data.size)) + 224
                                                                while idx < _13044:
                                                                    require mem[s] == mem[s]
                                                                    mem[t] = mem[s]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[mem[64] + 4] = this.address
                                                                require ext_code.size(rewardTokenAddress)
                                                                staticcall rewardTokenAddress.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args address(this.address)
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _19102 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_19102] == mem[_19102]
                                                                if sub_0b4b41bc <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require sub_0b4b41bc
                                                                sub_7f94bf16 = mem[_19102] / sub_0b4b41bc
                                                                mem[mem[64] + 4] = treasuryAddress
                                                                mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                                require ext_code.size(assetAddress)
                                                                call assetAddress.0xa9059cbb with:
                                                                     gas gas_remaining wei
                                                                    args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _21268 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_21268] == bool(mem[_21268])
                                                            else:
                                                                mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                                mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                                mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                                mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[(6 * ceil32(return_data.size)) + 228] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                                mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                                mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + 128
                                                                t = (6 * ceil32(return_data.size)) + 420
                                                                while idx < 3:
                                                                    mem[t] = mem[s + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                                mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                                require ext_code.size(routerAddress)
                                                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = (7 * ceil32(return_data.size)) + 224
                                                                require return_data.size >= 32
                                                                _12641 = mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                                require mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                                _13043 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]
                                                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224] <= test266151307()
                                                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 32 >= 0
                                                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256
                                                                mem[(7 * ceil32(return_data.size)) + 224] = _13043
                                                                require _12641 + (32 * _13043) + 32 <= return_data.size
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + _12641 + 256
                                                                t = (7 * ceil32(return_data.size)) + 256
                                                                while idx < _13043:
                                                                    require mem[s] == mem[s]
                                                                    mem[t] = mem[s]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[mem[64] + 4] = this.address
                                                                require ext_code.size(rewardTokenAddress)
                                                                staticcall rewardTokenAddress.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args address(this.address)
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _19101 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_19101] == mem[_19101]
                                                                if sub_0b4b41bc <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require sub_0b4b41bc
                                                                sub_7f94bf16 = mem[_19101] / sub_0b4b41bc
                                                                mem[mem[64] + 4] = treasuryAddress
                                                                mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                                require ext_code.size(assetAddress)
                                                                call assetAddress.0xa9059cbb with:
                                                                     gas gas_remaining wei
                                                                    args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _21267 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_21267] == bool(mem[_21267])
                                        else:
                                            require (sub_f12c8e0d * block.timestamp) + (sub_7f94bf16 * block.timestamp) - (sub_f12c8e0d * lastRewardTimestamp) - (sub_7f94bf16 * lastRewardTimestamp)
                                            if (10^12 * sub_f12c8e0d * block.timestamp) + (10^12 * sub_7f94bf16 * block.timestamp) - (10^12 * sub_f12c8e0d * lastRewardTimestamp) - (10^12 * sub_7f94bf16 * lastRewardTimestamp) / (sub_f12c8e0d * block.timestamp) + (sub_7f94bf16 * block.timestamp) - (sub_f12c8e0d * lastRewardTimestamp) - (sub_7f94bf16 * lastRewardTimestamp) != 10^12:
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
                                            if totalDeposited <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalDeposited
                                            if sub_a9ac33dd + ((10^12 * sub_f12c8e0d * block.timestamp) + (10^12 * sub_7f94bf16 * block.timestamp) - (10^12 * sub_f12c8e0d * lastRewardTimestamp) - (10^12 * sub_7f94bf16 * lastRewardTimestamp) / totalDeposited) < sub_a9ac33dd:
                                                revert with 0, 'SafeMath: addition overflow'
                                            sub_a9ac33dd += (10^12 * sub_f12c8e0d * block.timestamp) + (10^12 * sub_7f94bf16 * block.timestamp) - (10^12 * sub_f12c8e0d * lastRewardTimestamp) - (10^12 * sub_7f94bf16 * lastRewardTimestamp) / totalDeposited
                                            lastRewardTimestamp = block.timestamp
                                            mem[100] = this.address
                                            require ext_code.size(sub_b8ab24bdAddress)
                                            staticcall sub_b8ab24bdAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            mem[96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_call.return_data[0] == ext_call.return_data[0]
                                            if not ext_call.return_data[0] - totalDeposited:
                                                if not ext_call.return_data[0] - totalDeposited:
                                                    if not ext_call.return_data[0] - totalDeposited:
                                                        sub_bf4c8572 = 0
                                                        mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                                        mem[ceil32(return_data.size) + 132] = -1
                                                        require ext_code.size(sub_b8ab24bdAddress)
                                                        call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args lendingPoolAddress, -1
                                                        mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                        mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                                        mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                                        mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                                        require ext_code.size(lendingPoolAddress)
                                                        call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                             gas gas_remaining wei
                                                            args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                                        mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == ext_call.return_data[0]
                                                        mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                                        mem[(4 * ceil32(return_data.size)) + 132] = -1
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.approve(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args routerAddress, -1
                                                        mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                        if assetAddress == WAVAXAddress:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 388
                                                            while idx < 2:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 192
                                                            require return_data.size >= 32
                                                            _12637 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                            require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                            _13039 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                            mem[(7 * ceil32(return_data.size)) + 192] = _13039
                                                            require _12637 + (32 * _13039) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12637 + 224
                                                            t = (7 * ceil32(return_data.size)) + 224
                                                            while idx < _13039:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19097 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19097] == mem[_19097]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19097] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = 0
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, 0
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21263 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21263] == bool(mem[_21263])
                                                        else:
                                                            if rewardTokenAddress == WAVAXAddress:
                                                                mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                                mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                                mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                                mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + 128
                                                                t = (6 * ceil32(return_data.size)) + 388
                                                                while idx < 2:
                                                                    mem[t] = mem[s + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                                mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                                require ext_code.size(routerAddress)
                                                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = (7 * ceil32(return_data.size)) + 192
                                                                require return_data.size >= 32
                                                                _12639 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                                require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                                _13041 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                                mem[(7 * ceil32(return_data.size)) + 192] = _13041
                                                                require _12639 + (32 * _13041) + 32 <= return_data.size
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + _12639 + 224
                                                                t = (7 * ceil32(return_data.size)) + 224
                                                                while idx < _13041:
                                                                    require mem[s] == mem[s]
                                                                    mem[t] = mem[s]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[mem[64] + 4] = this.address
                                                                require ext_code.size(rewardTokenAddress)
                                                                staticcall rewardTokenAddress.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args address(this.address)
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _19099 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_19099] == mem[_19099]
                                                                if sub_0b4b41bc <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require sub_0b4b41bc
                                                                sub_7f94bf16 = mem[_19099] / sub_0b4b41bc
                                                                mem[mem[64] + 4] = treasuryAddress
                                                                mem[mem[64] + 36] = 0
                                                                require ext_code.size(assetAddress)
                                                                call assetAddress.0xa9059cbb with:
                                                                     gas gas_remaining wei
                                                                    args treasuryAddress, 0
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _21265 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_21265] == bool(mem[_21265])
                                                            else:
                                                                mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                                mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                                mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                                mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                                mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + 128
                                                                t = (6 * ceil32(return_data.size)) + 420
                                                                while idx < 3:
                                                                    mem[t] = mem[s + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                                mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                                require ext_code.size(routerAddress)
                                                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args 0, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = (7 * ceil32(return_data.size)) + 224
                                                                require return_data.size >= 32
                                                                _12638 = mem[(6 * ceil32(return_data.size)) + 224 len 4], 0
                                                                require mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 <= test266151307()
                                                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                                _13040 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]
                                                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224] <= test266151307()
                                                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 32 >= 0
                                                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256
                                                                mem[(7 * ceil32(return_data.size)) + 224] = _13040
                                                                require _12638 + (32 * _13040) + 32 <= return_data.size
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + _12638 + 256
                                                                t = (7 * ceil32(return_data.size)) + 256
                                                                while idx < _13040:
                                                                    require mem[s] == mem[s]
                                                                    mem[t] = mem[s]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[mem[64] + 4] = this.address
                                                                require ext_code.size(rewardTokenAddress)
                                                                staticcall rewardTokenAddress.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args address(this.address)
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _19098 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_19098] == mem[_19098]
                                                                if sub_0b4b41bc <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require sub_0b4b41bc
                                                                sub_7f94bf16 = mem[_19098] / sub_0b4b41bc
                                                                mem[mem[64] + 4] = treasuryAddress
                                                                mem[mem[64] + 36] = 0
                                                                require ext_code.size(assetAddress)
                                                                call assetAddress.0xa9059cbb with:
                                                                     gas gas_remaining wei
                                                                    args treasuryAddress, 0
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _21264 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_21264] == bool(mem[_21264])
                                                    else:
                                                        require ext_call.return_data[0] - totalDeposited
                                                        if (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / ext_call.return_data[0] - totalDeposited != sub_7e72b29f:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        sub_bf4c8572 = (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / 10000
                                                        mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                                        mem[ceil32(return_data.size) + 132] = -1
                                                        require ext_code.size(sub_b8ab24bdAddress)
                                                        call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args lendingPoolAddress, -1
                                                        mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                        mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                                        mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                                        mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                                        require ext_code.size(lendingPoolAddress)
                                                        call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                             gas gas_remaining wei
                                                            args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                                        mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == ext_call.return_data[0]
                                                        mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                                        mem[(4 * ceil32(return_data.size)) + 132] = -1
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.approve(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args routerAddress, -1
                                                        mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                        if assetAddress == WAVAXAddress:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 388
                                                            while idx < 2:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 192
                                                            require return_data.size >= 32
                                                            _12634 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                            require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                            _13036 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                            mem[(7 * ceil32(return_data.size)) + 192] = _13036
                                                            require _12634 + (32 * _13036) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12634 + 224
                                                            t = (7 * ceil32(return_data.size)) + 224
                                                            while idx < _13036:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19094 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19094] == mem[_19094]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19094] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = 0
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, 0
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21260 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21260] == bool(mem[_21260])
                                                        else:
                                                            if rewardTokenAddress == WAVAXAddress:
                                                                mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                                mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                                mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                                mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + 128
                                                                t = (6 * ceil32(return_data.size)) + 388
                                                                while idx < 2:
                                                                    mem[t] = mem[s + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                                mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                                require ext_code.size(routerAddress)
                                                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = (7 * ceil32(return_data.size)) + 192
                                                                require return_data.size >= 32
                                                                _12636 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                                require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                                _13038 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                                mem[(7 * ceil32(return_data.size)) + 192] = _13038
                                                                require _12636 + (32 * _13038) + 32 <= return_data.size
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + _12636 + 224
                                                                t = (7 * ceil32(return_data.size)) + 224
                                                                while idx < _13038:
                                                                    require mem[s] == mem[s]
                                                                    mem[t] = mem[s]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[mem[64] + 4] = this.address
                                                                require ext_code.size(rewardTokenAddress)
                                                                staticcall rewardTokenAddress.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args address(this.address)
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _19096 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_19096] == mem[_19096]
                                                                if sub_0b4b41bc <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require sub_0b4b41bc
                                                                sub_7f94bf16 = mem[_19096] / sub_0b4b41bc
                                                                mem[mem[64] + 4] = treasuryAddress
                                                                mem[mem[64] + 36] = 0
                                                                require ext_code.size(assetAddress)
                                                                call assetAddress.0xa9059cbb with:
                                                                     gas gas_remaining wei
                                                                    args treasuryAddress, 0
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _21262 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_21262] == bool(mem[_21262])
                                                            else:
                                                                mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                                mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                                mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                                mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                                mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + 128
                                                                t = (6 * ceil32(return_data.size)) + 420
                                                                while idx < 3:
                                                                    mem[t] = mem[s + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                                mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                                require ext_code.size(routerAddress)
                                                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args 0, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = (7 * ceil32(return_data.size)) + 224
                                                                require return_data.size >= 32
                                                                _12635 = mem[(6 * ceil32(return_data.size)) + 224 len 4], 0
                                                                require mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 <= test266151307()
                                                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                                _13037 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]
                                                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224] <= test266151307()
                                                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 32 >= 0
                                                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256
                                                                mem[(7 * ceil32(return_data.size)) + 224] = _13037
                                                                require _12635 + (32 * _13037) + 32 <= return_data.size
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + _12635 + 256
                                                                t = (7 * ceil32(return_data.size)) + 256
                                                                while idx < _13037:
                                                                    require mem[s] == mem[s]
                                                                    mem[t] = mem[s]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[mem[64] + 4] = this.address
                                                                require ext_code.size(rewardTokenAddress)
                                                                staticcall rewardTokenAddress.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args address(this.address)
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _19095 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_19095] == mem[_19095]
                                                                if sub_0b4b41bc <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require sub_0b4b41bc
                                                                sub_7f94bf16 = mem[_19095] / sub_0b4b41bc
                                                                mem[mem[64] + 4] = treasuryAddress
                                                                mem[mem[64] + 36] = 0
                                                                require ext_code.size(assetAddress)
                                                                call assetAddress.0xa9059cbb with:
                                                                     gas gas_remaining wei
                                                                    args treasuryAddress, 0
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _21261 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_21261] == bool(mem[_21261])
                                                else:
                                                    require ext_call.return_data[0] - totalDeposited
                                                    if (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / ext_call.return_data[0] - totalDeposited != sub_2f6236be:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not ext_call.return_data[0] - totalDeposited:
                                                        sub_bf4c8572 = 0
                                                        mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                                        mem[ceil32(return_data.size) + 132] = -1
                                                        require ext_code.size(sub_b8ab24bdAddress)
                                                        call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args lendingPoolAddress, -1
                                                        mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                        mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                                        mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                                        mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                                        require ext_code.size(lendingPoolAddress)
                                                        call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                             gas gas_remaining wei
                                                            args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                                        mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == ext_call.return_data[0]
                                                        mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                                        mem[(4 * ceil32(return_data.size)) + 132] = -1
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.approve(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args routerAddress, -1
                                                        mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                        if assetAddress == WAVAXAddress:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 388
                                                            while idx < 2:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 192
                                                            require return_data.size >= 32
                                                            _12631 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                            require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                            _13033 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                            mem[(7 * ceil32(return_data.size)) + 192] = _13033
                                                            require _12631 + (32 * _13033) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12631 + 224
                                                            t = (7 * ceil32(return_data.size)) + 224
                                                            while idx < _13033:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19091 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19091] == mem[_19091]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19091] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = 0
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, 0
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21257 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21257] == bool(mem[_21257])
                                                        else:
                                                            if rewardTokenAddress == WAVAXAddress:
                                                                mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                                mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                                mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                                mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                                mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + 128
                                                                t = (6 * ceil32(return_data.size)) + 388
                                                                while idx < 2:
                                                                    mem[t] = mem[s + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                                mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                                require ext_code.size(routerAddress)
                                                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = (7 * ceil32(return_data.size)) + 192
                                                                require return_data.size >= 32
                                                                _12633 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                                require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                                _13035 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                                mem[(7 * ceil32(return_data.size)) + 192] = _13035
                                                                require _12633 + (32 * _13035) + 32 <= return_data.size
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + _12633 + 224
                                                                t = (7 * ceil32(return_data.size)) + 224
                                                                while idx < _13035:
                                                                    require mem[s] == mem[s]
                                                                    mem[t] = mem[s]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[mem[64] + 4] = this.address
                                                                require ext_code.size(rewardTokenAddress)
                                                                staticcall rewardTokenAddress.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args address(this.address)
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _19093 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_19093] == mem[_19093]
                                                                if sub_0b4b41bc <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require sub_0b4b41bc
                                                                sub_7f94bf16 = mem[_19093] / sub_0b4b41bc
                                                                mem[mem[64] + 4] = treasuryAddress
                                                                mem[mem[64] + 36] = 0
                                                                require ext_code.size(assetAddress)
                                                                call assetAddress.0xa9059cbb with:
                                                                     gas gas_remaining wei
                                                                    args treasuryAddress, 0
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _21259 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_21259] == bool(mem[_21259])
                                                            else:
                                                                mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                                mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                                mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                                mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[(6 * ceil32(return_data.size)) + 228] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                                mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                                mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + 128
                                                                t = (6 * ceil32(return_data.size)) + 420
                                                                while idx < 3:
                                                                    mem[t] = mem[s + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                                mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                                require ext_code.size(routerAddress)
                                                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = (7 * ceil32(return_data.size)) + 224
                                                                require return_data.size >= 32
                                                                _12632 = mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                                require mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                                _13034 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]
                                                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224] <= test266151307()
                                                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 32 >= 0
                                                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256
                                                                mem[(7 * ceil32(return_data.size)) + 224] = _13034
                                                                require _12632 + (32 * _13034) + 32 <= return_data.size
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + _12632 + 256
                                                                t = (7 * ceil32(return_data.size)) + 256
                                                                while idx < _13034:
                                                                    require mem[s] == mem[s]
                                                                    mem[t] = mem[s]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[mem[64] + 4] = this.address
                                                                require ext_code.size(rewardTokenAddress)
                                                                staticcall rewardTokenAddress.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args address(this.address)
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _19092 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_19092] == mem[_19092]
                                                                if sub_0b4b41bc <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require sub_0b4b41bc
                                                                sub_7f94bf16 = mem[_19092] / sub_0b4b41bc
                                                                mem[mem[64] + 4] = treasuryAddress
                                                                mem[mem[64] + 36] = 0
                                                                require ext_code.size(assetAddress)
                                                                call assetAddress.0xa9059cbb with:
                                                                     gas gas_remaining wei
                                                                    args treasuryAddress, 0
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _21258 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_21258] == bool(mem[_21258])
                                                    else:
                                                        require ext_call.return_data[0] - totalDeposited
                                                        if (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / ext_call.return_data[0] - totalDeposited != sub_7e72b29f:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        sub_bf4c8572 = (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / 10000
                                                        mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                                        mem[ceil32(return_data.size) + 132] = -1
                                                        require ext_code.size(sub_b8ab24bdAddress)
                                                        call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args lendingPoolAddress, -1
                                                        mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                        mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                                        mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                                        mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                                        require ext_code.size(lendingPoolAddress)
                                                        call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                             gas gas_remaining wei
                                                            args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                                        mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == ext_call.return_data[0]
                                                        mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                                        mem[(4 * ceil32(return_data.size)) + 132] = -1
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.approve(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args routerAddress, -1
                                                        mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                        if assetAddress == WAVAXAddress:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 388
                                                            while idx < 2:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 192
                                                            require return_data.size >= 32
                                                            _12628 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                            require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                            _13030 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                            mem[(7 * ceil32(return_data.size)) + 192] = _13030
                                                            require _12628 + (32 * _13030) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12628 + 224
                                                            t = (7 * ceil32(return_data.size)) + 224
                                                            while idx < _13030:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19088 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19088] == mem[_19088]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19088] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = 0
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, 0
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21254 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21254] == bool(mem[_21254])
                                                        else:
                                                            if rewardTokenAddress == WAVAXAddress:
                                                                mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                                mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                                mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                                mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                                mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + 128
                                                                t = (6 * ceil32(return_data.size)) + 388
                                                                while idx < 2:
                                                                    mem[t] = mem[s + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                                mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                                require ext_code.size(routerAddress)
                                                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = (7 * ceil32(return_data.size)) + 192
                                                                require return_data.size >= 32
                                                                _12630 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                                require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                                _13032 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                                mem[(7 * ceil32(return_data.size)) + 192] = _13032
                                                                require _12630 + (32 * _13032) + 32 <= return_data.size
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + _12630 + 224
                                                                t = (7 * ceil32(return_data.size)) + 224
                                                                while idx < _13032:
                                                                    require mem[s] == mem[s]
                                                                    mem[t] = mem[s]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[mem[64] + 4] = this.address
                                                                require ext_code.size(rewardTokenAddress)
                                                                staticcall rewardTokenAddress.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args address(this.address)
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _19090 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_19090] == mem[_19090]
                                                                if sub_0b4b41bc <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require sub_0b4b41bc
                                                                sub_7f94bf16 = mem[_19090] / sub_0b4b41bc
                                                                mem[mem[64] + 4] = treasuryAddress
                                                                mem[mem[64] + 36] = 0
                                                                require ext_code.size(assetAddress)
                                                                call assetAddress.0xa9059cbb with:
                                                                     gas gas_remaining wei
                                                                    args treasuryAddress, 0
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _21256 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_21256] == bool(mem[_21256])
                                                            else:
                                                                mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                                mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                                mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                                mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[(6 * ceil32(return_data.size)) + 228] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                                mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                                mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + 128
                                                                t = (6 * ceil32(return_data.size)) + 420
                                                                while idx < 3:
                                                                    mem[t] = mem[s + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                                mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                                require ext_code.size(routerAddress)
                                                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = (7 * ceil32(return_data.size)) + 224
                                                                require return_data.size >= 32
                                                                _12629 = mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                                require mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                                _13031 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]
                                                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224] <= test266151307()
                                                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 32 >= 0
                                                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256
                                                                mem[(7 * ceil32(return_data.size)) + 224] = _13031
                                                                require _12629 + (32 * _13031) + 32 <= return_data.size
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + _12629 + 256
                                                                t = (7 * ceil32(return_data.size)) + 256
                                                                while idx < _13031:
                                                                    require mem[s] == mem[s]
                                                                    mem[t] = mem[s]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[mem[64] + 4] = this.address
                                                                require ext_code.size(rewardTokenAddress)
                                                                staticcall rewardTokenAddress.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args address(this.address)
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _19089 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_19089] == mem[_19089]
                                                                if sub_0b4b41bc <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require sub_0b4b41bc
                                                                sub_7f94bf16 = mem[_19089] / sub_0b4b41bc
                                                                mem[mem[64] + 4] = treasuryAddress
                                                                mem[mem[64] + 36] = 0
                                                                require ext_code.size(assetAddress)
                                                                call assetAddress.0xa9059cbb with:
                                                                     gas gas_remaining wei
                                                                    args treasuryAddress, 0
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _21255 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_21255] == bool(mem[_21255])
                                            else:
                                                require ext_call.return_data[0] - totalDeposited
                                                if (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / ext_call.return_data[0] - totalDeposited != sub_7796ff37:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not ext_call.return_data[0] - totalDeposited:
                                                    if not ext_call.return_data[0] - totalDeposited:
                                                        sub_bf4c8572 = 0
                                                        mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                                        mem[ceil32(return_data.size) + 132] = -1
                                                        require ext_code.size(sub_b8ab24bdAddress)
                                                        call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args lendingPoolAddress, -1
                                                        mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                        mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                                        mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                                        mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                                        require ext_code.size(lendingPoolAddress)
                                                        call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                             gas gas_remaining wei
                                                            args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                                        mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == ext_call.return_data[0]
                                                        mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                                        mem[(4 * ceil32(return_data.size)) + 132] = -1
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.approve(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args routerAddress, -1
                                                        mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                        if assetAddress == WAVAXAddress:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 388
                                                            while idx < 2:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 192
                                                            require return_data.size >= 32
                                                            _12625 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                            require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                            _13027 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                            mem[(7 * ceil32(return_data.size)) + 192] = _13027
                                                            require _12625 + (32 * _13027) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12625 + 224
                                                            t = (7 * ceil32(return_data.size)) + 224
                                                            while idx < _13027:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19085 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19085] == mem[_19085]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19085] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21251 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21251] == bool(mem[_21251])
                                                        else:
                                                            if rewardTokenAddress == WAVAXAddress:
                                                                mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                                mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                                mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                                mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + 128
                                                                t = (6 * ceil32(return_data.size)) + 388
                                                                while idx < 2:
                                                                    mem[t] = mem[s + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                                mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                                require ext_code.size(routerAddress)
                                                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = (7 * ceil32(return_data.size)) + 192
                                                                require return_data.size >= 32
                                                                _12627 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                                require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                                _13029 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                                mem[(7 * ceil32(return_data.size)) + 192] = _13029
                                                                require _12627 + (32 * _13029) + 32 <= return_data.size
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + _12627 + 224
                                                                t = (7 * ceil32(return_data.size)) + 224
                                                                while idx < _13029:
                                                                    require mem[s] == mem[s]
                                                                    mem[t] = mem[s]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[mem[64] + 4] = this.address
                                                                require ext_code.size(rewardTokenAddress)
                                                                staticcall rewardTokenAddress.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args address(this.address)
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _19087 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_19087] == mem[_19087]
                                                                if sub_0b4b41bc <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require sub_0b4b41bc
                                                                sub_7f94bf16 = mem[_19087] / sub_0b4b41bc
                                                                mem[mem[64] + 4] = treasuryAddress
                                                                mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                                require ext_code.size(assetAddress)
                                                                call assetAddress.0xa9059cbb with:
                                                                     gas gas_remaining wei
                                                                    args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _21253 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_21253] == bool(mem[_21253])
                                                            else:
                                                                mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                                mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                                mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                                mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                                mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + 128
                                                                t = (6 * ceil32(return_data.size)) + 420
                                                                while idx < 3:
                                                                    mem[t] = mem[s + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                                mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                                require ext_code.size(routerAddress)
                                                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args 0, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = (7 * ceil32(return_data.size)) + 224
                                                                require return_data.size >= 32
                                                                _12626 = mem[(6 * ceil32(return_data.size)) + 224 len 4], 0
                                                                require mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 <= test266151307()
                                                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                                _13028 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]
                                                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224] <= test266151307()
                                                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 32 >= 0
                                                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256
                                                                mem[(7 * ceil32(return_data.size)) + 224] = _13028
                                                                require _12626 + (32 * _13028) + 32 <= return_data.size
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + _12626 + 256
                                                                t = (7 * ceil32(return_data.size)) + 256
                                                                while idx < _13028:
                                                                    require mem[s] == mem[s]
                                                                    mem[t] = mem[s]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[mem[64] + 4] = this.address
                                                                require ext_code.size(rewardTokenAddress)
                                                                staticcall rewardTokenAddress.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args address(this.address)
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _19086 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_19086] == mem[_19086]
                                                                if sub_0b4b41bc <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require sub_0b4b41bc
                                                                sub_7f94bf16 = mem[_19086] / sub_0b4b41bc
                                                                mem[mem[64] + 4] = treasuryAddress
                                                                mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                                require ext_code.size(assetAddress)
                                                                call assetAddress.0xa9059cbb with:
                                                                     gas gas_remaining wei
                                                                    args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _21252 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_21252] == bool(mem[_21252])
                                                    else:
                                                        require ext_call.return_data[0] - totalDeposited
                                                        if (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / ext_call.return_data[0] - totalDeposited != sub_7e72b29f:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        sub_bf4c8572 = (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / 10000
                                                        mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                                        mem[ceil32(return_data.size) + 132] = -1
                                                        require ext_code.size(sub_b8ab24bdAddress)
                                                        call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args lendingPoolAddress, -1
                                                        mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                        mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                                        mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                                        mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                                        require ext_code.size(lendingPoolAddress)
                                                        call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                             gas gas_remaining wei
                                                            args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                                        mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == ext_call.return_data[0]
                                                        mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                                        mem[(4 * ceil32(return_data.size)) + 132] = -1
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.approve(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args routerAddress, -1
                                                        mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                        if assetAddress == WAVAXAddress:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 388
                                                            while idx < 2:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 192
                                                            require return_data.size >= 32
                                                            _12622 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                            require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                            _13024 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                            mem[(7 * ceil32(return_data.size)) + 192] = _13024
                                                            require _12622 + (32 * _13024) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12622 + 224
                                                            t = (7 * ceil32(return_data.size)) + 224
                                                            while idx < _13024:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19082 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19082] == mem[_19082]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19082] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21248 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21248] == bool(mem[_21248])
                                                        else:
                                                            if rewardTokenAddress == WAVAXAddress:
                                                                mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                                mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                                mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                                mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + 128
                                                                t = (6 * ceil32(return_data.size)) + 388
                                                                while idx < 2:
                                                                    mem[t] = mem[s + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                                mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                                require ext_code.size(routerAddress)
                                                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = (7 * ceil32(return_data.size)) + 192
                                                                require return_data.size >= 32
                                                                _12624 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                                require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                                _13026 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                                mem[(7 * ceil32(return_data.size)) + 192] = _13026
                                                                require _12624 + (32 * _13026) + 32 <= return_data.size
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + _12624 + 224
                                                                t = (7 * ceil32(return_data.size)) + 224
                                                                while idx < _13026:
                                                                    require mem[s] == mem[s]
                                                                    mem[t] = mem[s]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[mem[64] + 4] = this.address
                                                                require ext_code.size(rewardTokenAddress)
                                                                staticcall rewardTokenAddress.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args address(this.address)
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _19084 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_19084] == mem[_19084]
                                                                if sub_0b4b41bc <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require sub_0b4b41bc
                                                                sub_7f94bf16 = mem[_19084] / sub_0b4b41bc
                                                                mem[mem[64] + 4] = treasuryAddress
                                                                mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                                require ext_code.size(assetAddress)
                                                                call assetAddress.0xa9059cbb with:
                                                                     gas gas_remaining wei
                                                                    args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _21250 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_21250] == bool(mem[_21250])
                                                            else:
                                                                mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                                mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                                mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                                mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                                mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + 128
                                                                t = (6 * ceil32(return_data.size)) + 420
                                                                while idx < 3:
                                                                    mem[t] = mem[s + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                                mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                                require ext_code.size(routerAddress)
                                                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args 0, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = (7 * ceil32(return_data.size)) + 224
                                                                require return_data.size >= 32
                                                                _12623 = mem[(6 * ceil32(return_data.size)) + 224 len 4], 0
                                                                require mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 <= test266151307()
                                                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                                _13025 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]
                                                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224] <= test266151307()
                                                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 32 >= 0
                                                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256
                                                                mem[(7 * ceil32(return_data.size)) + 224] = _13025
                                                                require _12623 + (32 * _13025) + 32 <= return_data.size
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + _12623 + 256
                                                                t = (7 * ceil32(return_data.size)) + 256
                                                                while idx < _13025:
                                                                    require mem[s] == mem[s]
                                                                    mem[t] = mem[s]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[mem[64] + 4] = this.address
                                                                require ext_code.size(rewardTokenAddress)
                                                                staticcall rewardTokenAddress.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args address(this.address)
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _19083 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_19083] == mem[_19083]
                                                                if sub_0b4b41bc <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require sub_0b4b41bc
                                                                sub_7f94bf16 = mem[_19083] / sub_0b4b41bc
                                                                mem[mem[64] + 4] = treasuryAddress
                                                                mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                                require ext_code.size(assetAddress)
                                                                call assetAddress.0xa9059cbb with:
                                                                     gas gas_remaining wei
                                                                    args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _21249 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_21249] == bool(mem[_21249])
                                                else:
                                                    require ext_call.return_data[0] - totalDeposited
                                                    if (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / ext_call.return_data[0] - totalDeposited != sub_2f6236be:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not ext_call.return_data[0] - totalDeposited:
                                                        sub_bf4c8572 = 0
                                                        mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                                        mem[ceil32(return_data.size) + 132] = -1
                                                        require ext_code.size(sub_b8ab24bdAddress)
                                                        call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args lendingPoolAddress, -1
                                                        mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                        mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                                        mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                                        mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                                        require ext_code.size(lendingPoolAddress)
                                                        call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                             gas gas_remaining wei
                                                            args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                                        mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == ext_call.return_data[0]
                                                        mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                                        mem[(4 * ceil32(return_data.size)) + 132] = -1
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.approve(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args routerAddress, -1
                                                        mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                        if assetAddress == WAVAXAddress:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 388
                                                            while idx < 2:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 192
                                                            require return_data.size >= 32
                                                            _12619 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                            require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                            _13021 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                            mem[(7 * ceil32(return_data.size)) + 192] = _13021
                                                            require _12619 + (32 * _13021) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12619 + 224
                                                            t = (7 * ceil32(return_data.size)) + 224
                                                            while idx < _13021:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19079 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19079] == mem[_19079]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19079] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21245 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21245] == bool(mem[_21245])
                                                        else:
                                                            if rewardTokenAddress == WAVAXAddress:
                                                                mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                                mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                                mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                                mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                                mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + 128
                                                                t = (6 * ceil32(return_data.size)) + 388
                                                                while idx < 2:
                                                                    mem[t] = mem[s + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                                mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                                require ext_code.size(routerAddress)
                                                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = (7 * ceil32(return_data.size)) + 192
                                                                require return_data.size >= 32
                                                                _12621 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                                require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                                _13023 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                                mem[(7 * ceil32(return_data.size)) + 192] = _13023
                                                                require _12621 + (32 * _13023) + 32 <= return_data.size
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + _12621 + 224
                                                                t = (7 * ceil32(return_data.size)) + 224
                                                                while idx < _13023:
                                                                    require mem[s] == mem[s]
                                                                    mem[t] = mem[s]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[mem[64] + 4] = this.address
                                                                require ext_code.size(rewardTokenAddress)
                                                                staticcall rewardTokenAddress.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args address(this.address)
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _19081 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_19081] == mem[_19081]
                                                                if sub_0b4b41bc <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require sub_0b4b41bc
                                                                sub_7f94bf16 = mem[_19081] / sub_0b4b41bc
                                                                mem[mem[64] + 4] = treasuryAddress
                                                                mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                                require ext_code.size(assetAddress)
                                                                call assetAddress.0xa9059cbb with:
                                                                     gas gas_remaining wei
                                                                    args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _21247 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_21247] == bool(mem[_21247])
                                                            else:
                                                                mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                                mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                                mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                                mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[(6 * ceil32(return_data.size)) + 228] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                                mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                                mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + 128
                                                                t = (6 * ceil32(return_data.size)) + 420
                                                                while idx < 3:
                                                                    mem[t] = mem[s + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                                mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                                require ext_code.size(routerAddress)
                                                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = (7 * ceil32(return_data.size)) + 224
                                                                require return_data.size >= 32
                                                                _12620 = mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                                require mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                                _13022 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]
                                                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224] <= test266151307()
                                                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 32 >= 0
                                                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256
                                                                mem[(7 * ceil32(return_data.size)) + 224] = _13022
                                                                require _12620 + (32 * _13022) + 32 <= return_data.size
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + _12620 + 256
                                                                t = (7 * ceil32(return_data.size)) + 256
                                                                while idx < _13022:
                                                                    require mem[s] == mem[s]
                                                                    mem[t] = mem[s]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[mem[64] + 4] = this.address
                                                                require ext_code.size(rewardTokenAddress)
                                                                staticcall rewardTokenAddress.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args address(this.address)
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _19080 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_19080] == mem[_19080]
                                                                if sub_0b4b41bc <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require sub_0b4b41bc
                                                                sub_7f94bf16 = mem[_19080] / sub_0b4b41bc
                                                                mem[mem[64] + 4] = treasuryAddress
                                                                mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                                require ext_code.size(assetAddress)
                                                                call assetAddress.0xa9059cbb with:
                                                                     gas gas_remaining wei
                                                                    args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _21246 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_21246] == bool(mem[_21246])
                                                    else:
                                                        require ext_call.return_data[0] - totalDeposited
                                                        if (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / ext_call.return_data[0] - totalDeposited != sub_7e72b29f:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        sub_bf4c8572 = (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / 10000
                                                        mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                                        mem[ceil32(return_data.size) + 132] = -1
                                                        require ext_code.size(sub_b8ab24bdAddress)
                                                        call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args lendingPoolAddress, -1
                                                        mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                        mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                                        mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                                        mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                                        require ext_code.size(lendingPoolAddress)
                                                        call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                             gas gas_remaining wei
                                                            args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                                        mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == ext_call.return_data[0]
                                                        mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                                        mem[(4 * ceil32(return_data.size)) + 132] = -1
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.approve(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args routerAddress, -1
                                                        mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                        if assetAddress == WAVAXAddress:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 388
                                                            while idx < 2:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 192
                                                            require return_data.size >= 32
                                                            _12616 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                            require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                            _13018 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                            mem[(7 * ceil32(return_data.size)) + 192] = _13018
                                                            require _12616 + (32 * _13018) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12616 + 224
                                                            t = (7 * ceil32(return_data.size)) + 224
                                                            while idx < _13018:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19076 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19076] == mem[_19076]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19076] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21242 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21242] == bool(mem[_21242])
                                                        else:
                                                            if rewardTokenAddress == WAVAXAddress:
                                                                mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                                mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                                mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                                mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                                mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + 128
                                                                t = (6 * ceil32(return_data.size)) + 388
                                                                while idx < 2:
                                                                    mem[t] = mem[s + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                                mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                                require ext_code.size(routerAddress)
                                                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = (7 * ceil32(return_data.size)) + 192
                                                                require return_data.size >= 32
                                                                _12618 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                                require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                                _13020 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                                mem[(7 * ceil32(return_data.size)) + 192] = _13020
                                                                require _12618 + (32 * _13020) + 32 <= return_data.size
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + _12618 + 224
                                                                t = (7 * ceil32(return_data.size)) + 224
                                                                while idx < _13020:
                                                                    require mem[s] == mem[s]
                                                                    mem[t] = mem[s]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[mem[64] + 4] = this.address
                                                                require ext_code.size(rewardTokenAddress)
                                                                staticcall rewardTokenAddress.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args address(this.address)
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _19078 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_19078] == mem[_19078]
                                                                if sub_0b4b41bc <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require sub_0b4b41bc
                                                                sub_7f94bf16 = mem[_19078] / sub_0b4b41bc
                                                                mem[mem[64] + 4] = treasuryAddress
                                                                mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                                require ext_code.size(assetAddress)
                                                                call assetAddress.0xa9059cbb with:
                                                                     gas gas_remaining wei
                                                                    args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _21244 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_21244] == bool(mem[_21244])
                                                            else:
                                                                mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                                mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                                mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                                mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[(6 * ceil32(return_data.size)) + 228] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                                mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                                mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + 128
                                                                t = (6 * ceil32(return_data.size)) + 420
                                                                while idx < 3:
                                                                    mem[t] = mem[s + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                                mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                                require ext_code.size(routerAddress)
                                                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = (7 * ceil32(return_data.size)) + 224
                                                                require return_data.size >= 32
                                                                _12617 = mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                                require mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                                _13019 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]
                                                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224] <= test266151307()
                                                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 32 >= 0
                                                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256
                                                                mem[(7 * ceil32(return_data.size)) + 224] = _13019
                                                                require _12617 + (32 * _13019) + 32 <= return_data.size
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + _12617 + 256
                                                                t = (7 * ceil32(return_data.size)) + 256
                                                                while idx < _13019:
                                                                    require mem[s] == mem[s]
                                                                    mem[t] = mem[s]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[mem[64] + 4] = this.address
                                                                require ext_code.size(rewardTokenAddress)
                                                                staticcall rewardTokenAddress.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args address(this.address)
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _19077 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_19077] == mem[_19077]
                                                                if sub_0b4b41bc <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require sub_0b4b41bc
                                                                sub_7f94bf16 = mem[_19077] / sub_0b4b41bc
                                                                mem[mem[64] + 4] = treasuryAddress
                                                                mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                                require ext_code.size(assetAddress)
                                                                call assetAddress.0xa9059cbb with:
                                                                     gas gas_remaining wei
                                                                    args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _21243 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_21243] == bool(mem[_21243])
                                    else:
                                        require (block.timestamp * sub_f12c8e0d) - (lastRewardTimestamp * sub_f12c8e0d)
                                        if (block.timestamp * sub_f12c8e0d) - (lastRewardTimestamp * sub_f12c8e0d) / (block.timestamp * sub_f12c8e0d) - (lastRewardTimestamp * sub_f12c8e0d) != 1:
                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
                                        require ext_code.size(rewardWalletAddress)
                                        call rewardWalletAddress.requestReward(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args ((block.timestamp * sub_f12c8e0d) - (lastRewardTimestamp * sub_f12c8e0d))
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not (sub_f12c8e0d * block.timestamp) + (sub_7f94bf16 * block.timestamp) - (sub_f12c8e0d * lastRewardTimestamp) - (sub_7f94bf16 * lastRewardTimestamp):
                                            if totalDeposited <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalDeposited
                                            if sub_a9ac33dd + (0 / totalDeposited) < sub_a9ac33dd:
                                                revert with 0, 'SafeMath: addition overflow'
                                            sub_a9ac33dd += 0 / totalDeposited
                                            lastRewardTimestamp = block.timestamp
                                            mem[100] = this.address
                                            require ext_code.size(sub_b8ab24bdAddress)
                                            staticcall sub_b8ab24bdAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            mem[96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_call.return_data[0] == ext_call.return_data[0]
                                            if not ext_call.return_data[0] - totalDeposited:
                                                if not ext_call.return_data[0] - totalDeposited:
                                                    if not ext_call.return_data[0] - totalDeposited:
                                                        sub_bf4c8572 = 0
                                                        mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                                        mem[ceil32(return_data.size) + 132] = -1
                                                        require ext_code.size(sub_b8ab24bdAddress)
                                                        call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args lendingPoolAddress, -1
                                                        mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                        mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                                        mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                                        mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                                        require ext_code.size(lendingPoolAddress)
                                                        call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                             gas gas_remaining wei
                                                            args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                                        mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == ext_call.return_data[0]
                                                        mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                                        mem[(4 * ceil32(return_data.size)) + 132] = -1
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.approve(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args routerAddress, -1
                                                        mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                        if assetAddress == WAVAXAddress:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 388
                                                            while idx < 2:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 192
                                                            require return_data.size >= 32
                                                            _12613 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                            require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                            _13015 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                            mem[(7 * ceil32(return_data.size)) + 192] = _13015
                                                            require _12613 + (32 * _13015) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12613 + 224
                                                            t = (7 * ceil32(return_data.size)) + 224
                                                            while idx < _13015:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19073 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19073] == mem[_19073]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19073] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = 0
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, 0
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21239 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21239] == bool(mem[_21239])
                                                        else:
                                                            if rewardTokenAddress == WAVAXAddress:
                                                                mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                                mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                                mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                                mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + 128
                                                                t = (6 * ceil32(return_data.size)) + 388
                                                                while idx < 2:
                                                                    mem[t] = mem[s + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                                mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                                require ext_code.size(routerAddress)
                                                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = (7 * ceil32(return_data.size)) + 192
                                                                require return_data.size >= 32
                                                                _12615 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                                require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                                _13017 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                                mem[(7 * ceil32(return_data.size)) + 192] = _13017
                                                                require _12615 + (32 * _13017) + 32 <= return_data.size
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + _12615 + 224
                                                                t = (7 * ceil32(return_data.size)) + 224
                                                                while idx < _13017:
                                                                    require mem[s] == mem[s]
                                                                    mem[t] = mem[s]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[mem[64] + 4] = this.address
                                                                require ext_code.size(rewardTokenAddress)
                                                                staticcall rewardTokenAddress.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args address(this.address)
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _19075 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_19075] == mem[_19075]
                                                                if sub_0b4b41bc <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require sub_0b4b41bc
                                                                sub_7f94bf16 = mem[_19075] / sub_0b4b41bc
                                                                mem[mem[64] + 4] = treasuryAddress
                                                                mem[mem[64] + 36] = 0
                                                                require ext_code.size(assetAddress)
                                                                call assetAddress.0xa9059cbb with:
                                                                     gas gas_remaining wei
                                                                    args treasuryAddress, 0
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _21241 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_21241] == bool(mem[_21241])
                                                            else:
                                                                mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                                mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                                mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                                mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                                mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + 128
                                                                t = (6 * ceil32(return_data.size)) + 420
                                                                while idx < 3:
                                                                    mem[t] = mem[s + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                                mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                                require ext_code.size(routerAddress)
                                                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args 0, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = (7 * ceil32(return_data.size)) + 224
                                                                require return_data.size >= 32
                                                                _12614 = mem[(6 * ceil32(return_data.size)) + 224 len 4], 0
                                                                require mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 <= test266151307()
                                                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                                _13016 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]
                                                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224] <= test266151307()
                                                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 32 >= 0
                                                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256
                                                                mem[(7 * ceil32(return_data.size)) + 224] = _13016
                                                                require _12614 + (32 * _13016) + 32 <= return_data.size
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + _12614 + 256
                                                                t = (7 * ceil32(return_data.size)) + 256
                                                                while idx < _13016:
                                                                    require mem[s] == mem[s]
                                                                    mem[t] = mem[s]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[mem[64] + 4] = this.address
                                                                require ext_code.size(rewardTokenAddress)
                                                                staticcall rewardTokenAddress.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args address(this.address)
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _19074 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_19074] == mem[_19074]
                                                                if sub_0b4b41bc <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require sub_0b4b41bc
                                                                sub_7f94bf16 = mem[_19074] / sub_0b4b41bc
                                                                mem[mem[64] + 4] = treasuryAddress
                                                                mem[mem[64] + 36] = 0
                                                                require ext_code.size(assetAddress)
                                                                call assetAddress.0xa9059cbb with:
                                                                     gas gas_remaining wei
                                                                    args treasuryAddress, 0
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _21240 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_21240] == bool(mem[_21240])
                                                    else:
                                                        require ext_call.return_data[0] - totalDeposited
                                                        if (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / ext_call.return_data[0] - totalDeposited != sub_7e72b29f:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        sub_bf4c8572 = (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / 10000
                                                        mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                                        mem[ceil32(return_data.size) + 132] = -1
                                                        require ext_code.size(sub_b8ab24bdAddress)
                                                        call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args lendingPoolAddress, -1
                                                        mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                        mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                                        mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                                        mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                                        require ext_code.size(lendingPoolAddress)
                                                        call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                             gas gas_remaining wei
                                                            args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                                        mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == ext_call.return_data[0]
                                                        mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                                        mem[(4 * ceil32(return_data.size)) + 132] = -1
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.approve(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args routerAddress, -1
                                                        mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                        if assetAddress == WAVAXAddress:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 388
                                                            while idx < 2:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 192
                                                            require return_data.size >= 32
                                                            _12610 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                            require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                            _13012 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                            mem[(7 * ceil32(return_data.size)) + 192] = _13012
                                                            require _12610 + (32 * _13012) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12610 + 224
                                                            t = (7 * ceil32(return_data.size)) + 224
                                                            while idx < _13012:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19070 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19070] == mem[_19070]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19070] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = 0
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, 0
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21236 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21236] == bool(mem[_21236])
                                                        else:
                                                            if rewardTokenAddress == WAVAXAddress:
                                                                mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                                mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                                mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                                mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + 128
                                                                t = (6 * ceil32(return_data.size)) + 388
                                                                while idx < 2:
                                                                    mem[t] = mem[s + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                                mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                                require ext_code.size(routerAddress)
                                                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = (7 * ceil32(return_data.size)) + 192
                                                                require return_data.size >= 32
                                                                _12612 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                                require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                                _13014 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                                mem[(7 * ceil32(return_data.size)) + 192] = _13014
                                                                require _12612 + (32 * _13014) + 32 <= return_data.size
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + _12612 + 224
                                                                t = (7 * ceil32(return_data.size)) + 224
                                                                while idx < _13014:
                                                                    require mem[s] == mem[s]
                                                                    mem[t] = mem[s]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[mem[64] + 4] = this.address
                                                                require ext_code.size(rewardTokenAddress)
                                                                staticcall rewardTokenAddress.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args address(this.address)
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _19072 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_19072] == mem[_19072]
                                                                if sub_0b4b41bc <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require sub_0b4b41bc
                                                                sub_7f94bf16 = mem[_19072] / sub_0b4b41bc
                                                                mem[mem[64] + 4] = treasuryAddress
                                                                mem[mem[64] + 36] = 0
                                                                require ext_code.size(assetAddress)
                                                                call assetAddress.0xa9059cbb with:
                                                                     gas gas_remaining wei
                                                                    args treasuryAddress, 0
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _21238 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_21238] == bool(mem[_21238])
                                                            else:
                                                                mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                                mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                                mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                                mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                                mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + 128
                                                                t = (6 * ceil32(return_data.size)) + 420
                                                                while idx < 3:
                                                                    mem[t] = mem[s + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                                mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                                require ext_code.size(routerAddress)
                                                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args 0, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = (7 * ceil32(return_data.size)) + 224
                                                                require return_data.size >= 32
                                                                _12611 = mem[(6 * ceil32(return_data.size)) + 224 len 4], 0
                                                                require mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 <= test266151307()
                                                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                                _13013 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]
                                                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224] <= test266151307()
                                                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 32 >= 0
                                                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256
                                                                mem[(7 * ceil32(return_data.size)) + 224] = _13013
                                                                require _12611 + (32 * _13013) + 32 <= return_data.size
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + _12611 + 256
                                                                t = (7 * ceil32(return_data.size)) + 256
                                                                while idx < _13013:
                                                                    require mem[s] == mem[s]
                                                                    mem[t] = mem[s]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[mem[64] + 4] = this.address
                                                                require ext_code.size(rewardTokenAddress)
                                                                staticcall rewardTokenAddress.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args address(this.address)
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _19071 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_19071] == mem[_19071]
                                                                if sub_0b4b41bc <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require sub_0b4b41bc
                                                                sub_7f94bf16 = mem[_19071] / sub_0b4b41bc
                                                                mem[mem[64] + 4] = treasuryAddress
                                                                mem[mem[64] + 36] = 0
                                                                require ext_code.size(assetAddress)
                                                                call assetAddress.0xa9059cbb with:
                                                                     gas gas_remaining wei
                                                                    args treasuryAddress, 0
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _21237 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_21237] == bool(mem[_21237])
                                                else:
                                                    require ext_call.return_data[0] - totalDeposited
                                                    if (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / ext_call.return_data[0] - totalDeposited != sub_2f6236be:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not ext_call.return_data[0] - totalDeposited:
                                                        sub_bf4c8572 = 0
                                                        mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                                        mem[ceil32(return_data.size) + 132] = -1
                                                        require ext_code.size(sub_b8ab24bdAddress)
                                                        call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args lendingPoolAddress, -1
                                                        mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                        mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                                        mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                                        mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                                        require ext_code.size(lendingPoolAddress)
                                                        call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                             gas gas_remaining wei
                                                            args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                                        mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == ext_call.return_data[0]
                                                        mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                                        mem[(4 * ceil32(return_data.size)) + 132] = -1
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.approve(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args routerAddress, -1
                                                        mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                        if assetAddress == WAVAXAddress:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 388
                                                            while idx < 2:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 192
                                                            require return_data.size >= 32
                                                            _12607 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                            require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                            _13009 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                            mem[(7 * ceil32(return_data.size)) + 192] = _13009
                                                            require _12607 + (32 * _13009) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12607 + 224
                                                            t = (7 * ceil32(return_data.size)) + 224
                                                            while idx < _13009:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19067 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19067] == mem[_19067]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19067] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = 0
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, 0
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21233 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21233] == bool(mem[_21233])
                                                        else:
                                                            if rewardTokenAddress == WAVAXAddress:
                                                                mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                                mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                                mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                                mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                                mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + 128
                                                                t = (6 * ceil32(return_data.size)) + 388
                                                                while idx < 2:
                                                                    mem[t] = mem[s + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                                mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                                require ext_code.size(routerAddress)
                                                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = (7 * ceil32(return_data.size)) + 192
                                                                require return_data.size >= 32
                                                                _12609 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                                require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                                _13011 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                                mem[(7 * ceil32(return_data.size)) + 192] = _13011
                                                                require _12609 + (32 * _13011) + 32 <= return_data.size
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + _12609 + 224
                                                                t = (7 * ceil32(return_data.size)) + 224
                                                                while idx < _13011:
                                                                    require mem[s] == mem[s]
                                                                    mem[t] = mem[s]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[mem[64] + 4] = this.address
                                                                require ext_code.size(rewardTokenAddress)
                                                                staticcall rewardTokenAddress.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args address(this.address)
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _19069 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_19069] == mem[_19069]
                                                                if sub_0b4b41bc <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require sub_0b4b41bc
                                                                sub_7f94bf16 = mem[_19069] / sub_0b4b41bc
                                                                mem[mem[64] + 4] = treasuryAddress
                                                                mem[mem[64] + 36] = 0
                                                                require ext_code.size(assetAddress)
                                                                call assetAddress.0xa9059cbb with:
                                                                     gas gas_remaining wei
                                                                    args treasuryAddress, 0
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _21235 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_21235] == bool(mem[_21235])
                                                            else:
                                                                mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                                mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                                mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                                mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[(6 * ceil32(return_data.size)) + 228] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                                mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                                mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + 128
                                                                t = (6 * ceil32(return_data.size)) + 420
                                                                while idx < 3:
                                                                    mem[t] = mem[s + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                                mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                                require ext_code.size(routerAddress)
                                                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = (7 * ceil32(return_data.size)) + 224
                                                                require return_data.size >= 32
                                                                _12608 = mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                                require mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                                _13010 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]
                                                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224] <= test266151307()
                                                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 32 >= 0
                                                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256
                                                                mem[(7 * ceil32(return_data.size)) + 224] = _13010
                                                                require _12608 + (32 * _13010) + 32 <= return_data.size
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + _12608 + 256
                                                                t = (7 * ceil32(return_data.size)) + 256
                                                                while idx < _13010:
                                                                    require mem[s] == mem[s]
                                                                    mem[t] = mem[s]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[mem[64] + 4] = this.address
                                                                require ext_code.size(rewardTokenAddress)
                                                                staticcall rewardTokenAddress.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args address(this.address)
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _19068 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_19068] == mem[_19068]
                                                                if sub_0b4b41bc <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require sub_0b4b41bc
                                                                sub_7f94bf16 = mem[_19068] / sub_0b4b41bc
                                                                mem[mem[64] + 4] = treasuryAddress
                                                                mem[mem[64] + 36] = 0
                                                                require ext_code.size(assetAddress)
                                                                call assetAddress.0xa9059cbb with:
                                                                     gas gas_remaining wei
                                                                    args treasuryAddress, 0
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _21234 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_21234] == bool(mem[_21234])
                                                    else:
                                                        require ext_call.return_data[0] - totalDeposited
                                                        if (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / ext_call.return_data[0] - totalDeposited != sub_7e72b29f:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        sub_bf4c8572 = (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / 10000
                                                        mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                                        mem[ceil32(return_data.size) + 132] = -1
                                                        require ext_code.size(sub_b8ab24bdAddress)
                                                        call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args lendingPoolAddress, -1
                                                        mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                        mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                                        mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                                        mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                                        require ext_code.size(lendingPoolAddress)
                                                        call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                             gas gas_remaining wei
                                                            args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                                        mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == ext_call.return_data[0]
                                                        mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                                        mem[(4 * ceil32(return_data.size)) + 132] = -1
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.approve(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args routerAddress, -1
                                                        mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                        if assetAddress == WAVAXAddress:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 388
                                                            while idx < 2:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 192
                                                            require return_data.size >= 32
                                                            _12604 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                            require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                            _13006 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                            mem[(7 * ceil32(return_data.size)) + 192] = _13006
                                                            require _12604 + (32 * _13006) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12604 + 224
                                                            t = (7 * ceil32(return_data.size)) + 224
                                                            while idx < _13006:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19064 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19064] == mem[_19064]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19064] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = 0
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, 0
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21230 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21230] == bool(mem[_21230])
                                                        else:
                                                            if rewardTokenAddress == WAVAXAddress:
                                                                mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                                mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                                mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                                mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                                mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + 128
                                                                t = (6 * ceil32(return_data.size)) + 388
                                                                while idx < 2:
                                                                    mem[t] = mem[s + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                                mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                                require ext_code.size(routerAddress)
                                                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = (7 * ceil32(return_data.size)) + 192
                                                                require return_data.size >= 32
                                                                _12606 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                                require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                                _13008 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                                mem[(7 * ceil32(return_data.size)) + 192] = _13008
                                                                require _12606 + (32 * _13008) + 32 <= return_data.size
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + _12606 + 224
                                                                t = (7 * ceil32(return_data.size)) + 224
                                                                while idx < _13008:
                                                                    require mem[s] == mem[s]
                                                                    mem[t] = mem[s]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[mem[64] + 4] = this.address
                                                                require ext_code.size(rewardTokenAddress)
                                                                staticcall rewardTokenAddress.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args address(this.address)
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _19066 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_19066] == mem[_19066]
                                                                if sub_0b4b41bc <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require sub_0b4b41bc
                                                                sub_7f94bf16 = mem[_19066] / sub_0b4b41bc
                                                                mem[mem[64] + 4] = treasuryAddress
                                                                mem[mem[64] + 36] = 0
                                                                require ext_code.size(assetAddress)
                                                                call assetAddress.0xa9059cbb with:
                                                                     gas gas_remaining wei
                                                                    args treasuryAddress, 0
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _21232 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_21232] == bool(mem[_21232])
                                                            else:
                                                                mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                                mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                                mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                                mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[(6 * ceil32(return_data.size)) + 228] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                                mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                                mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + 128
                                                                t = (6 * ceil32(return_data.size)) + 420
                                                                while idx < 3:
                                                                    mem[t] = mem[s + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                                mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                                require ext_code.size(routerAddress)
                                                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = (7 * ceil32(return_data.size)) + 224
                                                                require return_data.size >= 32
                                                                _12605 = mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                                require mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                                _13007 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]
                                                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224] <= test266151307()
                                                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 32 >= 0
                                                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256
                                                                mem[(7 * ceil32(return_data.size)) + 224] = _13007
                                                                require _12605 + (32 * _13007) + 32 <= return_data.size
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + _12605 + 256
                                                                t = (7 * ceil32(return_data.size)) + 256
                                                                while idx < _13007:
                                                                    require mem[s] == mem[s]
                                                                    mem[t] = mem[s]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[mem[64] + 4] = this.address
                                                                require ext_code.size(rewardTokenAddress)
                                                                staticcall rewardTokenAddress.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args address(this.address)
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _19065 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_19065] == mem[_19065]
                                                                if sub_0b4b41bc <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require sub_0b4b41bc
                                                                sub_7f94bf16 = mem[_19065] / sub_0b4b41bc
                                                                mem[mem[64] + 4] = treasuryAddress
                                                                mem[mem[64] + 36] = 0
                                                                require ext_code.size(assetAddress)
                                                                call assetAddress.0xa9059cbb with:
                                                                     gas gas_remaining wei
                                                                    args treasuryAddress, 0
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _21231 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_21231] == bool(mem[_21231])
                                            else:
                                                require ext_call.return_data[0] - totalDeposited
                                                if (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / ext_call.return_data[0] - totalDeposited != sub_7796ff37:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not ext_call.return_data[0] - totalDeposited:
                                                    if not ext_call.return_data[0] - totalDeposited:
                                                        sub_bf4c8572 = 0
                                                        mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                                        mem[ceil32(return_data.size) + 132] = -1
                                                        require ext_code.size(sub_b8ab24bdAddress)
                                                        call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args lendingPoolAddress, -1
                                                        mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                        mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                                        mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                                        mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                                        require ext_code.size(lendingPoolAddress)
                                                        call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                             gas gas_remaining wei
                                                            args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                                        mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == ext_call.return_data[0]
                                                        mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                                        mem[(4 * ceil32(return_data.size)) + 132] = -1
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.approve(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args routerAddress, -1
                                                        mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                        if assetAddress == WAVAXAddress:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 388
                                                            while idx < 2:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 192
                                                            require return_data.size >= 32
                                                            _12601 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                            require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                            _13003 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                            mem[(7 * ceil32(return_data.size)) + 192] = _13003
                                                            require _12601 + (32 * _13003) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12601 + 224
                                                            t = (7 * ceil32(return_data.size)) + 224
                                                            while idx < _13003:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19061 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19061] == mem[_19061]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19061] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21227 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21227] == bool(mem[_21227])
                                                        else:
                                                            if rewardTokenAddress == WAVAXAddress:
                                                                mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                                mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                                mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                                mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + 128
                                                                t = (6 * ceil32(return_data.size)) + 388
                                                                while idx < 2:
                                                                    mem[t] = mem[s + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                                mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                                require ext_code.size(routerAddress)
                                                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = (7 * ceil32(return_data.size)) + 192
                                                                require return_data.size >= 32
                                                                _12603 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                                require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                                _13005 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                                mem[(7 * ceil32(return_data.size)) + 192] = _13005
                                                                require _12603 + (32 * _13005) + 32 <= return_data.size
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + _12603 + 224
                                                                t = (7 * ceil32(return_data.size)) + 224
                                                                while idx < _13005:
                                                                    require mem[s] == mem[s]
                                                                    mem[t] = mem[s]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[mem[64] + 4] = this.address
                                                                require ext_code.size(rewardTokenAddress)
                                                                staticcall rewardTokenAddress.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args address(this.address)
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _19063 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_19063] == mem[_19063]
                                                                if sub_0b4b41bc <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require sub_0b4b41bc
                                                                sub_7f94bf16 = mem[_19063] / sub_0b4b41bc
                                                                mem[mem[64] + 4] = treasuryAddress
                                                                mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                                require ext_code.size(assetAddress)
                                                                call assetAddress.0xa9059cbb with:
                                                                     gas gas_remaining wei
                                                                    args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _21229 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_21229] == bool(mem[_21229])
                                                            else:
                                                                mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                                mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                                mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                                mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                                mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + 128
                                                                t = (6 * ceil32(return_data.size)) + 420
                                                                while idx < 3:
                                                                    mem[t] = mem[s + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                                mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                                require ext_code.size(routerAddress)
                                                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args 0, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = (7 * ceil32(return_data.size)) + 224
                                                                require return_data.size >= 32
                                                                _12602 = mem[(6 * ceil32(return_data.size)) + 224 len 4], 0
                                                                require mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 <= test266151307()
                                                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                                _13004 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]
                                                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224] <= test266151307()
                                                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 32 >= 0
                                                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256
                                                                mem[(7 * ceil32(return_data.size)) + 224] = _13004
                                                                require _12602 + (32 * _13004) + 32 <= return_data.size
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + _12602 + 256
                                                                t = (7 * ceil32(return_data.size)) + 256
                                                                while idx < _13004:
                                                                    require mem[s] == mem[s]
                                                                    mem[t] = mem[s]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[mem[64] + 4] = this.address
                                                                require ext_code.size(rewardTokenAddress)
                                                                staticcall rewardTokenAddress.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args address(this.address)
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _19062 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_19062] == mem[_19062]
                                                                if sub_0b4b41bc <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require sub_0b4b41bc
                                                                sub_7f94bf16 = mem[_19062] / sub_0b4b41bc
                                                                mem[mem[64] + 4] = treasuryAddress
                                                                mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                                require ext_code.size(assetAddress)
                                                                call assetAddress.0xa9059cbb with:
                                                                     gas gas_remaining wei
                                                                    args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _21228 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_21228] == bool(mem[_21228])
                                                    else:
                                                        require ext_call.return_data[0] - totalDeposited
                                                        if (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / ext_call.return_data[0] - totalDeposited != sub_7e72b29f:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        sub_bf4c8572 = (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / 10000
                                                        mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                                        mem[ceil32(return_data.size) + 132] = -1
                                                        require ext_code.size(sub_b8ab24bdAddress)
                                                        call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args lendingPoolAddress, -1
                                                        mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                        mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                                        mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                                        mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                                        require ext_code.size(lendingPoolAddress)
                                                        call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                             gas gas_remaining wei
                                                            args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                                        mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == ext_call.return_data[0]
                                                        mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                                        mem[(4 * ceil32(return_data.size)) + 132] = -1
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.approve(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args routerAddress, -1
                                                        mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                        if assetAddress == WAVAXAddress:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 388
                                                            while idx < 2:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 192
                                                            require return_data.size >= 32
                                                            _12598 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                            require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                            _13000 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                            mem[(7 * ceil32(return_data.size)) + 192] = _13000
                                                            require _12598 + (32 * _13000) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12598 + 224
                                                            t = (7 * ceil32(return_data.size)) + 224
                                                            while idx < _13000:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19058 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19058] == mem[_19058]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19058] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21224 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21224] == bool(mem[_21224])
                                                        else:
                                                            if rewardTokenAddress == WAVAXAddress:
                                                                mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                                mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                                mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                                mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + 128
                                                                t = (6 * ceil32(return_data.size)) + 388
                                                                while idx < 2:
                                                                    mem[t] = mem[s + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                                mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                                require ext_code.size(routerAddress)
                                                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = (7 * ceil32(return_data.size)) + 192
                                                                require return_data.size >= 32
                                                                _12600 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                                require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                                _13002 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                                mem[(7 * ceil32(return_data.size)) + 192] = _13002
                                                                require _12600 + (32 * _13002) + 32 <= return_data.size
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + _12600 + 224
                                                                t = (7 * ceil32(return_data.size)) + 224
                                                                while idx < _13002:
                                                                    require mem[s] == mem[s]
                                                                    mem[t] = mem[s]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[mem[64] + 4] = this.address
                                                                require ext_code.size(rewardTokenAddress)
                                                                staticcall rewardTokenAddress.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args address(this.address)
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _19060 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_19060] == mem[_19060]
                                                                if sub_0b4b41bc <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require sub_0b4b41bc
                                                                sub_7f94bf16 = mem[_19060] / sub_0b4b41bc
                                                                mem[mem[64] + 4] = treasuryAddress
                                                                mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                                require ext_code.size(assetAddress)
                                                                call assetAddress.0xa9059cbb with:
                                                                     gas gas_remaining wei
                                                                    args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _21226 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_21226] == bool(mem[_21226])
                                                            else:
                                                                mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                                mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                                mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                                mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                                mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + 128
                                                                t = (6 * ceil32(return_data.size)) + 420
                                                                while idx < 3:
                                                                    mem[t] = mem[s + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                                mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                                require ext_code.size(routerAddress)
                                                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args 0, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = (7 * ceil32(return_data.size)) + 224
                                                                require return_data.size >= 32
                                                                _12599 = mem[(6 * ceil32(return_data.size)) + 224 len 4], 0
                                                                require mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 <= test266151307()
                                                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                                _13001 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]
                                                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224] <= test266151307()
                                                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 32 >= 0
                                                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256
                                                                mem[(7 * ceil32(return_data.size)) + 224] = _13001
                                                                require _12599 + (32 * _13001) + 32 <= return_data.size
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + _12599 + 256
                                                                t = (7 * ceil32(return_data.size)) + 256
                                                                while idx < _13001:
                                                                    require mem[s] == mem[s]
                                                                    mem[t] = mem[s]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[mem[64] + 4] = this.address
                                                                require ext_code.size(rewardTokenAddress)
                                                                staticcall rewardTokenAddress.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args address(this.address)
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _19059 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_19059] == mem[_19059]
                                                                if sub_0b4b41bc <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require sub_0b4b41bc
                                                                sub_7f94bf16 = mem[_19059] / sub_0b4b41bc
                                                                mem[mem[64] + 4] = treasuryAddress
                                                                mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                                require ext_code.size(assetAddress)
                                                                call assetAddress.0xa9059cbb with:
                                                                     gas gas_remaining wei
                                                                    args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _21225 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_21225] == bool(mem[_21225])
                                                else:
                                                    require ext_call.return_data[0] - totalDeposited
                                                    if (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / ext_call.return_data[0] - totalDeposited != sub_2f6236be:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not ext_call.return_data[0] - totalDeposited:
                                                        sub_bf4c8572 = 0
                                                        mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                                        mem[ceil32(return_data.size) + 132] = -1
                                                        require ext_code.size(sub_b8ab24bdAddress)
                                                        call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args lendingPoolAddress, -1
                                                        mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                        mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                                        mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                                        mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                                        require ext_code.size(lendingPoolAddress)
                                                        call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                             gas gas_remaining wei
                                                            args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                                        mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == ext_call.return_data[0]
                                                        mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                                        mem[(4 * ceil32(return_data.size)) + 132] = -1
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.approve(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args routerAddress, -1
                                                        mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                        if assetAddress == WAVAXAddress:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 388
                                                            while idx < 2:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 192
                                                            require return_data.size >= 32
                                                            _12595 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                            require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                            _12997 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                            mem[(7 * ceil32(return_data.size)) + 192] = _12997
                                                            require _12595 + (32 * _12997) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12595 + 224
                                                            t = (7 * ceil32(return_data.size)) + 224
                                                            while idx < _12997:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19055 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19055] == mem[_19055]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19055] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21221 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21221] == bool(mem[_21221])
                                                        else:
                                                            if rewardTokenAddress == WAVAXAddress:
                                                                mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                                mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                                mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                                mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                                mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + 128
                                                                t = (6 * ceil32(return_data.size)) + 388
                                                                while idx < 2:
                                                                    mem[t] = mem[s + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                                mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                                require ext_code.size(routerAddress)
                                                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = (7 * ceil32(return_data.size)) + 192
                                                                require return_data.size >= 32
                                                                _12597 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                                require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                                _12999 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                                mem[(7 * ceil32(return_data.size)) + 192] = _12999
                                                                require _12597 + (32 * _12999) + 32 <= return_data.size
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + _12597 + 224
                                                                t = (7 * ceil32(return_data.size)) + 224
                                                                while idx < _12999:
                                                                    require mem[s] == mem[s]
                                                                    mem[t] = mem[s]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[mem[64] + 4] = this.address
                                                                require ext_code.size(rewardTokenAddress)
                                                                staticcall rewardTokenAddress.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args address(this.address)
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _19057 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_19057] == mem[_19057]
                                                                if sub_0b4b41bc <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require sub_0b4b41bc
                                                                sub_7f94bf16 = mem[_19057] / sub_0b4b41bc
                                                                mem[mem[64] + 4] = treasuryAddress
                                                                mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                                require ext_code.size(assetAddress)
                                                                call assetAddress.0xa9059cbb with:
                                                                     gas gas_remaining wei
                                                                    args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _21223 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_21223] == bool(mem[_21223])
                                                            else:
                                                                mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                                mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                                mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                                mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[(6 * ceil32(return_data.size)) + 228] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                                mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                                mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + 128
                                                                t = (6 * ceil32(return_data.size)) + 420
                                                                while idx < 3:
                                                                    mem[t] = mem[s + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                                mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                                require ext_code.size(routerAddress)
                                                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = (7 * ceil32(return_data.size)) + 224
                                                                require return_data.size >= 32
                                                                _12596 = mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                                require mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                                _12998 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]
                                                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224] <= test266151307()
                                                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 32 >= 0
                                                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256
                                                                mem[(7 * ceil32(return_data.size)) + 224] = _12998
                                                                require _12596 + (32 * _12998) + 32 <= return_data.size
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + _12596 + 256
                                                                t = (7 * ceil32(return_data.size)) + 256
                                                                while idx < _12998:
                                                                    require mem[s] == mem[s]
                                                                    mem[t] = mem[s]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[mem[64] + 4] = this.address
                                                                require ext_code.size(rewardTokenAddress)
                                                                staticcall rewardTokenAddress.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args address(this.address)
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _19056 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_19056] == mem[_19056]
                                                                if sub_0b4b41bc <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require sub_0b4b41bc
                                                                sub_7f94bf16 = mem[_19056] / sub_0b4b41bc
                                                                mem[mem[64] + 4] = treasuryAddress
                                                                mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                                require ext_code.size(assetAddress)
                                                                call assetAddress.0xa9059cbb with:
                                                                     gas gas_remaining wei
                                                                    args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _21222 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_21222] == bool(mem[_21222])
                                                    else:
                                                        require ext_call.return_data[0] - totalDeposited
                                                        if (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / ext_call.return_data[0] - totalDeposited != sub_7e72b29f:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        sub_bf4c8572 = (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / 10000
                                                        mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                                        mem[ceil32(return_data.size) + 132] = -1
                                                        require ext_code.size(sub_b8ab24bdAddress)
                                                        call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args lendingPoolAddress, -1
                                                        mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                        mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                                        mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                                        mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                                        require ext_code.size(lendingPoolAddress)
                                                        call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                             gas gas_remaining wei
                                                            args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                                        mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == ext_call.return_data[0]
                                                        mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                                        mem[(4 * ceil32(return_data.size)) + 132] = -1
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.approve(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args routerAddress, -1
                                                        mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                        if assetAddress == WAVAXAddress:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 388
                                                            while idx < 2:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 192
                                                            require return_data.size >= 32
                                                            _12592 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                            require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                            _12994 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                            mem[(7 * ceil32(return_data.size)) + 192] = _12994
                                                            require _12592 + (32 * _12994) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12592 + 224
                                                            t = (7 * ceil32(return_data.size)) + 224
                                                            while idx < _12994:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19052 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19052] == mem[_19052]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19052] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21218 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21218] == bool(mem[_21218])
                                                        else:
                                                            if rewardTokenAddress == WAVAXAddress:
                                                                mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                                mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                                mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                                mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                                mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + 128
                                                                t = (6 * ceil32(return_data.size)) + 388
                                                                while idx < 2:
                                                                    mem[t] = mem[s + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                                mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                                require ext_code.size(routerAddress)
                                                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = (7 * ceil32(return_data.size)) + 192
                                                                require return_data.size >= 32
                                                                _12594 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                                require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                                _12996 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                                mem[(7 * ceil32(return_data.size)) + 192] = _12996
                                                                require _12594 + (32 * _12996) + 32 <= return_data.size
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + _12594 + 224
                                                                t = (7 * ceil32(return_data.size)) + 224
                                                                while idx < _12996:
                                                                    require mem[s] == mem[s]
                                                                    mem[t] = mem[s]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[mem[64] + 4] = this.address
                                                                require ext_code.size(rewardTokenAddress)
                                                                staticcall rewardTokenAddress.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args address(this.address)
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _19054 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_19054] == mem[_19054]
                                                                if sub_0b4b41bc <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require sub_0b4b41bc
                                                                sub_7f94bf16 = mem[_19054] / sub_0b4b41bc
                                                                mem[mem[64] + 4] = treasuryAddress
                                                                mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                                require ext_code.size(assetAddress)
                                                                call assetAddress.0xa9059cbb with:
                                                                     gas gas_remaining wei
                                                                    args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _21220 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_21220] == bool(mem[_21220])
                                                            else:
                                                                mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                                mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                                mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                                mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[(6 * ceil32(return_data.size)) + 228] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                                mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                                mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + 128
                                                                t = (6 * ceil32(return_data.size)) + 420
                                                                while idx < 3:
                                                                    mem[t] = mem[s + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                                mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                                require ext_code.size(routerAddress)
                                                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = (7 * ceil32(return_data.size)) + 224
                                                                require return_data.size >= 32
                                                                _12593 = mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                                require mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                                _12995 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]
                                                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224] <= test266151307()
                                                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 32 >= 0
                                                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256
                                                                mem[(7 * ceil32(return_data.size)) + 224] = _12995
                                                                require _12593 + (32 * _12995) + 32 <= return_data.size
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + _12593 + 256
                                                                t = (7 * ceil32(return_data.size)) + 256
                                                                while idx < _12995:
                                                                    require mem[s] == mem[s]
                                                                    mem[t] = mem[s]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[mem[64] + 4] = this.address
                                                                require ext_code.size(rewardTokenAddress)
                                                                staticcall rewardTokenAddress.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args address(this.address)
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _19053 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_19053] == mem[_19053]
                                                                if sub_0b4b41bc <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require sub_0b4b41bc
                                                                sub_7f94bf16 = mem[_19053] / sub_0b4b41bc
                                                                mem[mem[64] + 4] = treasuryAddress
                                                                mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                                require ext_code.size(assetAddress)
                                                                call assetAddress.0xa9059cbb with:
                                                                     gas gas_remaining wei
                                                                    args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _21219 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_21219] == bool(mem[_21219])
                                        else:
                                            require (sub_f12c8e0d * block.timestamp) + (sub_7f94bf16 * block.timestamp) - (sub_f12c8e0d * lastRewardTimestamp) - (sub_7f94bf16 * lastRewardTimestamp)
                                            if (10^12 * sub_f12c8e0d * block.timestamp) + (10^12 * sub_7f94bf16 * block.timestamp) - (10^12 * sub_f12c8e0d * lastRewardTimestamp) - (10^12 * sub_7f94bf16 * lastRewardTimestamp) / (sub_f12c8e0d * block.timestamp) + (sub_7f94bf16 * block.timestamp) - (sub_f12c8e0d * lastRewardTimestamp) - (sub_7f94bf16 * lastRewardTimestamp) != 10^12:
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
                                            if totalDeposited <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalDeposited
                                            if sub_a9ac33dd + ((10^12 * sub_f12c8e0d * block.timestamp) + (10^12 * sub_7f94bf16 * block.timestamp) - (10^12 * sub_f12c8e0d * lastRewardTimestamp) - (10^12 * sub_7f94bf16 * lastRewardTimestamp) / totalDeposited) < sub_a9ac33dd:
                                                revert with 0, 'SafeMath: addition overflow'
                                            sub_a9ac33dd += (10^12 * sub_f12c8e0d * block.timestamp) + (10^12 * sub_7f94bf16 * block.timestamp) - (10^12 * sub_f12c8e0d * lastRewardTimestamp) - (10^12 * sub_7f94bf16 * lastRewardTimestamp) / totalDeposited
                                            lastRewardTimestamp = block.timestamp
                                            mem[100] = this.address
                                            require ext_code.size(sub_b8ab24bdAddress)
                                            staticcall sub_b8ab24bdAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            mem[96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_call.return_data[0] == ext_call.return_data[0]
                                            if not ext_call.return_data[0] - totalDeposited:
                                                if not ext_call.return_data[0] - totalDeposited:
                                                    if not ext_call.return_data[0] - totalDeposited:
                                                        sub_bf4c8572 = 0
                                                        mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                                        mem[ceil32(return_data.size) + 132] = -1
                                                        require ext_code.size(sub_b8ab24bdAddress)
                                                        call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args lendingPoolAddress, -1
                                                        mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                        mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                                        mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                                        mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                                        require ext_code.size(lendingPoolAddress)
                                                        call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                             gas gas_remaining wei
                                                            args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                                        mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == ext_call.return_data[0]
                                                        mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                                        mem[(4 * ceil32(return_data.size)) + 132] = -1
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.approve(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args routerAddress, -1
                                                        mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                        if assetAddress == WAVAXAddress:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 388
                                                            while idx < 2:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 192
                                                            require return_data.size >= 32
                                                            _12589 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                            require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                            _12991 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                            mem[(7 * ceil32(return_data.size)) + 192] = _12991
                                                            require _12589 + (32 * _12991) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12589 + 224
                                                            t = (7 * ceil32(return_data.size)) + 224
                                                            while idx < _12991:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19049 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19049] == mem[_19049]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19049] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = 0
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, 0
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21215 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21215] == bool(mem[_21215])
                                                        else:
                                                            if rewardTokenAddress == WAVAXAddress:
                                                                mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                                mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                                mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                                mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + 128
                                                                t = (6 * ceil32(return_data.size)) + 388
                                                                while idx < 2:
                                                                    mem[t] = mem[s + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                                mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                                require ext_code.size(routerAddress)
                                                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = (7 * ceil32(return_data.size)) + 192
                                                                require return_data.size >= 32
                                                                _12591 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                                require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                                _12993 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                                mem[(7 * ceil32(return_data.size)) + 192] = _12993
                                                                require _12591 + (32 * _12993) + 32 <= return_data.size
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + _12591 + 224
                                                                t = (7 * ceil32(return_data.size)) + 224
                                                                while idx < _12993:
                                                                    require mem[s] == mem[s]
                                                                    mem[t] = mem[s]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[mem[64] + 4] = this.address
                                                                require ext_code.size(rewardTokenAddress)
                                                                staticcall rewardTokenAddress.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args address(this.address)
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _19051 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_19051] == mem[_19051]
                                                                if sub_0b4b41bc <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require sub_0b4b41bc
                                                                sub_7f94bf16 = mem[_19051] / sub_0b4b41bc
                                                                mem[mem[64] + 4] = treasuryAddress
                                                                mem[mem[64] + 36] = 0
                                                                require ext_code.size(assetAddress)
                                                                call assetAddress.0xa9059cbb with:
                                                                     gas gas_remaining wei
                                                                    args treasuryAddress, 0
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _21217 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_21217] == bool(mem[_21217])
                                                            else:
                                                                mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                                mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                                mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                                mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                                mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + 128
                                                                t = (6 * ceil32(return_data.size)) + 420
                                                                while idx < 3:
                                                                    mem[t] = mem[s + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                                mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                                require ext_code.size(routerAddress)
                                                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args 0, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = (7 * ceil32(return_data.size)) + 224
                                                                require return_data.size >= 32
                                                                _12590 = mem[(6 * ceil32(return_data.size)) + 224 len 4], 0
                                                                require mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 <= test266151307()
                                                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                                _12992 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]
                                                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224] <= test266151307()
                                                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 32 >= 0
                                                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256
                                                                mem[(7 * ceil32(return_data.size)) + 224] = _12992
                                                                require _12590 + (32 * _12992) + 32 <= return_data.size
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + _12590 + 256
                                                                t = (7 * ceil32(return_data.size)) + 256
                                                                while idx < _12992:
                                                                    require mem[s] == mem[s]
                                                                    mem[t] = mem[s]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[mem[64] + 4] = this.address
                                                                require ext_code.size(rewardTokenAddress)
                                                                staticcall rewardTokenAddress.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args address(this.address)
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _19050 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_19050] == mem[_19050]
                                                                if sub_0b4b41bc <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require sub_0b4b41bc
                                                                sub_7f94bf16 = mem[_19050] / sub_0b4b41bc
                                                                mem[mem[64] + 4] = treasuryAddress
                                                                mem[mem[64] + 36] = 0
                                                                require ext_code.size(assetAddress)
                                                                call assetAddress.0xa9059cbb with:
                                                                     gas gas_remaining wei
                                                                    args treasuryAddress, 0
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _21216 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_21216] == bool(mem[_21216])
                                                    else:
                                                        require ext_call.return_data[0] - totalDeposited
                                                        if (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / ext_call.return_data[0] - totalDeposited != sub_7e72b29f:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        sub_bf4c8572 = (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / 10000
                                                        mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                                        mem[ceil32(return_data.size) + 132] = -1
                                                        require ext_code.size(sub_b8ab24bdAddress)
                                                        call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args lendingPoolAddress, -1
                                                        mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                        mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                                        mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                                        mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                                        require ext_code.size(lendingPoolAddress)
                                                        call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                             gas gas_remaining wei
                                                            args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                                        mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == ext_call.return_data[0]
                                                        mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                                        mem[(4 * ceil32(return_data.size)) + 132] = -1
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.approve(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args routerAddress, -1
                                                        mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                        if assetAddress == WAVAXAddress:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 388
                                                            while idx < 2:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 192
                                                            require return_data.size >= 32
                                                            _12586 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                            require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                            _12988 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                            mem[(7 * ceil32(return_data.size)) + 192] = _12988
                                                            require _12586 + (32 * _12988) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12586 + 224
                                                            t = (7 * ceil32(return_data.size)) + 224
                                                            while idx < _12988:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19046 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19046] == mem[_19046]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19046] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = 0
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, 0
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21212 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21212] == bool(mem[_21212])
                                                        else:
                                                            if rewardTokenAddress == WAVAXAddress:
                                                                mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                                mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                                mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                                mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + 128
                                                                t = (6 * ceil32(return_data.size)) + 388
                                                                while idx < 2:
                                                                    mem[t] = mem[s + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                                mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                                require ext_code.size(routerAddress)
                                                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = (7 * ceil32(return_data.size)) + 192
                                                                require return_data.size >= 32
                                                                _12588 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                                require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                                _12990 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                                mem[(7 * ceil32(return_data.size)) + 192] = _12990
                                                                require _12588 + (32 * _12990) + 32 <= return_data.size
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + _12588 + 224
                                                                t = (7 * ceil32(return_data.size)) + 224
                                                                while idx < _12990:
                                                                    require mem[s] == mem[s]
                                                                    mem[t] = mem[s]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[mem[64] + 4] = this.address
                                                                require ext_code.size(rewardTokenAddress)
                                                                staticcall rewardTokenAddress.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args address(this.address)
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _19048 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_19048] == mem[_19048]
                                                                if sub_0b4b41bc <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require sub_0b4b41bc
                                                                sub_7f94bf16 = mem[_19048] / sub_0b4b41bc
                                                                mem[mem[64] + 4] = treasuryAddress
                                                                mem[mem[64] + 36] = 0
                                                                require ext_code.size(assetAddress)
                                                                call assetAddress.0xa9059cbb with:
                                                                     gas gas_remaining wei
                                                                    args treasuryAddress, 0
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _21214 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_21214] == bool(mem[_21214])
                                                            else:
                                                                mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                                mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                                mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                                mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                                mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + 128
                                                                t = (6 * ceil32(return_data.size)) + 420
                                                                while idx < 3:
                                                                    mem[t] = mem[s + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                                mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                                require ext_code.size(routerAddress)
                                                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args 0, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = (7 * ceil32(return_data.size)) + 224
                                                                require return_data.size >= 32
                                                                _12587 = mem[(6 * ceil32(return_data.size)) + 224 len 4], 0
                                                                require mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 <= test266151307()
                                                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                                _12989 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]
                                                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224] <= test266151307()
                                                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 32 >= 0
                                                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256
                                                                mem[(7 * ceil32(return_data.size)) + 224] = _12989
                                                                require _12587 + (32 * _12989) + 32 <= return_data.size
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + _12587 + 256
                                                                t = (7 * ceil32(return_data.size)) + 256
                                                                while idx < _12989:
                                                                    require mem[s] == mem[s]
                                                                    mem[t] = mem[s]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[mem[64] + 4] = this.address
                                                                require ext_code.size(rewardTokenAddress)
                                                                staticcall rewardTokenAddress.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args address(this.address)
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _19047 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_19047] == mem[_19047]
                                                                if sub_0b4b41bc <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require sub_0b4b41bc
                                                                sub_7f94bf16 = mem[_19047] / sub_0b4b41bc
                                                                mem[mem[64] + 4] = treasuryAddress
                                                                mem[mem[64] + 36] = 0
                                                                require ext_code.size(assetAddress)
                                                                call assetAddress.0xa9059cbb with:
                                                                     gas gas_remaining wei
                                                                    args treasuryAddress, 0
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _21213 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_21213] == bool(mem[_21213])
                                                else:
                                                    require ext_call.return_data[0] - totalDeposited
                                                    if (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / ext_call.return_data[0] - totalDeposited != sub_2f6236be:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not ext_call.return_data[0] - totalDeposited:
                                                        sub_bf4c8572 = 0
                                                        mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                                        mem[ceil32(return_data.size) + 132] = -1
                                                        require ext_code.size(sub_b8ab24bdAddress)
                                                        call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args lendingPoolAddress, -1
                                                        mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                        mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                                        mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                                        mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                                        require ext_code.size(lendingPoolAddress)
                                                        call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                             gas gas_remaining wei
                                                            args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                                        mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == ext_call.return_data[0]
                                                        mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                                        mem[(4 * ceil32(return_data.size)) + 132] = -1
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.approve(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args routerAddress, -1
                                                        mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                        if assetAddress == WAVAXAddress:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 388
                                                            while idx < 2:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 192
                                                            require return_data.size >= 32
                                                            _12583 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                            require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                            _12985 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                            mem[(7 * ceil32(return_data.size)) + 192] = _12985
                                                            require _12583 + (32 * _12985) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12583 + 224
                                                            t = (7 * ceil32(return_data.size)) + 224
                                                            while idx < _12985:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19043 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19043] == mem[_19043]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19043] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = 0
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, 0
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21209 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21209] == bool(mem[_21209])
                                                        else:
                                                            if rewardTokenAddress == WAVAXAddress:
                                                                mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                                mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                                mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                                mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                                mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + 128
                                                                t = (6 * ceil32(return_data.size)) + 388
                                                                while idx < 2:
                                                                    mem[t] = mem[s + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                                mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                                require ext_code.size(routerAddress)
                                                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = (7 * ceil32(return_data.size)) + 192
                                                                require return_data.size >= 32
                                                                _12585 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                                require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                                _12987 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                                mem[(7 * ceil32(return_data.size)) + 192] = _12987
                                                                require _12585 + (32 * _12987) + 32 <= return_data.size
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + _12585 + 224
                                                                t = (7 * ceil32(return_data.size)) + 224
                                                                while idx < _12987:
                                                                    require mem[s] == mem[s]
                                                                    mem[t] = mem[s]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[mem[64] + 4] = this.address
                                                                require ext_code.size(rewardTokenAddress)
                                                                staticcall rewardTokenAddress.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args address(this.address)
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _19045 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_19045] == mem[_19045]
                                                                if sub_0b4b41bc <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require sub_0b4b41bc
                                                                sub_7f94bf16 = mem[_19045] / sub_0b4b41bc
                                                                mem[mem[64] + 4] = treasuryAddress
                                                                mem[mem[64] + 36] = 0
                                                                require ext_code.size(assetAddress)
                                                                call assetAddress.0xa9059cbb with:
                                                                     gas gas_remaining wei
                                                                    args treasuryAddress, 0
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _21211 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_21211] == bool(mem[_21211])
                                                            else:
                                                                mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                                mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                                mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                                mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[(6 * ceil32(return_data.size)) + 228] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                                mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                                mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + 128
                                                                t = (6 * ceil32(return_data.size)) + 420
                                                                while idx < 3:
                                                                    mem[t] = mem[s + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                                mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                                require ext_code.size(routerAddress)
                                                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = (7 * ceil32(return_data.size)) + 224
                                                                require return_data.size >= 32
                                                                _12584 = mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                                require mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                                _12986 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]
                                                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224] <= test266151307()
                                                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 32 >= 0
                                                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256
                                                                mem[(7 * ceil32(return_data.size)) + 224] = _12986
                                                                require _12584 + (32 * _12986) + 32 <= return_data.size
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + _12584 + 256
                                                                t = (7 * ceil32(return_data.size)) + 256
                                                                while idx < _12986:
                                                                    require mem[s] == mem[s]
                                                                    mem[t] = mem[s]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[mem[64] + 4] = this.address
                                                                require ext_code.size(rewardTokenAddress)
                                                                staticcall rewardTokenAddress.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args address(this.address)
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _19044 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_19044] == mem[_19044]
                                                                if sub_0b4b41bc <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require sub_0b4b41bc
                                                                sub_7f94bf16 = mem[_19044] / sub_0b4b41bc
                                                                mem[mem[64] + 4] = treasuryAddress
                                                                mem[mem[64] + 36] = 0
                                                                require ext_code.size(assetAddress)
                                                                call assetAddress.0xa9059cbb with:
                                                                     gas gas_remaining wei
                                                                    args treasuryAddress, 0
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _21210 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_21210] == bool(mem[_21210])
                                                    else:
                                                        require ext_call.return_data[0] - totalDeposited
                                                        if (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / ext_call.return_data[0] - totalDeposited != sub_7e72b29f:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        sub_bf4c8572 = (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / 10000
                                                        mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                                        mem[ceil32(return_data.size) + 132] = -1
                                                        require ext_code.size(sub_b8ab24bdAddress)
                                                        call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args lendingPoolAddress, -1
                                                        mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                        mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                                        mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                                        mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                                        require ext_code.size(lendingPoolAddress)
                                                        call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                             gas gas_remaining wei
                                                            args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                                        mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == ext_call.return_data[0]
                                                        mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                                        mem[(4 * ceil32(return_data.size)) + 132] = -1
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.approve(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args routerAddress, -1
                                                        mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                        if assetAddress == WAVAXAddress:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 388
                                                            while idx < 2:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 192
                                                            require return_data.size >= 32
                                                            _12580 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                            require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                            _12982 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                            mem[(7 * ceil32(return_data.size)) + 192] = _12982
                                                            require _12580 + (32 * _12982) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12580 + 224
                                                            t = (7 * ceil32(return_data.size)) + 224
                                                            while idx < _12982:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19040 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19040] == mem[_19040]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19040] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = 0
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, 0
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21206 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21206] == bool(mem[_21206])
                                                        else:
                                                            if rewardTokenAddress == WAVAXAddress:
                                                                mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                                mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                                mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                                mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                                mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + 128
                                                                t = (6 * ceil32(return_data.size)) + 388
                                                                while idx < 2:
                                                                    mem[t] = mem[s + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                                mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                                require ext_code.size(routerAddress)
                                                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = (7 * ceil32(return_data.size)) + 192
                                                                require return_data.size >= 32
                                                                _12582 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                                require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                                _12984 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                                mem[(7 * ceil32(return_data.size)) + 192] = _12984
                                                                require _12582 + (32 * _12984) + 32 <= return_data.size
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + _12582 + 224
                                                                t = (7 * ceil32(return_data.size)) + 224
                                                                while idx < _12984:
                                                                    require mem[s] == mem[s]
                                                                    mem[t] = mem[s]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[mem[64] + 4] = this.address
                                                                require ext_code.size(rewardTokenAddress)
                                                                staticcall rewardTokenAddress.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args address(this.address)
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _19042 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_19042] == mem[_19042]
                                                                if sub_0b4b41bc <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require sub_0b4b41bc
                                                                sub_7f94bf16 = mem[_19042] / sub_0b4b41bc
                                                                mem[mem[64] + 4] = treasuryAddress
                                                                mem[mem[64] + 36] = 0
                                                                require ext_code.size(assetAddress)
                                                                call assetAddress.0xa9059cbb with:
                                                                     gas gas_remaining wei
                                                                    args treasuryAddress, 0
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _21208 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_21208] == bool(mem[_21208])
                                                            else:
                                                                mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                                mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                                mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                                mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[(6 * ceil32(return_data.size)) + 228] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                                mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                                mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + 128
                                                                t = (6 * ceil32(return_data.size)) + 420
                                                                while idx < 3:
                                                                    mem[t] = mem[s + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                                mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                                require ext_code.size(routerAddress)
                                                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = (7 * ceil32(return_data.size)) + 224
                                                                require return_data.size >= 32
                                                                _12581 = mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                                require mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                                _12983 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]
                                                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224] <= test266151307()
                                                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 32 >= 0
                                                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256
                                                                mem[(7 * ceil32(return_data.size)) + 224] = _12983
                                                                require _12581 + (32 * _12983) + 32 <= return_data.size
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + _12581 + 256
                                                                t = (7 * ceil32(return_data.size)) + 256
                                                                while idx < _12983:
                                                                    require mem[s] == mem[s]
                                                                    mem[t] = mem[s]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[mem[64] + 4] = this.address
                                                                require ext_code.size(rewardTokenAddress)
                                                                staticcall rewardTokenAddress.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args address(this.address)
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _19041 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_19041] == mem[_19041]
                                                                if sub_0b4b41bc <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require sub_0b4b41bc
                                                                sub_7f94bf16 = mem[_19041] / sub_0b4b41bc
                                                                mem[mem[64] + 4] = treasuryAddress
                                                                mem[mem[64] + 36] = 0
                                                                require ext_code.size(assetAddress)
                                                                call assetAddress.0xa9059cbb with:
                                                                     gas gas_remaining wei
                                                                    args treasuryAddress, 0
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _21207 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_21207] == bool(mem[_21207])
                                            else:
                                                require ext_call.return_data[0] - totalDeposited
                                                if (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / ext_call.return_data[0] - totalDeposited != sub_7796ff37:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not ext_call.return_data[0] - totalDeposited:
                                                    if not ext_call.return_data[0] - totalDeposited:
                                                        sub_bf4c8572 = 0
                                                        mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                                        mem[ceil32(return_data.size) + 132] = -1
                                                        require ext_code.size(sub_b8ab24bdAddress)
                                                        call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args lendingPoolAddress, -1
                                                        mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                        mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                                        mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                                        mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                                        require ext_code.size(lendingPoolAddress)
                                                        call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                             gas gas_remaining wei
                                                            args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                                        mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == ext_call.return_data[0]
                                                        mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                                        mem[(4 * ceil32(return_data.size)) + 132] = -1
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.approve(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args routerAddress, -1
                                                        mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                        if assetAddress == WAVAXAddress:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 388
                                                            while idx < 2:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 192
                                                            require return_data.size >= 32
                                                            _12577 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                            require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                            _12979 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                            mem[(7 * ceil32(return_data.size)) + 192] = _12979
                                                            require _12577 + (32 * _12979) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12577 + 224
                                                            t = (7 * ceil32(return_data.size)) + 224
                                                            while idx < _12979:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19037 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19037] == mem[_19037]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19037] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21203 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21203] == bool(mem[_21203])
                                                        else:
                                                            if rewardTokenAddress == WAVAXAddress:
                                                                mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                                mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                                mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                                mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + 128
                                                                t = (6 * ceil32(return_data.size)) + 388
                                                                while idx < 2:
                                                                    mem[t] = mem[s + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                                mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                                require ext_code.size(routerAddress)
                                                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = (7 * ceil32(return_data.size)) + 192
                                                                require return_data.size >= 32
                                                                _12579 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                                require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                                _12981 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                                mem[(7 * ceil32(return_data.size)) + 192] = _12981
                                                                require _12579 + (32 * _12981) + 32 <= return_data.size
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + _12579 + 224
                                                                t = (7 * ceil32(return_data.size)) + 224
                                                                while idx < _12981:
                                                                    require mem[s] == mem[s]
                                                                    mem[t] = mem[s]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[mem[64] + 4] = this.address
                                                                require ext_code.size(rewardTokenAddress)
                                                                staticcall rewardTokenAddress.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args address(this.address)
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _19039 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_19039] == mem[_19039]
                                                                if sub_0b4b41bc <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require sub_0b4b41bc
                                                                sub_7f94bf16 = mem[_19039] / sub_0b4b41bc
                                                                mem[mem[64] + 4] = treasuryAddress
                                                                mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                                require ext_code.size(assetAddress)
                                                                call assetAddress.0xa9059cbb with:
                                                                     gas gas_remaining wei
                                                                    args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _21205 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_21205] == bool(mem[_21205])
                                                            else:
                                                                mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                                mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                                mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                                mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                                mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + 128
                                                                t = (6 * ceil32(return_data.size)) + 420
                                                                while idx < 3:
                                                                    mem[t] = mem[s + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                                mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                                require ext_code.size(routerAddress)
                                                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args 0, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = (7 * ceil32(return_data.size)) + 224
                                                                require return_data.size >= 32
                                                                _12578 = mem[(6 * ceil32(return_data.size)) + 224 len 4], 0
                                                                require mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 <= test266151307()
                                                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                                _12980 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]
                                                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224] <= test266151307()
                                                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 32 >= 0
                                                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256
                                                                mem[(7 * ceil32(return_data.size)) + 224] = _12980
                                                                require _12578 + (32 * _12980) + 32 <= return_data.size
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + _12578 + 256
                                                                t = (7 * ceil32(return_data.size)) + 256
                                                                while idx < _12980:
                                                                    require mem[s] == mem[s]
                                                                    mem[t] = mem[s]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[mem[64] + 4] = this.address
                                                                require ext_code.size(rewardTokenAddress)
                                                                staticcall rewardTokenAddress.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args address(this.address)
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _19038 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_19038] == mem[_19038]
                                                                if sub_0b4b41bc <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require sub_0b4b41bc
                                                                sub_7f94bf16 = mem[_19038] / sub_0b4b41bc
                                                                mem[mem[64] + 4] = treasuryAddress
                                                                mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                                require ext_code.size(assetAddress)
                                                                call assetAddress.0xa9059cbb with:
                                                                     gas gas_remaining wei
                                                                    args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _21204 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_21204] == bool(mem[_21204])
                                                    else:
                                                        require ext_call.return_data[0] - totalDeposited
                                                        if (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / ext_call.return_data[0] - totalDeposited != sub_7e72b29f:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        sub_bf4c8572 = (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / 10000
                                                        mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                                        mem[ceil32(return_data.size) + 132] = -1
                                                        require ext_code.size(sub_b8ab24bdAddress)
                                                        call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args lendingPoolAddress, -1
                                                        mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                        mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                                        mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                                        mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                                        require ext_code.size(lendingPoolAddress)
                                                        call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                             gas gas_remaining wei
                                                            args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                                        mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == ext_call.return_data[0]
                                                        mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                                        mem[(4 * ceil32(return_data.size)) + 132] = -1
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.approve(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args routerAddress, -1
                                                        mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                        if assetAddress == WAVAXAddress:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 388
                                                            while idx < 2:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 192
                                                            require return_data.size >= 32
                                                            _12574 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                            require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                            _12976 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                            mem[(7 * ceil32(return_data.size)) + 192] = _12976
                                                            require _12574 + (32 * _12976) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12574 + 224
                                                            t = (7 * ceil32(return_data.size)) + 224
                                                            while idx < _12976:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19034 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19034] == mem[_19034]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19034] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21200 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21200] == bool(mem[_21200])
                                                        else:
                                                            if rewardTokenAddress == WAVAXAddress:
                                                                mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                                mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                                mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[(6 * ceil32(return_data.size)) + 196] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                                mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + 128
                                                                t = (6 * ceil32(return_data.size)) + 388
                                                                while idx < 2:
                                                                    mem[t] = mem[s + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                                mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                                require ext_code.size(routerAddress)
                                                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = (7 * ceil32(return_data.size)) + 192
                                                                require return_data.size >= 32
                                                                _12576 = mem[(6 * ceil32(return_data.size)) + 192 len 4], 0
                                                                require mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                                                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                                _12978 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                                                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192] <= test266151307()
                                                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 32 >= 0
                                                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 224
                                                                mem[(7 * ceil32(return_data.size)) + 192] = _12978
                                                                require _12576 + (32 * _12978) + 32 <= return_data.size
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + _12576 + 224
                                                                t = (7 * ceil32(return_data.size)) + 224
                                                                while idx < _12978:
                                                                    require mem[s] == mem[s]
                                                                    mem[t] = mem[s]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[mem[64] + 4] = this.address
                                                                require ext_code.size(rewardTokenAddress)
                                                                staticcall rewardTokenAddress.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args address(this.address)
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _19036 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_19036] == mem[_19036]
                                                                if sub_0b4b41bc <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require sub_0b4b41bc
                                                                sub_7f94bf16 = mem[_19036] / sub_0b4b41bc
                                                                mem[mem[64] + 4] = treasuryAddress
                                                                mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                                require ext_code.size(assetAddress)
                                                                call assetAddress.0xa9059cbb with:
                                                                     gas gas_remaining wei
                                                                    args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _21202 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_21202] == bool(mem[_21202])
                                                            else:
                                                                mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                                mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                                mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                                mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                                mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + 128
                                                                t = (6 * ceil32(return_data.size)) + 420
                                                                while idx < 3:
                                                                    mem[t] = mem[s + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                                mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                                require ext_code.size(routerAddress)
                                                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args 0, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = (7 * ceil32(return_data.size)) + 224
                                                                require return_data.size >= 32
                                                                _12575 = mem[(6 * ceil32(return_data.size)) + 224 len 4], 0
                                                                require mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 <= test266151307()
                                                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                                _12977 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]
                                                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224] <= test266151307()
                                                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 32 >= 0
                                                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], 0 + 224]) + 256
                                                                mem[(7 * ceil32(return_data.size)) + 224] = _12977
                                                                require _12575 + (32 * _12977) + 32 <= return_data.size
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + _12575 + 256
                                                                t = (7 * ceil32(return_data.size)) + 256
                                                                while idx < _12977:
                                                                    require mem[s] == mem[s]
                                                                    mem[t] = mem[s]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[mem[64] + 4] = this.address
                                                                require ext_code.size(rewardTokenAddress)
                                                                staticcall rewardTokenAddress.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args address(this.address)
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _19035 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_19035] == mem[_19035]
                                                                if sub_0b4b41bc <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require sub_0b4b41bc
                                                                sub_7f94bf16 = mem[_19035] / sub_0b4b41bc
                                                                mem[mem[64] + 4] = treasuryAddress
                                                                mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                                require ext_code.size(assetAddress)
                                                                call assetAddress.0xa9059cbb with:
                                                                     gas gas_remaining wei
                                                                    args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _21201 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_21201] == bool(mem[_21201])
                                                else:
                                                    require ext_call.return_data[0] - totalDeposited
                                                    if (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / ext_call.return_data[0] - totalDeposited != sub_2f6236be:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not ext_call.return_data[0] - totalDeposited:
                                                        sub_bf4c8572 = 0
                                                        mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                                        mem[ceil32(return_data.size) + 132] = -1
                                                        require ext_code.size(sub_b8ab24bdAddress)
                                                        call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args lendingPoolAddress, -1
                                                        mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                        mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                                        mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                                        mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                                        require ext_code.size(lendingPoolAddress)
                                                        call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                             gas gas_remaining wei
                                                            args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                                        mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == ext_call.return_data[0]
                                                        mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                                        mem[(4 * ceil32(return_data.size)) + 132] = -1
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.approve(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args routerAddress, -1
                                                        mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                        if assetAddress == WAVAXAddress:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 388
                                                            while idx < 2:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 192
                                                            require return_data.size >= 32
                                                            _12571 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                            require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                            _12973 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                            mem[(7 * ceil32(return_data.size)) + 192] = _12973
                                                            require _12571 + (32 * _12973) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12571 + 224
                                                            t = (7 * ceil32(return_data.size)) + 224
                                                            while idx < _12973:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19031 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19031] == mem[_19031]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19031] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21197 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21197] == bool(mem[_21197])
                                                        else:
                                                            if rewardTokenAddress == WAVAXAddress:
                                                                mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                                mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                                mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                                mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                                mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + 128
                                                                t = (6 * ceil32(return_data.size)) + 388
                                                                while idx < 2:
                                                                    mem[t] = mem[s + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                                mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                                require ext_code.size(routerAddress)
                                                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = (7 * ceil32(return_data.size)) + 192
                                                                require return_data.size >= 32
                                                                _12573 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                                require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                                _12975 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                                mem[(7 * ceil32(return_data.size)) + 192] = _12975
                                                                require _12573 + (32 * _12975) + 32 <= return_data.size
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + _12573 + 224
                                                                t = (7 * ceil32(return_data.size)) + 224
                                                                while idx < _12975:
                                                                    require mem[s] == mem[s]
                                                                    mem[t] = mem[s]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[mem[64] + 4] = this.address
                                                                require ext_code.size(rewardTokenAddress)
                                                                staticcall rewardTokenAddress.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args address(this.address)
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _19033 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_19033] == mem[_19033]
                                                                if sub_0b4b41bc <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require sub_0b4b41bc
                                                                sub_7f94bf16 = mem[_19033] / sub_0b4b41bc
                                                                mem[mem[64] + 4] = treasuryAddress
                                                                mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                                require ext_code.size(assetAddress)
                                                                call assetAddress.0xa9059cbb with:
                                                                     gas gas_remaining wei
                                                                    args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _21199 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_21199] == bool(mem[_21199])
                                                            else:
                                                                mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                                mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                                mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                                mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[(6 * ceil32(return_data.size)) + 228] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                                mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                                mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + 128
                                                                t = (6 * ceil32(return_data.size)) + 420
                                                                while idx < 3:
                                                                    mem[t] = mem[s + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                                mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                                require ext_code.size(routerAddress)
                                                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = (7 * ceil32(return_data.size)) + 224
                                                                require return_data.size >= 32
                                                                _12572 = mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                                require mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                                _12974 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]
                                                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224] <= test266151307()
                                                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 32 >= 0
                                                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256
                                                                mem[(7 * ceil32(return_data.size)) + 224] = _12974
                                                                require _12572 + (32 * _12974) + 32 <= return_data.size
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + _12572 + 256
                                                                t = (7 * ceil32(return_data.size)) + 256
                                                                while idx < _12974:
                                                                    require mem[s] == mem[s]
                                                                    mem[t] = mem[s]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[mem[64] + 4] = this.address
                                                                require ext_code.size(rewardTokenAddress)
                                                                staticcall rewardTokenAddress.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args address(this.address)
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _19032 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_19032] == mem[_19032]
                                                                if sub_0b4b41bc <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require sub_0b4b41bc
                                                                sub_7f94bf16 = mem[_19032] / sub_0b4b41bc
                                                                mem[mem[64] + 4] = treasuryAddress
                                                                mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                                require ext_code.size(assetAddress)
                                                                call assetAddress.0xa9059cbb with:
                                                                     gas gas_remaining wei
                                                                    args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _21198 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_21198] == bool(mem[_21198])
                                                    else:
                                                        require ext_call.return_data[0] - totalDeposited
                                                        if (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / ext_call.return_data[0] - totalDeposited != sub_7e72b29f:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        sub_bf4c8572 = (ext_call.return_data[0] * sub_7e72b29f) - (totalDeposited * sub_7e72b29f) / 10000
                                                        mem[ceil32(return_data.size) + 100] = lendingPoolAddress
                                                        mem[ceil32(return_data.size) + 132] = -1
                                                        require ext_code.size(sub_b8ab24bdAddress)
                                                        call sub_b8ab24bdAddress.approve(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args lendingPoolAddress, -1
                                                        mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                        mem[(2 * ceil32(return_data.size)) + 100] = assetAddress
                                                        mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0] - totalDeposited
                                                        mem[(2 * ceil32(return_data.size)) + 164] = this.address
                                                        require ext_code.size(lendingPoolAddress)
                                                        call lendingPoolAddress.withdraw(address arg1, uint256 arg2, address arg3) with:
                                                             gas gas_remaining wei
                                                            args assetAddress, ext_call.return_data[0] - totalDeposited, this.address
                                                        mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == ext_call.return_data[0]
                                                        mem[(4 * ceil32(return_data.size)) + 100] = routerAddress
                                                        mem[(4 * ceil32(return_data.size)) + 132] = -1
                                                        require ext_code.size(assetAddress)
                                                        call assetAddress.approve(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args routerAddress, -1
                                                        mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                                        if assetAddress == WAVAXAddress:
                                                            mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                            mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                            mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                            mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                            mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                            mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                            mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + 128
                                                            t = (6 * ceil32(return_data.size)) + 388
                                                            while idx < 2:
                                                                mem[t] = mem[s + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                            mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                            require ext_code.size(routerAddress)
                                                            call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (7 * ceil32(return_data.size)) + 192
                                                            require return_data.size >= 32
                                                            _12568 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                            require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                            require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                            _12970 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                            require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                            require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                            mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                            mem[(7 * ceil32(return_data.size)) + 192] = _12970
                                                            require _12568 + (32 * _12970) + 32 <= return_data.size
                                                            idx = 0
                                                            s = (6 * ceil32(return_data.size)) + _12568 + 224
                                                            t = (7 * ceil32(return_data.size)) + 224
                                                            while idx < _12970:
                                                                require mem[s] == mem[s]
                                                                mem[t] = mem[s]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[mem[64] + 4] = this.address
                                                            require ext_code.size(rewardTokenAddress)
                                                            staticcall rewardTokenAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args address(this.address)
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _19028 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_19028] == mem[_19028]
                                                            if sub_0b4b41bc <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require sub_0b4b41bc
                                                            sub_7f94bf16 = mem[_19028] / sub_0b4b41bc
                                                            mem[mem[64] + 4] = treasuryAddress
                                                            mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            require ext_code.size(assetAddress)
                                                            call assetAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _21194 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_21194] == bool(mem[_21194])
                                                        else:
                                                            if rewardTokenAddress == WAVAXAddress:
                                                                mem[(6 * ceil32(return_data.size)) + 96] = 2
                                                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                                mem[(6 * ceil32(return_data.size)) + 160] = rewardTokenAddress
                                                                mem[(6 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[(6 * ceil32(return_data.size)) + 196] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                                mem[(6 * ceil32(return_data.size)) + 228] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 260] = 160
                                                                mem[(6 * ceil32(return_data.size)) + 356] = 2
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + 128
                                                                t = (6 * ceil32(return_data.size)) + 388
                                                                while idx < 2:
                                                                    mem[t] = mem[s + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[(6 * ceil32(return_data.size)) + 292] = this.address
                                                                mem[(6 * ceil32(return_data.size)) + 324] = block.timestamp
                                                                require ext_code.size(routerAddress)
                                                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 388 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[(6 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = (7 * ceil32(return_data.size)) + 192
                                                                require return_data.size >= 32
                                                                _12570 = mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                                require mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 223 < (6 * ceil32(return_data.size)) + return_data.size + 192
                                                                _12972 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]
                                                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192] <= test266151307()
                                                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 32 >= 0
                                                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 192]) + 224
                                                                mem[(7 * ceil32(return_data.size)) + 192] = _12972
                                                                require _12570 + (32 * _12972) + 32 <= return_data.size
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + _12570 + 224
                                                                t = (7 * ceil32(return_data.size)) + 224
                                                                while idx < _12972:
                                                                    require mem[s] == mem[s]
                                                                    mem[t] = mem[s]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[mem[64] + 4] = this.address
                                                                require ext_code.size(rewardTokenAddress)
                                                                staticcall rewardTokenAddress.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args address(this.address)
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _19030 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_19030] == mem[_19030]
                                                                if sub_0b4b41bc <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require sub_0b4b41bc
                                                                sub_7f94bf16 = mem[_19030] / sub_0b4b41bc
                                                                mem[mem[64] + 4] = treasuryAddress
                                                                mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                                require ext_code.size(assetAddress)
                                                                call assetAddress.0xa9059cbb with:
                                                                     gas gas_remaining wei
                                                                    args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _21196 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_21196] == bool(mem[_21196])
                                                            else:
                                                                mem[(6 * ceil32(return_data.size)) + 96] = 3
                                                                mem[(6 * ceil32(return_data.size)) + 128] = assetAddress
                                                                mem[(6 * ceil32(return_data.size)) + 160] = WAVAXAddress
                                                                mem[(6 * ceil32(return_data.size)) + 192] = rewardTokenAddress
                                                                mem[(6 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[(6 * ceil32(return_data.size)) + 228] = (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000
                                                                mem[(6 * ceil32(return_data.size)) + 260] = 0
                                                                mem[(6 * ceil32(return_data.size)) + 292] = 160
                                                                mem[(6 * ceil32(return_data.size)) + 388] = 3
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + 128
                                                                t = (6 * ceil32(return_data.size)) + 420
                                                                while idx < 3:
                                                                    mem[t] = mem[s + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[(6 * ceil32(return_data.size)) + 324] = this.address
                                                                mem[(6 * ceil32(return_data.size)) + 356] = block.timestamp
                                                                require ext_code.size(routerAddress)
                                                                call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000, 0, 160, address(this.address), block.timestamp, 3, mem[(6 * ceil32(return_data.size)) + 420 len 96]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = (7 * ceil32(return_data.size)) + 224
                                                                require return_data.size >= 32
                                                                _12569 = mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32
                                                                require mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 <= test266151307()
                                                                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                                                                _12971 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]
                                                                require mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224] <= test266151307()
                                                                require (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256 <= test266151307() and (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 32 >= 0
                                                                mem[64] = (7 * ceil32(return_data.size)) + (32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (ext_call.return_data[0] * sub_2f6236be) - (totalDeposited * sub_2f6236be) / 10000) >> 32 + 224]) + 256
                                                                mem[(7 * ceil32(return_data.size)) + 224] = _12971
                                                                require _12569 + (32 * _12971) + 32 <= return_data.size
                                                                idx = 0
                                                                s = (6 * ceil32(return_data.size)) + _12569 + 256
                                                                t = (7 * ceil32(return_data.size)) + 256
                                                                while idx < _12971:
                                                                    require mem[s] == mem[s]
                                                                    mem[t] = mem[s]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[mem[64] + 4] = this.address
                                                                require ext_code.size(rewardTokenAddress)
                                                                staticcall rewardTokenAddress.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args address(this.address)
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _19029 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_19029] == mem[_19029]
                                                                if sub_0b4b41bc <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require sub_0b4b41bc
                                                                sub_7f94bf16 = mem[_19029] / sub_0b4b41bc
                                                                mem[mem[64] + 4] = treasuryAddress
                                                                mem[mem[64] + 36] = (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                                require ext_code.size(assetAddress)
                                                                call assetAddress.0xa9059cbb with:
                                                                     gas gas_remaining wei
                                                                    args treasuryAddress, (ext_call.return_data[0] * sub_7796ff37) - (totalDeposited * sub_7796ff37) / 10000
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _21195 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_21195] == bool(mem[_21195])
}



}

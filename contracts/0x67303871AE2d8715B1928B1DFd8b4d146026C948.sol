contract main {




// =====================  Runtime code  =====================


#
#  - createMultipleLocks(address arg1, address arg2, uint256[] arg3, uint256[] arg4)
#
uint8 stor0;
uint8 stor0; offset 8
uint256 stor0; offset 8
address owner;
uint8 paused;
uint256 depositId;
array of struct allDepositIds;
array of struct depositsByWithdrawal;
mapping of struct lockedToken;
mapping of uint256 tokenBalanceBy;
address sub_3eac8dacAddress;
uint256 stor206;
address sub_e3f1bc2bAddress;
uint256 sub_aa182aef;
address companyWalletAddress;
mapping of uint8 stor210;
array of uint256 stor30232785535072749652971633506012447853310042529756156461386917081222683561697;

function companyWallet() {
    return companyWalletAddress
}

function isFreeToken(address arg1) {
    require calldata.size - 4 >= 32
    return bool(stor210[address(arg1)])
}

function getTokenBalanceByAddress(address arg1, address arg2) {
    require calldata.size - 4 >= 64
    return tokenBalanceBy[address(arg1)][address(arg2)]
}

function sub_3eac8dac(?) {
    return address(sub_3eac8dacAddress)
}

function depositsByWithdrawalAddress(address arg1, uint256 arg2) {
    require calldata.size - 4 >= 64
    require arg2 < depositsByWithdrawal[arg1].field_0
    return depositsByWithdrawal[arg1][arg2].field_0
}

function paused() {
    return bool(paused)
}

function getDepositDetails(uint256 arg1) {
    require calldata.size - 4 >= 32
    return lockedToken[arg1].field_0, 
           lockedToken[arg1].field_256,
           lockedToken[arg1].field_512,
           lockedToken[arg1].field_768,
           bool(lockedToken[arg1].field_1024)
}

function owner() {
    return owner
}

function depositId() {
    return depositId
}

function sub_aa182aef(?) {
    return sub_aa182aef
}

function walletTokenBalance(address arg1, address arg2) {
    require calldata.size - 4 >= 64
    return tokenBalanceBy[arg1][arg2]
}

function lockedToken(uint256 arg1) {
    require calldata.size - 4 >= 32
    return lockedToken[arg1].field_0, 
           lockedToken[arg1].field_256,
           lockedToken[arg1].field_512,
           lockedToken[arg1].field_768,
           bool(lockedToken[arg1].field_1024),
           lockedToken[arg1].field_1024
}

function allDepositIds(uint256 arg1) {
    require calldata.size - 4 >= 32
    require arg1 < allDepositIds.length
    return allDepositIds[arg1].field_0
}

function sub_e3f1bc2b(?) {
    return sub_e3f1bc2bAddress
}

function _fallback() payable {
    revert
}

function renounceOwnership() {
    if owner != msg.sender:
        revert with 0, 'wOwnable: caller is not the owne'
    emit OwnershipTransferred(owner, 0);
    owner = 0
}

function pause() {
    if owner != msg.sender:
        revert with 0, 'wOwnable: caller is not the owne'
    if paused:
        revert with 0, 'Pausable: paused'
    paused = 1
    emit Paused(msg.sender);
}

function unpause() {
    if owner != msg.sender:
        revert with 0, 'wOwnable: caller is not the owne'
    if not paused:
        revert with 0, 'Pausable: not paused'
    paused = 0
    emit Unpaused(msg.sender);
}

function setCompanyWallet(address arg1) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'wOwnable: caller is not the owne'
    if not arg1:
        revert with 0, 'Invalid wallet address'
    companyWalletAddress = arg1
}

function sub_c8e6aa98(?) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'wOwnable: caller is not the owne'
    if arg1 <= 0:
        revert with 0, 'fees should be greater than 0'
    sub_aa182aef = arg1
    emit FeesChanged(arg1);
}

function extendLockDuration(uint256 arg1, uint256 arg2) {
    require calldata.size - 4 >= 64
    require arg2 < 10^10
    require arg2 > lockedToken[arg1].field_768
    require not lockedToken[arg1].field_1024
    require msg.sender == lockedToken[arg1].field_256
    lockedToken[arg1].field_768 = arg2
}

function getTotalTokenBalance(address arg1) {
    require calldata.size - 4 >= 32
    require ext_code.size(arg1)
    staticcall arg1.0x70a08231 with:
            gas gas_remaining wei
           args this.address
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    return ext_call.return_data[0]
}

function onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) {
    require calldata.size - 4 >= 128
    require arg4 <= 4294967296
    require arg4 + 36 <= calldata.size
    require arg4.length <= 4294967296 and arg4 + arg4.length + 36 <= calldata.size
    mem[ceil32(arg4.length) + 128] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
    return Mask(8 * -ceil32(arg4.length) + arg4.length + 32, 0, 0), mem[arg4.length + 160 len -arg4.length + ceil32(arg4.length)]
}

function transferOwnership(address arg1) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'wOwnable: caller is not the owne'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    38,
                    0xfe4f776e61626c653a206e6577206f776e657220697320746865207a65726f20616464726573,
                    mem[202 len 26]
    emit OwnershipTransferred(owner, arg1);
    owner = arg1
}

function addTokenToFreeList(address arg1) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'wOwnable: caller is not the owne'
    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    39,
                    0x73546865206164647265737320646f6573206e6f7420636f6e7461696e206120636f6e74726163,
                    mem[203 len 25]
    if not ext_code.hash(arg1):
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    39,
                    0x73546865206164647265737320646f6573206e6f7420636f6e7461696e206120636f6e74726163,
                    mem[203 len 25]
    stor210[address(arg1)] = 1
}

function removeTokenFromFreeList(address arg1) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'wOwnable: caller is not the owne'
    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    39,
                    0x73546865206164647265737320646f6573206e6f7420636f6e7461696e206120636f6e74726163,
                    mem[203 len 25]
    if not ext_code.hash(arg1):
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    39,
                    0x73546865206164647265737320646f6573206e6f7420636f6e7461696e206120636f6e74726163,
                    mem[203 len 25]
    stor210[address(arg1)] = 0
}

function getAllDepositIds() {
    if not allDepositIds.length:
        mem[(32 * allDepositIds.length) + 128] = 32
        mem[(32 * allDepositIds.length) + 160] = allDepositIds.length
        mem[(32 * allDepositIds.length) + 192 len floor32(allDepositIds.length)] = mem[128 len floor32(allDepositIds.length)]
        return memory
          from (32 * allDepositIds.length) + 128
           len (96 * allDepositIds.length) + 64
    mem[128] = uint256(allDepositIds.field_0)
    idx = 128
    s = 0
    while (32 * allDepositIds.length) + 96 > idx:
        mem[idx + 32] = allDepositIds[s].field_256
        idx = idx + 32
        s = s + 1
        continue 
    mem[(32 * allDepositIds.length) + 192 len floor32(allDepositIds.length)] = mem[128 len floor32(allDepositIds.length)]
    return Array(len=allDepositIds.length, data=mem[128 len floor32(allDepositIds.length)], mem[(32 * allDepositIds.length) + floor32(allDepositIds.length) + 192 len (32 * allDepositIds.length) - floor32(allDepositIds.length)]), 
}

function getDepositsByWithdrawalAddress(address arg1) {
    require calldata.size - 4 >= 32
    if not depositsByWithdrawal[address(arg1)].field_0:
        mem[(32 * depositsByWithdrawal[address(arg1)].field_0) + 128] = 32
        mem[(32 * depositsByWithdrawal[address(arg1)].field_0) + 160] = depositsByWithdrawal[address(arg1)].field_0
        mem[(32 * depositsByWithdrawal[address(arg1)].field_0) + 192 len floor32(depositsByWithdrawal[address(arg1)].field_0)] = mem[128 len floor32(depositsByWithdrawal[address(arg1)].field_0)]
        return memory
          from (32 * depositsByWithdrawal[address(arg1)].field_0) + 128
           len (96 * depositsByWithdrawal[address(arg1)].field_0) + 64
    mem[128] = depositsByWithdrawal[address(arg1)].field_0
    idx = 128
    s = 0
    while (32 * depositsByWithdrawal[address(arg1)].field_0) + 96 > idx:
        mem[idx + 32] = depositsByWithdrawal[address(arg1)][s].field_256
        idx = idx + 32
        s = s + 1
        continue 
    mem[(32 * depositsByWithdrawal[address(arg1)].field_0) + 192 len floor32(depositsByWithdrawal[address(arg1)].field_0)] = mem[128 len floor32(depositsByWithdrawal[address(arg1)].field_0)]
    return Array(len=depositsByWithdrawal[address(arg1)].field_0, data=mem[128 len floor32(depositsByWithdrawal[address(arg1)].field_0)], mem[(32 * depositsByWithdrawal[address(arg1)].field_0) + floor32(depositsByWithdrawal[address(arg1)].field_0) + 192 len (32 * depositsByWithdrawal[address(arg1)].field_0) - floor32(depositsByWithdrawal[address(arg1)].field_0)]), 
}

function sub_6e8fa91d(?) {
    require calldata.size - 4 >= 128
    if owner != msg.sender:
        revert with 0, 'wOwnable: caller is not the owne'
    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    39,
                    0x73546865206164647265737320646f6573206e6f7420636f6e7461696e206120636f6e74726163,
                    mem[203 len 25]
    if not ext_code.hash(arg1):
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    39,
                    0x73546865206164647265737320646f6573206e6f7420636f6e7461696e206120636f6e74726163,
                    mem[203 len 25]
    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg2):
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    39,
                    0x73546865206164647265737320646f6573206e6f7420636f6e7461696e206120636f6e74726163,
                    mem[203 len 25]
    if not ext_code.hash(arg2):
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    39,
                    0x73546865206164647265737320646f6573206e6f7420636f6e7461696e206120636f6e74726163,
                    mem[203 len 25]
    if not arg1:
        revert with 0, 'Invalid price estimator address'
    if not arg2:
        revert with 0, 'Invalid USD token address'
    if arg3 <= 0:
        revert with 0, 'fees should be greater than 0'
    if not arg4:
        revert with 0, 'Invalid wallet address'
    sub_e3f1bc2bAddress = arg1
    address(sub_3eac8dacAddress) = arg2
    sub_aa182aef = arg3
    companyWalletAddress = arg4
    emit FeesChanged(arg3);
}

function transferLocks(uint256 arg1, address arg2) {
    require calldata.size - 4 >= 64
    require not lockedToken[arg1].field_1024
    require msg.sender == lockedToken[arg1].field_256
    if lockedToken[arg1].field_512 > tokenBalanceBy[stor204[arg1].field_0][msg.sender]:
        revert with 0, 'SafeMath: subtraction overflow'
    tokenBalanceBy[stor204[arg1].field_0][msg.sender] -= lockedToken[arg1].field_512
    if lockedToken[arg1].field_512 + tokenBalanceBy[stor204[arg1].field_0][address(arg2)] < tokenBalanceBy[stor204[arg1].field_0][address(arg2)]:
        revert with 0, 'SafeMath: addition overflow'
    tokenBalanceBy[stor204[arg1].field_0][address(arg2)] += lockedToken[arg1].field_512
    idx = 0
    while idx < depositsByWithdrawal[stor204[arg1].field_256].field_0:
        mem[32] = 203
        require idx < depositsByWithdrawal[stor204[arg1].field_256].field_0
        mem[0] = sha3(lockedToken[arg1].field_256, 203)
        if depositsByWithdrawal[stor204[arg1].field_256][idx].field_0 != arg1:
            idx = idx + 1
            continue 
        require depositsByWithdrawal[stor204[arg1].field_256].field_0 - 1 < depositsByWithdrawal[stor204[arg1].field_256].field_0
        require idx < depositsByWithdrawal[stor204[arg1].field_256].field_0
        depositsByWithdrawal[stor204[arg1].field_256][idx].field_0 = depositsByWithdrawal[stor204[arg1].field_256][depositsByWithdrawal[stor204[arg1].field_256].field_0].field_0
        require depositsByWithdrawal[stor204[arg1].field_256].field_0
        depositsByWithdrawal[stor204[arg1].field_256][depositsByWithdrawal[stor204[arg1].field_256].field_0].field_0 = 0
        depositsByWithdrawal[stor204[arg1].field_256].field_0--
        lockedToken[arg1].field_256 = arg2
        depositsByWithdrawal[address(arg2)].field_0++
        depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = arg1
    lockedToken[arg1].field_256 = arg2
    depositsByWithdrawal[address(arg2)].field_0++
    depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = arg1
}

function withdrawTokens(uint256 arg1) {
    require calldata.size - 4 >= 32
    require block.timestamp >= lockedToken[arg1].field_768
    require msg.sender == lockedToken[arg1].field_256
    require not lockedToken[arg1].field_1024
    lockedToken[arg1].field_1024 = 1
    if lockedToken[arg1].field_512 > tokenBalanceBy[stor204[arg1].field_0][msg.sender]:
        revert with 0, 'SafeMath: subtraction overflow'
    tokenBalanceBy[stor204[arg1].field_0][msg.sender] -= lockedToken[arg1].field_512
    idx = 0
    while idx < depositsByWithdrawal[stor204[arg1].field_256].field_0:
        mem[32] = 203
        require idx < depositsByWithdrawal[stor204[arg1].field_256].field_0
        mem[0] = sha3(lockedToken[arg1].field_256, 203)
        if depositsByWithdrawal[stor204[arg1].field_256][idx].field_0 != arg1:
            idx = idx + 1
            continue 
        require depositsByWithdrawal[stor204[arg1].field_256].field_0 - 1 < depositsByWithdrawal[stor204[arg1].field_256].field_0
        require idx < depositsByWithdrawal[stor204[arg1].field_256].field_0
        depositsByWithdrawal[stor204[arg1].field_256][idx].field_0 = depositsByWithdrawal[stor204[arg1].field_256][depositsByWithdrawal[stor204[arg1].field_256].field_0].field_0
        require depositsByWithdrawal[stor204[arg1].field_256].field_0
        depositsByWithdrawal[stor204[arg1].field_256][depositsByWithdrawal[stor204[arg1].field_256].field_0].field_0 = 0
        depositsByWithdrawal[stor204[arg1].field_256].field_0--
        require ext_code.size(lockedToken[arg1].field_0)
        if lockedToken[arg1].field_1032:
            call lockedToken[arg1].field_0.0x42842e0e with:
                 gas gas_remaining wei
                args this.address, msg.sender, lockedToken[arg1].field_1032
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
        else:
            call lockedToken[arg1].field_0.0xa9059cbb with:
                 gas gas_remaining wei
                args msg.sender, lockedToken[arg1].field_512
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0]
        emit LogWithdrawal(msg.sender, lockedToken[arg1].field_512);
    require ext_code.size(lockedToken[arg1].field_0)
    if lockedToken[arg1].field_1032:
        call lockedToken[arg1].field_0.0x42842e0e with:
             gas gas_remaining wei
            args this.address, msg.sender, lockedToken[arg1].field_1032
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
    else:
        call lockedToken[arg1].field_0.0xa9059cbb with:
             gas gas_remaining wei
            args msg.sender, lockedToken[arg1].field_512
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0]
    emit LogWithdrawal(msg.sender, lockedToken[arg1].field_512);
}

function initialize() {
    if uint8(stor0.field_8):
        owner = msg.sender
        emit OwnershipTransferred(0, msg.sender);
        paused = 0
    else:
        if ext_code.size(this.address):
            if uint8(stor0.field_0):
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            46,
                            0x72436f6e747261637420696e7374616e63652068617320616c7265616479206265656e20696e697469616c697a65,
                            mem[210 len 18]
        if uint8(stor0.field_8):
            owner = msg.sender
            emit OwnershipTransferred(0, msg.sender);
            paused = 0
        else:
            uint8(stor0.field_0) = 1
            uint8(stor0.field_8) = 1
            Mask(248, 0, stor0.field_8) = 0
            if ext_code.size(this.address):
                if uint8(stor0.field_0):
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                46,
                                0x72436f6e747261637420696e7374616e63652068617320616c7265616479206265656e20696e697469616c697a65,
                                mem[210 len 18]
            if uint8(stor0.field_8):
                owner = msg.sender
                emit OwnershipTransferred(0, msg.sender);
                paused = 0
            else:
                uint8(stor0.field_0) = 1
                uint8(stor0.field_8) = 1
                Mask(248, 0, stor0.field_8) = 0
                uint8(stor0.field_8) = 0
                if ext_code.size(this.address):
                    if uint8(stor0.field_0):
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    46,
                                    0x72436f6e747261637420696e7374616e63652068617320616c7265616479206265656e20696e697469616c697a65,
                                    mem[210 len 18]
                if uint8(stor0.field_8):
                    owner = msg.sender
                    emit OwnershipTransferred(0, msg.sender);
                    paused = 0
                else:
                    uint8(stor0.field_0) = 1
                    uint8(stor0.field_8) = 1
                    Mask(248, 0, stor0.field_8) = 0
                    owner = msg.sender
                    emit OwnershipTransferred(0, msg.sender);
                    uint8(stor0.field_8) = 0
                    if ext_code.size(this.address):
                        if uint8(stor0.field_0):
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        46,
                                        0x72436f6e747261637420696e7374616e63652068617320616c7265616479206265656e20696e697469616c697a65,
                                        mem[210 len 18]
                    if uint8(stor0.field_8):
                        paused = 0
                    else:
                        uint8(stor0.field_0) = 1
                        uint8(stor0.field_8) = 1
                        Mask(248, 0, stor0.field_8) = 0
                        paused = 0
                        uint8(stor0.field_8) = 0
                        uint8(stor0.field_8) = 0
}

function sub_feeb733d(?) {
    require calldata.size - 4 >= 32
    if stor210[address(arg1)]:
        return 0
    if not sub_e3f1bc2bAddress:
        return 0
    if not address(sub_3eac8dacAddress):
        return 0
    if not sub_aa182aef:
        return 0
    require ext_code.size(address(sub_3eac8dacAddress))
    staticcall address(sub_3eac8dacAddress).0x313ce567 with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    mem[96] = 0x50a2394500000000000000000000000000000000000000000000000000000000
    mem[100] = 10^uint8(ext_call.return_data[0])
    mem[132] = address(sub_3eac8dacAddress)
    require ext_code.size(sub_e3f1bc2bAddress)
    staticcall sub_e3f1bc2bAddress.getEstimatedETHforERC20(uint256 arg1, address arg2) with:
            gas gas_remaining wei
           args 10^uint8(ext_call.return_data[0]), address(sub_3eac8dacAddress)
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    mem[96 len return_data.size] = ext_call.return_data[0 len return_data.size]
    mem[64] = ceil32(return_data.size) + 96
    require return_data.size >= 32
    _17 = mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32
    require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 <= 4294967296
    require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 + 32 <= return_data.size
    require mem[mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 + 96] <= 4294967296 and mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 + (32 * mem[mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 + 96]) + 32 <= return_data.size
    mem[ceil32(return_data.size) + 96] = mem[mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 + 96]
    _20 = mem[_17 + 96]
    mem[ceil32(return_data.size) + 128 len floor32(mem[_17 + 96])] = mem[_17 + 128 len floor32(mem[_17 + 96])]
    require 0 < mem[ceil32(return_data.size) + 96]
    if not mem[ceil32(return_data.size) + 128]:
        if 0 > mem[ceil32(return_data.size) + 128]:
            revert with 0, 'SafeMath: subtraction overflow'
        if not sub_aa182aef:
            if not 10^uint8(ext_call.return_data[0]):
                revert with 0, 'SafeMath: division by zero'
            return (0 / 10^uint8(ext_call.return_data[0]))
        if mem[ceil32(return_data.size) + 128] * sub_aa182aef / sub_aa182aef != mem[ceil32(return_data.size) + 128]:
            revert with 0, 
                        32,
                        33,
                        0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[(32 * _20) + ceil32(return_data.size) + 357 len 31]
        if not 10^uint8(ext_call.return_data[0]):
            revert with 0, 'SafeMath: division by zero'
        return (mem[ceil32(return_data.size) + 128] * sub_aa182aef / 10^uint8(ext_call.return_data[0]))
    if 3 * mem[ceil32(return_data.size) + 128] / mem[ceil32(return_data.size) + 128] != 3:
        revert with 0, 
                    32,
                    33,
                    0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                    mem[(32 * _20) + ceil32(return_data.size) + 229 len 31]
    if 3 * mem[ceil32(return_data.size) + 128] / 1000 > mem[ceil32(return_data.size) + 128]:
        revert with 0, 'SafeMath: subtraction overflow'
    if not sub_aa182aef:
        if not 10^uint8(ext_call.return_data[0]):
            revert with 0, 'SafeMath: division by zero'
        return (0 / 10^uint8(ext_call.return_data[0]))
    if (mem[ceil32(return_data.size) + 128] * sub_aa182aef) - (3 * mem[ceil32(return_data.size) + 128] / 1000 * sub_aa182aef) / sub_aa182aef != mem[ceil32(return_data.size) + 128] - (3 * mem[ceil32(return_data.size) + 128] / 1000):
        revert with 0, 
                    32,
                    33,
                    0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                    mem[(32 * _20) + ceil32(return_data.size) + 357 len 31]
    if not 10^uint8(ext_call.return_data[0]):
        revert with 0, 'SafeMath: division by zero'
    return ((mem[ceil32(return_data.size) + 128] * sub_aa182aef) - (3 * mem[ceil32(return_data.size) + 128] / 1000 * sub_aa182aef) / 10^uint8(ext_call.return_data[0]))
}

function sub_e2b71bba(?) payable {
    require calldata.size - 4 >= 160
    if paused:
        revert with 0, 'Pausable: paused'
    require arg3 > 0
    require arg4 < 10^10
    if Mask(248, 0, arg5):
        require ext_code.size(arg1)
        call arg1.0x42842e0e with:
             gas gas_remaining wei
            args msg.sender, this.address, Mask(248, 0, arg5)
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        if arg3 + tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
            revert with 0, 'SafeMath: addition overflow'
        tokenBalanceBy[address(arg1)][address(arg2)] += arg3
        depositId++
        lockedToken[stor201 + 1].field_0 = arg1
        lockedToken[stor201 + 1].field_256 = arg2
        lockedToken[stor201 + 1].field_512 = arg3
    else:
        mem[0] = arg1
        mem[32] = 210
        if stor210[address(arg1)]:
            require ext_code.size(arg1)
            staticcall arg1.0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                revert with 0, 'SafeERC20: call to non-contract'
            if not ext_code.hash(arg1):
                revert with 0, 'SafeERC20: call to non-contract'
            mem[228 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
            mem[352 len 4] = uint32(arg3)
            call arg1 with:
                 gas gas_remaining wei
                args Mask(224, 32, arg3) << 480, mem[324 len 4]
            if not return_data.size:
                if not ext_call.success:
                    revert with 0, 'SafeERC20: low-level call failed'
                if not unknown_0x23b872dd(?????), Mask(224, 32, msg.sender) >> 32:
                    revert with 0, 
                                32,
                                42,
                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                mem[338 len 14],
                                uint32(arg3),
                                mem[356 len 4]
            else:
                mem[260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    revert with 0, 'SafeERC20: low-level call failed'
                if return_data.size:
                    require return_data.size >= 32
                    if not mem[260]:
                        revert with 0, 
                                    32,
                                    42,
                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                    mem[ceil32(return_data.size) + 339 len 22]
        else:
            if not sub_e3f1bc2bAddress:
                require ext_code.size(arg1)
                staticcall arg1.0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                    revert with 0, 'SafeERC20: call to non-contract'
                if not ext_code.hash(arg1):
                    revert with 0, 'SafeERC20: call to non-contract'
                mem[228 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                mem[352 len 4] = uint32(arg3)
                call arg1 with:
                     gas gas_remaining wei
                    args Mask(224, 32, arg3) << 480, mem[324 len 4]
                if not return_data.size:
                    if not ext_call.success:
                        revert with 0, 'SafeERC20: low-level call failed'
                    if not unknown_0x23b872dd(?????), Mask(224, 32, msg.sender) >> 32:
                        revert with 0, 
                                    32,
                                    42,
                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                    mem[338 len 14],
                                    uint32(arg3),
                                    mem[356 len 4]
                else:
                    mem[260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        revert with 0, 'SafeERC20: low-level call failed'
                    if return_data.size:
                        require return_data.size >= 32
                        if not mem[260]:
                            revert with 0, 
                                        32,
                                        42,
                                        0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                        mem[ceil32(return_data.size) + 339 len 22]
            else:
                if not address(sub_3eac8dacAddress):
                    require ext_code.size(arg1)
                    staticcall arg1.0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                        revert with 0, 'SafeERC20: call to non-contract'
                    if not ext_code.hash(arg1):
                        revert with 0, 'SafeERC20: call to non-contract'
                    mem[228 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                    mem[352 len 4] = uint32(arg3)
                    call arg1 with:
                         gas gas_remaining wei
                        args Mask(224, 32, arg3) << 480, mem[324 len 4]
                    if not return_data.size:
                        if not ext_call.success:
                            revert with 0, 'SafeERC20: low-level call failed'
                        if not unknown_0x23b872dd(?????), Mask(224, 32, msg.sender) >> 32:
                            revert with 0, 
                                        32,
                                        42,
                                        0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                        mem[338 len 14],
                                        uint32(arg3),
                                        mem[356 len 4]
                    else:
                        mem[260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size:
                            require return_data.size >= 32
                            if not mem[260]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[ceil32(return_data.size) + 339 len 22]
                else:
                    if not sub_aa182aef:
                        require ext_code.size(arg1)
                        staticcall arg1.0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                            revert with 0, 'SafeERC20: call to non-contract'
                        if not ext_code.hash(arg1):
                            revert with 0, 'SafeERC20: call to non-contract'
                        mem[228 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                        mem[352 len 4] = uint32(arg3)
                        call arg1 with:
                             gas gas_remaining wei
                            args Mask(224, 32, arg3) << 480, mem[324 len 4]
                        if not return_data.size:
                            if not ext_call.success:
                                revert with 0, 'SafeERC20: low-level call failed'
                            if not unknown_0x23b872dd(?????), Mask(224, 32, msg.sender) >> 32:
                                revert with 0, 
                                            32,
                                            42,
                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[338 len 14],
                                            uint32(arg3),
                                            mem[356 len 4]
                        else:
                            mem[260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                revert with 0, 'SafeERC20: low-level call failed'
                            if return_data.size:
                                require return_data.size >= 32
                                if not mem[260]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[ceil32(return_data.size) + 339 len 22]
                    else:
                        require ext_code.size(address(sub_3eac8dacAddress))
                        staticcall address(sub_3eac8dacAddress).0x313ce567 with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[96] = 0x50a2394500000000000000000000000000000000000000000000000000000000
                        mem[100] = 10^uint8(ext_call.return_data[0])
                        mem[132] = address(sub_3eac8dacAddress)
                        require ext_code.size(sub_e3f1bc2bAddress)
                        staticcall sub_e3f1bc2bAddress.getEstimatedETHforERC20(uint256 arg1, address arg2) with:
                                gas gas_remaining wei
                               args 10^uint8(ext_call.return_data[0]), address(sub_3eac8dacAddress)
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = ceil32(return_data.size) + 96
                        require return_data.size >= 32
                        _48 = mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32
                        require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 <= 4294967296
                        require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 + 32 <= return_data.size
                        require mem[mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 + 96] <= 4294967296 and mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 + (32 * mem[mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 + 96]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 96] = mem[mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 + 96]
                        _57 = mem[_48 + 96]
                        mem[ceil32(return_data.size) + 128 len floor32(mem[_48 + 96])] = mem[_48 + 128 len floor32(mem[_48 + 96])]
                        require 0 < mem[ceil32(return_data.size) + 96]
                        if not mem[ceil32(return_data.size) + 128]:
                            if 0 > mem[ceil32(return_data.size) + 128]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not sub_aa182aef:
                                if not 10^uint8(ext_call.return_data[0]):
                                    revert with 0, 'SafeMath: division by zero'
                                if not 0 / 10^uint8(ext_call.return_data[0]):
                                    require ext_code.size(arg1)
                                    staticcall arg1.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                        revert with 0, 'SafeERC20: call to non-contract'
                                    if not ext_code.hash(arg1):
                                        revert with 0, 'SafeERC20: call to non-contract'
                                    mem[(32 * _57) + ceil32(return_data.size) + 452 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                    mem[(32 * _57) + ceil32(return_data.size) + 576 len 4] = uint32(arg3)
                                    call arg1 with:
                                         gas gas_remaining wei
                                        args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + 548 len 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                            require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                            if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[(32 * _57) + ceil32(return_data.size) + 562 len 14],
                                                            uint32(arg3),
                                                            mem[(32 * _57) + ceil32(return_data.size) + 580 len 4]
                                    else:
                                        mem[(32 * _57) + ceil32(return_data.size) + 484 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if return_data.size:
                                            require return_data.size >= 32
                                            if not mem[(32 * _57) + ceil32(return_data.size) + 484]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 563 len 22]
                                else:
                                    if 0 / 10^uint8(ext_call.return_data[0]) <= msg.value:
                                        call companyWalletAddress with:
                                           value 0 / 10^uint8(ext_call.return_data[0]) wei
                                             gas gas_remaining wei
                                        if not return_data.size:
                                            if not ext_call.success:
                                                revert with 0, 'Fee transfer failed'
                                            if 0 / 10^uint8(ext_call.return_data[0]) > msg.value:
                                                require ext_code.size(arg1)
                                                staticcall arg1.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(arg1):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                mem[(32 * _57) + ceil32(return_data.size) + 516 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                mem[(32 * _57) + ceil32(return_data.size) + 640 len 4] = uint32(arg3)
                                                call arg1 with:
                                                     gas gas_remaining wei
                                                    args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + 612 len 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                        require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                        if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[(32 * _57) + ceil32(return_data.size) + 626 len 14],
                                                                        uint32(arg3),
                                                                        mem[(32 * _57) + ceil32(return_data.size) + 644 len 4]
                                                else:
                                                    mem[(32 * _57) + ceil32(return_data.size) + 548 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[(32 * _57) + ceil32(return_data.size) + 548]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 627 len 22]
                                                require ext_code.size(arg1)
                                                staticcall arg1.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                depositId++
                                                lockedToken[stor201 + 1].field_0 = arg1
                                                lockedToken[stor201 + 1].field_256 = arg2
                                                lockedToken[stor201 + 1].field_512 = 0
                                                lockedToken[stor201 + 1].field_768 = arg4
                                                lockedToken[stor201 + 1].field_1024 = 0
                                                lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                allDepositIds.length++
                                                stor42D7[stor202.length] = depositId + 1
                                                depositsByWithdrawal[address(arg2)].field_0++
                                                depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                return (depositId + 1)
                                            if msg.value - (0 / 10^uint8(ext_call.return_data[0])) <= 0:
                                                require ext_code.size(arg1)
                                                staticcall arg1.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(arg1):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                mem[(32 * _57) + ceil32(return_data.size) + 516 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                mem[(32 * _57) + ceil32(return_data.size) + 640 len 4] = uint32(arg3)
                                                call arg1 with:
                                                     gas gas_remaining wei
                                                    args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + 612 len 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                        require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                        if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[(32 * _57) + ceil32(return_data.size) + 626 len 14],
                                                                        uint32(arg3),
                                                                        mem[(32 * _57) + ceil32(return_data.size) + 644 len 4]
                                                else:
                                                    mem[(32 * _57) + ceil32(return_data.size) + 548 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[(32 * _57) + ceil32(return_data.size) + 548]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 627 len 22]
                                                require ext_code.size(arg1)
                                                staticcall arg1.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                depositId++
                                                lockedToken[stor201 + 1].field_0 = arg1
                                                lockedToken[stor201 + 1].field_256 = arg2
                                                lockedToken[stor201 + 1].field_512 = 0
                                                lockedToken[stor201 + 1].field_768 = arg4
                                                lockedToken[stor201 + 1].field_1024 = 0
                                                lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                allDepositIds.length++
                                                stor42D7[stor202.length] = depositId + 1
                                                depositsByWithdrawal[address(arg2)].field_0++
                                                depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                return (depositId + 1)
                                            call msg.sender with:
                                               value msg.value - (0 / 10^uint8(ext_call.return_data[0])) wei
                                                 gas gas_remaining wei
                                            require ext_code.size(arg1)
                                            staticcall arg1.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                revert with 0, 'SafeERC20: call to non-contract'
                                            if not ext_code.hash(arg1):
                                                revert with 0, 'SafeERC20: call to non-contract'
                                            if not return_data.size:
                                                mem[(32 * _57) + ceil32(return_data.size) + 516 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                mem[(32 * _57) + ceil32(return_data.size) + 640 len 4] = uint32(arg3)
                                                call arg1 with:
                                                     gas gas_remaining wei
                                                    args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + 612 len 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                        require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                        if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[(32 * _57) + ceil32(return_data.size) + 626 len 14],
                                                                        uint32(arg3),
                                                                        mem[(32 * _57) + ceil32(return_data.size) + 644 len 4]
                                                else:
                                                    mem[(32 * _57) + ceil32(return_data.size) + 548 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[(32 * _57) + ceil32(return_data.size) + 548]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 627 len 22]
                                                require ext_code.size(arg1)
                                                staticcall arg1.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                depositId++
                                                lockedToken[stor201 + 1].field_0 = arg1
                                                lockedToken[stor201 + 1].field_256 = arg2
                                                lockedToken[stor201 + 1].field_512 = 0
                                                lockedToken[stor201 + 1].field_768 = arg4
                                                lockedToken[stor201 + 1].field_1024 = 0
                                                lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                allDepositIds.length++
                                                stor42D7[stor202.length] = depositId + 1
                                                depositsByWithdrawal[address(arg2)].field_0++
                                                depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                return (depositId + 1)
                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 517 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 641 len 4] = uint32(arg3)
                                            call arg1 with:
                                                 gas gas_remaining wei
                                                args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                    require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                    if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                        revert with 0, 
                                                                    32,
                                                                    42,
                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 627 len 14],
                                                                    uint32(arg3),
                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 645 len 4]
                                                require ext_code.size(arg1)
                                                staticcall arg1.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                depositId++
                                                lockedToken[stor201 + 1].field_0 = arg1
                                                lockedToken[stor201 + 1].field_256 = arg2
                                                lockedToken[stor201 + 1].field_512 = 0
                                                lockedToken[stor201 + 1].field_768 = arg4
                                                lockedToken[stor201 + 1].field_1024 = 0
                                                lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                allDepositIds.length++
                                                stor42D7[stor202.length] = depositId + 1
                                                depositsByWithdrawal[address(arg2)].field_0++
                                                depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                return (depositId + 1)
                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 517] = return_data.size
                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 549 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = 32
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 554] = 32
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 'SafeERC20: low-level call failed'
                                                revert with memory
                                                  from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                            if return_data.size:
                                                require return_data.size >= 32
                                                if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 549]:
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = 32
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 554] = 42
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586 len 42] = 0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565
                                                    revert with memory
                                                      from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                                       len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = this.address
                                            require ext_code.size(arg1)
                                            staticcall arg1.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522 len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = 32
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 554] = 27
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 'SafeMath: addition overflow'
                                                revert with memory
                                                  from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                            depositId++
                                            lockedToken[stor201 + 1].field_0 = arg1
                                            lockedToken[stor201 + 1].field_256 = arg2
                                            lockedToken[stor201 + 1].field_512 = 0
                                            lockedToken[stor201 + 1].field_768 = arg4
                                            lockedToken[stor201 + 1].field_1024 = 0
                                            lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                            allDepositIds.length++
                                            stor42D7[stor202.length] = depositId + 1
                                            depositsByWithdrawal[address(arg2)].field_0++
                                            depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = depositId + 1
                                            return memory
                                              from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32
                                        mem[(32 * _57) + ceil32(return_data.size) + 416 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            revert with 0, 'Fee transfer failed'
                                        if 0 / 10^uint8(ext_call.return_data[0]) > msg.value:
                                            require ext_code.size(arg1)
                                            staticcall arg1.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                revert with 0, 'SafeERC20: call to non-contract'
                                            if not ext_code.hash(arg1):
                                                revert with 0, 'SafeERC20: call to non-contract'
                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 517 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 641 len 4] = uint32(arg3)
                                            call arg1 with:
                                                 gas gas_remaining wei
                                                args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                    require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                    if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                        revert with 0, 
                                                                    32,
                                                                    42,
                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 627 len 14],
                                                                    uint32(arg3),
                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 645 len 4]
                                                require ext_code.size(arg1)
                                                staticcall arg1.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                depositId++
                                                lockedToken[stor201 + 1].field_0 = arg1
                                                lockedToken[stor201 + 1].field_256 = arg2
                                                lockedToken[stor201 + 1].field_512 = 0
                                                lockedToken[stor201 + 1].field_768 = arg4
                                                lockedToken[stor201 + 1].field_1024 = 0
                                                lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                allDepositIds.length++
                                                stor42D7[stor202.length] = depositId + 1
                                                depositsByWithdrawal[address(arg2)].field_0++
                                                depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                return (depositId + 1)
                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 517] = return_data.size
                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 549 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = 32
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 554] = 32
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 'SafeERC20: low-level call failed'
                                                revert with memory
                                                  from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                            if return_data.size:
                                                require return_data.size >= 32
                                                if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 549]:
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = 32
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 554] = 42
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586 len 42] = 0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565
                                                    revert with memory
                                                      from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                                       len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = this.address
                                            require ext_code.size(arg1)
                                            staticcall arg1.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522 len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = 32
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 554] = 27
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 'SafeMath: addition overflow'
                                                revert with memory
                                                  from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                            depositId++
                                            lockedToken[stor201 + 1].field_0 = arg1
                                            lockedToken[stor201 + 1].field_256 = arg2
                                            lockedToken[stor201 + 1].field_512 = 0
                                            lockedToken[stor201 + 1].field_768 = arg4
                                            lockedToken[stor201 + 1].field_1024 = 0
                                            lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                            allDepositIds.length++
                                            stor42D7[stor202.length] = depositId + 1
                                            depositsByWithdrawal[address(arg2)].field_0++
                                            depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = depositId + 1
                                            return memory
                                              from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32
                                        if msg.value - (0 / 10^uint8(ext_call.return_data[0])) <= 0:
                                            require ext_code.size(arg1)
                                            staticcall arg1.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                revert with 0, 'SafeERC20: call to non-contract'
                                            if not ext_code.hash(arg1):
                                                revert with 0, 'SafeERC20: call to non-contract'
                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 517 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 641 len 4] = uint32(arg3)
                                            call arg1 with:
                                                 gas gas_remaining wei
                                                args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                    require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                    if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                        revert with 0, 
                                                                    32,
                                                                    42,
                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 627 len 14],
                                                                    uint32(arg3),
                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 645 len 4]
                                                require ext_code.size(arg1)
                                                staticcall arg1.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                depositId++
                                                lockedToken[stor201 + 1].field_0 = arg1
                                                lockedToken[stor201 + 1].field_256 = arg2
                                                lockedToken[stor201 + 1].field_512 = 0
                                                lockedToken[stor201 + 1].field_768 = arg4
                                                lockedToken[stor201 + 1].field_1024 = 0
                                                lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                allDepositIds.length++
                                                stor42D7[stor202.length] = depositId + 1
                                                depositsByWithdrawal[address(arg2)].field_0++
                                                depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                return (depositId + 1)
                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 517] = return_data.size
                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 549 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = 32
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 554] = 32
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 'SafeERC20: low-level call failed'
                                                revert with memory
                                                  from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                            if return_data.size:
                                                require return_data.size >= 32
                                                if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 549]:
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = 32
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 554] = 42
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586 len 42] = 0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565
                                                    revert with memory
                                                      from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                                       len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = this.address
                                            require ext_code.size(arg1)
                                            staticcall arg1.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522 len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = 32
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 554] = 27
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 'SafeMath: addition overflow'
                                                revert with memory
                                                  from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                            depositId++
                                            lockedToken[stor201 + 1].field_0 = arg1
                                            lockedToken[stor201 + 1].field_256 = arg2
                                            lockedToken[stor201 + 1].field_512 = 0
                                            lockedToken[stor201 + 1].field_768 = arg4
                                            lockedToken[stor201 + 1].field_1024 = 0
                                            lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                            allDepositIds.length++
                                            stor42D7[stor202.length] = depositId + 1
                                            depositsByWithdrawal[address(arg2)].field_0++
                                            depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = depositId + 1
                                            return memory
                                              from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32
                                        call msg.sender with:
                                           value msg.value - (0 / 10^uint8(ext_call.return_data[0])) wei
                                             gas gas_remaining wei
                                        if not return_data.size:
                                            require ext_code.size(arg1)
                                            staticcall arg1.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                revert with 0, 'SafeERC20: call to non-contract'
                                            if not ext_code.hash(arg1):
                                                revert with 0, 'SafeERC20: call to non-contract'
                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 517 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 641 len 4] = uint32(arg3)
                                            call arg1 with:
                                                 gas gas_remaining wei
                                                args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                    require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                    if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                        revert with 0, 
                                                                    32,
                                                                    42,
                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 627 len 14],
                                                                    uint32(arg3),
                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 645 len 4]
                                                require ext_code.size(arg1)
                                                staticcall arg1.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                depositId++
                                                lockedToken[stor201 + 1].field_0 = arg1
                                                lockedToken[stor201 + 1].field_256 = arg2
                                                lockedToken[stor201 + 1].field_512 = 0
                                                lockedToken[stor201 + 1].field_768 = arg4
                                                lockedToken[stor201 + 1].field_1024 = 0
                                                lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                allDepositIds.length++
                                                stor42D7[stor202.length] = depositId + 1
                                                depositsByWithdrawal[address(arg2)].field_0++
                                                depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                return (depositId + 1)
                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 517] = return_data.size
                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 549 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = 32
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 554] = 32
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 'SafeERC20: low-level call failed'
                                                revert with memory
                                                  from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                            if return_data.size:
                                                require return_data.size >= 32
                                                if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 549]:
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = 32
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 554] = 42
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586 len 42] = 0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565
                                                    revert with memory
                                                      from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                                       len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = this.address
                                            require ext_code.size(arg1)
                                            staticcall arg1.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522 len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = 32
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 554] = 27
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 'SafeMath: addition overflow'
                                                revert with memory
                                                  from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                            depositId++
                                            lockedToken[stor201 + 1].field_0 = arg1
                                            lockedToken[stor201 + 1].field_256 = arg2
                                            lockedToken[stor201 + 1].field_512 = 0
                                            lockedToken[stor201 + 1].field_768 = arg4
                                            lockedToken[stor201 + 1].field_1024 = 0
                                            lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                            allDepositIds.length++
                                            stor42D7[stor202.length] = depositId + 1
                                            depositsByWithdrawal[address(arg2)].field_0++
                                            depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = depositId + 1
                                            return memory
                                              from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32
                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 385] = return_data.size
                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 417 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 390] = this.address
                                        require ext_code.size(arg1)
                                        staticcall arg1.0x70a08231 with:
                                                gas gas_remaining wei
                                               args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 390 len (5 * ceil32(return_data.size)) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 486] = arg3
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        if not ext_code.hash(arg1):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518 len floor32((5 * ceil32(return_data.size)) + 100)] = unknown_0x23b872dd(?????), msg.sender, address(this.address), mem[(32 * _57) + (4 * ceil32(return_data.size)) + 486 len floor32((5 * ceil32(return_data.size)) + 100) - 68]
                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + floor32((5 * ceil32(return_data.size)) + 100) + -((5 * ceil32(return_data.size)) + 100 % 32) + 550 len (5 * ceil32(return_data.size)) + 100 % 32] = mem[(32 * _57) + (4 * ceil32(return_data.size)) + -((5 * ceil32(return_data.size)) + 100 % 32) + floor32((5 * ceil32(return_data.size)) + 100) + 450 len (5 * ceil32(return_data.size)) + 100 % 32]
                                        call arg1.mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522 len (5 * ceil32(return_data.size)) + 96]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 628 len 22]
                                        else:
                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 550 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if return_data.size:
                                                require return_data.size >= 32
                                                if not mem[(32 * _57) + (4 * ceil32(return_data.size)) + 550]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 629 len 22]
                                    else:
                                        if msg.value > 0 / 10^uint8(ext_call.return_data[0]):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 0 / 10^uint8(ext_call.return_data[0]) <= msg.value:
                                            call companyWalletAddress with:
                                               value 0 / 10^uint8(ext_call.return_data[0]) wei
                                                 gas gas_remaining wei
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    revert with 0, 'Fee transfer failed'
                                                if 0 / 10^uint8(ext_call.return_data[0]) > msg.value:
                                                    require ext_code.size(arg1)
                                                    staticcall arg1.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(arg1):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    mem[(32 * _57) + ceil32(return_data.size) + 516 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                    mem[(32 * _57) + ceil32(return_data.size) + 640 len 4] = uint32(arg3)
                                                    call arg1 with:
                                                         gas gas_remaining wei
                                                        args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + 612 len 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                            require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                            if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[(32 * _57) + ceil32(return_data.size) + 626 len 14],
                                                                            uint32(arg3),
                                                                            mem[(32 * _57) + ceil32(return_data.size) + 644 len 4]
                                                    else:
                                                        mem[(32 * _57) + ceil32(return_data.size) + 548 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[(32 * _57) + ceil32(return_data.size) + 548]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 627 len 22]
                                                else:
                                                    if (0 / 10^uint8(ext_call.return_data[0])) - msg.value <= 0:
                                                        require ext_code.size(arg1)
                                                        staticcall arg1.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        if not ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        mem[(32 * _57) + ceil32(return_data.size) + 516 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                        mem[(32 * _57) + ceil32(return_data.size) + 640 len 4] = uint32(arg3)
                                                        call arg1 with:
                                                             gas gas_remaining wei
                                                            args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + 612 len 4]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                revert with 0, 'SafeERC20: low-level call failed'
                                                            if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[(32 * _57) + ceil32(return_data.size) + 626 len 14],
                                                                                uint32(arg3),
                                                                                mem[(32 * _57) + ceil32(return_data.size) + 644 len 4]
                                                        else:
                                                            mem[(32 * _57) + ceil32(return_data.size) + 548 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            if not ext_call.success:
                                                                revert with 0, 'SafeERC20: low-level call failed'
                                                            if return_data.size:
                                                                require return_data.size >= 32
                                                                if not mem[(32 * _57) + ceil32(return_data.size) + 548]:
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 627 len 22]
                                                    else:
                                                        call msg.sender with:
                                                           value (0 / 10^uint8(ext_call.return_data[0])) - msg.value wei
                                                             gas gas_remaining wei
                                                        require ext_code.size(arg1)
                                                        staticcall arg1.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        if not ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        if not return_data.size:
                                                            mem[(32 * _57) + ceil32(return_data.size) + 516 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                            mem[(32 * _57) + ceil32(return_data.size) + 640 len 4] = uint32(arg3)
                                                            call arg1 with:
                                                                 gas gas_remaining wei
                                                                args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + 612 len 4]
                                                            if not return_data.size:
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                    require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                    if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + 626 len 14],
                                                                                    uint32(arg3),
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + 644 len 4]
                                                            else:
                                                                mem[(32 * _57) + ceil32(return_data.size) + 548 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if return_data.size:
                                                                    require return_data.size >= 32
                                                                    if not mem[(32 * _57) + ceil32(return_data.size) + 548]:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 627 len 22]
                                                        else:
                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 517 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 641 len 4] = uint32(arg3)
                                                            call arg1 with:
                                                                 gas gas_remaining wei
                                                                args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len 4]
                                                            if not return_data.size:
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                    require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                    if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 627 len 14],
                                                                                    uint32(arg3),
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 645 len 4]
                                                            else:
                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 549 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if return_data.size:
                                                                    require return_data.size >= 32
                                                                    if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 549]:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 628 len 22]
                                            else:
                                                mem[(32 * _57) + ceil32(return_data.size) + 416 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    revert with 0, 'Fee transfer failed'
                                                if 0 / 10^uint8(ext_call.return_data[0]) > msg.value:
                                                    require ext_code.size(arg1)
                                                    staticcall arg1.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(arg1):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 517 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 641 len 4] = uint32(arg3)
                                                    call arg1 with:
                                                         gas gas_remaining wei
                                                        args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                            require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                            if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 627 len 14],
                                                                            uint32(arg3),
                                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 645 len 4]
                                                    else:
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 549 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 549]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 628 len 22]
                                                else:
                                                    if (0 / 10^uint8(ext_call.return_data[0])) - msg.value <= 0:
                                                        require ext_code.size(arg1)
                                                        staticcall arg1.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        if not ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 517 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 641 len 4] = uint32(arg3)
                                                        call arg1 with:
                                                             gas gas_remaining wei
                                                            args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len 4]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                revert with 0, 'SafeERC20: low-level call failed'
                                                            if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 627 len 14],
                                                                                uint32(arg3),
                                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 645 len 4]
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            depositId++
                                                            lockedToken[stor201 + 1].field_0 = arg1
                                                            lockedToken[stor201 + 1].field_256 = arg2
                                                            lockedToken[stor201 + 1].field_512 = 0
                                                            lockedToken[stor201 + 1].field_768 = arg4
                                                            lockedToken[stor201 + 1].field_1024 = 0
                                                            lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                            allDepositIds.length++
                                                            stor42D7[stor202.length] = depositId + 1
                                                            depositsByWithdrawal[address(arg2)].field_0++
                                                            depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                            return (depositId + 1)
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 517] = return_data.size
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 549 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 554] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 'SafeERC20: low-level call failed'
                                                            revert with memory
                                                              from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 549]:
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = 32
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 554] = 42
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586 len 42] = 0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565
                                                                revert with memory
                                                                  from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = this.address
                                                        require ext_code.size(arg1)
                                                        staticcall arg1.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522 len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 554] = 27
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 'SafeMath: addition overflow'
                                                            revert with memory
                                                              from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                        depositId++
                                                        lockedToken[stor201 + 1].field_0 = arg1
                                                        lockedToken[stor201 + 1].field_256 = arg2
                                                        lockedToken[stor201 + 1].field_512 = 0
                                                        lockedToken[stor201 + 1].field_768 = arg4
                                                        lockedToken[stor201 + 1].field_1024 = 0
                                                        lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                        allDepositIds.length++
                                                        stor42D7[stor202.length] = depositId + 1
                                                        depositsByWithdrawal[address(arg2)].field_0++
                                                        depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = depositId + 1
                                                        return memory
                                                          from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                                           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32
                                                    call msg.sender with:
                                                       value (0 / 10^uint8(ext_call.return_data[0])) - msg.value wei
                                                         gas gas_remaining wei
                                                    if not return_data.size:
                                                        require ext_code.size(arg1)
                                                        staticcall arg1.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        if not ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 517 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 641 len 4] = uint32(arg3)
                                                        call arg1 with:
                                                             gas gas_remaining wei
                                                            args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len 4]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                revert with 0, 'SafeERC20: low-level call failed'
                                                            if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 627 len 14],
                                                                                uint32(arg3),
                                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 645 len 4]
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            depositId++
                                                            lockedToken[stor201 + 1].field_0 = arg1
                                                            lockedToken[stor201 + 1].field_256 = arg2
                                                            lockedToken[stor201 + 1].field_512 = 0
                                                            lockedToken[stor201 + 1].field_768 = arg4
                                                            lockedToken[stor201 + 1].field_1024 = 0
                                                            lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                            allDepositIds.length++
                                                            stor42D7[stor202.length] = depositId + 1
                                                            depositsByWithdrawal[address(arg2)].field_0++
                                                            depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                            return (depositId + 1)
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 517] = return_data.size
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 549 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 554] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 'SafeERC20: low-level call failed'
                                                            revert with memory
                                                              from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 549]:
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = 32
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 554] = 42
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586 len 42] = 0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565
                                                                revert with memory
                                                                  from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = this.address
                                                        require ext_code.size(arg1)
                                                        staticcall arg1.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522 len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 554] = 27
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 'SafeMath: addition overflow'
                                                            revert with memory
                                                              from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                        depositId++
                                                        lockedToken[stor201 + 1].field_0 = arg1
                                                        lockedToken[stor201 + 1].field_256 = arg2
                                                        lockedToken[stor201 + 1].field_512 = 0
                                                        lockedToken[stor201 + 1].field_768 = arg4
                                                        lockedToken[stor201 + 1].field_1024 = 0
                                                        lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                        allDepositIds.length++
                                                        stor42D7[stor202.length] = depositId + 1
                                                        depositsByWithdrawal[address(arg2)].field_0++
                                                        depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = depositId + 1
                                                        return memory
                                                          from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                                           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32
                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 385] = return_data.size
                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 417 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 390] = this.address
                                                    require ext_code.size(arg1)
                                                    staticcall arg1.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 390 len (5 * ceil32(return_data.size)) + 32]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 486] = arg3
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(arg1):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518 len floor32((5 * ceil32(return_data.size)) + 100)] = unknown_0x23b872dd(?????), msg.sender, address(this.address), mem[(32 * _57) + (4 * ceil32(return_data.size)) + 486 len floor32((5 * ceil32(return_data.size)) + 100) - 68]
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + floor32((5 * ceil32(return_data.size)) + 100) + -((5 * ceil32(return_data.size)) + 100 % 32) + 550 len (5 * ceil32(return_data.size)) + 100 % 32] = mem[(32 * _57) + (4 * ceil32(return_data.size)) + -((5 * ceil32(return_data.size)) + 100 % 32) + floor32((5 * ceil32(return_data.size)) + 100) + 450 len (5 * ceil32(return_data.size)) + 100 % 32]
                                                    call arg1.mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522 len (5 * ceil32(return_data.size)) + 96]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                            require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                            if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 628 len 22]
                                                    else:
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 550 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[(32 * _57) + (4 * ceil32(return_data.size)) + 550]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 629 len 22]
                                        else:
                                            if not (0 / 10^uint8(ext_call.return_data[0])) - msg.value:
                                                if not 0 / 10^uint8(ext_call.return_data[0]):
                                                    revert with 0, 'SafeMath: division by zero'
                                                if 0 / 0 / 10^uint8(ext_call.return_data[0]) > 5:
                                                    revert with 0, 'Fee Not Met'
                                                if 0 / 10^uint8(ext_call.return_data[0]) > msg.value:
                                                    call companyWalletAddress with:
                                                       value msg.value wei
                                                         gas gas_remaining wei
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'Fee transfer failed'
                                                        if 0 / 10^uint8(ext_call.return_data[0]) > msg.value:
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                                revert with 0, 'SafeERC20: call to non-contract'
                                                            if not ext_code.hash(arg1):
                                                                revert with 0, 'SafeERC20: call to non-contract'
                                                            mem[(32 * _57) + ceil32(return_data.size) + 580 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                            mem[(32 * _57) + ceil32(return_data.size) + 704 len 4] = uint32(arg3)
                                                            call arg1 with:
                                                                 gas gas_remaining wei
                                                                args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + 676 len 4]
                                                            if not return_data.size:
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                    require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                    if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + 690 len 14],
                                                                                    uint32(arg3),
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + 708 len 4]
                                                            else:
                                                                mem[(32 * _57) + ceil32(return_data.size) + 612 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if return_data.size:
                                                                    require return_data.size >= 32
                                                                    if not mem[(32 * _57) + ceil32(return_data.size) + 612]:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 22]
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            depositId++
                                                            lockedToken[stor201 + 1].field_0 = arg1
                                                            lockedToken[stor201 + 1].field_256 = arg2
                                                            lockedToken[stor201 + 1].field_512 = 0
                                                            lockedToken[stor201 + 1].field_768 = arg4
                                                            lockedToken[stor201 + 1].field_1024 = 0
                                                            lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                            allDepositIds.length++
                                                            stor42D7[stor202.length] = depositId + 1
                                                            depositsByWithdrawal[address(arg2)].field_0++
                                                            depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                            return (depositId + 1)
                                                        if (0 / 10^uint8(ext_call.return_data[0])) - msg.value <= 0:
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                                revert with 0, 'SafeERC20: call to non-contract'
                                                            if not ext_code.hash(arg1):
                                                                revert with 0, 'SafeERC20: call to non-contract'
                                                            mem[(32 * _57) + ceil32(return_data.size) + 580 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                            mem[(32 * _57) + ceil32(return_data.size) + 704 len 4] = uint32(arg3)
                                                            call arg1 with:
                                                                 gas gas_remaining wei
                                                                args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + 676 len 4]
                                                            if not return_data.size:
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                    require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                    if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + 690 len 14],
                                                                                    uint32(arg3),
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + 708 len 4]
                                                            else:
                                                                mem[(32 * _57) + ceil32(return_data.size) + 612 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if return_data.size:
                                                                    require return_data.size >= 32
                                                                    if not mem[(32 * _57) + ceil32(return_data.size) + 612]:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 22]
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            depositId++
                                                            lockedToken[stor201 + 1].field_0 = arg1
                                                            lockedToken[stor201 + 1].field_256 = arg2
                                                            lockedToken[stor201 + 1].field_512 = 0
                                                            lockedToken[stor201 + 1].field_768 = arg4
                                                            lockedToken[stor201 + 1].field_1024 = 0
                                                            lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                            allDepositIds.length++
                                                            stor42D7[stor202.length] = depositId + 1
                                                            depositsByWithdrawal[address(arg2)].field_0++
                                                            depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                            return (depositId + 1)
                                                        call msg.sender with:
                                                           value (0 / 10^uint8(ext_call.return_data[0])) - msg.value wei
                                                             gas gas_remaining wei
                                                        require ext_code.size(arg1)
                                                        staticcall arg1.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        if not ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        if not return_data.size:
                                                            mem[(32 * _57) + ceil32(return_data.size) + 580 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                            mem[(32 * _57) + ceil32(return_data.size) + 704 len 4] = uint32(arg3)
                                                            call arg1 with:
                                                                 gas gas_remaining wei
                                                                args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + 676 len 4]
                                                            if not return_data.size:
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                    require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                    if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + 690 len 14],
                                                                                    uint32(arg3),
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + 708 len 4]
                                                            else:
                                                                mem[(32 * _57) + ceil32(return_data.size) + 612 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if return_data.size:
                                                                    require return_data.size >= 32
                                                                    if not mem[(32 * _57) + ceil32(return_data.size) + 612]:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 22]
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            depositId++
                                                            lockedToken[stor201 + 1].field_0 = arg1
                                                            lockedToken[stor201 + 1].field_256 = arg2
                                                            lockedToken[stor201 + 1].field_512 = 0
                                                            lockedToken[stor201 + 1].field_768 = arg4
                                                            lockedToken[stor201 + 1].field_1024 = 0
                                                            lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                            allDepositIds.length++
                                                            stor42D7[stor202.length] = depositId + 1
                                                            depositsByWithdrawal[address(arg2)].field_0++
                                                            depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                            return (depositId + 1)
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 705 len 4] = uint32(arg3)
                                                        call arg1 with:
                                                             gas gas_remaining wei
                                                            args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 677 len 4]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                revert with 0, 'SafeERC20: low-level call failed'
                                                            if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 14],
                                                                                uint32(arg3),
                                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 709 len 4]
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            depositId++
                                                            lockedToken[stor201 + 1].field_0 = arg1
                                                            lockedToken[stor201 + 1].field_256 = arg2
                                                            lockedToken[stor201 + 1].field_512 = 0
                                                            lockedToken[stor201 + 1].field_768 = arg4
                                                            lockedToken[stor201 + 1].field_1024 = 0
                                                            lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                            allDepositIds.length++
                                                            stor42D7[stor202.length] = depositId + 1
                                                            depositsByWithdrawal[address(arg2)].field_0++
                                                            depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                            return (depositId + 1)
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581] = return_data.size
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650] = 'SafeERC20: low-level call failed'
                                                            revert with memory
                                                              from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613]:
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 42
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650 len 42] = 0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565
                                                                revert with memory
                                                                  from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = this.address
                                                        require ext_code.size(arg1)
                                                        staticcall arg1.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586 len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 27
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650] = 'SafeMath: addition overflow'
                                                            revert with memory
                                                              from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                        depositId++
                                                        lockedToken[stor201 + 1].field_0 = arg1
                                                        lockedToken[stor201 + 1].field_256 = arg2
                                                        lockedToken[stor201 + 1].field_512 = 0
                                                        lockedToken[stor201 + 1].field_768 = arg4
                                                        lockedToken[stor201 + 1].field_1024 = 0
                                                        lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                        allDepositIds.length++
                                                        stor42D7[stor202.length] = depositId + 1
                                                        depositsByWithdrawal[address(arg2)].field_0++
                                                        depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = depositId + 1
                                                        return memory
                                                          from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32
                                                    mem[(32 * _57) + ceil32(return_data.size) + 480 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'Fee transfer failed'
                                                    if 0 / 10^uint8(ext_call.return_data[0]) > msg.value:
                                                        require ext_code.size(arg1)
                                                        staticcall arg1.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        if not ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 705 len 4] = uint32(arg3)
                                                        call arg1 with:
                                                             gas gas_remaining wei
                                                            args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 677 len 4]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                revert with 0, 'SafeERC20: low-level call failed'
                                                            if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 14],
                                                                                uint32(arg3),
                                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 709 len 4]
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            depositId++
                                                            lockedToken[stor201 + 1].field_0 = arg1
                                                            lockedToken[stor201 + 1].field_256 = arg2
                                                            lockedToken[stor201 + 1].field_512 = 0
                                                            lockedToken[stor201 + 1].field_768 = arg4
                                                            lockedToken[stor201 + 1].field_1024 = 0
                                                            lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                            allDepositIds.length++
                                                            stor42D7[stor202.length] = depositId + 1
                                                            depositsByWithdrawal[address(arg2)].field_0++
                                                            depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                            return (depositId + 1)
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581] = return_data.size
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650] = 'SafeERC20: low-level call failed'
                                                            revert with memory
                                                              from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613]:
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 42
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650 len 42] = 0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565
                                                                revert with memory
                                                                  from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = this.address
                                                        require ext_code.size(arg1)
                                                        staticcall arg1.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586 len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 27
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650] = 'SafeMath: addition overflow'
                                                            revert with memory
                                                              from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                        depositId++
                                                        lockedToken[stor201 + 1].field_0 = arg1
                                                        lockedToken[stor201 + 1].field_256 = arg2
                                                        lockedToken[stor201 + 1].field_512 = 0
                                                        lockedToken[stor201 + 1].field_768 = arg4
                                                        lockedToken[stor201 + 1].field_1024 = 0
                                                        lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                        allDepositIds.length++
                                                        stor42D7[stor202.length] = depositId + 1
                                                        depositsByWithdrawal[address(arg2)].field_0++
                                                        depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = depositId + 1
                                                        return memory
                                                          from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32
                                                    if (0 / 10^uint8(ext_call.return_data[0])) - msg.value <= 0:
                                                        require ext_code.size(arg1)
                                                        staticcall arg1.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        if not ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 705 len 4] = uint32(arg3)
                                                        call arg1 with:
                                                             gas gas_remaining wei
                                                            args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 677 len 4]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                revert with 0, 'SafeERC20: low-level call failed'
                                                            if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 14],
                                                                                uint32(arg3),
                                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 709 len 4]
                                                        else:
                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            if not ext_call.success:
                                                                revert with 0, 'SafeERC20: low-level call failed'
                                                            if return_data.size:
                                                                require return_data.size >= 32
                                                                if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613]:
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 692 len 22]
                                                    else:
                                                        call msg.sender with:
                                                           value (0 / 10^uint8(ext_call.return_data[0])) - msg.value wei
                                                             gas gas_remaining wei
                                                        if not return_data.size:
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                                revert with 0, 'SafeERC20: call to non-contract'
                                                            if not ext_code.hash(arg1):
                                                                revert with 0, 'SafeERC20: call to non-contract'
                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 705 len 4] = uint32(arg3)
                                                            call arg1 with:
                                                                 gas gas_remaining wei
                                                                args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 677 len 4]
                                                            if not return_data.size:
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                    require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                    if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 14],
                                                                                    uint32(arg3),
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 709 len 4]
                                                                require ext_code.size(arg1)
                                                                staticcall arg1.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args this.address
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                require return_data.size >= 32
                                                                if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                depositId++
                                                                lockedToken[stor201 + 1].field_0 = arg1
                                                                lockedToken[stor201 + 1].field_256 = arg2
                                                                lockedToken[stor201 + 1].field_512 = 0
                                                                lockedToken[stor201 + 1].field_768 = arg4
                                                                lockedToken[stor201 + 1].field_1024 = 0
                                                                lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                                allDepositIds.length++
                                                                stor42D7[stor202.length] = depositId + 1
                                                                depositsByWithdrawal[address(arg2)].field_0++
                                                                depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                                return (depositId + 1)
                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581] = return_data.size
                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            if not ext_call.success:
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 32
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650] = 'SafeERC20: low-level call failed'
                                                                revert with memory
                                                                  from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                            if return_data.size:
                                                                require return_data.size >= 32
                                                                if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613]:
                                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 42
                                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650 len 42] = 0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565
                                                                    revert with memory
                                                                      from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                                       len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = this.address
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586 len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 27
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650] = 'SafeMath: addition overflow'
                                                                revert with memory
                                                                  from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                            depositId++
                                                            lockedToken[stor201 + 1].field_0 = arg1
                                                            lockedToken[stor201 + 1].field_256 = arg2
                                                            lockedToken[stor201 + 1].field_512 = 0
                                                            lockedToken[stor201 + 1].field_768 = arg4
                                                            lockedToken[stor201 + 1].field_1024 = 0
                                                            lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                            allDepositIds.length++
                                                            stor42D7[stor202.length] = depositId + 1
                                                            depositsByWithdrawal[address(arg2)].field_0++
                                                            depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = depositId + 1
                                                            return memory
                                                              from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 449] = return_data.size
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 481 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 454] = this.address
                                                        require ext_code.size(arg1)
                                                        staticcall arg1.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 454 len (5 * ceil32(return_data.size)) + 32]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 550] = arg3
                                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        if not ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582 len floor32((5 * ceil32(return_data.size)) + 100)] = unknown_0x23b872dd(?????), msg.sender, address(this.address), mem[(32 * _57) + (4 * ceil32(return_data.size)) + 550 len floor32((5 * ceil32(return_data.size)) + 100) - 68]
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + floor32((5 * ceil32(return_data.size)) + 100) + -((5 * ceil32(return_data.size)) + 100 % 32) + 614 len (5 * ceil32(return_data.size)) + 100 % 32] = mem[(32 * _57) + (4 * ceil32(return_data.size)) + -((5 * ceil32(return_data.size)) + 100 % 32) + floor32((5 * ceil32(return_data.size)) + 100) + 514 len (5 * ceil32(return_data.size)) + 100 % 32]
                                                        call arg1.mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582 len 4] with:
                                                             gas gas_remaining wei
                                                            args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586 len (5 * ceil32(return_data.size)) + 96]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                revert with 0, 'SafeERC20: low-level call failed'
                                                            if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 692 len 22]
                                                        else:
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 614 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            if not ext_call.success:
                                                                revert with 0, 'SafeERC20: low-level call failed'
                                                            if return_data.size:
                                                                require return_data.size >= 32
                                                                if not mem[(32 * _57) + (4 * ceil32(return_data.size)) + 614]:
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 693 len 22]
                                                else:
                                                    call companyWalletAddress with:
                                                       value 0 / 10^uint8(ext_call.return_data[0]) wei
                                                         gas gas_remaining wei
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'Fee transfer failed'
                                                        if 0 / 10^uint8(ext_call.return_data[0]) > msg.value:
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                                revert with 0, 'SafeERC20: call to non-contract'
                                                            if not ext_code.hash(arg1):
                                                                revert with 0, 'SafeERC20: call to non-contract'
                                                            mem[(32 * _57) + ceil32(return_data.size) + 580 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                            mem[(32 * _57) + ceil32(return_data.size) + 704 len 4] = uint32(arg3)
                                                            call arg1 with:
                                                                 gas gas_remaining wei
                                                                args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + 676 len 4]
                                                            if not return_data.size:
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                    require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                    if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + 690 len 14],
                                                                                    uint32(arg3),
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + 708 len 4]
                                                            else:
                                                                mem[(32 * _57) + ceil32(return_data.size) + 612 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if return_data.size:
                                                                    require return_data.size >= 32
                                                                    if not mem[(32 * _57) + ceil32(return_data.size) + 612]:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 22]
                                                        else:
                                                            if (0 / 10^uint8(ext_call.return_data[0])) - msg.value <= 0:
                                                                require ext_code.size(arg1)
                                                                staticcall arg1.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args this.address
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                require return_data.size >= 32
                                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                                if not ext_code.hash(arg1):
                                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                                mem[(32 * _57) + ceil32(return_data.size) + 580 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                                mem[(32 * _57) + ceil32(return_data.size) + 704 len 4] = uint32(arg3)
                                                                call arg1 with:
                                                                     gas gas_remaining wei
                                                                    args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + 676 len 4]
                                                                if not return_data.size:
                                                                    if not ext_call.success:
                                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                                    if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                        require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                        if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                            revert with 0, 
                                                                                        32,
                                                                                        42,
                                                                                        0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                        mem[(32 * _57) + ceil32(return_data.size) + 690 len 14],
                                                                                        uint32(arg3),
                                                                                        mem[(32 * _57) + ceil32(return_data.size) + 708 len 4]
                                                                else:
                                                                    mem[(32 * _57) + ceil32(return_data.size) + 612 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    if not ext_call.success:
                                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                                    if return_data.size:
                                                                        require return_data.size >= 32
                                                                        if not mem[(32 * _57) + ceil32(return_data.size) + 612]:
                                                                            revert with 0, 
                                                                                        32,
                                                                                        42,
                                                                                        0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 22]
                                                            else:
                                                                call msg.sender with:
                                                                   value (0 / 10^uint8(ext_call.return_data[0])) - msg.value wei
                                                                     gas gas_remaining wei
                                                                require ext_code.size(arg1)
                                                                staticcall arg1.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args this.address
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                require return_data.size >= 32
                                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                                if not ext_code.hash(arg1):
                                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                                if not return_data.size:
                                                                    mem[(32 * _57) + ceil32(return_data.size) + 580 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                                    mem[(32 * _57) + ceil32(return_data.size) + 704 len 4] = uint32(arg3)
                                                                    call arg1 with:
                                                                         gas gas_remaining wei
                                                                        args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + 676 len 4]
                                                                    if not return_data.size:
                                                                        if not ext_call.success:
                                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                                        if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                            require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                            if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                                revert with 0, 
                                                                                            32,
                                                                                            42,
                                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                            mem[(32 * _57) + ceil32(return_data.size) + 690 len 14],
                                                                                            uint32(arg3),
                                                                                            mem[(32 * _57) + ceil32(return_data.size) + 708 len 4]
                                                                    else:
                                                                        mem[(32 * _57) + ceil32(return_data.size) + 612 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                        if not ext_call.success:
                                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                                        if return_data.size:
                                                                            require return_data.size >= 32
                                                                            if not mem[(32 * _57) + ceil32(return_data.size) + 612]:
                                                                                revert with 0, 
                                                                                            32,
                                                                                            42,
                                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 22]
                                                                else:
                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 705 len 4] = uint32(arg3)
                                                                    call arg1 with:
                                                                         gas gas_remaining wei
                                                                        args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 677 len 4]
                                                                    if not return_data.size:
                                                                        if not ext_call.success:
                                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                                        if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                            require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                            if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                                revert with 0, 
                                                                                            32,
                                                                                            42,
                                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 14],
                                                                                            uint32(arg3),
                                                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 709 len 4]
                                                                    else:
                                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                        if not ext_call.success:
                                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                                        if return_data.size:
                                                                            require return_data.size >= 32
                                                                            if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613]:
                                                                                revert with 0, 
                                                                                            32,
                                                                                            42,
                                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 692 len 22]
                                                    else:
                                                        mem[(32 * _57) + ceil32(return_data.size) + 480 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'Fee transfer failed'
                                                        if 0 / 10^uint8(ext_call.return_data[0]) > msg.value:
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                                revert with 0, 'SafeERC20: call to non-contract'
                                                            if not ext_code.hash(arg1):
                                                                revert with 0, 'SafeERC20: call to non-contract'
                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 705 len 4] = uint32(arg3)
                                                            call arg1 with:
                                                                 gas gas_remaining wei
                                                                args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 677 len 4]
                                                            if not return_data.size:
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                    require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                    if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 14],
                                                                                    uint32(arg3),
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 709 len 4]
                                                            else:
                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if return_data.size:
                                                                    require return_data.size >= 32
                                                                    if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613]:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 692 len 22]
                                                        else:
                                                            if (0 / 10^uint8(ext_call.return_data[0])) - msg.value <= 0:
                                                                require ext_code.size(arg1)
                                                                staticcall arg1.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args this.address
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                require return_data.size >= 32
                                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                                if not ext_code.hash(arg1):
                                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 705 len 4] = uint32(arg3)
                                                                call arg1 with:
                                                                     gas gas_remaining wei
                                                                    args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 677 len 4]
                                                                if not return_data.size:
                                                                    if not ext_call.success:
                                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                                    if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                        require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                        if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                            revert with 0, 
                                                                                        32,
                                                                                        42,
                                                                                        0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 14],
                                                                                        uint32(arg3),
                                                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 709 len 4]
                                                                else:
                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    if not ext_call.success:
                                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                                    if return_data.size:
                                                                        require return_data.size >= 32
                                                                        if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613]:
                                                                            revert with 0, 
                                                                                        32,
                                                                                        42,
                                                                                        0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 692 len 22]
                                                            else:
                                                                call msg.sender with:
                                                                   value (0 / 10^uint8(ext_call.return_data[0])) - msg.value wei
                                                                     gas gas_remaining wei
                                                                if not return_data.size:
                                                                    require ext_code.size(arg1)
                                                                    staticcall arg1.0x70a08231 with:
                                                                            gas gas_remaining wei
                                                                           args this.address
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    require return_data.size >= 32
                                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                                    if not ext_code.hash(arg1):
                                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 705 len 4] = uint32(arg3)
                                                                    call arg1 with:
                                                                         gas gas_remaining wei
                                                                        args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 677 len 4]
                                                                    if not return_data.size:
                                                                        if not ext_call.success:
                                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                                        if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                            require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                            if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                                revert with 0, 
                                                                                            32,
                                                                                            42,
                                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 14],
                                                                                            uint32(arg3),
                                                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 709 len 4]
                                                                    else:
                                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                        if not ext_call.success:
                                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                                        if return_data.size:
                                                                            require return_data.size >= 32
                                                                            if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613]:
                                                                                revert with 0, 
                                                                                            32,
                                                                                            42,
                                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 692 len 22]
                                                                else:
                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 449] = return_data.size
                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 481 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 454] = this.address
                                                                    require ext_code.size(arg1)
                                                                    staticcall arg1.0x70a08231 with:
                                                                            gas gas_remaining wei
                                                                           args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 454 len (5 * ceil32(return_data.size)) + 32]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    require return_data.size >= 32
                                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 550] = arg3
                                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                                    if not ext_code.hash(arg1):
                                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582 len floor32((5 * ceil32(return_data.size)) + 100)] = unknown_0x23b872dd(?????), msg.sender, address(this.address), mem[(32 * _57) + (4 * ceil32(return_data.size)) + 550 len floor32((5 * ceil32(return_data.size)) + 100) - 68]
                                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + floor32((5 * ceil32(return_data.size)) + 100) + -((5 * ceil32(return_data.size)) + 100 % 32) + 614 len (5 * ceil32(return_data.size)) + 100 % 32] = mem[(32 * _57) + (4 * ceil32(return_data.size)) + -((5 * ceil32(return_data.size)) + 100 % 32) + floor32((5 * ceil32(return_data.size)) + 100) + 514 len (5 * ceil32(return_data.size)) + 100 % 32]
                                                                    call arg1.mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582 len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586 len (5 * ceil32(return_data.size)) + 96]
                                                                    if not return_data.size:
                                                                        if not ext_call.success:
                                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                                        if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                            require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                            if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                                revert with 0, 
                                                                                            32,
                                                                                            42,
                                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 692 len 22]
                                                                    else:
                                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 614 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                        if not ext_call.success:
                                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                                        if return_data.size:
                                                                            require return_data.size >= 32
                                                                            if not mem[(32 * _57) + (4 * ceil32(return_data.size)) + 614]:
                                                                                revert with 0, 
                                                                                            32,
                                                                                            42,
                                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 693 len 22]
                                            else:
                                                if (100 * 0 / 10^uint8(ext_call.return_data[0])) - (100 * msg.value) / (0 / 10^uint8(ext_call.return_data[0])) - msg.value != 100:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _57) + ceil32(return_data.size) + 485 len 31]
                                                if not 0 / 10^uint8(ext_call.return_data[0]):
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (100 * 0 / 10^uint8(ext_call.return_data[0])) - (100 * msg.value) / 0 / 10^uint8(ext_call.return_data[0]) > 5:
                                                    revert with 0, 'Fee Not Met'
                                                if 0 / 10^uint8(ext_call.return_data[0]) > msg.value:
                                                    call companyWalletAddress with:
                                                       value msg.value wei
                                                         gas gas_remaining wei
                                                else:
                                                    call companyWalletAddress with:
                                                       value 0 / 10^uint8(ext_call.return_data[0]) wei
                                                         gas gas_remaining wei
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'Fee transfer failed'
                                                    if 0 / 10^uint8(ext_call.return_data[0]) > msg.value:
                                                        require ext_code.size(arg1)
                                                        staticcall arg1.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        if not ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        mem[(32 * _57) + ceil32(return_data.size) + 580 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                        mem[(32 * _57) + ceil32(return_data.size) + 704 len 4] = uint32(arg3)
                                                        call arg1 with:
                                                             gas gas_remaining wei
                                                            args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + 676 len 4]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                revert with 0, 'SafeERC20: low-level call failed'
                                                            if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[(32 * _57) + ceil32(return_data.size) + 690 len 14],
                                                                                uint32(arg3),
                                                                                mem[(32 * _57) + ceil32(return_data.size) + 708 len 4]
                                                        else:
                                                            mem[(32 * _57) + ceil32(return_data.size) + 612 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            if not ext_call.success:
                                                                revert with 0, 'SafeERC20: low-level call failed'
                                                            if return_data.size:
                                                                require return_data.size >= 32
                                                                if not mem[(32 * _57) + ceil32(return_data.size) + 612]:
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 22]
                                                        require ext_code.size(arg1)
                                                        staticcall arg1.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        depositId++
                                                        lockedToken[stor201 + 1].field_0 = arg1
                                                        lockedToken[stor201 + 1].field_256 = arg2
                                                        lockedToken[stor201 + 1].field_512 = 0
                                                        lockedToken[stor201 + 1].field_768 = arg4
                                                        lockedToken[stor201 + 1].field_1024 = 0
                                                        lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                        allDepositIds.length++
                                                        stor42D7[stor202.length] = depositId + 1
                                                        depositsByWithdrawal[address(arg2)].field_0++
                                                        depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                        return (depositId + 1)
                                                    if (0 / 10^uint8(ext_call.return_data[0])) - msg.value <= 0:
                                                        require ext_code.size(arg1)
                                                        staticcall arg1.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        if not ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        mem[(32 * _57) + ceil32(return_data.size) + 580 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                        mem[(32 * _57) + ceil32(return_data.size) + 704 len 4] = uint32(arg3)
                                                        call arg1 with:
                                                             gas gas_remaining wei
                                                            args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + 676 len 4]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                revert with 0, 'SafeERC20: low-level call failed'
                                                            if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[(32 * _57) + ceil32(return_data.size) + 690 len 14],
                                                                                uint32(arg3),
                                                                                mem[(32 * _57) + ceil32(return_data.size) + 708 len 4]
                                                        else:
                                                            mem[(32 * _57) + ceil32(return_data.size) + 612 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            if not ext_call.success:
                                                                revert with 0, 'SafeERC20: low-level call failed'
                                                            if return_data.size:
                                                                require return_data.size >= 32
                                                                if not mem[(32 * _57) + ceil32(return_data.size) + 612]:
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 22]
                                                        require ext_code.size(arg1)
                                                        staticcall arg1.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        depositId++
                                                        lockedToken[stor201 + 1].field_0 = arg1
                                                        lockedToken[stor201 + 1].field_256 = arg2
                                                        lockedToken[stor201 + 1].field_512 = 0
                                                        lockedToken[stor201 + 1].field_768 = arg4
                                                        lockedToken[stor201 + 1].field_1024 = 0
                                                        lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                        allDepositIds.length++
                                                        stor42D7[stor202.length] = depositId + 1
                                                        depositsByWithdrawal[address(arg2)].field_0++
                                                        depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                        return (depositId + 1)
                                                    call msg.sender with:
                                                       value (0 / 10^uint8(ext_call.return_data[0])) - msg.value wei
                                                         gas gas_remaining wei
                                                    require ext_code.size(arg1)
                                                    staticcall arg1.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(arg1):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not return_data.size:
                                                        mem[(32 * _57) + ceil32(return_data.size) + 580 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                        mem[(32 * _57) + ceil32(return_data.size) + 704 len 4] = uint32(arg3)
                                                        call arg1 with:
                                                             gas gas_remaining wei
                                                            args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + 676 len 4]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                revert with 0, 'SafeERC20: low-level call failed'
                                                            if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[(32 * _57) + ceil32(return_data.size) + 690 len 14],
                                                                                uint32(arg3),
                                                                                mem[(32 * _57) + ceil32(return_data.size) + 708 len 4]
                                                        else:
                                                            mem[(32 * _57) + ceil32(return_data.size) + 612 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            if not ext_call.success:
                                                                revert with 0, 'SafeERC20: low-level call failed'
                                                            if return_data.size:
                                                                require return_data.size >= 32
                                                                if not mem[(32 * _57) + ceil32(return_data.size) + 612]:
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 22]
                                                        require ext_code.size(arg1)
                                                        staticcall arg1.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        depositId++
                                                        lockedToken[stor201 + 1].field_0 = arg1
                                                        lockedToken[stor201 + 1].field_256 = arg2
                                                        lockedToken[stor201 + 1].field_512 = 0
                                                        lockedToken[stor201 + 1].field_768 = arg4
                                                        lockedToken[stor201 + 1].field_1024 = 0
                                                        lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                        allDepositIds.length++
                                                        stor42D7[stor202.length] = depositId + 1
                                                        depositsByWithdrawal[address(arg2)].field_0++
                                                        depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                        return (depositId + 1)
                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 705 len 4] = uint32(arg3)
                                                    call arg1 with:
                                                         gas gas_remaining wei
                                                        args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 677 len 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                            require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                            if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 14],
                                                                            uint32(arg3),
                                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 709 len 4]
                                                        require ext_code.size(arg1)
                                                        staticcall arg1.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        depositId++
                                                        lockedToken[stor201 + 1].field_0 = arg1
                                                        lockedToken[stor201 + 1].field_256 = arg2
                                                        lockedToken[stor201 + 1].field_512 = 0
                                                        lockedToken[stor201 + 1].field_768 = arg4
                                                        lockedToken[stor201 + 1].field_1024 = 0
                                                        lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                        allDepositIds.length++
                                                        stor42D7[stor202.length] = depositId + 1
                                                        depositsByWithdrawal[address(arg2)].field_0++
                                                        depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                        return (depositId + 1)
                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581] = return_data.size
                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 32
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650] = 'SafeERC20: low-level call failed'
                                                        revert with memory
                                                          from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613]:
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 42
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650 len 42] = 0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565
                                                            revert with memory
                                                              from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = this.address
                                                    require ext_code.size(arg1)
                                                    staticcall arg1.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586 len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 27
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650] = 'SafeMath: addition overflow'
                                                        revert with memory
                                                          from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                    depositId++
                                                    lockedToken[stor201 + 1].field_0 = arg1
                                                    lockedToken[stor201 + 1].field_256 = arg2
                                                    lockedToken[stor201 + 1].field_512 = 0
                                                    lockedToken[stor201 + 1].field_768 = arg4
                                                    lockedToken[stor201 + 1].field_1024 = 0
                                                    lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                    allDepositIds.length++
                                                    stor42D7[stor202.length] = depositId + 1
                                                    depositsByWithdrawal[address(arg2)].field_0++
                                                    depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = depositId + 1
                                                    return memory
                                                      from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                       len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32
                                                mem[(32 * _57) + ceil32(return_data.size) + 480 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    revert with 0, 'Fee transfer failed'
                                                if 0 / 10^uint8(ext_call.return_data[0]) > msg.value:
                                                    require ext_code.size(arg1)
                                                    staticcall arg1.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(arg1):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 705 len 4] = uint32(arg3)
                                                    call arg1 with:
                                                         gas gas_remaining wei
                                                        args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 677 len 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                            require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                            if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 14],
                                                                            uint32(arg3),
                                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 709 len 4]
                                                        require ext_code.size(arg1)
                                                        staticcall arg1.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        depositId++
                                                        lockedToken[stor201 + 1].field_0 = arg1
                                                        lockedToken[stor201 + 1].field_256 = arg2
                                                        lockedToken[stor201 + 1].field_512 = 0
                                                        lockedToken[stor201 + 1].field_768 = arg4
                                                        lockedToken[stor201 + 1].field_1024 = 0
                                                        lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                        allDepositIds.length++
                                                        stor42D7[stor202.length] = depositId + 1
                                                        depositsByWithdrawal[address(arg2)].field_0++
                                                        depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                        return (depositId + 1)
                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581] = return_data.size
                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 32
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650] = 'SafeERC20: low-level call failed'
                                                        revert with memory
                                                          from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613]:
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 42
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650 len 42] = 0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565
                                                            revert with memory
                                                              from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = this.address
                                                    require ext_code.size(arg1)
                                                    staticcall arg1.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586 len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 27
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650] = 'SafeMath: addition overflow'
                                                        revert with memory
                                                          from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                    depositId++
                                                    lockedToken[stor201 + 1].field_0 = arg1
                                                    lockedToken[stor201 + 1].field_256 = arg2
                                                    lockedToken[stor201 + 1].field_512 = 0
                                                    lockedToken[stor201 + 1].field_768 = arg4
                                                    lockedToken[stor201 + 1].field_1024 = 0
                                                    lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                    allDepositIds.length++
                                                    stor42D7[stor202.length] = depositId + 1
                                                    depositsByWithdrawal[address(arg2)].field_0++
                                                    depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = depositId + 1
                                                    return memory
                                                      from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                       len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32
                                                if (0 / 10^uint8(ext_call.return_data[0])) - msg.value <= 0:
                                                    require ext_code.size(arg1)
                                                    staticcall arg1.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(arg1):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 705 len 4] = uint32(arg3)
                                                    call arg1 with:
                                                         gas gas_remaining wei
                                                        args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 677 len 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                            require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                            if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 14],
                                                                            uint32(arg3),
                                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 709 len 4]
                                                    else:
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 692 len 22]
                                                else:
                                                    call msg.sender with:
                                                       value (0 / 10^uint8(ext_call.return_data[0])) - msg.value wei
                                                         gas gas_remaining wei
                                                    if not return_data.size:
                                                        require ext_code.size(arg1)
                                                        staticcall arg1.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        if not ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 705 len 4] = uint32(arg3)
                                                        call arg1 with:
                                                             gas gas_remaining wei
                                                            args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 677 len 4]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                revert with 0, 'SafeERC20: low-level call failed'
                                                            if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 14],
                                                                                uint32(arg3),
                                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 709 len 4]
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            depositId++
                                                            lockedToken[stor201 + 1].field_0 = arg1
                                                            lockedToken[stor201 + 1].field_256 = arg2
                                                            lockedToken[stor201 + 1].field_512 = 0
                                                            lockedToken[stor201 + 1].field_768 = arg4
                                                            lockedToken[stor201 + 1].field_1024 = 0
                                                            lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                            allDepositIds.length++
                                                            stor42D7[stor202.length] = depositId + 1
                                                            depositsByWithdrawal[address(arg2)].field_0++
                                                            depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                            return (depositId + 1)
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581] = return_data.size
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650] = 'SafeERC20: low-level call failed'
                                                            revert with memory
                                                              from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613]:
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 42
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650 len 42] = 0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565
                                                                revert with memory
                                                                  from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = this.address
                                                        require ext_code.size(arg1)
                                                        staticcall arg1.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586 len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 27
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650] = 'SafeMath: addition overflow'
                                                            revert with memory
                                                              from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                        depositId++
                                                        lockedToken[stor201 + 1].field_0 = arg1
                                                        lockedToken[stor201 + 1].field_256 = arg2
                                                        lockedToken[stor201 + 1].field_512 = 0
                                                        lockedToken[stor201 + 1].field_768 = arg4
                                                        lockedToken[stor201 + 1].field_1024 = 0
                                                        lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                        allDepositIds.length++
                                                        stor42D7[stor202.length] = depositId + 1
                                                        depositsByWithdrawal[address(arg2)].field_0++
                                                        depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = depositId + 1
                                                        return memory
                                                          from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32
                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 449] = return_data.size
                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 481 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 454] = this.address
                                                    require ext_code.size(arg1)
                                                    staticcall arg1.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 454 len (5 * ceil32(return_data.size)) + 32]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 550] = arg3
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(arg1):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582 len floor32((5 * ceil32(return_data.size)) + 100)] = unknown_0x23b872dd(?????), msg.sender, address(this.address), mem[(32 * _57) + (4 * ceil32(return_data.size)) + 550 len floor32((5 * ceil32(return_data.size)) + 100) - 68]
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + floor32((5 * ceil32(return_data.size)) + 100) + -((5 * ceil32(return_data.size)) + 100 % 32) + 614 len (5 * ceil32(return_data.size)) + 100 % 32] = mem[(32 * _57) + (4 * ceil32(return_data.size)) + -((5 * ceil32(return_data.size)) + 100 % 32) + floor32((5 * ceil32(return_data.size)) + 100) + 514 len (5 * ceil32(return_data.size)) + 100 % 32]
                                                    call arg1.mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586 len (5 * ceil32(return_data.size)) + 96]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                            require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                            if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 692 len 22]
                                                    else:
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 614 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[(32 * _57) + (4 * ceil32(return_data.size)) + 614]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 693 len 22]
                            else:
                                if mem[ceil32(return_data.size) + 128] * sub_aa182aef / sub_aa182aef != mem[ceil32(return_data.size) + 128]:
                                    revert with 0, 
                                                32,
                                                33,
                                                0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[(32 * _57) + ceil32(return_data.size) + 357 len 31]
                                if not 10^uint8(ext_call.return_data[0]):
                                    revert with 0, 'SafeMath: division by zero'
                                if not mem[ceil32(return_data.size) + 128] * sub_aa182aef / 10^uint8(ext_call.return_data[0]):
                                    require ext_code.size(arg1)
                                    staticcall arg1.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                        revert with 0, 'SafeERC20: call to non-contract'
                                    if not ext_code.hash(arg1):
                                        revert with 0, 'SafeERC20: call to non-contract'
                                    mem[(32 * _57) + ceil32(return_data.size) + 452 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                    mem[(32 * _57) + ceil32(return_data.size) + 576 len 4] = uint32(arg3)
                                    call arg1 with:
                                         gas gas_remaining wei
                                        args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + 548 len 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                            require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                            if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[(32 * _57) + ceil32(return_data.size) + 562 len 14],
                                                            uint32(arg3),
                                                            mem[(32 * _57) + ceil32(return_data.size) + 580 len 4]
                                    else:
                                        mem[(32 * _57) + ceil32(return_data.size) + 484 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if return_data.size:
                                            require return_data.size >= 32
                                            if not mem[(32 * _57) + ceil32(return_data.size) + 484]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 563 len 22]
                                else:
                                    if mem[ceil32(return_data.size) + 128] * sub_aa182aef / 10^uint8(ext_call.return_data[0]) <= msg.value:
                                        call companyWalletAddress with:
                                           value mem[ceil32(return_data.size) + 128] * sub_aa182aef / 10^uint8(ext_call.return_data[0]) wei
                                             gas gas_remaining wei
                                        if not return_data.size:
                                            if not ext_call.success:
                                                revert with 0, 'Fee transfer failed'
                                            if mem[ceil32(return_data.size) + 128] * sub_aa182aef / 10^uint8(ext_call.return_data[0]) > msg.value:
                                                require ext_code.size(arg1)
                                                staticcall arg1.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(arg1):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                mem[(32 * _57) + ceil32(return_data.size) + 516 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                mem[(32 * _57) + ceil32(return_data.size) + 640 len 4] = uint32(arg3)
                                                call arg1 with:
                                                     gas gas_remaining wei
                                                    args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + 612 len 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                        require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                        if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[(32 * _57) + ceil32(return_data.size) + 626 len 14],
                                                                        uint32(arg3),
                                                                        mem[(32 * _57) + ceil32(return_data.size) + 644 len 4]
                                                else:
                                                    mem[(32 * _57) + ceil32(return_data.size) + 548 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[(32 * _57) + ceil32(return_data.size) + 548]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 627 len 22]
                                            else:
                                                if msg.value - (mem[ceil32(return_data.size) + 128] * sub_aa182aef / 10^uint8(ext_call.return_data[0])) <= 0:
                                                    require ext_code.size(arg1)
                                                    staticcall arg1.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(arg1):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    mem[(32 * _57) + ceil32(return_data.size) + 516 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                    mem[(32 * _57) + ceil32(return_data.size) + 640 len 4] = uint32(arg3)
                                                    call arg1 with:
                                                         gas gas_remaining wei
                                                        args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + 612 len 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                            require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                            if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[(32 * _57) + ceil32(return_data.size) + 626 len 14],
                                                                            uint32(arg3),
                                                                            mem[(32 * _57) + ceil32(return_data.size) + 644 len 4]
                                                    else:
                                                        mem[(32 * _57) + ceil32(return_data.size) + 548 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[(32 * _57) + ceil32(return_data.size) + 548]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 627 len 22]
                                                else:
                                                    call msg.sender with:
                                                       value msg.value - (mem[ceil32(return_data.size) + 128] * sub_aa182aef / 10^uint8(ext_call.return_data[0])) wei
                                                         gas gas_remaining wei
                                                    require ext_code.size(arg1)
                                                    staticcall arg1.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(arg1):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not return_data.size:
                                                        mem[(32 * _57) + ceil32(return_data.size) + 516 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                        mem[(32 * _57) + ceil32(return_data.size) + 640 len 4] = uint32(arg3)
                                                        call arg1 with:
                                                             gas gas_remaining wei
                                                            args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + 612 len 4]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                revert with 0, 'SafeERC20: low-level call failed'
                                                            if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[(32 * _57) + ceil32(return_data.size) + 626 len 14],
                                                                                uint32(arg3),
                                                                                mem[(32 * _57) + ceil32(return_data.size) + 644 len 4]
                                                        else:
                                                            mem[(32 * _57) + ceil32(return_data.size) + 548 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            if not ext_call.success:
                                                                revert with 0, 'SafeERC20: low-level call failed'
                                                            if return_data.size:
                                                                require return_data.size >= 32
                                                                if not mem[(32 * _57) + ceil32(return_data.size) + 548]:
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 627 len 22]
                                                    else:
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 517 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 641 len 4] = uint32(arg3)
                                                        call arg1 with:
                                                             gas gas_remaining wei
                                                            args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len 4]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                revert with 0, 'SafeERC20: low-level call failed'
                                                            if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 627 len 14],
                                                                                uint32(arg3),
                                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 645 len 4]
                                                        else:
                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 549 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            if not ext_call.success:
                                                                revert with 0, 'SafeERC20: low-level call failed'
                                                            if return_data.size:
                                                                require return_data.size >= 32
                                                                if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 549]:
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 628 len 22]
                                        else:
                                            mem[(32 * _57) + ceil32(return_data.size) + 416 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                revert with 0, 'Fee transfer failed'
                                            if mem[ceil32(return_data.size) + 128] * sub_aa182aef / 10^uint8(ext_call.return_data[0]) > msg.value:
                                                require ext_code.size(arg1)
                                                staticcall arg1.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(arg1):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 517 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 641 len 4] = uint32(arg3)
                                                call arg1 with:
                                                     gas gas_remaining wei
                                                    args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                        require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                        if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 627 len 14],
                                                                        uint32(arg3),
                                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 645 len 4]
                                                    require ext_code.size(arg1)
                                                    staticcall arg1.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    depositId++
                                                    lockedToken[stor201 + 1].field_0 = arg1
                                                    lockedToken[stor201 + 1].field_256 = arg2
                                                    lockedToken[stor201 + 1].field_512 = 0
                                                    lockedToken[stor201 + 1].field_768 = arg4
                                                    lockedToken[stor201 + 1].field_1024 = 0
                                                    lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                    allDepositIds.length++
                                                    stor42D7[stor202.length] = depositId + 1
                                                    depositsByWithdrawal[address(arg2)].field_0++
                                                    depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                    return (depositId + 1)
                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 517] = return_data.size
                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 549 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = 32
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 554] = 32
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 'SafeERC20: low-level call failed'
                                                    revert with memory
                                                      from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                                       len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 549]:
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = 32
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 554] = 42
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586 len 42] = 0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565
                                                        revert with memory
                                                          from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                                           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = this.address
                                                require ext_code.size(arg1)
                                                staticcall arg1.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522 len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = 32
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 554] = 27
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 'SafeMath: addition overflow'
                                                    revert with memory
                                                      from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                                       len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                depositId++
                                                lockedToken[stor201 + 1].field_0 = arg1
                                                lockedToken[stor201 + 1].field_256 = arg2
                                                lockedToken[stor201 + 1].field_512 = 0
                                                lockedToken[stor201 + 1].field_768 = arg4
                                                lockedToken[stor201 + 1].field_1024 = 0
                                                lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                allDepositIds.length++
                                                stor42D7[stor202.length] = depositId + 1
                                                depositsByWithdrawal[address(arg2)].field_0++
                                                depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = depositId + 1
                                                return memory
                                                  from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32
                                            if msg.value - (mem[ceil32(return_data.size) + 128] * sub_aa182aef / 10^uint8(ext_call.return_data[0])) <= 0:
                                                require ext_code.size(arg1)
                                                staticcall arg1.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(arg1):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 517 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 641 len 4] = uint32(arg3)
                                                call arg1 with:
                                                     gas gas_remaining wei
                                                    args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                        require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                        if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 627 len 14],
                                                                        uint32(arg3),
                                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 645 len 4]
                                                    require ext_code.size(arg1)
                                                    staticcall arg1.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    depositId++
                                                    lockedToken[stor201 + 1].field_0 = arg1
                                                    lockedToken[stor201 + 1].field_256 = arg2
                                                    lockedToken[stor201 + 1].field_512 = 0
                                                    lockedToken[stor201 + 1].field_768 = arg4
                                                    lockedToken[stor201 + 1].field_1024 = 0
                                                    lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                    allDepositIds.length++
                                                    stor42D7[stor202.length] = depositId + 1
                                                    depositsByWithdrawal[address(arg2)].field_0++
                                                    depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                    return (depositId + 1)
                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 517] = return_data.size
                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 549 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = 32
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 554] = 32
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 'SafeERC20: low-level call failed'
                                                    revert with memory
                                                      from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                                       len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 549]:
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = 32
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 554] = 42
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586 len 42] = 0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565
                                                        revert with memory
                                                          from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                                           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = this.address
                                                require ext_code.size(arg1)
                                                staticcall arg1.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522 len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = 32
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 554] = 27
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 'SafeMath: addition overflow'
                                                    revert with memory
                                                      from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                                       len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                depositId++
                                                lockedToken[stor201 + 1].field_0 = arg1
                                                lockedToken[stor201 + 1].field_256 = arg2
                                                lockedToken[stor201 + 1].field_512 = 0
                                                lockedToken[stor201 + 1].field_768 = arg4
                                                lockedToken[stor201 + 1].field_1024 = 0
                                                lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                allDepositIds.length++
                                                stor42D7[stor202.length] = depositId + 1
                                                depositsByWithdrawal[address(arg2)].field_0++
                                                depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = depositId + 1
                                                return memory
                                                  from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32
                                            call msg.sender with:
                                               value msg.value - (mem[ceil32(return_data.size) + 128] * sub_aa182aef / 10^uint8(ext_call.return_data[0])) wei
                                                 gas gas_remaining wei
                                            if not return_data.size:
                                                require ext_code.size(arg1)
                                                staticcall arg1.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(arg1):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 517 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 641 len 4] = uint32(arg3)
                                                call arg1 with:
                                                     gas gas_remaining wei
                                                    args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                        require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                        if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 627 len 14],
                                                                        uint32(arg3),
                                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 645 len 4]
                                                else:
                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 549 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 549]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 628 len 22]
                                            else:
                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 385] = return_data.size
                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 417 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 390] = this.address
                                                require ext_code.size(arg1)
                                                staticcall arg1.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 390 len (5 * ceil32(return_data.size)) + 32]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 486] = arg3
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(arg1):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518 len floor32((5 * ceil32(return_data.size)) + 100)] = unknown_0x23b872dd(?????), msg.sender, address(this.address), mem[(32 * _57) + (4 * ceil32(return_data.size)) + 486 len floor32((5 * ceil32(return_data.size)) + 100) - 68]
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + floor32((5 * ceil32(return_data.size)) + 100) + -((5 * ceil32(return_data.size)) + 100 % 32) + 550 len (5 * ceil32(return_data.size)) + 100 % 32] = mem[(32 * _57) + (4 * ceil32(return_data.size)) + floor32((5 * ceil32(return_data.size)) + 100) + -((5 * ceil32(return_data.size)) + 100 % 32) + 450 len (5 * ceil32(return_data.size)) + 100 % 32]
                                                call arg1.mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522 len (5 * ceil32(return_data.size)) + 96]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                        require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                        if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 628 len 22]
                                                else:
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 550 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[(32 * _57) + (4 * ceil32(return_data.size)) + 550]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 629 len 22]
                                    else:
                                        if msg.value > mem[ceil32(return_data.size) + 128] * sub_aa182aef / 10^uint8(ext_call.return_data[0]):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if mem[ceil32(return_data.size) + 128] * sub_aa182aef / 10^uint8(ext_call.return_data[0]) <= msg.value:
                                            call companyWalletAddress with:
                                               value mem[ceil32(return_data.size) + 128] * sub_aa182aef / 10^uint8(ext_call.return_data[0]) wei
                                                 gas gas_remaining wei
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    revert with 0, 'Fee transfer failed'
                                                if mem[ceil32(return_data.size) + 128] * sub_aa182aef / 10^uint8(ext_call.return_data[0]) > msg.value:
                                                    require ext_code.size(arg1)
                                                    staticcall arg1.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(arg1):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    mem[(32 * _57) + ceil32(return_data.size) + 516 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                    mem[(32 * _57) + ceil32(return_data.size) + 640 len 4] = uint32(arg3)
                                                    call arg1 with:
                                                         gas gas_remaining wei
                                                        args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + 612 len 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                            require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                            if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[(32 * _57) + ceil32(return_data.size) + 626 len 14],
                                                                            uint32(arg3),
                                                                            mem[(32 * _57) + ceil32(return_data.size) + 644 len 4]
                                                    else:
                                                        mem[(32 * _57) + ceil32(return_data.size) + 548 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[(32 * _57) + ceil32(return_data.size) + 548]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 627 len 22]
                                                    require ext_code.size(arg1)
                                                    staticcall arg1.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    depositId++
                                                    lockedToken[stor201 + 1].field_0 = arg1
                                                    lockedToken[stor201 + 1].field_256 = arg2
                                                    lockedToken[stor201 + 1].field_512 = 0
                                                    lockedToken[stor201 + 1].field_768 = arg4
                                                    lockedToken[stor201 + 1].field_1024 = 0
                                                    lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                    allDepositIds.length++
                                                    stor42D7[stor202.length] = depositId + 1
                                                    depositsByWithdrawal[address(arg2)].field_0++
                                                    depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                    return (depositId + 1)
                                                if (mem[ceil32(return_data.size) + 128] * sub_aa182aef / 10^uint8(ext_call.return_data[0])) - msg.value <= 0:
                                                    require ext_code.size(arg1)
                                                    staticcall arg1.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(arg1):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    mem[(32 * _57) + ceil32(return_data.size) + 516 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                    mem[(32 * _57) + ceil32(return_data.size) + 640 len 4] = uint32(arg3)
                                                    call arg1 with:
                                                         gas gas_remaining wei
                                                        args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + 612 len 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                            require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                            if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[(32 * _57) + ceil32(return_data.size) + 626 len 14],
                                                                            uint32(arg3),
                                                                            mem[(32 * _57) + ceil32(return_data.size) + 644 len 4]
                                                    else:
                                                        mem[(32 * _57) + ceil32(return_data.size) + 548 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[(32 * _57) + ceil32(return_data.size) + 548]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 627 len 22]
                                                    require ext_code.size(arg1)
                                                    staticcall arg1.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    depositId++
                                                    lockedToken[stor201 + 1].field_0 = arg1
                                                    lockedToken[stor201 + 1].field_256 = arg2
                                                    lockedToken[stor201 + 1].field_512 = 0
                                                    lockedToken[stor201 + 1].field_768 = arg4
                                                    lockedToken[stor201 + 1].field_1024 = 0
                                                    lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                    allDepositIds.length++
                                                    stor42D7[stor202.length] = depositId + 1
                                                    depositsByWithdrawal[address(arg2)].field_0++
                                                    depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                    return (depositId + 1)
                                                call msg.sender with:
                                                   value (mem[ceil32(return_data.size) + 128] * sub_aa182aef / 10^uint8(ext_call.return_data[0])) - msg.value wei
                                                     gas gas_remaining wei
                                                require ext_code.size(arg1)
                                                staticcall arg1.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(arg1):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not return_data.size:
                                                    mem[(32 * _57) + ceil32(return_data.size) + 516 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                    mem[(32 * _57) + ceil32(return_data.size) + 640 len 4] = uint32(arg3)
                                                    call arg1 with:
                                                         gas gas_remaining wei
                                                        args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + 612 len 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                            require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                            if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[(32 * _57) + ceil32(return_data.size) + 626 len 14],
                                                                            uint32(arg3),
                                                                            mem[(32 * _57) + ceil32(return_data.size) + 644 len 4]
                                                    else:
                                                        mem[(32 * _57) + ceil32(return_data.size) + 548 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[(32 * _57) + ceil32(return_data.size) + 548]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 627 len 22]
                                                    require ext_code.size(arg1)
                                                    staticcall arg1.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    depositId++
                                                    lockedToken[stor201 + 1].field_0 = arg1
                                                    lockedToken[stor201 + 1].field_256 = arg2
                                                    lockedToken[stor201 + 1].field_512 = 0
                                                    lockedToken[stor201 + 1].field_768 = arg4
                                                    lockedToken[stor201 + 1].field_1024 = 0
                                                    lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                    allDepositIds.length++
                                                    stor42D7[stor202.length] = depositId + 1
                                                    depositsByWithdrawal[address(arg2)].field_0++
                                                    depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                    return (depositId + 1)
                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 517 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 641 len 4] = uint32(arg3)
                                                call arg1 with:
                                                     gas gas_remaining wei
                                                    args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                        require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                        if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 627 len 14],
                                                                        uint32(arg3),
                                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 645 len 4]
                                                    require ext_code.size(arg1)
                                                    staticcall arg1.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    depositId++
                                                    lockedToken[stor201 + 1].field_0 = arg1
                                                    lockedToken[stor201 + 1].field_256 = arg2
                                                    lockedToken[stor201 + 1].field_512 = 0
                                                    lockedToken[stor201 + 1].field_768 = arg4
                                                    lockedToken[stor201 + 1].field_1024 = 0
                                                    lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                    allDepositIds.length++
                                                    stor42D7[stor202.length] = depositId + 1
                                                    depositsByWithdrawal[address(arg2)].field_0++
                                                    depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                    return (depositId + 1)
                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 517] = return_data.size
                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 549 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = 32
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 554] = 32
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 'SafeERC20: low-level call failed'
                                                    revert with memory
                                                      from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                                       len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 549]:
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = 32
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 554] = 42
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586 len 42] = 0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565
                                                        revert with memory
                                                          from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                                           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = this.address
                                                require ext_code.size(arg1)
                                                staticcall arg1.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522 len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = 32
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 554] = 27
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 'SafeMath: addition overflow'
                                                    revert with memory
                                                      from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                                       len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                depositId++
                                                lockedToken[stor201 + 1].field_0 = arg1
                                                lockedToken[stor201 + 1].field_256 = arg2
                                                lockedToken[stor201 + 1].field_512 = 0
                                                lockedToken[stor201 + 1].field_768 = arg4
                                                lockedToken[stor201 + 1].field_1024 = 0
                                                lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                allDepositIds.length++
                                                stor42D7[stor202.length] = depositId + 1
                                                depositsByWithdrawal[address(arg2)].field_0++
                                                depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = depositId + 1
                                                return memory
                                                  from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32
                                            mem[(32 * _57) + ceil32(return_data.size) + 416 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                revert with 0, 'Fee transfer failed'
                                            if mem[ceil32(return_data.size) + 128] * sub_aa182aef / 10^uint8(ext_call.return_data[0]) > msg.value:
                                                require ext_code.size(arg1)
                                                staticcall arg1.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(arg1):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 517 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 641 len 4] = uint32(arg3)
                                                call arg1 with:
                                                     gas gas_remaining wei
                                                    args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                        require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                        if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 627 len 14],
                                                                        uint32(arg3),
                                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 645 len 4]
                                                    require ext_code.size(arg1)
                                                    staticcall arg1.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    depositId++
                                                    lockedToken[stor201 + 1].field_0 = arg1
                                                    lockedToken[stor201 + 1].field_256 = arg2
                                                    lockedToken[stor201 + 1].field_512 = 0
                                                    lockedToken[stor201 + 1].field_768 = arg4
                                                    lockedToken[stor201 + 1].field_1024 = 0
                                                    lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                    allDepositIds.length++
                                                    stor42D7[stor202.length] = depositId + 1
                                                    depositsByWithdrawal[address(arg2)].field_0++
                                                    depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                    return (depositId + 1)
                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 517] = return_data.size
                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 549 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = 32
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 554] = 32
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 'SafeERC20: low-level call failed'
                                                    revert with memory
                                                      from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                                       len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 549]:
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = 32
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 554] = 42
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586 len 42] = 0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565
                                                        revert with memory
                                                          from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                                           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = this.address
                                                require ext_code.size(arg1)
                                                staticcall arg1.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522 len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = 32
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 554] = 27
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 'SafeMath: addition overflow'
                                                    revert with memory
                                                      from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                                       len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                depositId++
                                                lockedToken[stor201 + 1].field_0 = arg1
                                                lockedToken[stor201 + 1].field_256 = arg2
                                                lockedToken[stor201 + 1].field_512 = 0
                                                lockedToken[stor201 + 1].field_768 = arg4
                                                lockedToken[stor201 + 1].field_1024 = 0
                                                lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                allDepositIds.length++
                                                stor42D7[stor202.length] = depositId + 1
                                                depositsByWithdrawal[address(arg2)].field_0++
                                                depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = depositId + 1
                                                return memory
                                                  from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32
                                            if (mem[ceil32(return_data.size) + 128] * sub_aa182aef / 10^uint8(ext_call.return_data[0])) - msg.value <= 0:
                                                require ext_code.size(arg1)
                                                staticcall arg1.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(arg1):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 517 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 641 len 4] = uint32(arg3)
                                                call arg1 with:
                                                     gas gas_remaining wei
                                                    args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                        require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                        if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 627 len 14],
                                                                        uint32(arg3),
                                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 645 len 4]
                                                else:
                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 549 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 549]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 628 len 22]
                                            else:
                                                call msg.sender with:
                                                   value (mem[ceil32(return_data.size) + 128] * sub_aa182aef / 10^uint8(ext_call.return_data[0])) - msg.value wei
                                                     gas gas_remaining wei
                                                if not return_data.size:
                                                    require ext_code.size(arg1)
                                                    staticcall arg1.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(arg1):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 517 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 641 len 4] = uint32(arg3)
                                                    call arg1 with:
                                                         gas gas_remaining wei
                                                        args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                            require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                            if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 627 len 14],
                                                                            uint32(arg3),
                                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 645 len 4]
                                                        require ext_code.size(arg1)
                                                        staticcall arg1.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        depositId++
                                                        lockedToken[stor201 + 1].field_0 = arg1
                                                        lockedToken[stor201 + 1].field_256 = arg2
                                                        lockedToken[stor201 + 1].field_512 = 0
                                                        lockedToken[stor201 + 1].field_768 = arg4
                                                        lockedToken[stor201 + 1].field_1024 = 0
                                                        lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                        allDepositIds.length++
                                                        stor42D7[stor202.length] = depositId + 1
                                                        depositsByWithdrawal[address(arg2)].field_0++
                                                        depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                        return (depositId + 1)
                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 517] = return_data.size
                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 549 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = 32
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 554] = 32
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 'SafeERC20: low-level call failed'
                                                        revert with memory
                                                          from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                                           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 549]:
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 554] = 42
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586 len 42] = 0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565
                                                            revert with memory
                                                              from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = this.address
                                                    require ext_code.size(arg1)
                                                    staticcall arg1.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522 len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = 32
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 554] = 27
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 'SafeMath: addition overflow'
                                                        revert with memory
                                                          from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                                           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                    depositId++
                                                    lockedToken[stor201 + 1].field_0 = arg1
                                                    lockedToken[stor201 + 1].field_256 = arg2
                                                    lockedToken[stor201 + 1].field_512 = 0
                                                    lockedToken[stor201 + 1].field_768 = arg4
                                                    lockedToken[stor201 + 1].field_1024 = 0
                                                    lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                    allDepositIds.length++
                                                    stor42D7[stor202.length] = depositId + 1
                                                    depositsByWithdrawal[address(arg2)].field_0++
                                                    depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = depositId + 1
                                                    return memory
                                                      from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                                       len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32
                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 385] = return_data.size
                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 417 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 390] = this.address
                                                require ext_code.size(arg1)
                                                staticcall arg1.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 390 len (5 * ceil32(return_data.size)) + 32]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 486] = arg3
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(arg1):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518 len floor32((5 * ceil32(return_data.size)) + 100)] = unknown_0x23b872dd(?????), msg.sender, address(this.address), mem[(32 * _57) + (4 * ceil32(return_data.size)) + 486 len floor32((5 * ceil32(return_data.size)) + 100) - 68]
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + floor32((5 * ceil32(return_data.size)) + 100) + -((5 * ceil32(return_data.size)) + 100 % 32) + 550 len (5 * ceil32(return_data.size)) + 100 % 32] = mem[(32 * _57) + (4 * ceil32(return_data.size)) + -((5 * ceil32(return_data.size)) + 100 % 32) + floor32((5 * ceil32(return_data.size)) + 100) + 450 len (5 * ceil32(return_data.size)) + 100 % 32]
                                                call arg1.mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522 len (5 * ceil32(return_data.size)) + 96]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                        require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                        if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 628 len 22]
                                                else:
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 550 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[(32 * _57) + (4 * ceil32(return_data.size)) + 550]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 629 len 22]
                                        else:
                                            if not (mem[ceil32(return_data.size) + 128] * sub_aa182aef / 10^uint8(ext_call.return_data[0])) - msg.value:
                                                if not mem[ceil32(return_data.size) + 128] * sub_aa182aef / 10^uint8(ext_call.return_data[0]):
                                                    revert with 0, 'SafeMath: division by zero'
                                                if 0 / mem[ceil32(return_data.size) + 128] * sub_aa182aef / 10^uint8(ext_call.return_data[0]) > 5:
                                                    revert with 0, 'Fee Not Met'
                                                if mem[ceil32(return_data.size) + 128] * sub_aa182aef / 10^uint8(ext_call.return_data[0]) > msg.value:
                                                    call companyWalletAddress with:
                                                       value msg.value wei
                                                         gas gas_remaining wei
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'Fee transfer failed'
                                                        if mem[ceil32(return_data.size) + 128] * sub_aa182aef / 10^uint8(ext_call.return_data[0]) > msg.value:
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                                revert with 0, 'SafeERC20: call to non-contract'
                                                            if not ext_code.hash(arg1):
                                                                revert with 0, 'SafeERC20: call to non-contract'
                                                            mem[(32 * _57) + ceil32(return_data.size) + 580 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                            mem[(32 * _57) + ceil32(return_data.size) + 704 len 4] = uint32(arg3)
                                                            call arg1 with:
                                                                 gas gas_remaining wei
                                                                args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + 676 len 4]
                                                            if not return_data.size:
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                    require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                    if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + 690 len 14],
                                                                                    uint32(arg3),
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + 708 len 4]
                                                            else:
                                                                mem[(32 * _57) + ceil32(return_data.size) + 612 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if return_data.size:
                                                                    require return_data.size >= 32
                                                                    if not mem[(32 * _57) + ceil32(return_data.size) + 612]:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 22]
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            depositId++
                                                            lockedToken[stor201 + 1].field_0 = arg1
                                                            lockedToken[stor201 + 1].field_256 = arg2
                                                            lockedToken[stor201 + 1].field_512 = 0
                                                            lockedToken[stor201 + 1].field_768 = arg4
                                                            lockedToken[stor201 + 1].field_1024 = 0
                                                            lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                            allDepositIds.length++
                                                            stor42D7[stor202.length] = depositId + 1
                                                            depositsByWithdrawal[address(arg2)].field_0++
                                                            depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                            return (depositId + 1)
                                                        if (mem[ceil32(return_data.size) + 128] * sub_aa182aef / 10^uint8(ext_call.return_data[0])) - msg.value <= 0:
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                                revert with 0, 'SafeERC20: call to non-contract'
                                                            if not ext_code.hash(arg1):
                                                                revert with 0, 'SafeERC20: call to non-contract'
                                                            mem[(32 * _57) + ceil32(return_data.size) + 580 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                            mem[(32 * _57) + ceil32(return_data.size) + 704 len 4] = uint32(arg3)
                                                            call arg1 with:
                                                                 gas gas_remaining wei
                                                                args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + 676 len 4]
                                                            if not return_data.size:
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                    require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                    if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + 690 len 14],
                                                                                    uint32(arg3),
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + 708 len 4]
                                                            else:
                                                                mem[(32 * _57) + ceil32(return_data.size) + 612 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if return_data.size:
                                                                    require return_data.size >= 32
                                                                    if not mem[(32 * _57) + ceil32(return_data.size) + 612]:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 22]
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            depositId++
                                                            lockedToken[stor201 + 1].field_0 = arg1
                                                            lockedToken[stor201 + 1].field_256 = arg2
                                                            lockedToken[stor201 + 1].field_512 = 0
                                                            lockedToken[stor201 + 1].field_768 = arg4
                                                            lockedToken[stor201 + 1].field_1024 = 0
                                                            lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                            allDepositIds.length++
                                                            stor42D7[stor202.length] = depositId + 1
                                                            depositsByWithdrawal[address(arg2)].field_0++
                                                            depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                            return (depositId + 1)
                                                        call msg.sender with:
                                                           value (mem[ceil32(return_data.size) + 128] * sub_aa182aef / 10^uint8(ext_call.return_data[0])) - msg.value wei
                                                             gas gas_remaining wei
                                                        require ext_code.size(arg1)
                                                        staticcall arg1.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        if not ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        if not return_data.size:
                                                            mem[(32 * _57) + ceil32(return_data.size) + 580 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                            mem[(32 * _57) + ceil32(return_data.size) + 704 len 4] = uint32(arg3)
                                                            call arg1 with:
                                                                 gas gas_remaining wei
                                                                args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + 676 len 4]
                                                            if not return_data.size:
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                    require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                    if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + 690 len 14],
                                                                                    uint32(arg3),
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + 708 len 4]
                                                            else:
                                                                mem[(32 * _57) + ceil32(return_data.size) + 612 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if return_data.size:
                                                                    require return_data.size >= 32
                                                                    if not mem[(32 * _57) + ceil32(return_data.size) + 612]:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 22]
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            depositId++
                                                            lockedToken[stor201 + 1].field_0 = arg1
                                                            lockedToken[stor201 + 1].field_256 = arg2
                                                            lockedToken[stor201 + 1].field_512 = 0
                                                            lockedToken[stor201 + 1].field_768 = arg4
                                                            lockedToken[stor201 + 1].field_1024 = 0
                                                            lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                            allDepositIds.length++
                                                            stor42D7[stor202.length] = depositId + 1
                                                            depositsByWithdrawal[address(arg2)].field_0++
                                                            depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                            return (depositId + 1)
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 705 len 4] = uint32(arg3)
                                                        call arg1 with:
                                                             gas gas_remaining wei
                                                            args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 677 len 4]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                revert with 0, 'SafeERC20: low-level call failed'
                                                            if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 14],
                                                                                uint32(arg3),
                                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 709 len 4]
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            depositId++
                                                            lockedToken[stor201 + 1].field_0 = arg1
                                                            lockedToken[stor201 + 1].field_256 = arg2
                                                            lockedToken[stor201 + 1].field_512 = 0
                                                            lockedToken[stor201 + 1].field_768 = arg4
                                                            lockedToken[stor201 + 1].field_1024 = 0
                                                            lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                            allDepositIds.length++
                                                            stor42D7[stor202.length] = depositId + 1
                                                            depositsByWithdrawal[address(arg2)].field_0++
                                                            depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                            return (depositId + 1)
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581] = return_data.size
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650] = 'SafeERC20: low-level call failed'
                                                            revert with memory
                                                              from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613]:
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 42
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650 len 42] = 0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565
                                                                revert with memory
                                                                  from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = this.address
                                                        require ext_code.size(arg1)
                                                        staticcall arg1.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586 len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 27
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650] = 'SafeMath: addition overflow'
                                                            revert with memory
                                                              from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                        depositId++
                                                        lockedToken[stor201 + 1].field_0 = arg1
                                                        lockedToken[stor201 + 1].field_256 = arg2
                                                        lockedToken[stor201 + 1].field_512 = 0
                                                        lockedToken[stor201 + 1].field_768 = arg4
                                                        lockedToken[stor201 + 1].field_1024 = 0
                                                        lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                        allDepositIds.length++
                                                        stor42D7[stor202.length] = depositId + 1
                                                        depositsByWithdrawal[address(arg2)].field_0++
                                                        depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = depositId + 1
                                                        return memory
                                                          from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32
                                                    mem[(32 * _57) + ceil32(return_data.size) + 480 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'Fee transfer failed'
                                                    if mem[ceil32(return_data.size) + 128] * sub_aa182aef / 10^uint8(ext_call.return_data[0]) > msg.value:
                                                        require ext_code.size(arg1)
                                                        staticcall arg1.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        if not ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 705 len 4] = uint32(arg3)
                                                        call arg1 with:
                                                             gas gas_remaining wei
                                                            args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 677 len 4]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                revert with 0, 'SafeERC20: low-level call failed'
                                                            if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 14],
                                                                                uint32(arg3),
                                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 709 len 4]
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            depositId++
                                                            lockedToken[stor201 + 1].field_0 = arg1
                                                            lockedToken[stor201 + 1].field_256 = arg2
                                                            lockedToken[stor201 + 1].field_512 = 0
                                                            lockedToken[stor201 + 1].field_768 = arg4
                                                            lockedToken[stor201 + 1].field_1024 = 0
                                                            lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                            allDepositIds.length++
                                                            stor42D7[stor202.length] = depositId + 1
                                                            depositsByWithdrawal[address(arg2)].field_0++
                                                            depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                            return (depositId + 1)
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581] = return_data.size
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650] = 'SafeERC20: low-level call failed'
                                                            revert with memory
                                                              from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613]:
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 42
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650 len 42] = 0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565
                                                                revert with memory
                                                                  from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = this.address
                                                        require ext_code.size(arg1)
                                                        staticcall arg1.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586 len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 27
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650] = 'SafeMath: addition overflow'
                                                            revert with memory
                                                              from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                        depositId++
                                                        lockedToken[stor201 + 1].field_0 = arg1
                                                        lockedToken[stor201 + 1].field_256 = arg2
                                                        lockedToken[stor201 + 1].field_512 = 0
                                                        lockedToken[stor201 + 1].field_768 = arg4
                                                        lockedToken[stor201 + 1].field_1024 = 0
                                                        lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                        allDepositIds.length++
                                                        stor42D7[stor202.length] = depositId + 1
                                                        depositsByWithdrawal[address(arg2)].field_0++
                                                        depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = depositId + 1
                                                        return memory
                                                          from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32
                                                    if (mem[ceil32(return_data.size) + 128] * sub_aa182aef / 10^uint8(ext_call.return_data[0])) - msg.value <= 0:
                                                        require ext_code.size(arg1)
                                                        staticcall arg1.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        if not ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 705 len 4] = uint32(arg3)
                                                        call arg1 with:
                                                             gas gas_remaining wei
                                                            args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 677 len 4]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                revert with 0, 'SafeERC20: low-level call failed'
                                                            if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 14],
                                                                                uint32(arg3),
                                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 709 len 4]
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            depositId++
                                                            lockedToken[stor201 + 1].field_0 = arg1
                                                            lockedToken[stor201 + 1].field_256 = arg2
                                                            lockedToken[stor201 + 1].field_512 = 0
                                                            lockedToken[stor201 + 1].field_768 = arg4
                                                            lockedToken[stor201 + 1].field_1024 = 0
                                                            lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                            allDepositIds.length++
                                                            stor42D7[stor202.length] = depositId + 1
                                                            depositsByWithdrawal[address(arg2)].field_0++
                                                            depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                            return (depositId + 1)
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581] = return_data.size
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650] = 'SafeERC20: low-level call failed'
                                                            revert with memory
                                                              from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613]:
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 42
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650 len 42] = 0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565
                                                                revert with memory
                                                                  from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = this.address
                                                        require ext_code.size(arg1)
                                                        staticcall arg1.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586 len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 27
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650] = 'SafeMath: addition overflow'
                                                            revert with memory
                                                              from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                        depositId++
                                                        lockedToken[stor201 + 1].field_0 = arg1
                                                        lockedToken[stor201 + 1].field_256 = arg2
                                                        lockedToken[stor201 + 1].field_512 = 0
                                                        lockedToken[stor201 + 1].field_768 = arg4
                                                        lockedToken[stor201 + 1].field_1024 = 0
                                                        lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                        allDepositIds.length++
                                                        stor42D7[stor202.length] = depositId + 1
                                                        depositsByWithdrawal[address(arg2)].field_0++
                                                        depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = depositId + 1
                                                        return memory
                                                          from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32
                                                    call msg.sender with:
                                                       value (mem[ceil32(return_data.size) + 128] * sub_aa182aef / 10^uint8(ext_call.return_data[0])) - msg.value wei
                                                         gas gas_remaining wei
                                                    if not return_data.size:
                                                        require ext_code.size(arg1)
                                                        staticcall arg1.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        if not ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 705 len 4] = uint32(arg3)
                                                        call arg1 with:
                                                             gas gas_remaining wei
                                                            args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 677 len 4]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                revert with 0, 'SafeERC20: low-level call failed'
                                                            if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 14],
                                                                                uint32(arg3),
                                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 709 len 4]
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            depositId++
                                                            lockedToken[stor201 + 1].field_0 = arg1
                                                            lockedToken[stor201 + 1].field_256 = arg2
                                                            lockedToken[stor201 + 1].field_512 = 0
                                                            lockedToken[stor201 + 1].field_768 = arg4
                                                            lockedToken[stor201 + 1].field_1024 = 0
                                                            lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                            allDepositIds.length++
                                                            stor42D7[stor202.length] = depositId + 1
                                                            depositsByWithdrawal[address(arg2)].field_0++
                                                            depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                            return (depositId + 1)
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581] = return_data.size
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650] = 'SafeERC20: low-level call failed'
                                                            revert with memory
                                                              from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613]:
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 42
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650 len 42] = 0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565
                                                                revert with memory
                                                                  from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = this.address
                                                        require ext_code.size(arg1)
                                                        staticcall arg1.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586 len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 27
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650] = 'SafeMath: addition overflow'
                                                            revert with memory
                                                              from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                        depositId++
                                                        lockedToken[stor201 + 1].field_0 = arg1
                                                        lockedToken[stor201 + 1].field_256 = arg2
                                                        lockedToken[stor201 + 1].field_512 = 0
                                                        lockedToken[stor201 + 1].field_768 = arg4
                                                        lockedToken[stor201 + 1].field_1024 = 0
                                                        lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                        allDepositIds.length++
                                                        stor42D7[stor202.length] = depositId + 1
                                                        depositsByWithdrawal[address(arg2)].field_0++
                                                        depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = depositId + 1
                                                        return memory
                                                          from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32
                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 449] = return_data.size
                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 481 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 454] = this.address
                                                    require ext_code.size(arg1)
                                                    staticcall arg1.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 454 len (5 * ceil32(return_data.size)) + 32]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 550] = arg3
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(arg1):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582 len floor32((5 * ceil32(return_data.size)) + 100)] = unknown_0x23b872dd(?????), msg.sender, address(this.address), mem[(32 * _57) + (4 * ceil32(return_data.size)) + 550 len floor32((5 * ceil32(return_data.size)) + 100) - 68]
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + floor32((5 * ceil32(return_data.size)) + 100) + -((5 * ceil32(return_data.size)) + 100 % 32) + 614 len (5 * ceil32(return_data.size)) + 100 % 32] = mem[(32 * _57) + (4 * ceil32(return_data.size)) + -((5 * ceil32(return_data.size)) + 100 % 32) + floor32((5 * ceil32(return_data.size)) + 100) + 514 len (5 * ceil32(return_data.size)) + 100 % 32]
                                                    call arg1.mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586 len (5 * ceil32(return_data.size)) + 96]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                            require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                            if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 692 len 22]
                                                    else:
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 614 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[(32 * _57) + (4 * ceil32(return_data.size)) + 614]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 693 len 22]
                                                else:
                                                    call companyWalletAddress with:
                                                       value mem[ceil32(return_data.size) + 128] * sub_aa182aef / 10^uint8(ext_call.return_data[0]) wei
                                                         gas gas_remaining wei
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'Fee transfer failed'
                                                        if mem[ceil32(return_data.size) + 128] * sub_aa182aef / 10^uint8(ext_call.return_data[0]) > msg.value:
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                                revert with 0, 'SafeERC20: call to non-contract'
                                                            if not ext_code.hash(arg1):
                                                                revert with 0, 'SafeERC20: call to non-contract'
                                                            mem[(32 * _57) + ceil32(return_data.size) + 580 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                            mem[(32 * _57) + ceil32(return_data.size) + 704 len 4] = uint32(arg3)
                                                            call arg1 with:
                                                                 gas gas_remaining wei
                                                                args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + 676 len 4]
                                                            if not return_data.size:
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                    require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                    if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + 690 len 14],
                                                                                    uint32(arg3),
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + 708 len 4]
                                                            else:
                                                                mem[(32 * _57) + ceil32(return_data.size) + 612 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if return_data.size:
                                                                    require return_data.size >= 32
                                                                    if not mem[(32 * _57) + ceil32(return_data.size) + 612]:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 22]
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            depositId++
                                                            lockedToken[stor201 + 1].field_0 = arg1
                                                            lockedToken[stor201 + 1].field_256 = arg2
                                                            lockedToken[stor201 + 1].field_512 = 0
                                                            lockedToken[stor201 + 1].field_768 = arg4
                                                            lockedToken[stor201 + 1].field_1024 = 0
                                                            lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                            allDepositIds.length++
                                                            stor42D7[stor202.length] = depositId + 1
                                                            depositsByWithdrawal[address(arg2)].field_0++
                                                            depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                            return (depositId + 1)
                                                        if (mem[ceil32(return_data.size) + 128] * sub_aa182aef / 10^uint8(ext_call.return_data[0])) - msg.value <= 0:
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                                revert with 0, 'SafeERC20: call to non-contract'
                                                            if not ext_code.hash(arg1):
                                                                revert with 0, 'SafeERC20: call to non-contract'
                                                            mem[(32 * _57) + ceil32(return_data.size) + 580 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                            mem[(32 * _57) + ceil32(return_data.size) + 704 len 4] = uint32(arg3)
                                                            call arg1 with:
                                                                 gas gas_remaining wei
                                                                args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + 676 len 4]
                                                            if not return_data.size:
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                    require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                    if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + 690 len 14],
                                                                                    uint32(arg3),
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + 708 len 4]
                                                            else:
                                                                mem[(32 * _57) + ceil32(return_data.size) + 612 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if return_data.size:
                                                                    require return_data.size >= 32
                                                                    if not mem[(32 * _57) + ceil32(return_data.size) + 612]:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 22]
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            depositId++
                                                            lockedToken[stor201 + 1].field_0 = arg1
                                                            lockedToken[stor201 + 1].field_256 = arg2
                                                            lockedToken[stor201 + 1].field_512 = 0
                                                            lockedToken[stor201 + 1].field_768 = arg4
                                                            lockedToken[stor201 + 1].field_1024 = 0
                                                            lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                            allDepositIds.length++
                                                            stor42D7[stor202.length] = depositId + 1
                                                            depositsByWithdrawal[address(arg2)].field_0++
                                                            depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                            return (depositId + 1)
                                                        call msg.sender with:
                                                           value (mem[ceil32(return_data.size) + 128] * sub_aa182aef / 10^uint8(ext_call.return_data[0])) - msg.value wei
                                                             gas gas_remaining wei
                                                        require ext_code.size(arg1)
                                                        staticcall arg1.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        if not ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        if not return_data.size:
                                                            mem[(32 * _57) + ceil32(return_data.size) + 580 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                            mem[(32 * _57) + ceil32(return_data.size) + 704 len 4] = uint32(arg3)
                                                            call arg1 with:
                                                                 gas gas_remaining wei
                                                                args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + 676 len 4]
                                                            if not return_data.size:
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                    require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                    if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + 690 len 14],
                                                                                    uint32(arg3),
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + 708 len 4]
                                                            else:
                                                                mem[(32 * _57) + ceil32(return_data.size) + 612 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if return_data.size:
                                                                    require return_data.size >= 32
                                                                    if not mem[(32 * _57) + ceil32(return_data.size) + 612]:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 22]
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            depositId++
                                                            lockedToken[stor201 + 1].field_0 = arg1
                                                            lockedToken[stor201 + 1].field_256 = arg2
                                                            lockedToken[stor201 + 1].field_512 = 0
                                                            lockedToken[stor201 + 1].field_768 = arg4
                                                            lockedToken[stor201 + 1].field_1024 = 0
                                                            lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                            allDepositIds.length++
                                                            stor42D7[stor202.length] = depositId + 1
                                                            depositsByWithdrawal[address(arg2)].field_0++
                                                            depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                            return (depositId + 1)
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 705 len 4] = uint32(arg3)
                                                        call arg1 with:
                                                             gas gas_remaining wei
                                                            args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 677 len 4]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                revert with 0, 'SafeERC20: low-level call failed'
                                                            if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 14],
                                                                                uint32(arg3),
                                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 709 len 4]
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            depositId++
                                                            lockedToken[stor201 + 1].field_0 = arg1
                                                            lockedToken[stor201 + 1].field_256 = arg2
                                                            lockedToken[stor201 + 1].field_512 = 0
                                                            lockedToken[stor201 + 1].field_768 = arg4
                                                            lockedToken[stor201 + 1].field_1024 = 0
                                                            lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                            allDepositIds.length++
                                                            stor42D7[stor202.length] = depositId + 1
                                                            depositsByWithdrawal[address(arg2)].field_0++
                                                            depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                            return (depositId + 1)
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581] = return_data.size
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650] = 'SafeERC20: low-level call failed'
                                                            revert with memory
                                                              from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613]:
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 42
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650 len 42] = 0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565
                                                                revert with memory
                                                                  from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = this.address
                                                        require ext_code.size(arg1)
                                                        staticcall arg1.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586 len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 27
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650] = 'SafeMath: addition overflow'
                                                            revert with memory
                                                              from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                        depositId++
                                                        lockedToken[stor201 + 1].field_0 = arg1
                                                        lockedToken[stor201 + 1].field_256 = arg2
                                                        lockedToken[stor201 + 1].field_512 = 0
                                                        lockedToken[stor201 + 1].field_768 = arg4
                                                        lockedToken[stor201 + 1].field_1024 = 0
                                                        lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                        allDepositIds.length++
                                                        stor42D7[stor202.length] = depositId + 1
                                                        depositsByWithdrawal[address(arg2)].field_0++
                                                        depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = depositId + 1
                                                        return memory
                                                          from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32
                                                    mem[(32 * _57) + ceil32(return_data.size) + 480 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'Fee transfer failed'
                                                    if mem[ceil32(return_data.size) + 128] * sub_aa182aef / 10^uint8(ext_call.return_data[0]) > msg.value:
                                                        require ext_code.size(arg1)
                                                        staticcall arg1.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        if not ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 705 len 4] = uint32(arg3)
                                                        call arg1 with:
                                                             gas gas_remaining wei
                                                            args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 677 len 4]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                revert with 0, 'SafeERC20: low-level call failed'
                                                            if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 14],
                                                                                uint32(arg3),
                                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 709 len 4]
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            depositId++
                                                            lockedToken[stor201 + 1].field_0 = arg1
                                                            lockedToken[stor201 + 1].field_256 = arg2
                                                            lockedToken[stor201 + 1].field_512 = 0
                                                            lockedToken[stor201 + 1].field_768 = arg4
                                                            lockedToken[stor201 + 1].field_1024 = 0
                                                            lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                            allDepositIds.length++
                                                            stor42D7[stor202.length] = depositId + 1
                                                            depositsByWithdrawal[address(arg2)].field_0++
                                                            depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                            return (depositId + 1)
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581] = return_data.size
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650] = 'SafeERC20: low-level call failed'
                                                            revert with memory
                                                              from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613]:
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 42
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650 len 42] = 0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565
                                                                revert with memory
                                                                  from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = this.address
                                                        require ext_code.size(arg1)
                                                        staticcall arg1.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586 len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 27
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650] = 'SafeMath: addition overflow'
                                                            revert with memory
                                                              from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                        depositId++
                                                        lockedToken[stor201 + 1].field_0 = arg1
                                                        lockedToken[stor201 + 1].field_256 = arg2
                                                        lockedToken[stor201 + 1].field_512 = 0
                                                        lockedToken[stor201 + 1].field_768 = arg4
                                                        lockedToken[stor201 + 1].field_1024 = 0
                                                        lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                        allDepositIds.length++
                                                        stor42D7[stor202.length] = depositId + 1
                                                        depositsByWithdrawal[address(arg2)].field_0++
                                                        depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = depositId + 1
                                                        return memory
                                                          from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32
                                                    if (mem[ceil32(return_data.size) + 128] * sub_aa182aef / 10^uint8(ext_call.return_data[0])) - msg.value <= 0:
                                                        require ext_code.size(arg1)
                                                        staticcall arg1.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        if not ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 705 len 4] = uint32(arg3)
                                                        call arg1 with:
                                                             gas gas_remaining wei
                                                            args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 677 len 4]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                revert with 0, 'SafeERC20: low-level call failed'
                                                            if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 14],
                                                                                uint32(arg3),
                                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 709 len 4]
                                                        else:
                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            if not ext_call.success:
                                                                revert with 0, 'SafeERC20: low-level call failed'
                                                            if return_data.size:
                                                                require return_data.size >= 32
                                                                if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613]:
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 692 len 22]
                                                    else:
                                                        call msg.sender with:
                                                           value (mem[ceil32(return_data.size) + 128] * sub_aa182aef / 10^uint8(ext_call.return_data[0])) - msg.value wei
                                                             gas gas_remaining wei
                                                        if not return_data.size:
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                                revert with 0, 'SafeERC20: call to non-contract'
                                                            if not ext_code.hash(arg1):
                                                                revert with 0, 'SafeERC20: call to non-contract'
                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 705 len 4] = uint32(arg3)
                                                            call arg1 with:
                                                                 gas gas_remaining wei
                                                                args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 677 len 4]
                                                            if not return_data.size:
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                    require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                    if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 14],
                                                                                    uint32(arg3),
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 709 len 4]
                                                                require ext_code.size(arg1)
                                                                staticcall arg1.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args this.address
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                require return_data.size >= 32
                                                                if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                depositId++
                                                                lockedToken[stor201 + 1].field_0 = arg1
                                                                lockedToken[stor201 + 1].field_256 = arg2
                                                                lockedToken[stor201 + 1].field_512 = 0
                                                                lockedToken[stor201 + 1].field_768 = arg4
                                                                lockedToken[stor201 + 1].field_1024 = 0
                                                                lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                                allDepositIds.length++
                                                                stor42D7[stor202.length] = depositId + 1
                                                                depositsByWithdrawal[address(arg2)].field_0++
                                                                depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                                return (depositId + 1)
                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581] = return_data.size
                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            if not ext_call.success:
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 32
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650] = 'SafeERC20: low-level call failed'
                                                                revert with memory
                                                                  from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                            if return_data.size:
                                                                require return_data.size >= 32
                                                                if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613]:
                                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 42
                                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650 len 42] = 0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565
                                                                    revert with memory
                                                                      from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                                       len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = this.address
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586 len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 27
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650] = 'SafeMath: addition overflow'
                                                                revert with memory
                                                                  from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                            depositId++
                                                            lockedToken[stor201 + 1].field_0 = arg1
                                                            lockedToken[stor201 + 1].field_256 = arg2
                                                            lockedToken[stor201 + 1].field_512 = 0
                                                            lockedToken[stor201 + 1].field_768 = arg4
                                                            lockedToken[stor201 + 1].field_1024 = 0
                                                            lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                            allDepositIds.length++
                                                            stor42D7[stor202.length] = depositId + 1
                                                            depositsByWithdrawal[address(arg2)].field_0++
                                                            depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = depositId + 1
                                                            return memory
                                                              from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 449] = return_data.size
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 481 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 454] = this.address
                                                        require ext_code.size(arg1)
                                                        staticcall arg1.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 454 len (5 * ceil32(return_data.size)) + 32]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 550] = arg3
                                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        if not ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582 len floor32((5 * ceil32(return_data.size)) + 100)] = unknown_0x23b872dd(?????), msg.sender, address(this.address), mem[(32 * _57) + (4 * ceil32(return_data.size)) + 550 len floor32((5 * ceil32(return_data.size)) + 100) - 68]
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + floor32((5 * ceil32(return_data.size)) + 100) + -((5 * ceil32(return_data.size)) + 100 % 32) + 614 len (5 * ceil32(return_data.size)) + 100 % 32] = mem[(32 * _57) + (4 * ceil32(return_data.size)) + -((5 * ceil32(return_data.size)) + 100 % 32) + floor32((5 * ceil32(return_data.size)) + 100) + 514 len (5 * ceil32(return_data.size)) + 100 % 32]
                                                        call arg1.mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582 len 4] with:
                                                             gas gas_remaining wei
                                                            args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586 len (5 * ceil32(return_data.size)) + 96]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                revert with 0, 'SafeERC20: low-level call failed'
                                                            if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 692 len 22]
                                                        else:
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 614 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            if not ext_call.success:
                                                                revert with 0, 'SafeERC20: low-level call failed'
                                                            if return_data.size:
                                                                require return_data.size >= 32
                                                                if not mem[(32 * _57) + (4 * ceil32(return_data.size)) + 614]:
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 693 len 22]
                                            else:
                                                if (100 * mem[ceil32(return_data.size) + 128] * sub_aa182aef / 10^uint8(ext_call.return_data[0])) - (100 * msg.value) / (mem[ceil32(return_data.size) + 128] * sub_aa182aef / 10^uint8(ext_call.return_data[0])) - msg.value != 100:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _57) + ceil32(return_data.size) + 485 len 31]
                                                if not mem[ceil32(return_data.size) + 128] * sub_aa182aef / 10^uint8(ext_call.return_data[0]):
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (100 * mem[ceil32(return_data.size) + 128] * sub_aa182aef / 10^uint8(ext_call.return_data[0])) - (100 * msg.value) / mem[ceil32(return_data.size) + 128] * sub_aa182aef / 10^uint8(ext_call.return_data[0]) > 5:
                                                    revert with 0, 'Fee Not Met'
                                                if mem[ceil32(return_data.size) + 128] * sub_aa182aef / 10^uint8(ext_call.return_data[0]) > msg.value:
                                                    call companyWalletAddress with:
                                                       value msg.value wei
                                                         gas gas_remaining wei
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'Fee transfer failed'
                                                        if mem[ceil32(return_data.size) + 128] * sub_aa182aef / 10^uint8(ext_call.return_data[0]) > msg.value:
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                                revert with 0, 'SafeERC20: call to non-contract'
                                                            if not ext_code.hash(arg1):
                                                                revert with 0, 'SafeERC20: call to non-contract'
                                                            mem[(32 * _57) + ceil32(return_data.size) + 580 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                            mem[(32 * _57) + ceil32(return_data.size) + 704 len 4] = uint32(arg3)
                                                            call arg1 with:
                                                                 gas gas_remaining wei
                                                                args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + 676 len 4]
                                                            if not return_data.size:
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                    require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                    if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + 690 len 14],
                                                                                    uint32(arg3),
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + 708 len 4]
                                                            else:
                                                                mem[(32 * _57) + ceil32(return_data.size) + 612 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if return_data.size:
                                                                    require return_data.size >= 32
                                                                    if not mem[(32 * _57) + ceil32(return_data.size) + 612]:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 22]
                                                        else:
                                                            if (mem[ceil32(return_data.size) + 128] * sub_aa182aef / 10^uint8(ext_call.return_data[0])) - msg.value <= 0:
                                                                require ext_code.size(arg1)
                                                                staticcall arg1.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args this.address
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                require return_data.size >= 32
                                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                                if not ext_code.hash(arg1):
                                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                                mem[(32 * _57) + ceil32(return_data.size) + 580 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                                mem[(32 * _57) + ceil32(return_data.size) + 704 len 4] = uint32(arg3)
                                                                call arg1 with:
                                                                     gas gas_remaining wei
                                                                    args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + 676 len 4]
                                                                if not return_data.size:
                                                                    if not ext_call.success:
                                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                                    if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                        require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                        if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                            revert with 0, 
                                                                                        32,
                                                                                        42,
                                                                                        0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                        mem[(32 * _57) + ceil32(return_data.size) + 690 len 14],
                                                                                        uint32(arg3),
                                                                                        mem[(32 * _57) + ceil32(return_data.size) + 708 len 4]
                                                                else:
                                                                    mem[(32 * _57) + ceil32(return_data.size) + 612 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    if not ext_call.success:
                                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                                    if return_data.size:
                                                                        require return_data.size >= 32
                                                                        if not mem[(32 * _57) + ceil32(return_data.size) + 612]:
                                                                            revert with 0, 
                                                                                        32,
                                                                                        42,
                                                                                        0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 22]
                                                            else:
                                                                call msg.sender with:
                                                                   value (mem[ceil32(return_data.size) + 128] * sub_aa182aef / 10^uint8(ext_call.return_data[0])) - msg.value wei
                                                                     gas gas_remaining wei
                                                                require ext_code.size(arg1)
                                                                staticcall arg1.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args this.address
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                require return_data.size >= 32
                                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                                if not ext_code.hash(arg1):
                                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                                if not return_data.size:
                                                                    mem[(32 * _57) + ceil32(return_data.size) + 580 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                                    mem[(32 * _57) + ceil32(return_data.size) + 704 len 4] = uint32(arg3)
                                                                    call arg1 with:
                                                                         gas gas_remaining wei
                                                                        args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + 676 len 4]
                                                                    if not return_data.size:
                                                                        if not ext_call.success:
                                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                                        if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                            require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                            if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                                revert with 0, 
                                                                                            32,
                                                                                            42,
                                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                            mem[(32 * _57) + ceil32(return_data.size) + 690 len 14],
                                                                                            uint32(arg3),
                                                                                            mem[(32 * _57) + ceil32(return_data.size) + 708 len 4]
                                                                    else:
                                                                        mem[(32 * _57) + ceil32(return_data.size) + 612 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                        if not ext_call.success:
                                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                                        if return_data.size:
                                                                            require return_data.size >= 32
                                                                            if not mem[(32 * _57) + ceil32(return_data.size) + 612]:
                                                                                revert with 0, 
                                                                                            32,
                                                                                            42,
                                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 22]
                                                                else:
                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 705 len 4] = uint32(arg3)
                                                                    call arg1 with:
                                                                         gas gas_remaining wei
                                                                        args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 677 len 4]
                                                                    if not return_data.size:
                                                                        if not ext_call.success:
                                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                                        if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                            require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                            if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                                revert with 0, 
                                                                                            32,
                                                                                            42,
                                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 14],
                                                                                            uint32(arg3),
                                                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 709 len 4]
                                                                    else:
                                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                        if not ext_call.success:
                                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                                        if return_data.size:
                                                                            require return_data.size >= 32
                                                                            if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613]:
                                                                                revert with 0, 
                                                                                            32,
                                                                                            42,
                                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 692 len 22]
                                                    else:
                                                        mem[(32 * _57) + ceil32(return_data.size) + 480 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'Fee transfer failed'
                                                        if mem[ceil32(return_data.size) + 128] * sub_aa182aef / 10^uint8(ext_call.return_data[0]) > msg.value:
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                                revert with 0, 'SafeERC20: call to non-contract'
                                                            if not ext_code.hash(arg1):
                                                                revert with 0, 'SafeERC20: call to non-contract'
                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 705 len 4] = uint32(arg3)
                                                            call arg1 with:
                                                                 gas gas_remaining wei
                                                                args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 677 len 4]
                                                            if not return_data.size:
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                    require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                    if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 14],
                                                                                    uint32(arg3),
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 709 len 4]
                                                            else:
                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if return_data.size:
                                                                    require return_data.size >= 32
                                                                    if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613]:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 692 len 22]
                                                        else:
                                                            if (mem[ceil32(return_data.size) + 128] * sub_aa182aef / 10^uint8(ext_call.return_data[0])) - msg.value <= 0:
                                                                require ext_code.size(arg1)
                                                                staticcall arg1.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args this.address
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                require return_data.size >= 32
                                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                                if not ext_code.hash(arg1):
                                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 705 len 4] = uint32(arg3)
                                                                call arg1 with:
                                                                     gas gas_remaining wei
                                                                    args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 677 len 4]
                                                                if not return_data.size:
                                                                    if not ext_call.success:
                                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                                    if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                        require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                        if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                            revert with 0, 
                                                                                        32,
                                                                                        42,
                                                                                        0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 14],
                                                                                        uint32(arg3),
                                                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 709 len 4]
                                                                    require ext_code.size(arg1)
                                                                    staticcall arg1.0x70a08231 with:
                                                                            gas gas_remaining wei
                                                                           args this.address
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    require return_data.size >= 32
                                                                    if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    depositId++
                                                                    lockedToken[stor201 + 1].field_0 = arg1
                                                                    lockedToken[stor201 + 1].field_256 = arg2
                                                                    lockedToken[stor201 + 1].field_512 = 0
                                                                    lockedToken[stor201 + 1].field_768 = arg4
                                                                    lockedToken[stor201 + 1].field_1024 = 0
                                                                    lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                                    allDepositIds.length++
                                                                    stor42D7[stor202.length] = depositId + 1
                                                                    depositsByWithdrawal[address(arg2)].field_0++
                                                                    depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                                    return (depositId + 1)
                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581] = return_data.size
                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                if not ext_call.success:
                                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 32
                                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650] = 'SafeERC20: low-level call failed'
                                                                    revert with memory
                                                                      from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                                       len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                                if return_data.size:
                                                                    require return_data.size >= 32
                                                                    if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613]:
                                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 42
                                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650 len 42] = 0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565
                                                                        revert with memory
                                                                          from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                                           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = this.address
                                                                require ext_code.size(arg1)
                                                                staticcall arg1.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586 len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                require return_data.size >= 32
                                                                if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 27
                                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650] = 'SafeMath: addition overflow'
                                                                    revert with memory
                                                                      from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                                       len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                                depositId++
                                                                lockedToken[stor201 + 1].field_0 = arg1
                                                                lockedToken[stor201 + 1].field_256 = arg2
                                                                lockedToken[stor201 + 1].field_512 = 0
                                                                lockedToken[stor201 + 1].field_768 = arg4
                                                                lockedToken[stor201 + 1].field_1024 = 0
                                                                lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                                allDepositIds.length++
                                                                stor42D7[stor202.length] = depositId + 1
                                                                depositsByWithdrawal[address(arg2)].field_0++
                                                                depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = depositId + 1
                                                                return memory
                                                                  from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32
                                                            call msg.sender with:
                                                               value (mem[ceil32(return_data.size) + 128] * sub_aa182aef / 10^uint8(ext_call.return_data[0])) - msg.value wei
                                                                 gas gas_remaining wei
                                                            if not return_data.size:
                                                                require ext_code.size(arg1)
                                                                staticcall arg1.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args this.address
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                require return_data.size >= 32
                                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                                if not ext_code.hash(arg1):
                                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 705 len 4] = uint32(arg3)
                                                                call arg1 with:
                                                                     gas gas_remaining wei
                                                                    args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 677 len 4]
                                                                if not return_data.size:
                                                                    if not ext_call.success:
                                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                                    if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                        require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                        if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                            revert with 0, 
                                                                                        32,
                                                                                        42,
                                                                                        0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 14],
                                                                                        uint32(arg3),
                                                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 709 len 4]
                                                                    require ext_code.size(arg1)
                                                                    staticcall arg1.0x70a08231 with:
                                                                            gas gas_remaining wei
                                                                           args this.address
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    require return_data.size >= 32
                                                                    if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    depositId++
                                                                    lockedToken[stor201 + 1].field_0 = arg1
                                                                    lockedToken[stor201 + 1].field_256 = arg2
                                                                    lockedToken[stor201 + 1].field_512 = 0
                                                                    lockedToken[stor201 + 1].field_768 = arg4
                                                                    lockedToken[stor201 + 1].field_1024 = 0
                                                                    lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                                    allDepositIds.length++
                                                                    stor42D7[stor202.length] = depositId + 1
                                                                    depositsByWithdrawal[address(arg2)].field_0++
                                                                    depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                                    return (depositId + 1)
                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581] = return_data.size
                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                if not ext_call.success:
                                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 32
                                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650] = 'SafeERC20: low-level call failed'
                                                                    revert with memory
                                                                      from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                                       len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                                if return_data.size:
                                                                    require return_data.size >= 32
                                                                    if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613]:
                                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 42
                                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650 len 42] = 0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565
                                                                        revert with memory
                                                                          from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                                           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = this.address
                                                                require ext_code.size(arg1)
                                                                staticcall arg1.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586 len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                require return_data.size >= 32
                                                                if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 27
                                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650] = 'SafeMath: addition overflow'
                                                                    revert with memory
                                                                      from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                                       len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                                depositId++
                                                                lockedToken[stor201 + 1].field_0 = arg1
                                                                lockedToken[stor201 + 1].field_256 = arg2
                                                                lockedToken[stor201 + 1].field_512 = 0
                                                                lockedToken[stor201 + 1].field_768 = arg4
                                                                lockedToken[stor201 + 1].field_1024 = 0
                                                                lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                                allDepositIds.length++
                                                                stor42D7[stor202.length] = depositId + 1
                                                                depositsByWithdrawal[address(arg2)].field_0++
                                                                depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = depositId + 1
                                                                return memory
                                                                  from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32
                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 449] = return_data.size
                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 481 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 454] = this.address
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 454 len (5 * ceil32(return_data.size)) + 32]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 550] = arg3
                                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                                revert with 0, 'SafeERC20: call to non-contract'
                                                            if not ext_code.hash(arg1):
                                                                revert with 0, 'SafeERC20: call to non-contract'
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582 len floor32((5 * ceil32(return_data.size)) + 100)] = unknown_0x23b872dd(?????), msg.sender, address(this.address), mem[(32 * _57) + (4 * ceil32(return_data.size)) + 550 len floor32((5 * ceil32(return_data.size)) + 100) - 68]
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + floor32((5 * ceil32(return_data.size)) + 100) + -((5 * ceil32(return_data.size)) + 100 % 32) + 614 len (5 * ceil32(return_data.size)) + 100 % 32] = mem[(32 * _57) + (4 * ceil32(return_data.size)) + -((5 * ceil32(return_data.size)) + 100 % 32) + floor32((5 * ceil32(return_data.size)) + 100) + 514 len (5 * ceil32(return_data.size)) + 100 % 32]
                                                            call arg1.mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582 len 4] with:
                                                                 gas gas_remaining wei
                                                                args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586 len (5 * ceil32(return_data.size)) + 96]
                                                            if not return_data.size:
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                    require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                    if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 692 len 22]
                                                            else:
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 614 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if return_data.size:
                                                                    require return_data.size >= 32
                                                                    if not mem[(32 * _57) + (4 * ceil32(return_data.size)) + 614]:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 693 len 22]
                                                else:
                                                    call companyWalletAddress with:
                                                       value mem[ceil32(return_data.size) + 128] * sub_aa182aef / 10^uint8(ext_call.return_data[0]) wei
                                                         gas gas_remaining wei
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'Fee transfer failed'
                                                        if mem[ceil32(return_data.size) + 128] * sub_aa182aef / 10^uint8(ext_call.return_data[0]) > msg.value:
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                                revert with 0, 'SafeERC20: call to non-contract'
                                                            if not ext_code.hash(arg1):
                                                                revert with 0, 'SafeERC20: call to non-contract'
                                                            mem[(32 * _57) + ceil32(return_data.size) + 580 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                            mem[(32 * _57) + ceil32(return_data.size) + 704 len 4] = uint32(arg3)
                                                            call arg1 with:
                                                                 gas gas_remaining wei
                                                                args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + 676 len 4]
                                                            if not return_data.size:
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                    require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                    if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + 690 len 14],
                                                                                    uint32(arg3),
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + 708 len 4]
                                                            else:
                                                                mem[(32 * _57) + ceil32(return_data.size) + 612 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if return_data.size:
                                                                    require return_data.size >= 32
                                                                    if not mem[(32 * _57) + ceil32(return_data.size) + 612]:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 22]
                                                        else:
                                                            if (mem[ceil32(return_data.size) + 128] * sub_aa182aef / 10^uint8(ext_call.return_data[0])) - msg.value <= 0:
                                                                require ext_code.size(arg1)
                                                                staticcall arg1.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args this.address
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                require return_data.size >= 32
                                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                                if not ext_code.hash(arg1):
                                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                                mem[(32 * _57) + ceil32(return_data.size) + 580 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                                mem[(32 * _57) + ceil32(return_data.size) + 704 len 4] = uint32(arg3)
                                                                call arg1 with:
                                                                     gas gas_remaining wei
                                                                    args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + 676 len 4]
                                                                if not return_data.size:
                                                                    if not ext_call.success:
                                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                                    if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                        require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                        if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                            revert with 0, 
                                                                                        32,
                                                                                        42,
                                                                                        0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                        mem[(32 * _57) + ceil32(return_data.size) + 690 len 14],
                                                                                        uint32(arg3),
                                                                                        mem[(32 * _57) + ceil32(return_data.size) + 708 len 4]
                                                                else:
                                                                    mem[(32 * _57) + ceil32(return_data.size) + 612 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    if not ext_call.success:
                                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                                    if return_data.size:
                                                                        require return_data.size >= 32
                                                                        if not mem[(32 * _57) + ceil32(return_data.size) + 612]:
                                                                            revert with 0, 
                                                                                        32,
                                                                                        42,
                                                                                        0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 22]
                                                            else:
                                                                call msg.sender with:
                                                                   value (mem[ceil32(return_data.size) + 128] * sub_aa182aef / 10^uint8(ext_call.return_data[0])) - msg.value wei
                                                                     gas gas_remaining wei
                                                                require ext_code.size(arg1)
                                                                staticcall arg1.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args this.address
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                require return_data.size >= 32
                                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                                if not ext_code.hash(arg1):
                                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                                if not return_data.size:
                                                                    mem[(32 * _57) + ceil32(return_data.size) + 580 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                                    mem[(32 * _57) + ceil32(return_data.size) + 704 len 4] = uint32(arg3)
                                                                    call arg1 with:
                                                                         gas gas_remaining wei
                                                                        args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + 676 len 4]
                                                                    if not return_data.size:
                                                                        if not ext_call.success:
                                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                                        if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                            require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                            if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                                revert with 0, 
                                                                                            32,
                                                                                            42,
                                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                            mem[(32 * _57) + ceil32(return_data.size) + 690 len 14],
                                                                                            uint32(arg3),
                                                                                            mem[(32 * _57) + ceil32(return_data.size) + 708 len 4]
                                                                    else:
                                                                        mem[(32 * _57) + ceil32(return_data.size) + 612 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                        if not ext_call.success:
                                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                                        if return_data.size:
                                                                            require return_data.size >= 32
                                                                            if not mem[(32 * _57) + ceil32(return_data.size) + 612]:
                                                                                revert with 0, 
                                                                                            32,
                                                                                            42,
                                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 22]
                                                                else:
                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 705 len 4] = uint32(arg3)
                                                                    call arg1 with:
                                                                         gas gas_remaining wei
                                                                        args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 677 len 4]
                                                                    if not return_data.size:
                                                                        if not ext_call.success:
                                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                                        if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                            require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                            if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                                revert with 0, 
                                                                                            32,
                                                                                            42,
                                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 14],
                                                                                            uint32(arg3),
                                                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 709 len 4]
                                                                    else:
                                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                        if not ext_call.success:
                                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                                        if return_data.size:
                                                                            require return_data.size >= 32
                                                                            if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613]:
                                                                                revert with 0, 
                                                                                            32,
                                                                                            42,
                                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 692 len 22]
                                                    else:
                                                        mem[(32 * _57) + ceil32(return_data.size) + 480 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'Fee transfer failed'
                                                        if mem[ceil32(return_data.size) + 128] * sub_aa182aef / 10^uint8(ext_call.return_data[0]) > msg.value:
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                                revert with 0, 'SafeERC20: call to non-contract'
                                                            if not ext_code.hash(arg1):
                                                                revert with 0, 'SafeERC20: call to non-contract'
                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 705 len 4] = uint32(arg3)
                                                            call arg1 with:
                                                                 gas gas_remaining wei
                                                                args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 677 len 4]
                                                            if not return_data.size:
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                    require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                    if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 14],
                                                                                    uint32(arg3),
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 709 len 4]
                                                                require ext_code.size(arg1)
                                                                staticcall arg1.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args this.address
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                require return_data.size >= 32
                                                                if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                depositId++
                                                                lockedToken[stor201 + 1].field_0 = arg1
                                                                lockedToken[stor201 + 1].field_256 = arg2
                                                                lockedToken[stor201 + 1].field_512 = 0
                                                                lockedToken[stor201 + 1].field_768 = arg4
                                                                lockedToken[stor201 + 1].field_1024 = 0
                                                                lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                                allDepositIds.length++
                                                                stor42D7[stor202.length] = depositId + 1
                                                                depositsByWithdrawal[address(arg2)].field_0++
                                                                depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                                return (depositId + 1)
                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581] = return_data.size
                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            if not ext_call.success:
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 32
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650] = 'SafeERC20: low-level call failed'
                                                                revert with memory
                                                                  from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                            if return_data.size:
                                                                require return_data.size >= 32
                                                                if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613]:
                                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 42
                                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650 len 42] = 0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565
                                                                    revert with memory
                                                                      from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                                       len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = this.address
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586 len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 27
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650] = 'SafeMath: addition overflow'
                                                                revert with memory
                                                                  from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                            depositId++
                                                            lockedToken[stor201 + 1].field_0 = arg1
                                                            lockedToken[stor201 + 1].field_256 = arg2
                                                            lockedToken[stor201 + 1].field_512 = 0
                                                            lockedToken[stor201 + 1].field_768 = arg4
                                                            lockedToken[stor201 + 1].field_1024 = 0
                                                            lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                            allDepositIds.length++
                                                            stor42D7[stor202.length] = depositId + 1
                                                            depositsByWithdrawal[address(arg2)].field_0++
                                                            depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = depositId + 1
                                                            return memory
                                                              from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32
                                                        if (mem[ceil32(return_data.size) + 128] * sub_aa182aef / 10^uint8(ext_call.return_data[0])) - msg.value <= 0:
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                                revert with 0, 'SafeERC20: call to non-contract'
                                                            if not ext_code.hash(arg1):
                                                                revert with 0, 'SafeERC20: call to non-contract'
                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 705 len 4] = uint32(arg3)
                                                            call arg1 with:
                                                                 gas gas_remaining wei
                                                                args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 677 len 4]
                                                            if not return_data.size:
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                    require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                    if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 14],
                                                                                    uint32(arg3),
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 709 len 4]
                                                                require ext_code.size(arg1)
                                                                staticcall arg1.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args this.address
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                require return_data.size >= 32
                                                                if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                depositId++
                                                                lockedToken[stor201 + 1].field_0 = arg1
                                                                lockedToken[stor201 + 1].field_256 = arg2
                                                                lockedToken[stor201 + 1].field_512 = 0
                                                                lockedToken[stor201 + 1].field_768 = arg4
                                                                lockedToken[stor201 + 1].field_1024 = 0
                                                                lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                                allDepositIds.length++
                                                                stor42D7[stor202.length] = depositId + 1
                                                                depositsByWithdrawal[address(arg2)].field_0++
                                                                depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                                return (depositId + 1)
                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581] = return_data.size
                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            if not ext_call.success:
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 32
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650] = 'SafeERC20: low-level call failed'
                                                                revert with memory
                                                                  from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                            if return_data.size:
                                                                require return_data.size >= 32
                                                                if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613]:
                                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 42
                                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650 len 42] = 0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565
                                                                    revert with memory
                                                                      from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                                       len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = this.address
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586 len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 27
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650] = 'SafeMath: addition overflow'
                                                                revert with memory
                                                                  from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                            depositId++
                                                            lockedToken[stor201 + 1].field_0 = arg1
                                                            lockedToken[stor201 + 1].field_256 = arg2
                                                            lockedToken[stor201 + 1].field_512 = 0
                                                            lockedToken[stor201 + 1].field_768 = arg4
                                                            lockedToken[stor201 + 1].field_1024 = 0
                                                            lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                            allDepositIds.length++
                                                            stor42D7[stor202.length] = depositId + 1
                                                            depositsByWithdrawal[address(arg2)].field_0++
                                                            depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = depositId + 1
                                                            return memory
                                                              from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32
                                                        call msg.sender with:
                                                           value (mem[ceil32(return_data.size) + 128] * sub_aa182aef / 10^uint8(ext_call.return_data[0])) - msg.value wei
                                                             gas gas_remaining wei
                                                        if not return_data.size:
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                                revert with 0, 'SafeERC20: call to non-contract'
                                                            if not ext_code.hash(arg1):
                                                                revert with 0, 'SafeERC20: call to non-contract'
                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 705 len 4] = uint32(arg3)
                                                            call arg1 with:
                                                                 gas gas_remaining wei
                                                                args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 677 len 4]
                                                            if not return_data.size:
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                    require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                    if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 14],
                                                                                    uint32(arg3),
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 709 len 4]
                                                                require ext_code.size(arg1)
                                                                staticcall arg1.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args this.address
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                require return_data.size >= 32
                                                                if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                depositId++
                                                                lockedToken[stor201 + 1].field_0 = arg1
                                                                lockedToken[stor201 + 1].field_256 = arg2
                                                                lockedToken[stor201 + 1].field_512 = 0
                                                                lockedToken[stor201 + 1].field_768 = arg4
                                                                lockedToken[stor201 + 1].field_1024 = 0
                                                                lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                                allDepositIds.length++
                                                                stor42D7[stor202.length] = depositId + 1
                                                                depositsByWithdrawal[address(arg2)].field_0++
                                                                depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                                return (depositId + 1)
                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581] = return_data.size
                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            if not ext_call.success:
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 32
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650] = 'SafeERC20: low-level call failed'
                                                                revert with memory
                                                                  from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                            if return_data.size:
                                                                require return_data.size >= 32
                                                                if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613]:
                                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 42
                                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650 len 42] = 0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565
                                                                    revert with memory
                                                                      from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                                       len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = this.address
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586 len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 27
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650] = 'SafeMath: addition overflow'
                                                                revert with memory
                                                                  from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                            depositId++
                                                            lockedToken[stor201 + 1].field_0 = arg1
                                                            lockedToken[stor201 + 1].field_256 = arg2
                                                            lockedToken[stor201 + 1].field_512 = 0
                                                            lockedToken[stor201 + 1].field_768 = arg4
                                                            lockedToken[stor201 + 1].field_1024 = 0
                                                            lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                            allDepositIds.length++
                                                            stor42D7[stor202.length] = depositId + 1
                                                            depositsByWithdrawal[address(arg2)].field_0++
                                                            depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = depositId + 1
                                                            return memory
                                                              from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 449] = return_data.size
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 481 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 454] = this.address
                                                        require ext_code.size(arg1)
                                                        staticcall arg1.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 454 len (5 * ceil32(return_data.size)) + 32]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 550] = arg3
                                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        if not ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582 len floor32((5 * ceil32(return_data.size)) + 100)] = unknown_0x23b872dd(?????), msg.sender, address(this.address), mem[(32 * _57) + (4 * ceil32(return_data.size)) + 550 len floor32((5 * ceil32(return_data.size)) + 100) - 68]
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + floor32((5 * ceil32(return_data.size)) + 100) + -((5 * ceil32(return_data.size)) + 100 % 32) + 614 len (5 * ceil32(return_data.size)) + 100 % 32] = mem[(32 * _57) + (4 * ceil32(return_data.size)) + floor32((5 * ceil32(return_data.size)) + 100) + -((5 * ceil32(return_data.size)) + 100 % 32) + 514 len (5 * ceil32(return_data.size)) + 100 % 32]
                                                        call arg1.mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582 len 4] with:
                                                             gas gas_remaining wei
                                                            args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586 len (5 * ceil32(return_data.size)) + 96]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                revert with 0, 'SafeERC20: low-level call failed'
                                                            if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 692 len 22]
                                                        else:
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 614 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            if not ext_call.success:
                                                                revert with 0, 'SafeERC20: low-level call failed'
                                                            if return_data.size:
                                                                require return_data.size >= 32
                                                                if not mem[(32 * _57) + (4 * ceil32(return_data.size)) + 614]:
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 693 len 22]
                        else:
                            if 3 * mem[ceil32(return_data.size) + 128] / mem[ceil32(return_data.size) + 128] != 3:
                                revert with 0, 
                                            32,
                                            33,
                                            0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[(32 * _57) + ceil32(return_data.size) + 229 len 31]
                            if 3 * mem[ceil32(return_data.size) + 128] / 1000 > mem[ceil32(return_data.size) + 128]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not sub_aa182aef:
                                if not 10^uint8(ext_call.return_data[0]):
                                    revert with 0, 'SafeMath: division by zero'
                                if not 0 / 10^uint8(ext_call.return_data[0]):
                                    require ext_code.size(arg1)
                                    staticcall arg1.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                        revert with 0, 'SafeERC20: call to non-contract'
                                    if not ext_code.hash(arg1):
                                        revert with 0, 'SafeERC20: call to non-contract'
                                    mem[(32 * _57) + ceil32(return_data.size) + 452 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                    mem[(32 * _57) + ceil32(return_data.size) + 576 len 4] = uint32(arg3)
                                    call arg1 with:
                                         gas gas_remaining wei
                                        args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + 548 len 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                            require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                            if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[(32 * _57) + ceil32(return_data.size) + 562 len 14],
                                                            uint32(arg3),
                                                            mem[(32 * _57) + ceil32(return_data.size) + 580 len 4]
                                    else:
                                        mem[(32 * _57) + ceil32(return_data.size) + 484 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if return_data.size:
                                            require return_data.size >= 32
                                            if not mem[(32 * _57) + ceil32(return_data.size) + 484]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 563 len 22]
                                else:
                                    if 0 / 10^uint8(ext_call.return_data[0]) <= msg.value:
                                        call companyWalletAddress with:
                                           value 0 / 10^uint8(ext_call.return_data[0]) wei
                                             gas gas_remaining wei
                                        if not return_data.size:
                                            if not ext_call.success:
                                                revert with 0, 'Fee transfer failed'
                                            if 0 / 10^uint8(ext_call.return_data[0]) > msg.value:
                                                require ext_code.size(arg1)
                                                staticcall arg1.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(arg1):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                mem[(32 * _57) + ceil32(return_data.size) + 516 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                mem[(32 * _57) + ceil32(return_data.size) + 640 len 4] = uint32(arg3)
                                                call arg1 with:
                                                     gas gas_remaining wei
                                                    args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + 612 len 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                        require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                        if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[(32 * _57) + ceil32(return_data.size) + 626 len 14],
                                                                        uint32(arg3),
                                                                        mem[(32 * _57) + ceil32(return_data.size) + 644 len 4]
                                                else:
                                                    mem[(32 * _57) + ceil32(return_data.size) + 548 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[(32 * _57) + ceil32(return_data.size) + 548]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 627 len 22]
                                                require ext_code.size(arg1)
                                                staticcall arg1.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                depositId++
                                                lockedToken[stor201 + 1].field_0 = arg1
                                                lockedToken[stor201 + 1].field_256 = arg2
                                                lockedToken[stor201 + 1].field_512 = 0
                                                lockedToken[stor201 + 1].field_768 = arg4
                                                lockedToken[stor201 + 1].field_1024 = 0
                                                lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                allDepositIds.length++
                                                stor42D7[stor202.length] = depositId + 1
                                                depositsByWithdrawal[address(arg2)].field_0++
                                                depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                return (depositId + 1)
                                            if msg.value - (0 / 10^uint8(ext_call.return_data[0])) <= 0:
                                                require ext_code.size(arg1)
                                                staticcall arg1.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(arg1):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                mem[(32 * _57) + ceil32(return_data.size) + 516 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                mem[(32 * _57) + ceil32(return_data.size) + 640 len 4] = uint32(arg3)
                                                call arg1 with:
                                                     gas gas_remaining wei
                                                    args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + 612 len 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                        require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                        if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[(32 * _57) + ceil32(return_data.size) + 626 len 14],
                                                                        uint32(arg3),
                                                                        mem[(32 * _57) + ceil32(return_data.size) + 644 len 4]
                                                else:
                                                    mem[(32 * _57) + ceil32(return_data.size) + 548 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[(32 * _57) + ceil32(return_data.size) + 548]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 627 len 22]
                                                require ext_code.size(arg1)
                                                staticcall arg1.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                depositId++
                                                lockedToken[stor201 + 1].field_0 = arg1
                                                lockedToken[stor201 + 1].field_256 = arg2
                                                lockedToken[stor201 + 1].field_512 = 0
                                                lockedToken[stor201 + 1].field_768 = arg4
                                                lockedToken[stor201 + 1].field_1024 = 0
                                                lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                allDepositIds.length++
                                                stor42D7[stor202.length] = depositId + 1
                                                depositsByWithdrawal[address(arg2)].field_0++
                                                depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                return (depositId + 1)
                                            call msg.sender with:
                                               value msg.value - (0 / 10^uint8(ext_call.return_data[0])) wei
                                                 gas gas_remaining wei
                                            require ext_code.size(arg1)
                                            staticcall arg1.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                revert with 0, 'SafeERC20: call to non-contract'
                                            if not ext_code.hash(arg1):
                                                revert with 0, 'SafeERC20: call to non-contract'
                                            if not return_data.size:
                                                mem[(32 * _57) + ceil32(return_data.size) + 516 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                mem[(32 * _57) + ceil32(return_data.size) + 640 len 4] = uint32(arg3)
                                                call arg1 with:
                                                     gas gas_remaining wei
                                                    args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + 612 len 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                        require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                        if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[(32 * _57) + ceil32(return_data.size) + 626 len 14],
                                                                        uint32(arg3),
                                                                        mem[(32 * _57) + ceil32(return_data.size) + 644 len 4]
                                                else:
                                                    mem[(32 * _57) + ceil32(return_data.size) + 548 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[(32 * _57) + ceil32(return_data.size) + 548]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 627 len 22]
                                                require ext_code.size(arg1)
                                                staticcall arg1.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                depositId++
                                                lockedToken[stor201 + 1].field_0 = arg1
                                                lockedToken[stor201 + 1].field_256 = arg2
                                                lockedToken[stor201 + 1].field_512 = 0
                                                lockedToken[stor201 + 1].field_768 = arg4
                                                lockedToken[stor201 + 1].field_1024 = 0
                                                lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                allDepositIds.length++
                                                stor42D7[stor202.length] = depositId + 1
                                                depositsByWithdrawal[address(arg2)].field_0++
                                                depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                return (depositId + 1)
                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 517 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 641 len 4] = uint32(arg3)
                                            call arg1 with:
                                                 gas gas_remaining wei
                                                args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                    require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                    if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                        revert with 0, 
                                                                    32,
                                                                    42,
                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 627 len 14],
                                                                    uint32(arg3),
                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 645 len 4]
                                                require ext_code.size(arg1)
                                                staticcall arg1.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                depositId++
                                                lockedToken[stor201 + 1].field_0 = arg1
                                                lockedToken[stor201 + 1].field_256 = arg2
                                                lockedToken[stor201 + 1].field_512 = 0
                                                lockedToken[stor201 + 1].field_768 = arg4
                                                lockedToken[stor201 + 1].field_1024 = 0
                                                lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                allDepositIds.length++
                                                stor42D7[stor202.length] = depositId + 1
                                                depositsByWithdrawal[address(arg2)].field_0++
                                                depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                return (depositId + 1)
                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 517] = return_data.size
                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 549 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = 32
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 554] = 32
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 'SafeERC20: low-level call failed'
                                                revert with memory
                                                  from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                            if return_data.size:
                                                require return_data.size >= 32
                                                if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 549]:
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = 32
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 554] = 42
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586 len 42] = 0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565
                                                    revert with memory
                                                      from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                                       len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = this.address
                                            require ext_code.size(arg1)
                                            staticcall arg1.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522 len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = 32
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 554] = 27
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 'SafeMath: addition overflow'
                                                revert with memory
                                                  from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                            depositId++
                                            lockedToken[stor201 + 1].field_0 = arg1
                                            lockedToken[stor201 + 1].field_256 = arg2
                                            lockedToken[stor201 + 1].field_512 = 0
                                            lockedToken[stor201 + 1].field_768 = arg4
                                            lockedToken[stor201 + 1].field_1024 = 0
                                            lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                            allDepositIds.length++
                                            stor42D7[stor202.length] = depositId + 1
                                            depositsByWithdrawal[address(arg2)].field_0++
                                            depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = depositId + 1
                                            return memory
                                              from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32
                                        mem[(32 * _57) + ceil32(return_data.size) + 416 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            revert with 0, 'Fee transfer failed'
                                        if 0 / 10^uint8(ext_call.return_data[0]) > msg.value:
                                            require ext_code.size(arg1)
                                            staticcall arg1.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                revert with 0, 'SafeERC20: call to non-contract'
                                            if not ext_code.hash(arg1):
                                                revert with 0, 'SafeERC20: call to non-contract'
                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 517 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 641 len 4] = uint32(arg3)
                                            call arg1 with:
                                                 gas gas_remaining wei
                                                args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                    require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                    if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                        revert with 0, 
                                                                    32,
                                                                    42,
                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 627 len 14],
                                                                    uint32(arg3),
                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 645 len 4]
                                                require ext_code.size(arg1)
                                                staticcall arg1.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                depositId++
                                                lockedToken[stor201 + 1].field_0 = arg1
                                                lockedToken[stor201 + 1].field_256 = arg2
                                                lockedToken[stor201 + 1].field_512 = 0
                                                lockedToken[stor201 + 1].field_768 = arg4
                                                lockedToken[stor201 + 1].field_1024 = 0
                                                lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                allDepositIds.length++
                                                stor42D7[stor202.length] = depositId + 1
                                                depositsByWithdrawal[address(arg2)].field_0++
                                                depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                return (depositId + 1)
                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 517] = return_data.size
                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 549 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = 32
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 554] = 32
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 'SafeERC20: low-level call failed'
                                                revert with memory
                                                  from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                            if return_data.size:
                                                require return_data.size >= 32
                                                if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 549]:
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = 32
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 554] = 42
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586 len 42] = 0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565
                                                    revert with memory
                                                      from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                                       len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = this.address
                                            require ext_code.size(arg1)
                                            staticcall arg1.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522 len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = 32
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 554] = 27
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 'SafeMath: addition overflow'
                                                revert with memory
                                                  from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                            depositId++
                                            lockedToken[stor201 + 1].field_0 = arg1
                                            lockedToken[stor201 + 1].field_256 = arg2
                                            lockedToken[stor201 + 1].field_512 = 0
                                            lockedToken[stor201 + 1].field_768 = arg4
                                            lockedToken[stor201 + 1].field_1024 = 0
                                            lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                            allDepositIds.length++
                                            stor42D7[stor202.length] = depositId + 1
                                            depositsByWithdrawal[address(arg2)].field_0++
                                            depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = depositId + 1
                                            return memory
                                              from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32
                                        if msg.value - (0 / 10^uint8(ext_call.return_data[0])) <= 0:
                                            require ext_code.size(arg1)
                                            staticcall arg1.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                revert with 0, 'SafeERC20: call to non-contract'
                                            if not ext_code.hash(arg1):
                                                revert with 0, 'SafeERC20: call to non-contract'
                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 517 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 641 len 4] = uint32(arg3)
                                            call arg1 with:
                                                 gas gas_remaining wei
                                                args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                    require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                    if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                        revert with 0, 
                                                                    32,
                                                                    42,
                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 627 len 14],
                                                                    uint32(arg3),
                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 645 len 4]
                                                require ext_code.size(arg1)
                                                staticcall arg1.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                depositId++
                                                lockedToken[stor201 + 1].field_0 = arg1
                                                lockedToken[stor201 + 1].field_256 = arg2
                                                lockedToken[stor201 + 1].field_512 = 0
                                                lockedToken[stor201 + 1].field_768 = arg4
                                                lockedToken[stor201 + 1].field_1024 = 0
                                                lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                allDepositIds.length++
                                                stor42D7[stor202.length] = depositId + 1
                                                depositsByWithdrawal[address(arg2)].field_0++
                                                depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                return (depositId + 1)
                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 517] = return_data.size
                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 549 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = 32
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 554] = 32
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 'SafeERC20: low-level call failed'
                                                revert with memory
                                                  from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                            if return_data.size:
                                                require return_data.size >= 32
                                                if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 549]:
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = 32
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 554] = 42
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586 len 42] = 0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565
                                                    revert with memory
                                                      from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                                       len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = this.address
                                            require ext_code.size(arg1)
                                            staticcall arg1.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522 len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = 32
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 554] = 27
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 'SafeMath: addition overflow'
                                                revert with memory
                                                  from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                            depositId++
                                            lockedToken[stor201 + 1].field_0 = arg1
                                            lockedToken[stor201 + 1].field_256 = arg2
                                            lockedToken[stor201 + 1].field_512 = 0
                                            lockedToken[stor201 + 1].field_768 = arg4
                                            lockedToken[stor201 + 1].field_1024 = 0
                                            lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                            allDepositIds.length++
                                            stor42D7[stor202.length] = depositId + 1
                                            depositsByWithdrawal[address(arg2)].field_0++
                                            depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = depositId + 1
                                            return memory
                                              from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32
                                        call msg.sender with:
                                           value msg.value - (0 / 10^uint8(ext_call.return_data[0])) wei
                                             gas gas_remaining wei
                                        if not return_data.size:
                                            require ext_code.size(arg1)
                                            staticcall arg1.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                revert with 0, 'SafeERC20: call to non-contract'
                                            if not ext_code.hash(arg1):
                                                revert with 0, 'SafeERC20: call to non-contract'
                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 517 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 641 len 4] = uint32(arg3)
                                            call arg1 with:
                                                 gas gas_remaining wei
                                                args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                    require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                    if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                        revert with 0, 
                                                                    32,
                                                                    42,
                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 627 len 14],
                                                                    uint32(arg3),
                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 645 len 4]
                                                require ext_code.size(arg1)
                                                staticcall arg1.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                depositId++
                                                lockedToken[stor201 + 1].field_0 = arg1
                                                lockedToken[stor201 + 1].field_256 = arg2
                                                lockedToken[stor201 + 1].field_512 = 0
                                                lockedToken[stor201 + 1].field_768 = arg4
                                                lockedToken[stor201 + 1].field_1024 = 0
                                                lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                allDepositIds.length++
                                                stor42D7[stor202.length] = depositId + 1
                                                depositsByWithdrawal[address(arg2)].field_0++
                                                depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                return (depositId + 1)
                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 517] = return_data.size
                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 549 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = 32
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 554] = 32
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 'SafeERC20: low-level call failed'
                                                revert with memory
                                                  from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                            if return_data.size:
                                                require return_data.size >= 32
                                                if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 549]:
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = 32
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 554] = 42
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586 len 42] = 0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565
                                                    revert with memory
                                                      from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                                       len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = this.address
                                            require ext_code.size(arg1)
                                            staticcall arg1.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522 len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = 32
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 554] = 27
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 'SafeMath: addition overflow'
                                                revert with memory
                                                  from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                            depositId++
                                            lockedToken[stor201 + 1].field_0 = arg1
                                            lockedToken[stor201 + 1].field_256 = arg2
                                            lockedToken[stor201 + 1].field_512 = 0
                                            lockedToken[stor201 + 1].field_768 = arg4
                                            lockedToken[stor201 + 1].field_1024 = 0
                                            lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                            allDepositIds.length++
                                            stor42D7[stor202.length] = depositId + 1
                                            depositsByWithdrawal[address(arg2)].field_0++
                                            depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = depositId + 1
                                            return memory
                                              from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32
                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 385] = return_data.size
                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 417 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 390] = this.address
                                        require ext_code.size(arg1)
                                        staticcall arg1.0x70a08231 with:
                                                gas gas_remaining wei
                                               args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 390 len (5 * ceil32(return_data.size)) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 486] = arg3
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        if not ext_code.hash(arg1):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518 len floor32((5 * ceil32(return_data.size)) + 100)] = unknown_0x23b872dd(?????), msg.sender, address(this.address), mem[(32 * _57) + (4 * ceil32(return_data.size)) + 486 len floor32((5 * ceil32(return_data.size)) + 100) - 68]
                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + floor32((5 * ceil32(return_data.size)) + 100) + -((5 * ceil32(return_data.size)) + 100 % 32) + 550 len (5 * ceil32(return_data.size)) + 100 % 32] = mem[(32 * _57) + (4 * ceil32(return_data.size)) + -((5 * ceil32(return_data.size)) + 100 % 32) + floor32((5 * ceil32(return_data.size)) + 100) + 450 len (5 * ceil32(return_data.size)) + 100 % 32]
                                        call arg1.mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522 len (5 * ceil32(return_data.size)) + 96]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 628 len 22]
                                        else:
                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 550 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if return_data.size:
                                                require return_data.size >= 32
                                                if not mem[(32 * _57) + (4 * ceil32(return_data.size)) + 550]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 629 len 22]
                                    else:
                                        if msg.value > 0 / 10^uint8(ext_call.return_data[0]):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 0 / 10^uint8(ext_call.return_data[0]) <= msg.value:
                                            call companyWalletAddress with:
                                               value 0 / 10^uint8(ext_call.return_data[0]) wei
                                                 gas gas_remaining wei
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    revert with 0, 'Fee transfer failed'
                                                if 0 / 10^uint8(ext_call.return_data[0]) > msg.value:
                                                    require ext_code.size(arg1)
                                                    staticcall arg1.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(arg1):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    mem[(32 * _57) + ceil32(return_data.size) + 516 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                    mem[(32 * _57) + ceil32(return_data.size) + 640 len 4] = uint32(arg3)
                                                    call arg1 with:
                                                         gas gas_remaining wei
                                                        args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + 612 len 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                            require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                            if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[(32 * _57) + ceil32(return_data.size) + 626 len 14],
                                                                            uint32(arg3),
                                                                            mem[(32 * _57) + ceil32(return_data.size) + 644 len 4]
                                                    else:
                                                        mem[(32 * _57) + ceil32(return_data.size) + 548 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[(32 * _57) + ceil32(return_data.size) + 548]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 627 len 22]
                                                    require ext_code.size(arg1)
                                                    staticcall arg1.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    depositId++
                                                    lockedToken[stor201 + 1].field_0 = arg1
                                                    lockedToken[stor201 + 1].field_256 = arg2
                                                    lockedToken[stor201 + 1].field_512 = 0
                                                    lockedToken[stor201 + 1].field_768 = arg4
                                                    lockedToken[stor201 + 1].field_1024 = 0
                                                    lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                    allDepositIds.length++
                                                    stor42D7[stor202.length] = depositId + 1
                                                    depositsByWithdrawal[address(arg2)].field_0++
                                                    depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                    return (depositId + 1)
                                                if (0 / 10^uint8(ext_call.return_data[0])) - msg.value <= 0:
                                                    require ext_code.size(arg1)
                                                    staticcall arg1.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(arg1):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    mem[(32 * _57) + ceil32(return_data.size) + 516 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                    mem[(32 * _57) + ceil32(return_data.size) + 640 len 4] = uint32(arg3)
                                                    call arg1 with:
                                                         gas gas_remaining wei
                                                        args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + 612 len 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                            require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                            if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[(32 * _57) + ceil32(return_data.size) + 626 len 14],
                                                                            uint32(arg3),
                                                                            mem[(32 * _57) + ceil32(return_data.size) + 644 len 4]
                                                    else:
                                                        mem[(32 * _57) + ceil32(return_data.size) + 548 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[(32 * _57) + ceil32(return_data.size) + 548]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 627 len 22]
                                                    require ext_code.size(arg1)
                                                    staticcall arg1.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    depositId++
                                                    lockedToken[stor201 + 1].field_0 = arg1
                                                    lockedToken[stor201 + 1].field_256 = arg2
                                                    lockedToken[stor201 + 1].field_512 = 0
                                                    lockedToken[stor201 + 1].field_768 = arg4
                                                    lockedToken[stor201 + 1].field_1024 = 0
                                                    lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                    allDepositIds.length++
                                                    stor42D7[stor202.length] = depositId + 1
                                                    depositsByWithdrawal[address(arg2)].field_0++
                                                    depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                    return (depositId + 1)
                                                call msg.sender with:
                                                   value (0 / 10^uint8(ext_call.return_data[0])) - msg.value wei
                                                     gas gas_remaining wei
                                                require ext_code.size(arg1)
                                                staticcall arg1.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(arg1):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not return_data.size:
                                                    mem[(32 * _57) + ceil32(return_data.size) + 516 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                    mem[(32 * _57) + ceil32(return_data.size) + 640 len 4] = uint32(arg3)
                                                    call arg1 with:
                                                         gas gas_remaining wei
                                                        args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + 612 len 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                            require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                            if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[(32 * _57) + ceil32(return_data.size) + 626 len 14],
                                                                            uint32(arg3),
                                                                            mem[(32 * _57) + ceil32(return_data.size) + 644 len 4]
                                                    else:
                                                        mem[(32 * _57) + ceil32(return_data.size) + 548 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[(32 * _57) + ceil32(return_data.size) + 548]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 627 len 22]
                                                    require ext_code.size(arg1)
                                                    staticcall arg1.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    depositId++
                                                    lockedToken[stor201 + 1].field_0 = arg1
                                                    lockedToken[stor201 + 1].field_256 = arg2
                                                    lockedToken[stor201 + 1].field_512 = 0
                                                    lockedToken[stor201 + 1].field_768 = arg4
                                                    lockedToken[stor201 + 1].field_1024 = 0
                                                    lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                    allDepositIds.length++
                                                    stor42D7[stor202.length] = depositId + 1
                                                    depositsByWithdrawal[address(arg2)].field_0++
                                                    depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                    return (depositId + 1)
                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 517 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 641 len 4] = uint32(arg3)
                                                call arg1 with:
                                                     gas gas_remaining wei
                                                    args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                        require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                        if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 627 len 14],
                                                                        uint32(arg3),
                                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 645 len 4]
                                                    require ext_code.size(arg1)
                                                    staticcall arg1.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    depositId++
                                                    lockedToken[stor201 + 1].field_0 = arg1
                                                    lockedToken[stor201 + 1].field_256 = arg2
                                                    lockedToken[stor201 + 1].field_512 = 0
                                                    lockedToken[stor201 + 1].field_768 = arg4
                                                    lockedToken[stor201 + 1].field_1024 = 0
                                                    lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                    allDepositIds.length++
                                                    stor42D7[stor202.length] = depositId + 1
                                                    depositsByWithdrawal[address(arg2)].field_0++
                                                    depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                    return (depositId + 1)
                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 517] = return_data.size
                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 549 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = 32
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 554] = 32
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 'SafeERC20: low-level call failed'
                                                    revert with memory
                                                      from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                                       len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 549]:
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = 32
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 554] = 42
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586 len 42] = 0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565
                                                        revert with memory
                                                          from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                                           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = this.address
                                                require ext_code.size(arg1)
                                                staticcall arg1.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522 len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = 32
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 554] = 27
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 'SafeMath: addition overflow'
                                                    revert with memory
                                                      from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                                       len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                depositId++
                                                lockedToken[stor201 + 1].field_0 = arg1
                                                lockedToken[stor201 + 1].field_256 = arg2
                                                lockedToken[stor201 + 1].field_512 = 0
                                                lockedToken[stor201 + 1].field_768 = arg4
                                                lockedToken[stor201 + 1].field_1024 = 0
                                                lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                allDepositIds.length++
                                                stor42D7[stor202.length] = depositId + 1
                                                depositsByWithdrawal[address(arg2)].field_0++
                                                depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = depositId + 1
                                                return memory
                                                  from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32
                                            mem[(32 * _57) + ceil32(return_data.size) + 416 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                revert with 0, 'Fee transfer failed'
                                            if 0 / 10^uint8(ext_call.return_data[0]) > msg.value:
                                                require ext_code.size(arg1)
                                                staticcall arg1.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(arg1):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 517 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 641 len 4] = uint32(arg3)
                                                call arg1 with:
                                                     gas gas_remaining wei
                                                    args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                        require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                        if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 627 len 14],
                                                                        uint32(arg3),
                                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 645 len 4]
                                                    require ext_code.size(arg1)
                                                    staticcall arg1.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    depositId++
                                                    lockedToken[stor201 + 1].field_0 = arg1
                                                    lockedToken[stor201 + 1].field_256 = arg2
                                                    lockedToken[stor201 + 1].field_512 = 0
                                                    lockedToken[stor201 + 1].field_768 = arg4
                                                    lockedToken[stor201 + 1].field_1024 = 0
                                                    lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                    allDepositIds.length++
                                                    stor42D7[stor202.length] = depositId + 1
                                                    depositsByWithdrawal[address(arg2)].field_0++
                                                    depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                    return (depositId + 1)
                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 517] = return_data.size
                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 549 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = 32
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 554] = 32
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 'SafeERC20: low-level call failed'
                                                    revert with memory
                                                      from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                                       len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 549]:
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = 32
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 554] = 42
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586 len 42] = 0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565
                                                        revert with memory
                                                          from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                                           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = this.address
                                                require ext_code.size(arg1)
                                                staticcall arg1.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522 len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = 32
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 554] = 27
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 'SafeMath: addition overflow'
                                                    revert with memory
                                                      from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                                       len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                depositId++
                                                lockedToken[stor201 + 1].field_0 = arg1
                                                lockedToken[stor201 + 1].field_256 = arg2
                                                lockedToken[stor201 + 1].field_512 = 0
                                                lockedToken[stor201 + 1].field_768 = arg4
                                                lockedToken[stor201 + 1].field_1024 = 0
                                                lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                allDepositIds.length++
                                                stor42D7[stor202.length] = depositId + 1
                                                depositsByWithdrawal[address(arg2)].field_0++
                                                depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = depositId + 1
                                                return memory
                                                  from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32
                                            if (0 / 10^uint8(ext_call.return_data[0])) - msg.value <= 0:
                                                require ext_code.size(arg1)
                                                staticcall arg1.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(arg1):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 517 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 641 len 4] = uint32(arg3)
                                                call arg1 with:
                                                     gas gas_remaining wei
                                                    args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                        require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                        if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 627 len 14],
                                                                        uint32(arg3),
                                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 645 len 4]
                                                else:
                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 549 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 549]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 628 len 22]
                                            else:
                                                call msg.sender with:
                                                   value (0 / 10^uint8(ext_call.return_data[0])) - msg.value wei
                                                     gas gas_remaining wei
                                                if not return_data.size:
                                                    require ext_code.size(arg1)
                                                    staticcall arg1.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(arg1):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 517 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 641 len 4] = uint32(arg3)
                                                    call arg1 with:
                                                         gas gas_remaining wei
                                                        args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                            require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                            if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 627 len 14],
                                                                            uint32(arg3),
                                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 645 len 4]
                                                        require ext_code.size(arg1)
                                                        staticcall arg1.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        depositId++
                                                        lockedToken[stor201 + 1].field_0 = arg1
                                                        lockedToken[stor201 + 1].field_256 = arg2
                                                        lockedToken[stor201 + 1].field_512 = 0
                                                        lockedToken[stor201 + 1].field_768 = arg4
                                                        lockedToken[stor201 + 1].field_1024 = 0
                                                        lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                        allDepositIds.length++
                                                        stor42D7[stor202.length] = depositId + 1
                                                        depositsByWithdrawal[address(arg2)].field_0++
                                                        depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                        return (depositId + 1)
                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 517] = return_data.size
                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 549 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = 32
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 554] = 32
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 'SafeERC20: low-level call failed'
                                                        revert with memory
                                                          from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                                           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 549]:
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 554] = 42
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586 len 42] = 0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565
                                                            revert with memory
                                                              from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = this.address
                                                    require ext_code.size(arg1)
                                                    staticcall arg1.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522 len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = 32
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 554] = 27
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 'SafeMath: addition overflow'
                                                        revert with memory
                                                          from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                                           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                    depositId++
                                                    lockedToken[stor201 + 1].field_0 = arg1
                                                    lockedToken[stor201 + 1].field_256 = arg2
                                                    lockedToken[stor201 + 1].field_512 = 0
                                                    lockedToken[stor201 + 1].field_768 = arg4
                                                    lockedToken[stor201 + 1].field_1024 = 0
                                                    lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                    allDepositIds.length++
                                                    stor42D7[stor202.length] = depositId + 1
                                                    depositsByWithdrawal[address(arg2)].field_0++
                                                    depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = depositId + 1
                                                    return memory
                                                      from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                                       len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32
                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 385] = return_data.size
                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 417 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 390] = this.address
                                                require ext_code.size(arg1)
                                                staticcall arg1.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 390 len (5 * ceil32(return_data.size)) + 32]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 486] = arg3
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(arg1):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518 len floor32((5 * ceil32(return_data.size)) + 100)] = unknown_0x23b872dd(?????), msg.sender, address(this.address), mem[(32 * _57) + (4 * ceil32(return_data.size)) + 486 len floor32((5 * ceil32(return_data.size)) + 100) - 68]
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + floor32((5 * ceil32(return_data.size)) + 100) + -((5 * ceil32(return_data.size)) + 100 % 32) + 550 len (5 * ceil32(return_data.size)) + 100 % 32] = mem[(32 * _57) + (4 * ceil32(return_data.size)) + -((5 * ceil32(return_data.size)) + 100 % 32) + floor32((5 * ceil32(return_data.size)) + 100) + 450 len (5 * ceil32(return_data.size)) + 100 % 32]
                                                call arg1.mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522 len (5 * ceil32(return_data.size)) + 96]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                        require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                        if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 628 len 22]
                                                else:
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 550 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[(32 * _57) + (4 * ceil32(return_data.size)) + 550]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 629 len 22]
                                        else:
                                            if not (0 / 10^uint8(ext_call.return_data[0])) - msg.value:
                                                if not 0 / 10^uint8(ext_call.return_data[0]):
                                                    revert with 0, 'SafeMath: division by zero'
                                                if 0 / 0 / 10^uint8(ext_call.return_data[0]) > 5:
                                                    revert with 0, 'Fee Not Met'
                                                if 0 / 10^uint8(ext_call.return_data[0]) > msg.value:
                                                    call companyWalletAddress with:
                                                       value msg.value wei
                                                         gas gas_remaining wei
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'Fee transfer failed'
                                                        if 0 / 10^uint8(ext_call.return_data[0]) > msg.value:
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                                revert with 0, 'SafeERC20: call to non-contract'
                                                            if not ext_code.hash(arg1):
                                                                revert with 0, 'SafeERC20: call to non-contract'
                                                            mem[(32 * _57) + ceil32(return_data.size) + 580 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                            mem[(32 * _57) + ceil32(return_data.size) + 704 len 4] = uint32(arg3)
                                                            call arg1 with:
                                                                 gas gas_remaining wei
                                                                args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + 676 len 4]
                                                            if not return_data.size:
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                    require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                    if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + 690 len 14],
                                                                                    uint32(arg3),
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + 708 len 4]
                                                            else:
                                                                mem[(32 * _57) + ceil32(return_data.size) + 612 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if return_data.size:
                                                                    require return_data.size >= 32
                                                                    if not mem[(32 * _57) + ceil32(return_data.size) + 612]:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 22]
                                                        else:
                                                            if (0 / 10^uint8(ext_call.return_data[0])) - msg.value <= 0:
                                                                require ext_code.size(arg1)
                                                                staticcall arg1.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args this.address
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                require return_data.size >= 32
                                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                                if not ext_code.hash(arg1):
                                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                                mem[(32 * _57) + ceil32(return_data.size) + 580 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                                mem[(32 * _57) + ceil32(return_data.size) + 704 len 4] = uint32(arg3)
                                                                call arg1 with:
                                                                     gas gas_remaining wei
                                                                    args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + 676 len 4]
                                                                if not return_data.size:
                                                                    if not ext_call.success:
                                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                                    if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                        require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                        if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                            revert with 0, 
                                                                                        32,
                                                                                        42,
                                                                                        0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                        mem[(32 * _57) + ceil32(return_data.size) + 690 len 14],
                                                                                        uint32(arg3),
                                                                                        mem[(32 * _57) + ceil32(return_data.size) + 708 len 4]
                                                                else:
                                                                    mem[(32 * _57) + ceil32(return_data.size) + 612 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    if not ext_call.success:
                                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                                    if return_data.size:
                                                                        require return_data.size >= 32
                                                                        if not mem[(32 * _57) + ceil32(return_data.size) + 612]:
                                                                            revert with 0, 
                                                                                        32,
                                                                                        42,
                                                                                        0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 22]
                                                            else:
                                                                call msg.sender with:
                                                                   value (0 / 10^uint8(ext_call.return_data[0])) - msg.value wei
                                                                     gas gas_remaining wei
                                                                require ext_code.size(arg1)
                                                                staticcall arg1.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args this.address
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                require return_data.size >= 32
                                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                                if not ext_code.hash(arg1):
                                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                                if not return_data.size:
                                                                    mem[(32 * _57) + ceil32(return_data.size) + 580 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                                    mem[(32 * _57) + ceil32(return_data.size) + 704 len 4] = uint32(arg3)
                                                                    call arg1 with:
                                                                         gas gas_remaining wei
                                                                        args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + 676 len 4]
                                                                    if not return_data.size:
                                                                        if not ext_call.success:
                                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                                        if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                            require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                            if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                                revert with 0, 
                                                                                            32,
                                                                                            42,
                                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                            mem[(32 * _57) + ceil32(return_data.size) + 690 len 14],
                                                                                            uint32(arg3),
                                                                                            mem[(32 * _57) + ceil32(return_data.size) + 708 len 4]
                                                                    else:
                                                                        mem[(32 * _57) + ceil32(return_data.size) + 612 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                        if not ext_call.success:
                                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                                        if return_data.size:
                                                                            require return_data.size >= 32
                                                                            if not mem[(32 * _57) + ceil32(return_data.size) + 612]:
                                                                                revert with 0, 
                                                                                            32,
                                                                                            42,
                                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 22]
                                                                else:
                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 705 len 4] = uint32(arg3)
                                                                    call arg1 with:
                                                                         gas gas_remaining wei
                                                                        args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 677 len 4]
                                                                    if not return_data.size:
                                                                        if not ext_call.success:
                                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                                        if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                            require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                            if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                                revert with 0, 
                                                                                            32,
                                                                                            42,
                                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 14],
                                                                                            uint32(arg3),
                                                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 709 len 4]
                                                                    else:
                                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                        if not ext_call.success:
                                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                                        if return_data.size:
                                                                            require return_data.size >= 32
                                                                            if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613]:
                                                                                revert with 0, 
                                                                                            32,
                                                                                            42,
                                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 692 len 22]
                                                    else:
                                                        mem[(32 * _57) + ceil32(return_data.size) + 480 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'Fee transfer failed'
                                                        if 0 / 10^uint8(ext_call.return_data[0]) > msg.value:
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                                revert with 0, 'SafeERC20: call to non-contract'
                                                            if not ext_code.hash(arg1):
                                                                revert with 0, 'SafeERC20: call to non-contract'
                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 705 len 4] = uint32(arg3)
                                                            call arg1 with:
                                                                 gas gas_remaining wei
                                                                args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 677 len 4]
                                                            if not return_data.size:
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                    require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                    if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 14],
                                                                                    uint32(arg3),
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 709 len 4]
                                                                require ext_code.size(arg1)
                                                                staticcall arg1.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args this.address
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                require return_data.size >= 32
                                                                if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                depositId++
                                                                lockedToken[stor201 + 1].field_0 = arg1
                                                                lockedToken[stor201 + 1].field_256 = arg2
                                                                lockedToken[stor201 + 1].field_512 = 0
                                                                lockedToken[stor201 + 1].field_768 = arg4
                                                                lockedToken[stor201 + 1].field_1024 = 0
                                                                lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                                allDepositIds.length++
                                                                stor42D7[stor202.length] = depositId + 1
                                                                depositsByWithdrawal[address(arg2)].field_0++
                                                                depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                                return (depositId + 1)
                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581] = return_data.size
                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            if not ext_call.success:
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 32
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650] = 'SafeERC20: low-level call failed'
                                                                revert with memory
                                                                  from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                            if return_data.size:
                                                                require return_data.size >= 32
                                                                if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613]:
                                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 42
                                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650 len 42] = 0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565
                                                                    revert with memory
                                                                      from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                                       len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = this.address
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586 len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 27
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650] = 'SafeMath: addition overflow'
                                                                revert with memory
                                                                  from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                            depositId++
                                                            lockedToken[stor201 + 1].field_0 = arg1
                                                            lockedToken[stor201 + 1].field_256 = arg2
                                                            lockedToken[stor201 + 1].field_512 = 0
                                                            lockedToken[stor201 + 1].field_768 = arg4
                                                            lockedToken[stor201 + 1].field_1024 = 0
                                                            lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                            allDepositIds.length++
                                                            stor42D7[stor202.length] = depositId + 1
                                                            depositsByWithdrawal[address(arg2)].field_0++
                                                            depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = depositId + 1
                                                            return memory
                                                              from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32
                                                        if (0 / 10^uint8(ext_call.return_data[0])) - msg.value <= 0:
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                                revert with 0, 'SafeERC20: call to non-contract'
                                                            if not ext_code.hash(arg1):
                                                                revert with 0, 'SafeERC20: call to non-contract'
                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 705 len 4] = uint32(arg3)
                                                            call arg1 with:
                                                                 gas gas_remaining wei
                                                                args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 677 len 4]
                                                            if not return_data.size:
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                    require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                    if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 14],
                                                                                    uint32(arg3),
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 709 len 4]
                                                                require ext_code.size(arg1)
                                                                staticcall arg1.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args this.address
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                require return_data.size >= 32
                                                                if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                depositId++
                                                                lockedToken[stor201 + 1].field_0 = arg1
                                                                lockedToken[stor201 + 1].field_256 = arg2
                                                                lockedToken[stor201 + 1].field_512 = 0
                                                                lockedToken[stor201 + 1].field_768 = arg4
                                                                lockedToken[stor201 + 1].field_1024 = 0
                                                                lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                                allDepositIds.length++
                                                                stor42D7[stor202.length] = depositId + 1
                                                                depositsByWithdrawal[address(arg2)].field_0++
                                                                depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                                return (depositId + 1)
                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581] = return_data.size
                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            if not ext_call.success:
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 32
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650] = 'SafeERC20: low-level call failed'
                                                                revert with memory
                                                                  from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                            if return_data.size:
                                                                require return_data.size >= 32
                                                                if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613]:
                                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 42
                                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650 len 42] = 0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565
                                                                    revert with memory
                                                                      from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                                       len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = this.address
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586 len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 27
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650] = 'SafeMath: addition overflow'
                                                                revert with memory
                                                                  from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                            depositId++
                                                            lockedToken[stor201 + 1].field_0 = arg1
                                                            lockedToken[stor201 + 1].field_256 = arg2
                                                            lockedToken[stor201 + 1].field_512 = 0
                                                            lockedToken[stor201 + 1].field_768 = arg4
                                                            lockedToken[stor201 + 1].field_1024 = 0
                                                            lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                            allDepositIds.length++
                                                            stor42D7[stor202.length] = depositId + 1
                                                            depositsByWithdrawal[address(arg2)].field_0++
                                                            depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = depositId + 1
                                                            return memory
                                                              from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32
                                                        call msg.sender with:
                                                           value (0 / 10^uint8(ext_call.return_data[0])) - msg.value wei
                                                             gas gas_remaining wei
                                                        if not return_data.size:
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                                revert with 0, 'SafeERC20: call to non-contract'
                                                            if not ext_code.hash(arg1):
                                                                revert with 0, 'SafeERC20: call to non-contract'
                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 705 len 4] = uint32(arg3)
                                                            call arg1 with:
                                                                 gas gas_remaining wei
                                                                args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 677 len 4]
                                                            if not return_data.size:
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                    require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                    if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 14],
                                                                                    uint32(arg3),
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 709 len 4]
                                                                require ext_code.size(arg1)
                                                                staticcall arg1.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args this.address
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                require return_data.size >= 32
                                                                if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                depositId++
                                                                lockedToken[stor201 + 1].field_0 = arg1
                                                                lockedToken[stor201 + 1].field_256 = arg2
                                                                lockedToken[stor201 + 1].field_512 = 0
                                                                lockedToken[stor201 + 1].field_768 = arg4
                                                                lockedToken[stor201 + 1].field_1024 = 0
                                                                lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                                allDepositIds.length++
                                                                stor42D7[stor202.length] = depositId + 1
                                                                depositsByWithdrawal[address(arg2)].field_0++
                                                                depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                                return (depositId + 1)
                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581] = return_data.size
                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            if not ext_call.success:
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 32
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650] = 'SafeERC20: low-level call failed'
                                                                revert with memory
                                                                  from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                            if return_data.size:
                                                                require return_data.size >= 32
                                                                if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613]:
                                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 42
                                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650 len 42] = 0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565
                                                                    revert with memory
                                                                      from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                                       len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = this.address
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586 len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 27
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650] = 'SafeMath: addition overflow'
                                                                revert with memory
                                                                  from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                            depositId++
                                                            lockedToken[stor201 + 1].field_0 = arg1
                                                            lockedToken[stor201 + 1].field_256 = arg2
                                                            lockedToken[stor201 + 1].field_512 = 0
                                                            lockedToken[stor201 + 1].field_768 = arg4
                                                            lockedToken[stor201 + 1].field_1024 = 0
                                                            lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                            allDepositIds.length++
                                                            stor42D7[stor202.length] = depositId + 1
                                                            depositsByWithdrawal[address(arg2)].field_0++
                                                            depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = depositId + 1
                                                            return memory
                                                              from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 449] = return_data.size
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 481 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 454] = this.address
                                                        require ext_code.size(arg1)
                                                        staticcall arg1.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 454 len (5 * ceil32(return_data.size)) + 32]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 550] = arg3
                                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        if not ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582 len floor32((5 * ceil32(return_data.size)) + 100)] = unknown_0x23b872dd(?????), msg.sender, address(this.address), mem[(32 * _57) + (4 * ceil32(return_data.size)) + 550 len floor32((5 * ceil32(return_data.size)) + 100) - 68]
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + floor32((5 * ceil32(return_data.size)) + 100) + -((5 * ceil32(return_data.size)) + 100 % 32) + 614 len (5 * ceil32(return_data.size)) + 100 % 32] = mem[(32 * _57) + (4 * ceil32(return_data.size)) + -((5 * ceil32(return_data.size)) + 100 % 32) + floor32((5 * ceil32(return_data.size)) + 100) + 514 len (5 * ceil32(return_data.size)) + 100 % 32]
                                                        call arg1.mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582 len 4] with:
                                                             gas gas_remaining wei
                                                            args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586 len (5 * ceil32(return_data.size)) + 96]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                revert with 0, 'SafeERC20: low-level call failed'
                                                            if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 692 len 22]
                                                        else:
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 614 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            if not ext_call.success:
                                                                revert with 0, 'SafeERC20: low-level call failed'
                                                            if return_data.size:
                                                                require return_data.size >= 32
                                                                if not mem[(32 * _57) + (4 * ceil32(return_data.size)) + 614]:
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 693 len 22]
                                                else:
                                                    call companyWalletAddress with:
                                                       value 0 / 10^uint8(ext_call.return_data[0]) wei
                                                         gas gas_remaining wei
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'Fee transfer failed'
                                                        if 0 / 10^uint8(ext_call.return_data[0]) > msg.value:
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                                revert with 0, 'SafeERC20: call to non-contract'
                                                            if not ext_code.hash(arg1):
                                                                revert with 0, 'SafeERC20: call to non-contract'
                                                            mem[(32 * _57) + ceil32(return_data.size) + 580 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                            mem[(32 * _57) + ceil32(return_data.size) + 704 len 4] = uint32(arg3)
                                                            call arg1 with:
                                                                 gas gas_remaining wei
                                                                args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + 676 len 4]
                                                            if not return_data.size:
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                    require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                    if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + 690 len 14],
                                                                                    uint32(arg3),
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + 708 len 4]
                                                            else:
                                                                mem[(32 * _57) + ceil32(return_data.size) + 612 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if return_data.size:
                                                                    require return_data.size >= 32
                                                                    if not mem[(32 * _57) + ceil32(return_data.size) + 612]:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 22]
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            depositId++
                                                            lockedToken[stor201 + 1].field_0 = arg1
                                                            lockedToken[stor201 + 1].field_256 = arg2
                                                            lockedToken[stor201 + 1].field_512 = 0
                                                            lockedToken[stor201 + 1].field_768 = arg4
                                                            lockedToken[stor201 + 1].field_1024 = 0
                                                            lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                            allDepositIds.length++
                                                            stor42D7[stor202.length] = depositId + 1
                                                            depositsByWithdrawal[address(arg2)].field_0++
                                                            depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                            return (depositId + 1)
                                                        if (0 / 10^uint8(ext_call.return_data[0])) - msg.value <= 0:
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                                revert with 0, 'SafeERC20: call to non-contract'
                                                            if not ext_code.hash(arg1):
                                                                revert with 0, 'SafeERC20: call to non-contract'
                                                            mem[(32 * _57) + ceil32(return_data.size) + 580 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                            mem[(32 * _57) + ceil32(return_data.size) + 704 len 4] = uint32(arg3)
                                                            call arg1 with:
                                                                 gas gas_remaining wei
                                                                args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + 676 len 4]
                                                            if not return_data.size:
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                    require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                    if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + 690 len 14],
                                                                                    uint32(arg3),
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + 708 len 4]
                                                            else:
                                                                mem[(32 * _57) + ceil32(return_data.size) + 612 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if return_data.size:
                                                                    require return_data.size >= 32
                                                                    if not mem[(32 * _57) + ceil32(return_data.size) + 612]:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 22]
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            depositId++
                                                            lockedToken[stor201 + 1].field_0 = arg1
                                                            lockedToken[stor201 + 1].field_256 = arg2
                                                            lockedToken[stor201 + 1].field_512 = 0
                                                            lockedToken[stor201 + 1].field_768 = arg4
                                                            lockedToken[stor201 + 1].field_1024 = 0
                                                            lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                            allDepositIds.length++
                                                            stor42D7[stor202.length] = depositId + 1
                                                            depositsByWithdrawal[address(arg2)].field_0++
                                                            depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                            return (depositId + 1)
                                                        call msg.sender with:
                                                           value (0 / 10^uint8(ext_call.return_data[0])) - msg.value wei
                                                             gas gas_remaining wei
                                                        require ext_code.size(arg1)
                                                        staticcall arg1.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        if not ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        if not return_data.size:
                                                            mem[(32 * _57) + ceil32(return_data.size) + 580 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                            mem[(32 * _57) + ceil32(return_data.size) + 704 len 4] = uint32(arg3)
                                                            call arg1 with:
                                                                 gas gas_remaining wei
                                                                args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + 676 len 4]
                                                            if not return_data.size:
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                    require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                    if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + 690 len 14],
                                                                                    uint32(arg3),
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + 708 len 4]
                                                            else:
                                                                mem[(32 * _57) + ceil32(return_data.size) + 612 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if return_data.size:
                                                                    require return_data.size >= 32
                                                                    if not mem[(32 * _57) + ceil32(return_data.size) + 612]:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 22]
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            depositId++
                                                            lockedToken[stor201 + 1].field_0 = arg1
                                                            lockedToken[stor201 + 1].field_256 = arg2
                                                            lockedToken[stor201 + 1].field_512 = 0
                                                            lockedToken[stor201 + 1].field_768 = arg4
                                                            lockedToken[stor201 + 1].field_1024 = 0
                                                            lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                            allDepositIds.length++
                                                            stor42D7[stor202.length] = depositId + 1
                                                            depositsByWithdrawal[address(arg2)].field_0++
                                                            depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                            return (depositId + 1)
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 705 len 4] = uint32(arg3)
                                                        call arg1 with:
                                                             gas gas_remaining wei
                                                            args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 677 len 4]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                revert with 0, 'SafeERC20: low-level call failed'
                                                            if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 14],
                                                                                uint32(arg3),
                                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 709 len 4]
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            depositId++
                                                            lockedToken[stor201 + 1].field_0 = arg1
                                                            lockedToken[stor201 + 1].field_256 = arg2
                                                            lockedToken[stor201 + 1].field_512 = 0
                                                            lockedToken[stor201 + 1].field_768 = arg4
                                                            lockedToken[stor201 + 1].field_1024 = 0
                                                            lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                            allDepositIds.length++
                                                            stor42D7[stor202.length] = depositId + 1
                                                            depositsByWithdrawal[address(arg2)].field_0++
                                                            depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                            return (depositId + 1)
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581] = return_data.size
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650] = 'SafeERC20: low-level call failed'
                                                            revert with memory
                                                              from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613]:
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 42
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650 len 42] = 0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565
                                                                revert with memory
                                                                  from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = this.address
                                                        require ext_code.size(arg1)
                                                        staticcall arg1.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586 len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 27
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650] = 'SafeMath: addition overflow'
                                                            revert with memory
                                                              from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                        depositId++
                                                        lockedToken[stor201 + 1].field_0 = arg1
                                                        lockedToken[stor201 + 1].field_256 = arg2
                                                        lockedToken[stor201 + 1].field_512 = 0
                                                        lockedToken[stor201 + 1].field_768 = arg4
                                                        lockedToken[stor201 + 1].field_1024 = 0
                                                        lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                        allDepositIds.length++
                                                        stor42D7[stor202.length] = depositId + 1
                                                        depositsByWithdrawal[address(arg2)].field_0++
                                                        depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = depositId + 1
                                                        return memory
                                                          from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32
                                                    mem[(32 * _57) + ceil32(return_data.size) + 480 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'Fee transfer failed'
                                                    if 0 / 10^uint8(ext_call.return_data[0]) > msg.value:
                                                        require ext_code.size(arg1)
                                                        staticcall arg1.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        if not ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 705 len 4] = uint32(arg3)
                                                        call arg1 with:
                                                             gas gas_remaining wei
                                                            args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 677 len 4]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                revert with 0, 'SafeERC20: low-level call failed'
                                                            if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 14],
                                                                                uint32(arg3),
                                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 709 len 4]
                                                        else:
                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            if not ext_call.success:
                                                                revert with 0, 'SafeERC20: low-level call failed'
                                                            if return_data.size:
                                                                require return_data.size >= 32
                                                                if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613]:
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 692 len 22]
                                                    else:
                                                        if (0 / 10^uint8(ext_call.return_data[0])) - msg.value <= 0:
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                                revert with 0, 'SafeERC20: call to non-contract'
                                                            if not ext_code.hash(arg1):
                                                                revert with 0, 'SafeERC20: call to non-contract'
                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 705 len 4] = uint32(arg3)
                                                            call arg1 with:
                                                                 gas gas_remaining wei
                                                                args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 677 len 4]
                                                            if not return_data.size:
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                    require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                    if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 14],
                                                                                    uint32(arg3),
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 709 len 4]
                                                                require ext_code.size(arg1)
                                                                staticcall arg1.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args this.address
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                require return_data.size >= 32
                                                                if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                depositId++
                                                                lockedToken[stor201 + 1].field_0 = arg1
                                                                lockedToken[stor201 + 1].field_256 = arg2
                                                                lockedToken[stor201 + 1].field_512 = 0
                                                                lockedToken[stor201 + 1].field_768 = arg4
                                                                lockedToken[stor201 + 1].field_1024 = 0
                                                                lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                                allDepositIds.length++
                                                                stor42D7[stor202.length] = depositId + 1
                                                                depositsByWithdrawal[address(arg2)].field_0++
                                                                depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                                return (depositId + 1)
                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581] = return_data.size
                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            if not ext_call.success:
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 32
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650] = 'SafeERC20: low-level call failed'
                                                                revert with memory
                                                                  from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                            if return_data.size:
                                                                require return_data.size >= 32
                                                                if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613]:
                                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 42
                                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650 len 42] = 0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565
                                                                    revert with memory
                                                                      from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                                       len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = this.address
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586 len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 27
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650] = 'SafeMath: addition overflow'
                                                                revert with memory
                                                                  from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                            depositId++
                                                            lockedToken[stor201 + 1].field_0 = arg1
                                                            lockedToken[stor201 + 1].field_256 = arg2
                                                            lockedToken[stor201 + 1].field_512 = 0
                                                            lockedToken[stor201 + 1].field_768 = arg4
                                                            lockedToken[stor201 + 1].field_1024 = 0
                                                            lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                            allDepositIds.length++
                                                            stor42D7[stor202.length] = depositId + 1
                                                            depositsByWithdrawal[address(arg2)].field_0++
                                                            depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = depositId + 1
                                                            return memory
                                                              from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32
                                                        call msg.sender with:
                                                           value (0 / 10^uint8(ext_call.return_data[0])) - msg.value wei
                                                             gas gas_remaining wei
                                                        if not return_data.size:
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                                revert with 0, 'SafeERC20: call to non-contract'
                                                            if not ext_code.hash(arg1):
                                                                revert with 0, 'SafeERC20: call to non-contract'
                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 705 len 4] = uint32(arg3)
                                                            call arg1 with:
                                                                 gas gas_remaining wei
                                                                args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 677 len 4]
                                                            if not return_data.size:
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                    require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                    if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 14],
                                                                                    uint32(arg3),
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 709 len 4]
                                                                require ext_code.size(arg1)
                                                                staticcall arg1.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args this.address
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                require return_data.size >= 32
                                                                if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                depositId++
                                                                lockedToken[stor201 + 1].field_0 = arg1
                                                                lockedToken[stor201 + 1].field_256 = arg2
                                                                lockedToken[stor201 + 1].field_512 = 0
                                                                lockedToken[stor201 + 1].field_768 = arg4
                                                                lockedToken[stor201 + 1].field_1024 = 0
                                                                lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                                allDepositIds.length++
                                                                stor42D7[stor202.length] = depositId + 1
                                                                depositsByWithdrawal[address(arg2)].field_0++
                                                                depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                                return (depositId + 1)
                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581] = return_data.size
                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            if not ext_call.success:
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 32
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650] = 'SafeERC20: low-level call failed'
                                                                revert with memory
                                                                  from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                            if return_data.size:
                                                                require return_data.size >= 32
                                                                if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613]:
                                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 42
                                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650 len 42] = 0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565
                                                                    revert with memory
                                                                      from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                                       len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = this.address
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586 len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 27
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650] = 'SafeMath: addition overflow'
                                                                revert with memory
                                                                  from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                            depositId++
                                                            lockedToken[stor201 + 1].field_0 = arg1
                                                            lockedToken[stor201 + 1].field_256 = arg2
                                                            lockedToken[stor201 + 1].field_512 = 0
                                                            lockedToken[stor201 + 1].field_768 = arg4
                                                            lockedToken[stor201 + 1].field_1024 = 0
                                                            lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                            allDepositIds.length++
                                                            stor42D7[stor202.length] = depositId + 1
                                                            depositsByWithdrawal[address(arg2)].field_0++
                                                            depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = depositId + 1
                                                            return memory
                                                              from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 449] = return_data.size
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 481 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 454] = this.address
                                                        require ext_code.size(arg1)
                                                        staticcall arg1.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 454 len (5 * ceil32(return_data.size)) + 32]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 550] = arg3
                                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        if not ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582 len floor32((5 * ceil32(return_data.size)) + 100)] = unknown_0x23b872dd(?????), msg.sender, address(this.address), mem[(32 * _57) + (4 * ceil32(return_data.size)) + 550 len floor32((5 * ceil32(return_data.size)) + 100) - 68]
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + floor32((5 * ceil32(return_data.size)) + 100) + -((5 * ceil32(return_data.size)) + 100 % 32) + 614 len (5 * ceil32(return_data.size)) + 100 % 32] = mem[(32 * _57) + (4 * ceil32(return_data.size)) + -((5 * ceil32(return_data.size)) + 100 % 32) + floor32((5 * ceil32(return_data.size)) + 100) + 514 len (5 * ceil32(return_data.size)) + 100 % 32]
                                                        call arg1.mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582 len 4] with:
                                                             gas gas_remaining wei
                                                            args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586 len (5 * ceil32(return_data.size)) + 96]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                revert with 0, 'SafeERC20: low-level call failed'
                                                            if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 692 len 22]
                                                        else:
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 614 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            if not ext_call.success:
                                                                revert with 0, 'SafeERC20: low-level call failed'
                                                            if return_data.size:
                                                                require return_data.size >= 32
                                                                if not mem[(32 * _57) + (4 * ceil32(return_data.size)) + 614]:
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 693 len 22]
                                            else:
                                                if (100 * 0 / 10^uint8(ext_call.return_data[0])) - (100 * msg.value) / (0 / 10^uint8(ext_call.return_data[0])) - msg.value != 100:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _57) + ceil32(return_data.size) + 485 len 31]
                                                if not 0 / 10^uint8(ext_call.return_data[0]):
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (100 * 0 / 10^uint8(ext_call.return_data[0])) - (100 * msg.value) / 0 / 10^uint8(ext_call.return_data[0]) > 5:
                                                    revert with 0, 'Fee Not Met'
                                                if 0 / 10^uint8(ext_call.return_data[0]) > msg.value:
                                                    call companyWalletAddress with:
                                                       value msg.value wei
                                                         gas gas_remaining wei
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'Fee transfer failed'
                                                        if 0 / 10^uint8(ext_call.return_data[0]) > msg.value:
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                                revert with 0, 'SafeERC20: call to non-contract'
                                                            if not ext_code.hash(arg1):
                                                                revert with 0, 'SafeERC20: call to non-contract'
                                                            mem[(32 * _57) + ceil32(return_data.size) + 580 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                            mem[(32 * _57) + ceil32(return_data.size) + 704 len 4] = uint32(arg3)
                                                            call arg1 with:
                                                                 gas gas_remaining wei
                                                                args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + 676 len 4]
                                                            if not return_data.size:
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                    require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                    if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + 690 len 14],
                                                                                    uint32(arg3),
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + 708 len 4]
                                                            else:
                                                                mem[(32 * _57) + ceil32(return_data.size) + 612 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if return_data.size:
                                                                    require return_data.size >= 32
                                                                    if not mem[(32 * _57) + ceil32(return_data.size) + 612]:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 22]
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            depositId++
                                                            lockedToken[stor201 + 1].field_0 = arg1
                                                            lockedToken[stor201 + 1].field_256 = arg2
                                                            lockedToken[stor201 + 1].field_512 = 0
                                                            lockedToken[stor201 + 1].field_768 = arg4
                                                            lockedToken[stor201 + 1].field_1024 = 0
                                                            lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                            allDepositIds.length++
                                                            stor42D7[stor202.length] = depositId + 1
                                                            depositsByWithdrawal[address(arg2)].field_0++
                                                            depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                            return (depositId + 1)
                                                        if (0 / 10^uint8(ext_call.return_data[0])) - msg.value <= 0:
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                                revert with 0, 'SafeERC20: call to non-contract'
                                                            if not ext_code.hash(arg1):
                                                                revert with 0, 'SafeERC20: call to non-contract'
                                                            mem[(32 * _57) + ceil32(return_data.size) + 580 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                            mem[(32 * _57) + ceil32(return_data.size) + 704 len 4] = uint32(arg3)
                                                            call arg1 with:
                                                                 gas gas_remaining wei
                                                                args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + 676 len 4]
                                                            if not return_data.size:
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                    require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                    if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + 690 len 14],
                                                                                    uint32(arg3),
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + 708 len 4]
                                                            else:
                                                                mem[(32 * _57) + ceil32(return_data.size) + 612 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if return_data.size:
                                                                    require return_data.size >= 32
                                                                    if not mem[(32 * _57) + ceil32(return_data.size) + 612]:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 22]
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            depositId++
                                                            lockedToken[stor201 + 1].field_0 = arg1
                                                            lockedToken[stor201 + 1].field_256 = arg2
                                                            lockedToken[stor201 + 1].field_512 = 0
                                                            lockedToken[stor201 + 1].field_768 = arg4
                                                            lockedToken[stor201 + 1].field_1024 = 0
                                                            lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                            allDepositIds.length++
                                                            stor42D7[stor202.length] = depositId + 1
                                                            depositsByWithdrawal[address(arg2)].field_0++
                                                            depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                            return (depositId + 1)
                                                        call msg.sender with:
                                                           value (0 / 10^uint8(ext_call.return_data[0])) - msg.value wei
                                                             gas gas_remaining wei
                                                        require ext_code.size(arg1)
                                                        staticcall arg1.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        if not ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        if not return_data.size:
                                                            mem[(32 * _57) + ceil32(return_data.size) + 580 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                            mem[(32 * _57) + ceil32(return_data.size) + 704 len 4] = uint32(arg3)
                                                            call arg1 with:
                                                                 gas gas_remaining wei
                                                                args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + 676 len 4]
                                                            if not return_data.size:
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                    require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                    if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + 690 len 14],
                                                                                    uint32(arg3),
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + 708 len 4]
                                                            else:
                                                                mem[(32 * _57) + ceil32(return_data.size) + 612 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if return_data.size:
                                                                    require return_data.size >= 32
                                                                    if not mem[(32 * _57) + ceil32(return_data.size) + 612]:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 22]
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            depositId++
                                                            lockedToken[stor201 + 1].field_0 = arg1
                                                            lockedToken[stor201 + 1].field_256 = arg2
                                                            lockedToken[stor201 + 1].field_512 = 0
                                                            lockedToken[stor201 + 1].field_768 = arg4
                                                            lockedToken[stor201 + 1].field_1024 = 0
                                                            lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                            allDepositIds.length++
                                                            stor42D7[stor202.length] = depositId + 1
                                                            depositsByWithdrawal[address(arg2)].field_0++
                                                            depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                            return (depositId + 1)
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 705 len 4] = uint32(arg3)
                                                        call arg1 with:
                                                             gas gas_remaining wei
                                                            args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 677 len 4]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                revert with 0, 'SafeERC20: low-level call failed'
                                                            if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 14],
                                                                                uint32(arg3),
                                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 709 len 4]
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            depositId++
                                                            lockedToken[stor201 + 1].field_0 = arg1
                                                            lockedToken[stor201 + 1].field_256 = arg2
                                                            lockedToken[stor201 + 1].field_512 = 0
                                                            lockedToken[stor201 + 1].field_768 = arg4
                                                            lockedToken[stor201 + 1].field_1024 = 0
                                                            lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                            allDepositIds.length++
                                                            stor42D7[stor202.length] = depositId + 1
                                                            depositsByWithdrawal[address(arg2)].field_0++
                                                            depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                            return (depositId + 1)
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581] = return_data.size
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650] = 'SafeERC20: low-level call failed'
                                                            revert with memory
                                                              from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613]:
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 42
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650 len 42] = 0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565
                                                                revert with memory
                                                                  from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = this.address
                                                        require ext_code.size(arg1)
                                                        staticcall arg1.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586 len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 27
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650] = 'SafeMath: addition overflow'
                                                            revert with memory
                                                              from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                        depositId++
                                                        lockedToken[stor201 + 1].field_0 = arg1
                                                        lockedToken[stor201 + 1].field_256 = arg2
                                                        lockedToken[stor201 + 1].field_512 = 0
                                                        lockedToken[stor201 + 1].field_768 = arg4
                                                        lockedToken[stor201 + 1].field_1024 = 0
                                                        lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                        allDepositIds.length++
                                                        stor42D7[stor202.length] = depositId + 1
                                                        depositsByWithdrawal[address(arg2)].field_0++
                                                        depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = depositId + 1
                                                        return memory
                                                          from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32
                                                    mem[(32 * _57) + ceil32(return_data.size) + 480 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'Fee transfer failed'
                                                    if 0 / 10^uint8(ext_call.return_data[0]) > msg.value:
                                                        require ext_code.size(arg1)
                                                        staticcall arg1.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        if not ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 705 len 4] = uint32(arg3)
                                                        call arg1 with:
                                                             gas gas_remaining wei
                                                            args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 677 len 4]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                revert with 0, 'SafeERC20: low-level call failed'
                                                            if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 14],
                                                                                uint32(arg3),
                                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 709 len 4]
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            depositId++
                                                            lockedToken[stor201 + 1].field_0 = arg1
                                                            lockedToken[stor201 + 1].field_256 = arg2
                                                            lockedToken[stor201 + 1].field_512 = 0
                                                            lockedToken[stor201 + 1].field_768 = arg4
                                                            lockedToken[stor201 + 1].field_1024 = 0
                                                            lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                            allDepositIds.length++
                                                            stor42D7[stor202.length] = depositId + 1
                                                            depositsByWithdrawal[address(arg2)].field_0++
                                                            depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                            return (depositId + 1)
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581] = return_data.size
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650] = 'SafeERC20: low-level call failed'
                                                            revert with memory
                                                              from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613]:
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 42
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650 len 42] = 0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565
                                                                revert with memory
                                                                  from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = this.address
                                                        require ext_code.size(arg1)
                                                        staticcall arg1.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586 len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 27
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650] = 'SafeMath: addition overflow'
                                                            revert with memory
                                                              from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                        depositId++
                                                        lockedToken[stor201 + 1].field_0 = arg1
                                                        lockedToken[stor201 + 1].field_256 = arg2
                                                        lockedToken[stor201 + 1].field_512 = 0
                                                        lockedToken[stor201 + 1].field_768 = arg4
                                                        lockedToken[stor201 + 1].field_1024 = 0
                                                        lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                        allDepositIds.length++
                                                        stor42D7[stor202.length] = depositId + 1
                                                        depositsByWithdrawal[address(arg2)].field_0++
                                                        depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = depositId + 1
                                                        return memory
                                                          from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32
                                                    if (0 / 10^uint8(ext_call.return_data[0])) - msg.value <= 0:
                                                        require ext_code.size(arg1)
                                                        staticcall arg1.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        if not ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 705 len 4] = uint32(arg3)
                                                        call arg1 with:
                                                             gas gas_remaining wei
                                                            args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 677 len 4]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                revert with 0, 'SafeERC20: low-level call failed'
                                                            if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 14],
                                                                                uint32(arg3),
                                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 709 len 4]
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            depositId++
                                                            lockedToken[stor201 + 1].field_0 = arg1
                                                            lockedToken[stor201 + 1].field_256 = arg2
                                                            lockedToken[stor201 + 1].field_512 = 0
                                                            lockedToken[stor201 + 1].field_768 = arg4
                                                            lockedToken[stor201 + 1].field_1024 = 0
                                                            lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                            allDepositIds.length++
                                                            stor42D7[stor202.length] = depositId + 1
                                                            depositsByWithdrawal[address(arg2)].field_0++
                                                            depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                            return (depositId + 1)
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581] = return_data.size
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650] = 'SafeERC20: low-level call failed'
                                                            revert with memory
                                                              from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613]:
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 42
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650 len 42] = 0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565
                                                                revert with memory
                                                                  from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = this.address
                                                        require ext_code.size(arg1)
                                                        staticcall arg1.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586 len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 27
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650] = 'SafeMath: addition overflow'
                                                            revert with memory
                                                              from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                        depositId++
                                                        lockedToken[stor201 + 1].field_0 = arg1
                                                        lockedToken[stor201 + 1].field_256 = arg2
                                                        lockedToken[stor201 + 1].field_512 = 0
                                                        lockedToken[stor201 + 1].field_768 = arg4
                                                        lockedToken[stor201 + 1].field_1024 = 0
                                                        lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                        allDepositIds.length++
                                                        stor42D7[stor202.length] = depositId + 1
                                                        depositsByWithdrawal[address(arg2)].field_0++
                                                        depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = depositId + 1
                                                        return memory
                                                          from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32
                                                    call msg.sender with:
                                                       value (0 / 10^uint8(ext_call.return_data[0])) - msg.value wei
                                                         gas gas_remaining wei
                                                    if not return_data.size:
                                                        require ext_code.size(arg1)
                                                        staticcall arg1.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        if not ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 705 len 4] = uint32(arg3)
                                                        call arg1 with:
                                                             gas gas_remaining wei
                                                            args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 677 len 4]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                revert with 0, 'SafeERC20: low-level call failed'
                                                            if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 14],
                                                                                uint32(arg3),
                                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 709 len 4]
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            depositId++
                                                            lockedToken[stor201 + 1].field_0 = arg1
                                                            lockedToken[stor201 + 1].field_256 = arg2
                                                            lockedToken[stor201 + 1].field_512 = 0
                                                            lockedToken[stor201 + 1].field_768 = arg4
                                                            lockedToken[stor201 + 1].field_1024 = 0
                                                            lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                            allDepositIds.length++
                                                            stor42D7[stor202.length] = depositId + 1
                                                            depositsByWithdrawal[address(arg2)].field_0++
                                                            depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                            return (depositId + 1)
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581] = return_data.size
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650] = 'SafeERC20: low-level call failed'
                                                            revert with memory
                                                              from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613]:
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 42
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650 len 42] = 0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565
                                                                revert with memory
                                                                  from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = this.address
                                                        require ext_code.size(arg1)
                                                        staticcall arg1.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586 len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 27
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650] = 'SafeMath: addition overflow'
                                                            revert with memory
                                                              from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                        depositId++
                                                        lockedToken[stor201 + 1].field_0 = arg1
                                                        lockedToken[stor201 + 1].field_256 = arg2
                                                        lockedToken[stor201 + 1].field_512 = 0
                                                        lockedToken[stor201 + 1].field_768 = arg4
                                                        lockedToken[stor201 + 1].field_1024 = 0
                                                        lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                        allDepositIds.length++
                                                        stor42D7[stor202.length] = depositId + 1
                                                        depositsByWithdrawal[address(arg2)].field_0++
                                                        depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = depositId + 1
                                                        return memory
                                                          from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32
                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 449] = return_data.size
                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 481 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 454] = this.address
                                                    require ext_code.size(arg1)
                                                    staticcall arg1.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 454 len (5 * ceil32(return_data.size)) + 32]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 550] = arg3
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(arg1):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582 len floor32((5 * ceil32(return_data.size)) + 100)] = unknown_0x23b872dd(?????), msg.sender, address(this.address), mem[(32 * _57) + (4 * ceil32(return_data.size)) + 550 len floor32((5 * ceil32(return_data.size)) + 100) - 68]
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + floor32((5 * ceil32(return_data.size)) + 100) + -((5 * ceil32(return_data.size)) + 100 % 32) + 614 len (5 * ceil32(return_data.size)) + 100 % 32] = mem[(32 * _57) + (4 * ceil32(return_data.size)) + floor32((5 * ceil32(return_data.size)) + 100) + -((5 * ceil32(return_data.size)) + 100 % 32) + 514 len (5 * ceil32(return_data.size)) + 100 % 32]
                                                    call arg1.mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586 len (5 * ceil32(return_data.size)) + 96]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                            require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                            if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 692 len 22]
                                                    else:
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 614 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[(32 * _57) + (4 * ceil32(return_data.size)) + 614]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 693 len 22]
                                                else:
                                                    call companyWalletAddress with:
                                                       value 0 / 10^uint8(ext_call.return_data[0]) wei
                                                         gas gas_remaining wei
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'Fee transfer failed'
                                                        if 0 / 10^uint8(ext_call.return_data[0]) > msg.value:
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                                revert with 0, 'SafeERC20: call to non-contract'
                                                            if not ext_code.hash(arg1):
                                                                revert with 0, 'SafeERC20: call to non-contract'
                                                            mem[(32 * _57) + ceil32(return_data.size) + 580 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                            mem[(32 * _57) + ceil32(return_data.size) + 704 len 4] = uint32(arg3)
                                                            call arg1 with:
                                                                 gas gas_remaining wei
                                                                args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + 676 len 4]
                                                            if not return_data.size:
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                    require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                    if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + 690 len 14],
                                                                                    uint32(arg3),
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + 708 len 4]
                                                            else:
                                                                mem[(32 * _57) + ceil32(return_data.size) + 612 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if return_data.size:
                                                                    require return_data.size >= 32
                                                                    if not mem[(32 * _57) + ceil32(return_data.size) + 612]:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 22]
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            depositId++
                                                            lockedToken[stor201 + 1].field_0 = arg1
                                                            lockedToken[stor201 + 1].field_256 = arg2
                                                            lockedToken[stor201 + 1].field_512 = 0
                                                            lockedToken[stor201 + 1].field_768 = arg4
                                                            lockedToken[stor201 + 1].field_1024 = 0
                                                            lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                            allDepositIds.length++
                                                            stor42D7[stor202.length] = depositId + 1
                                                            depositsByWithdrawal[address(arg2)].field_0++
                                                            depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                            return (depositId + 1)
                                                        if (0 / 10^uint8(ext_call.return_data[0])) - msg.value <= 0:
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                                revert with 0, 'SafeERC20: call to non-contract'
                                                            if not ext_code.hash(arg1):
                                                                revert with 0, 'SafeERC20: call to non-contract'
                                                            mem[(32 * _57) + ceil32(return_data.size) + 580 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                            mem[(32 * _57) + ceil32(return_data.size) + 704 len 4] = uint32(arg3)
                                                            call arg1 with:
                                                                 gas gas_remaining wei
                                                                args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + 676 len 4]
                                                            if not return_data.size:
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                    require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                    if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + 690 len 14],
                                                                                    uint32(arg3),
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + 708 len 4]
                                                            else:
                                                                mem[(32 * _57) + ceil32(return_data.size) + 612 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if return_data.size:
                                                                    require return_data.size >= 32
                                                                    if not mem[(32 * _57) + ceil32(return_data.size) + 612]:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 22]
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            depositId++
                                                            lockedToken[stor201 + 1].field_0 = arg1
                                                            lockedToken[stor201 + 1].field_256 = arg2
                                                            lockedToken[stor201 + 1].field_512 = 0
                                                            lockedToken[stor201 + 1].field_768 = arg4
                                                            lockedToken[stor201 + 1].field_1024 = 0
                                                            lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                            allDepositIds.length++
                                                            stor42D7[stor202.length] = depositId + 1
                                                            depositsByWithdrawal[address(arg2)].field_0++
                                                            depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                            return (depositId + 1)
                                                        call msg.sender with:
                                                           value (0 / 10^uint8(ext_call.return_data[0])) - msg.value wei
                                                             gas gas_remaining wei
                                                        require ext_code.size(arg1)
                                                        staticcall arg1.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        if not ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        if not return_data.size:
                                                            mem[(32 * _57) + ceil32(return_data.size) + 580 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                            mem[(32 * _57) + ceil32(return_data.size) + 704 len 4] = uint32(arg3)
                                                            call arg1 with:
                                                                 gas gas_remaining wei
                                                                args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + 676 len 4]
                                                            if not return_data.size:
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                    require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                    if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + 690 len 14],
                                                                                    uint32(arg3),
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + 708 len 4]
                                                            else:
                                                                mem[(32 * _57) + ceil32(return_data.size) + 612 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if return_data.size:
                                                                    require return_data.size >= 32
                                                                    if not mem[(32 * _57) + ceil32(return_data.size) + 612]:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 22]
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            depositId++
                                                            lockedToken[stor201 + 1].field_0 = arg1
                                                            lockedToken[stor201 + 1].field_256 = arg2
                                                            lockedToken[stor201 + 1].field_512 = 0
                                                            lockedToken[stor201 + 1].field_768 = arg4
                                                            lockedToken[stor201 + 1].field_1024 = 0
                                                            lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                            allDepositIds.length++
                                                            stor42D7[stor202.length] = depositId + 1
                                                            depositsByWithdrawal[address(arg2)].field_0++
                                                            depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                            return (depositId + 1)
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 705 len 4] = uint32(arg3)
                                                        call arg1 with:
                                                             gas gas_remaining wei
                                                            args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 677 len 4]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                revert with 0, 'SafeERC20: low-level call failed'
                                                            if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 14],
                                                                                uint32(arg3),
                                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 709 len 4]
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            depositId++
                                                            lockedToken[stor201 + 1].field_0 = arg1
                                                            lockedToken[stor201 + 1].field_256 = arg2
                                                            lockedToken[stor201 + 1].field_512 = 0
                                                            lockedToken[stor201 + 1].field_768 = arg4
                                                            lockedToken[stor201 + 1].field_1024 = 0
                                                            lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                            allDepositIds.length++
                                                            stor42D7[stor202.length] = depositId + 1
                                                            depositsByWithdrawal[address(arg2)].field_0++
                                                            depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                            return (depositId + 1)
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581] = return_data.size
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650] = 'SafeERC20: low-level call failed'
                                                            revert with memory
                                                              from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613]:
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 42
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650 len 42] = 0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565
                                                                revert with memory
                                                                  from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = this.address
                                                        require ext_code.size(arg1)
                                                        staticcall arg1.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586 len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 27
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650] = 'SafeMath: addition overflow'
                                                            revert with memory
                                                              from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                        depositId++
                                                        lockedToken[stor201 + 1].field_0 = arg1
                                                        lockedToken[stor201 + 1].field_256 = arg2
                                                        lockedToken[stor201 + 1].field_512 = 0
                                                        lockedToken[stor201 + 1].field_768 = arg4
                                                        lockedToken[stor201 + 1].field_1024 = 0
                                                        lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                        allDepositIds.length++
                                                        stor42D7[stor202.length] = depositId + 1
                                                        depositsByWithdrawal[address(arg2)].field_0++
                                                        depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = depositId + 1
                                                        return memory
                                                          from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32
                                                    mem[(32 * _57) + ceil32(return_data.size) + 480 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'Fee transfer failed'
                                                    if 0 / 10^uint8(ext_call.return_data[0]) > msg.value:
                                                        require ext_code.size(arg1)
                                                        staticcall arg1.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        if not ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 705 len 4] = uint32(arg3)
                                                        call arg1 with:
                                                             gas gas_remaining wei
                                                            args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 677 len 4]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                revert with 0, 'SafeERC20: low-level call failed'
                                                            if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 14],
                                                                                uint32(arg3),
                                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 709 len 4]
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            depositId++
                                                            lockedToken[stor201 + 1].field_0 = arg1
                                                            lockedToken[stor201 + 1].field_256 = arg2
                                                            lockedToken[stor201 + 1].field_512 = 0
                                                            lockedToken[stor201 + 1].field_768 = arg4
                                                            lockedToken[stor201 + 1].field_1024 = 0
                                                            lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                            allDepositIds.length++
                                                            stor42D7[stor202.length] = depositId + 1
                                                            depositsByWithdrawal[address(arg2)].field_0++
                                                            depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                            return (depositId + 1)
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581] = return_data.size
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650] = 'SafeERC20: low-level call failed'
                                                            revert with memory
                                                              from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613]:
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 42
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650 len 42] = 0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565
                                                                revert with memory
                                                                  from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = this.address
                                                        require ext_code.size(arg1)
                                                        staticcall arg1.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586 len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 27
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650] = 'SafeMath: addition overflow'
                                                            revert with memory
                                                              from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                        depositId++
                                                        lockedToken[stor201 + 1].field_0 = arg1
                                                        lockedToken[stor201 + 1].field_256 = arg2
                                                        lockedToken[stor201 + 1].field_512 = 0
                                                        lockedToken[stor201 + 1].field_768 = arg4
                                                        lockedToken[stor201 + 1].field_1024 = 0
                                                        lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                        allDepositIds.length++
                                                        stor42D7[stor202.length] = depositId + 1
                                                        depositsByWithdrawal[address(arg2)].field_0++
                                                        depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = depositId + 1
                                                        return memory
                                                          from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32
                                                    if (0 / 10^uint8(ext_call.return_data[0])) - msg.value <= 0:
                                                        require ext_code.size(arg1)
                                                        staticcall arg1.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        if not ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 705 len 4] = uint32(arg3)
                                                        call arg1 with:
                                                             gas gas_remaining wei
                                                            args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 677 len 4]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                revert with 0, 'SafeERC20: low-level call failed'
                                                            if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 14],
                                                                                uint32(arg3),
                                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 709 len 4]
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            depositId++
                                                            lockedToken[stor201 + 1].field_0 = arg1
                                                            lockedToken[stor201 + 1].field_256 = arg2
                                                            lockedToken[stor201 + 1].field_512 = 0
                                                            lockedToken[stor201 + 1].field_768 = arg4
                                                            lockedToken[stor201 + 1].field_1024 = 0
                                                            lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                            allDepositIds.length++
                                                            stor42D7[stor202.length] = depositId + 1
                                                            depositsByWithdrawal[address(arg2)].field_0++
                                                            depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                            return (depositId + 1)
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581] = return_data.size
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650] = 'SafeERC20: low-level call failed'
                                                            revert with memory
                                                              from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613]:
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 42
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650 len 42] = 0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565
                                                                revert with memory
                                                                  from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = this.address
                                                        require ext_code.size(arg1)
                                                        staticcall arg1.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586 len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 27
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650] = 'SafeMath: addition overflow'
                                                            revert with memory
                                                              from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                        depositId++
                                                        lockedToken[stor201 + 1].field_0 = arg1
                                                        lockedToken[stor201 + 1].field_256 = arg2
                                                        lockedToken[stor201 + 1].field_512 = 0
                                                        lockedToken[stor201 + 1].field_768 = arg4
                                                        lockedToken[stor201 + 1].field_1024 = 0
                                                        lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                        allDepositIds.length++
                                                        stor42D7[stor202.length] = depositId + 1
                                                        depositsByWithdrawal[address(arg2)].field_0++
                                                        depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = depositId + 1
                                                        return memory
                                                          from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32
                                                    call msg.sender with:
                                                       value (0 / 10^uint8(ext_call.return_data[0])) - msg.value wei
                                                         gas gas_remaining wei
                                                    if not return_data.size:
                                                        require ext_code.size(arg1)
                                                        staticcall arg1.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        if not ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 705 len 4] = uint32(arg3)
                                                        call arg1 with:
                                                             gas gas_remaining wei
                                                            args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 677 len 4]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                revert with 0, 'SafeERC20: low-level call failed'
                                                            if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 14],
                                                                                uint32(arg3),
                                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 709 len 4]
                                                        else:
                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            if not ext_call.success:
                                                                revert with 0, 'SafeERC20: low-level call failed'
                                                            if return_data.size:
                                                                require return_data.size >= 32
                                                                if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613]:
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 692 len 22]
                                                    else:
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 449] = return_data.size
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 481 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 454] = this.address
                                                        require ext_code.size(arg1)
                                                        staticcall arg1.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 454 len (5 * ceil32(return_data.size)) + 32]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 550] = arg3
                                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        if not ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582 len floor32((5 * ceil32(return_data.size)) + 100)] = unknown_0x23b872dd(?????), msg.sender, address(this.address), mem[(32 * _57) + (4 * ceil32(return_data.size)) + 550 len floor32((5 * ceil32(return_data.size)) + 100) - 68]
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + floor32((5 * ceil32(return_data.size)) + 100) + -((5 * ceil32(return_data.size)) + 100 % 32) + 614 len (5 * ceil32(return_data.size)) + 100 % 32] = mem[(32 * _57) + (4 * ceil32(return_data.size)) + floor32((5 * ceil32(return_data.size)) + 100) + -((5 * ceil32(return_data.size)) + 100 % 32) + 514 len (5 * ceil32(return_data.size)) + 100 % 32]
                                                        call arg1.mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582 len 4] with:
                                                             gas gas_remaining wei
                                                            args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586 len (5 * ceil32(return_data.size)) + 96]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                revert with 0, 'SafeERC20: low-level call failed'
                                                            if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 692 len 22]
                                                        else:
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 614 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            if not ext_call.success:
                                                                revert with 0, 'SafeERC20: low-level call failed'
                                                            if return_data.size:
                                                                require return_data.size >= 32
                                                                if not mem[(32 * _57) + (4 * ceil32(return_data.size)) + 614]:
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 693 len 22]
                            else:
                                if (mem[ceil32(return_data.size) + 128] * sub_aa182aef) - (3 * mem[ceil32(return_data.size) + 128] / 1000 * sub_aa182aef) / sub_aa182aef != mem[ceil32(return_data.size) + 128] - (3 * mem[ceil32(return_data.size) + 128] / 1000):
                                    revert with 0, 
                                                32,
                                                33,
                                                0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[(32 * _57) + ceil32(return_data.size) + 357 len 31]
                                if not 10^uint8(ext_call.return_data[0]):
                                    revert with 0, 'SafeMath: division by zero'
                                if not (mem[ceil32(return_data.size) + 128] * sub_aa182aef) - (3 * mem[ceil32(return_data.size) + 128] / 1000 * sub_aa182aef) / 10^uint8(ext_call.return_data[0]):
                                    require ext_code.size(arg1)
                                    staticcall arg1.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                        revert with 0, 'SafeERC20: call to non-contract'
                                    if not ext_code.hash(arg1):
                                        revert with 0, 'SafeERC20: call to non-contract'
                                    mem[(32 * _57) + ceil32(return_data.size) + 452 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                    mem[(32 * _57) + ceil32(return_data.size) + 576 len 4] = uint32(arg3)
                                    call arg1 with:
                                         gas gas_remaining wei
                                        args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + 548 len 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                            require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                            if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[(32 * _57) + ceil32(return_data.size) + 562 len 14],
                                                            uint32(arg3),
                                                            mem[(32 * _57) + ceil32(return_data.size) + 580 len 4]
                                    else:
                                        mem[(32 * _57) + ceil32(return_data.size) + 484 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if return_data.size:
                                            require return_data.size >= 32
                                            if not mem[(32 * _57) + ceil32(return_data.size) + 484]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 563 len 22]
                                else:
                                    if (mem[ceil32(return_data.size) + 128] * sub_aa182aef) - (3 * mem[ceil32(return_data.size) + 128] / 1000 * sub_aa182aef) / 10^uint8(ext_call.return_data[0]) <= msg.value:
                                        call companyWalletAddress with:
                                           value (mem[ceil32(return_data.size) + 128] * sub_aa182aef) - (3 * mem[ceil32(return_data.size) + 128] / 1000 * sub_aa182aef) / 10^uint8(ext_call.return_data[0]) wei
                                             gas gas_remaining wei
                                        if not return_data.size:
                                            if not ext_call.success:
                                                revert with 0, 'Fee transfer failed'
                                            if (mem[ceil32(return_data.size) + 128] * sub_aa182aef) - (3 * mem[ceil32(return_data.size) + 128] / 1000 * sub_aa182aef) / 10^uint8(ext_call.return_data[0]) > msg.value:
                                                require ext_code.size(arg1)
                                                staticcall arg1.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(arg1):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                mem[(32 * _57) + ceil32(return_data.size) + 516 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                mem[(32 * _57) + ceil32(return_data.size) + 640 len 4] = uint32(arg3)
                                                call arg1 with:
                                                     gas gas_remaining wei
                                                    args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + 612 len 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                        require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                        if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[(32 * _57) + ceil32(return_data.size) + 626 len 14],
                                                                        uint32(arg3),
                                                                        mem[(32 * _57) + ceil32(return_data.size) + 644 len 4]
                                                else:
                                                    mem[(32 * _57) + ceil32(return_data.size) + 548 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[(32 * _57) + ceil32(return_data.size) + 548]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 627 len 22]
                                                require ext_code.size(arg1)
                                                staticcall arg1.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                depositId++
                                                lockedToken[stor201 + 1].field_0 = arg1
                                                lockedToken[stor201 + 1].field_256 = arg2
                                                lockedToken[stor201 + 1].field_512 = 0
                                                lockedToken[stor201 + 1].field_768 = arg4
                                                lockedToken[stor201 + 1].field_1024 = 0
                                                lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                allDepositIds.length++
                                                stor42D7[stor202.length] = depositId + 1
                                                depositsByWithdrawal[address(arg2)].field_0++
                                                depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                return (depositId + 1)
                                            if msg.value - ((mem[ceil32(return_data.size) + 128] * sub_aa182aef) - (3 * mem[ceil32(return_data.size) + 128] / 1000 * sub_aa182aef) / 10^uint8(ext_call.return_data[0])) <= 0:
                                                require ext_code.size(arg1)
                                                staticcall arg1.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(arg1):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                mem[(32 * _57) + ceil32(return_data.size) + 516 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                mem[(32 * _57) + ceil32(return_data.size) + 640 len 4] = uint32(arg3)
                                                call arg1 with:
                                                     gas gas_remaining wei
                                                    args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + 612 len 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                        require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                        if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[(32 * _57) + ceil32(return_data.size) + 626 len 14],
                                                                        uint32(arg3),
                                                                        mem[(32 * _57) + ceil32(return_data.size) + 644 len 4]
                                                else:
                                                    mem[(32 * _57) + ceil32(return_data.size) + 548 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[(32 * _57) + ceil32(return_data.size) + 548]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 627 len 22]
                                                require ext_code.size(arg1)
                                                staticcall arg1.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                depositId++
                                                lockedToken[stor201 + 1].field_0 = arg1
                                                lockedToken[stor201 + 1].field_256 = arg2
                                                lockedToken[stor201 + 1].field_512 = 0
                                                lockedToken[stor201 + 1].field_768 = arg4
                                                lockedToken[stor201 + 1].field_1024 = 0
                                                lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                allDepositIds.length++
                                                stor42D7[stor202.length] = depositId + 1
                                                depositsByWithdrawal[address(arg2)].field_0++
                                                depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                return (depositId + 1)
                                            call msg.sender with:
                                               value msg.value - ((mem[ceil32(return_data.size) + 128] * sub_aa182aef) - (3 * mem[ceil32(return_data.size) + 128] / 1000 * sub_aa182aef) / 10^uint8(ext_call.return_data[0])) wei
                                                 gas gas_remaining wei
                                            require ext_code.size(arg1)
                                            staticcall arg1.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                revert with 0, 'SafeERC20: call to non-contract'
                                            if not ext_code.hash(arg1):
                                                revert with 0, 'SafeERC20: call to non-contract'
                                            if not return_data.size:
                                                mem[(32 * _57) + ceil32(return_data.size) + 516 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                mem[(32 * _57) + ceil32(return_data.size) + 640 len 4] = uint32(arg3)
                                                call arg1 with:
                                                     gas gas_remaining wei
                                                    args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + 612 len 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                        require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                        if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[(32 * _57) + ceil32(return_data.size) + 626 len 14],
                                                                        uint32(arg3),
                                                                        mem[(32 * _57) + ceil32(return_data.size) + 644 len 4]
                                                else:
                                                    mem[(32 * _57) + ceil32(return_data.size) + 548 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[(32 * _57) + ceil32(return_data.size) + 548]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 627 len 22]
                                                require ext_code.size(arg1)
                                                staticcall arg1.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                depositId++
                                                lockedToken[stor201 + 1].field_0 = arg1
                                                lockedToken[stor201 + 1].field_256 = arg2
                                                lockedToken[stor201 + 1].field_512 = 0
                                                lockedToken[stor201 + 1].field_768 = arg4
                                                lockedToken[stor201 + 1].field_1024 = 0
                                                lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                allDepositIds.length++
                                                stor42D7[stor202.length] = depositId + 1
                                                depositsByWithdrawal[address(arg2)].field_0++
                                                depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                return (depositId + 1)
                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 517 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 641 len 4] = uint32(arg3)
                                            call arg1 with:
                                                 gas gas_remaining wei
                                                args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                    require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                    if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                        revert with 0, 
                                                                    32,
                                                                    42,
                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 627 len 14],
                                                                    uint32(arg3),
                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 645 len 4]
                                                require ext_code.size(arg1)
                                                staticcall arg1.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                depositId++
                                                lockedToken[stor201 + 1].field_0 = arg1
                                                lockedToken[stor201 + 1].field_256 = arg2
                                                lockedToken[stor201 + 1].field_512 = 0
                                                lockedToken[stor201 + 1].field_768 = arg4
                                                lockedToken[stor201 + 1].field_1024 = 0
                                                lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                allDepositIds.length++
                                                stor42D7[stor202.length] = depositId + 1
                                                depositsByWithdrawal[address(arg2)].field_0++
                                                depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                return (depositId + 1)
                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 517] = return_data.size
                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 549 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = 32
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 554] = 32
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 'SafeERC20: low-level call failed'
                                                revert with memory
                                                  from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                            if return_data.size:
                                                require return_data.size >= 32
                                                if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 549]:
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = 32
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 554] = 42
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586 len 42] = 0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565
                                                    revert with memory
                                                      from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                                       len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = this.address
                                            require ext_code.size(arg1)
                                            staticcall arg1.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522 len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = 32
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 554] = 27
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 'SafeMath: addition overflow'
                                                revert with memory
                                                  from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                            depositId++
                                            lockedToken[stor201 + 1].field_0 = arg1
                                            lockedToken[stor201 + 1].field_256 = arg2
                                            lockedToken[stor201 + 1].field_512 = 0
                                            lockedToken[stor201 + 1].field_768 = arg4
                                            lockedToken[stor201 + 1].field_1024 = 0
                                            lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                            allDepositIds.length++
                                            stor42D7[stor202.length] = depositId + 1
                                            depositsByWithdrawal[address(arg2)].field_0++
                                            depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = depositId + 1
                                            return memory
                                              from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32
                                        mem[(32 * _57) + ceil32(return_data.size) + 416 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            revert with 0, 'Fee transfer failed'
                                        if (mem[ceil32(return_data.size) + 128] * sub_aa182aef) - (3 * mem[ceil32(return_data.size) + 128] / 1000 * sub_aa182aef) / 10^uint8(ext_call.return_data[0]) > msg.value:
                                            require ext_code.size(arg1)
                                            staticcall arg1.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                revert with 0, 'SafeERC20: call to non-contract'
                                            if not ext_code.hash(arg1):
                                                revert with 0, 'SafeERC20: call to non-contract'
                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 517 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 641 len 4] = uint32(arg3)
                                            call arg1 with:
                                                 gas gas_remaining wei
                                                args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                    require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                    if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                        revert with 0, 
                                                                    32,
                                                                    42,
                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 627 len 14],
                                                                    uint32(arg3),
                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 645 len 4]
                                                require ext_code.size(arg1)
                                                staticcall arg1.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                depositId++
                                                lockedToken[stor201 + 1].field_0 = arg1
                                                lockedToken[stor201 + 1].field_256 = arg2
                                                lockedToken[stor201 + 1].field_512 = 0
                                                lockedToken[stor201 + 1].field_768 = arg4
                                                lockedToken[stor201 + 1].field_1024 = 0
                                                lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                allDepositIds.length++
                                                stor42D7[stor202.length] = depositId + 1
                                                depositsByWithdrawal[address(arg2)].field_0++
                                                depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                return (depositId + 1)
                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 517] = return_data.size
                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 549 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = 32
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 554] = 32
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 'SafeERC20: low-level call failed'
                                                revert with memory
                                                  from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                            if return_data.size:
                                                require return_data.size >= 32
                                                if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 549]:
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = 32
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 554] = 42
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586 len 42] = 0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565
                                                    revert with memory
                                                      from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                                       len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = this.address
                                            require ext_code.size(arg1)
                                            staticcall arg1.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522 len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = 32
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 554] = 27
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 'SafeMath: addition overflow'
                                                revert with memory
                                                  from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                            depositId++
                                            lockedToken[stor201 + 1].field_0 = arg1
                                            lockedToken[stor201 + 1].field_256 = arg2
                                            lockedToken[stor201 + 1].field_512 = 0
                                            lockedToken[stor201 + 1].field_768 = arg4
                                            lockedToken[stor201 + 1].field_1024 = 0
                                            lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                            allDepositIds.length++
                                            stor42D7[stor202.length] = depositId + 1
                                            depositsByWithdrawal[address(arg2)].field_0++
                                            depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = depositId + 1
                                            return memory
                                              from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32
                                        if msg.value - ((mem[ceil32(return_data.size) + 128] * sub_aa182aef) - (3 * mem[ceil32(return_data.size) + 128] / 1000 * sub_aa182aef) / 10^uint8(ext_call.return_data[0])) <= 0:
                                            require ext_code.size(arg1)
                                            staticcall arg1.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                revert with 0, 'SafeERC20: call to non-contract'
                                            if not ext_code.hash(arg1):
                                                revert with 0, 'SafeERC20: call to non-contract'
                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 517 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 641 len 4] = uint32(arg3)
                                            call arg1 with:
                                                 gas gas_remaining wei
                                                args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                    require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                    if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                        revert with 0, 
                                                                    32,
                                                                    42,
                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 627 len 14],
                                                                    uint32(arg3),
                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 645 len 4]
                                            else:
                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 549 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 549]:
                                                        revert with 0, 
                                                                    32,
                                                                    42,
                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 628 len 22]
                                        else:
                                            call msg.sender with:
                                               value msg.value - ((mem[ceil32(return_data.size) + 128] * sub_aa182aef) - (3 * mem[ceil32(return_data.size) + 128] / 1000 * sub_aa182aef) / 10^uint8(ext_call.return_data[0])) wei
                                                 gas gas_remaining wei
                                            if not return_data.size:
                                                require ext_code.size(arg1)
                                                staticcall arg1.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(arg1):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 517 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 641 len 4] = uint32(arg3)
                                                call arg1 with:
                                                     gas gas_remaining wei
                                                    args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                        require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                        if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 627 len 14],
                                                                        uint32(arg3),
                                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 645 len 4]
                                                else:
                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 549 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 549]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 628 len 22]
                                            else:
                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 385] = return_data.size
                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 417 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 390] = this.address
                                                require ext_code.size(arg1)
                                                staticcall arg1.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 390 len (5 * ceil32(return_data.size)) + 32]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 486] = arg3
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(arg1):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518 len floor32((5 * ceil32(return_data.size)) + 100)] = unknown_0x23b872dd(?????), msg.sender, address(this.address), mem[(32 * _57) + (4 * ceil32(return_data.size)) + 486 len floor32((5 * ceil32(return_data.size)) + 100) - 68]
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + floor32((5 * ceil32(return_data.size)) + 100) + -((5 * ceil32(return_data.size)) + 100 % 32) + 550 len (5 * ceil32(return_data.size)) + 100 % 32] = mem[(32 * _57) + (4 * ceil32(return_data.size)) + -((5 * ceil32(return_data.size)) + 100 % 32) + floor32((5 * ceil32(return_data.size)) + 100) + 450 len (5 * ceil32(return_data.size)) + 100 % 32]
                                                call arg1.mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522 len (5 * ceil32(return_data.size)) + 96]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                        require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                        if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 628 len 22]
                                                else:
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 550 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[(32 * _57) + (4 * ceil32(return_data.size)) + 550]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 629 len 22]
                                    else:
                                        if msg.value > (mem[ceil32(return_data.size) + 128] * sub_aa182aef) - (3 * mem[ceil32(return_data.size) + 128] / 1000 * sub_aa182aef) / 10^uint8(ext_call.return_data[0]):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if (mem[ceil32(return_data.size) + 128] * sub_aa182aef) - (3 * mem[ceil32(return_data.size) + 128] / 1000 * sub_aa182aef) / 10^uint8(ext_call.return_data[0]) <= msg.value:
                                            call companyWalletAddress with:
                                               value (mem[ceil32(return_data.size) + 128] * sub_aa182aef) - (3 * mem[ceil32(return_data.size) + 128] / 1000 * sub_aa182aef) / 10^uint8(ext_call.return_data[0]) wei
                                                 gas gas_remaining wei
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    revert with 0, 'Fee transfer failed'
                                                if (mem[ceil32(return_data.size) + 128] * sub_aa182aef) - (3 * mem[ceil32(return_data.size) + 128] / 1000 * sub_aa182aef) / 10^uint8(ext_call.return_data[0]) > msg.value:
                                                    require ext_code.size(arg1)
                                                    staticcall arg1.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(arg1):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    mem[(32 * _57) + ceil32(return_data.size) + 516 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                    mem[(32 * _57) + ceil32(return_data.size) + 640 len 4] = uint32(arg3)
                                                    call arg1 with:
                                                         gas gas_remaining wei
                                                        args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + 612 len 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                            require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                            if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[(32 * _57) + ceil32(return_data.size) + 626 len 14],
                                                                            uint32(arg3),
                                                                            mem[(32 * _57) + ceil32(return_data.size) + 644 len 4]
                                                    else:
                                                        mem[(32 * _57) + ceil32(return_data.size) + 548 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[(32 * _57) + ceil32(return_data.size) + 548]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 627 len 22]
                                                    require ext_code.size(arg1)
                                                    staticcall arg1.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    depositId++
                                                    lockedToken[stor201 + 1].field_0 = arg1
                                                    lockedToken[stor201 + 1].field_256 = arg2
                                                    lockedToken[stor201 + 1].field_512 = 0
                                                    lockedToken[stor201 + 1].field_768 = arg4
                                                    lockedToken[stor201 + 1].field_1024 = 0
                                                    lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                    allDepositIds.length++
                                                    stor42D7[stor202.length] = depositId + 1
                                                    depositsByWithdrawal[address(arg2)].field_0++
                                                    depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                    return (depositId + 1)
                                                if ((mem[ceil32(return_data.size) + 128] * sub_aa182aef) - (3 * mem[ceil32(return_data.size) + 128] / 1000 * sub_aa182aef) / 10^uint8(ext_call.return_data[0])) - msg.value <= 0:
                                                    require ext_code.size(arg1)
                                                    staticcall arg1.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(arg1):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    mem[(32 * _57) + ceil32(return_data.size) + 516 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                    mem[(32 * _57) + ceil32(return_data.size) + 640 len 4] = uint32(arg3)
                                                    call arg1 with:
                                                         gas gas_remaining wei
                                                        args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + 612 len 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                            require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                            if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[(32 * _57) + ceil32(return_data.size) + 626 len 14],
                                                                            uint32(arg3),
                                                                            mem[(32 * _57) + ceil32(return_data.size) + 644 len 4]
                                                    else:
                                                        mem[(32 * _57) + ceil32(return_data.size) + 548 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[(32 * _57) + ceil32(return_data.size) + 548]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 627 len 22]
                                                    require ext_code.size(arg1)
                                                    staticcall arg1.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    depositId++
                                                    lockedToken[stor201 + 1].field_0 = arg1
                                                    lockedToken[stor201 + 1].field_256 = arg2
                                                    lockedToken[stor201 + 1].field_512 = 0
                                                    lockedToken[stor201 + 1].field_768 = arg4
                                                    lockedToken[stor201 + 1].field_1024 = 0
                                                    lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                    allDepositIds.length++
                                                    stor42D7[stor202.length] = depositId + 1
                                                    depositsByWithdrawal[address(arg2)].field_0++
                                                    depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                    return (depositId + 1)
                                                call msg.sender with:
                                                   value ((mem[ceil32(return_data.size) + 128] * sub_aa182aef) - (3 * mem[ceil32(return_data.size) + 128] / 1000 * sub_aa182aef) / 10^uint8(ext_call.return_data[0])) - msg.value wei
                                                     gas gas_remaining wei
                                                require ext_code.size(arg1)
                                                staticcall arg1.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(arg1):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not return_data.size:
                                                    mem[(32 * _57) + ceil32(return_data.size) + 516 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                    mem[(32 * _57) + ceil32(return_data.size) + 640 len 4] = uint32(arg3)
                                                    call arg1 with:
                                                         gas gas_remaining wei
                                                        args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + 612 len 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                            require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                            if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[(32 * _57) + ceil32(return_data.size) + 626 len 14],
                                                                            uint32(arg3),
                                                                            mem[(32 * _57) + ceil32(return_data.size) + 644 len 4]
                                                    else:
                                                        mem[(32 * _57) + ceil32(return_data.size) + 548 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[(32 * _57) + ceil32(return_data.size) + 548]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 627 len 22]
                                                    require ext_code.size(arg1)
                                                    staticcall arg1.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    depositId++
                                                    lockedToken[stor201 + 1].field_0 = arg1
                                                    lockedToken[stor201 + 1].field_256 = arg2
                                                    lockedToken[stor201 + 1].field_512 = 0
                                                    lockedToken[stor201 + 1].field_768 = arg4
                                                    lockedToken[stor201 + 1].field_1024 = 0
                                                    lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                    allDepositIds.length++
                                                    stor42D7[stor202.length] = depositId + 1
                                                    depositsByWithdrawal[address(arg2)].field_0++
                                                    depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                    return (depositId + 1)
                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 517 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 641 len 4] = uint32(arg3)
                                                call arg1 with:
                                                     gas gas_remaining wei
                                                    args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                        require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                        if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 627 len 14],
                                                                        uint32(arg3),
                                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 645 len 4]
                                                    require ext_code.size(arg1)
                                                    staticcall arg1.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    depositId++
                                                    lockedToken[stor201 + 1].field_0 = arg1
                                                    lockedToken[stor201 + 1].field_256 = arg2
                                                    lockedToken[stor201 + 1].field_512 = 0
                                                    lockedToken[stor201 + 1].field_768 = arg4
                                                    lockedToken[stor201 + 1].field_1024 = 0
                                                    lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                    allDepositIds.length++
                                                    stor42D7[stor202.length] = depositId + 1
                                                    depositsByWithdrawal[address(arg2)].field_0++
                                                    depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                    return (depositId + 1)
                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 517] = return_data.size
                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 549 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = 32
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 554] = 32
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 'SafeERC20: low-level call failed'
                                                    revert with memory
                                                      from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                                       len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 549]:
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = 32
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 554] = 42
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586 len 42] = 0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565
                                                        revert with memory
                                                          from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                                           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = this.address
                                                require ext_code.size(arg1)
                                                staticcall arg1.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522 len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = 32
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 554] = 27
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 'SafeMath: addition overflow'
                                                    revert with memory
                                                      from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                                       len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                depositId++
                                                lockedToken[stor201 + 1].field_0 = arg1
                                                lockedToken[stor201 + 1].field_256 = arg2
                                                lockedToken[stor201 + 1].field_512 = 0
                                                lockedToken[stor201 + 1].field_768 = arg4
                                                lockedToken[stor201 + 1].field_1024 = 0
                                                lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                allDepositIds.length++
                                                stor42D7[stor202.length] = depositId + 1
                                                depositsByWithdrawal[address(arg2)].field_0++
                                                depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = depositId + 1
                                                return memory
                                                  from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32
                                            mem[(32 * _57) + ceil32(return_data.size) + 416 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                revert with 0, 'Fee transfer failed'
                                            if (mem[ceil32(return_data.size) + 128] * sub_aa182aef) - (3 * mem[ceil32(return_data.size) + 128] / 1000 * sub_aa182aef) / 10^uint8(ext_call.return_data[0]) > msg.value:
                                                require ext_code.size(arg1)
                                                staticcall arg1.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(arg1):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 517 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 641 len 4] = uint32(arg3)
                                                call arg1 with:
                                                     gas gas_remaining wei
                                                    args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                        require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                        if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 627 len 14],
                                                                        uint32(arg3),
                                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 645 len 4]
                                                    require ext_code.size(arg1)
                                                    staticcall arg1.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    depositId++
                                                    lockedToken[stor201 + 1].field_0 = arg1
                                                    lockedToken[stor201 + 1].field_256 = arg2
                                                    lockedToken[stor201 + 1].field_512 = 0
                                                    lockedToken[stor201 + 1].field_768 = arg4
                                                    lockedToken[stor201 + 1].field_1024 = 0
                                                    lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                    allDepositIds.length++
                                                    stor42D7[stor202.length] = depositId + 1
                                                    depositsByWithdrawal[address(arg2)].field_0++
                                                    depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                    return (depositId + 1)
                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 517] = return_data.size
                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 549 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = 32
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 554] = 32
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 'SafeERC20: low-level call failed'
                                                    revert with memory
                                                      from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                                       len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 549]:
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = 32
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 554] = 42
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586 len 42] = 0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565
                                                        revert with memory
                                                          from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                                           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = this.address
                                                require ext_code.size(arg1)
                                                staticcall arg1.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522 len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = 32
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 554] = 27
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 'SafeMath: addition overflow'
                                                    revert with memory
                                                      from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                                       len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                depositId++
                                                lockedToken[stor201 + 1].field_0 = arg1
                                                lockedToken[stor201 + 1].field_256 = arg2
                                                lockedToken[stor201 + 1].field_512 = 0
                                                lockedToken[stor201 + 1].field_768 = arg4
                                                lockedToken[stor201 + 1].field_1024 = 0
                                                lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                allDepositIds.length++
                                                stor42D7[stor202.length] = depositId + 1
                                                depositsByWithdrawal[address(arg2)].field_0++
                                                depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = depositId + 1
                                                return memory
                                                  from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32
                                            if ((mem[ceil32(return_data.size) + 128] * sub_aa182aef) - (3 * mem[ceil32(return_data.size) + 128] / 1000 * sub_aa182aef) / 10^uint8(ext_call.return_data[0])) - msg.value <= 0:
                                                require ext_code.size(arg1)
                                                staticcall arg1.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(arg1):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 517 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 641 len 4] = uint32(arg3)
                                                call arg1 with:
                                                     gas gas_remaining wei
                                                    args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                        require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                        if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 627 len 14],
                                                                        uint32(arg3),
                                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 645 len 4]
                                                    require ext_code.size(arg1)
                                                    staticcall arg1.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    depositId++
                                                    lockedToken[stor201 + 1].field_0 = arg1
                                                    lockedToken[stor201 + 1].field_256 = arg2
                                                    lockedToken[stor201 + 1].field_512 = 0
                                                    lockedToken[stor201 + 1].field_768 = arg4
                                                    lockedToken[stor201 + 1].field_1024 = 0
                                                    lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                    allDepositIds.length++
                                                    stor42D7[stor202.length] = depositId + 1
                                                    depositsByWithdrawal[address(arg2)].field_0++
                                                    depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                    return (depositId + 1)
                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 517] = return_data.size
                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 549 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = 32
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 554] = 32
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 'SafeERC20: low-level call failed'
                                                    revert with memory
                                                      from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                                       len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 549]:
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = 32
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 554] = 42
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586 len 42] = 0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565
                                                        revert with memory
                                                          from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                                           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = this.address
                                                require ext_code.size(arg1)
                                                staticcall arg1.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522 len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = 32
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 554] = 27
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 'SafeMath: addition overflow'
                                                    revert with memory
                                                      from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                                       len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                depositId++
                                                lockedToken[stor201 + 1].field_0 = arg1
                                                lockedToken[stor201 + 1].field_256 = arg2
                                                lockedToken[stor201 + 1].field_512 = 0
                                                lockedToken[stor201 + 1].field_768 = arg4
                                                lockedToken[stor201 + 1].field_1024 = 0
                                                lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                allDepositIds.length++
                                                stor42D7[stor202.length] = depositId + 1
                                                depositsByWithdrawal[address(arg2)].field_0++
                                                depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = depositId + 1
                                                return memory
                                                  from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32
                                            call msg.sender with:
                                               value ((mem[ceil32(return_data.size) + 128] * sub_aa182aef) - (3 * mem[ceil32(return_data.size) + 128] / 1000 * sub_aa182aef) / 10^uint8(ext_call.return_data[0])) - msg.value wei
                                                 gas gas_remaining wei
                                            if not return_data.size:
                                                require ext_code.size(arg1)
                                                staticcall arg1.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(arg1):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 517 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 641 len 4] = uint32(arg3)
                                                call arg1 with:
                                                     gas gas_remaining wei
                                                    args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                        require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                        if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 627 len 14],
                                                                        uint32(arg3),
                                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 645 len 4]
                                                    require ext_code.size(arg1)
                                                    staticcall arg1.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    depositId++
                                                    lockedToken[stor201 + 1].field_0 = arg1
                                                    lockedToken[stor201 + 1].field_256 = arg2
                                                    lockedToken[stor201 + 1].field_512 = 0
                                                    lockedToken[stor201 + 1].field_768 = arg4
                                                    lockedToken[stor201 + 1].field_1024 = 0
                                                    lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                    allDepositIds.length++
                                                    stor42D7[stor202.length] = depositId + 1
                                                    depositsByWithdrawal[address(arg2)].field_0++
                                                    depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                    return (depositId + 1)
                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 517] = return_data.size
                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 549 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = 32
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 554] = 32
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 'SafeERC20: low-level call failed'
                                                    revert with memory
                                                      from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                                       len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 549]:
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = 32
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 554] = 42
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586 len 42] = 0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565
                                                        revert with memory
                                                          from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                                           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = this.address
                                                require ext_code.size(arg1)
                                                staticcall arg1.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522 len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522] = 32
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 554] = 27
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 'SafeMath: addition overflow'
                                                    revert with memory
                                                      from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                                       len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                depositId++
                                                lockedToken[stor201 + 1].field_0 = arg1
                                                lockedToken[stor201 + 1].field_256 = arg2
                                                lockedToken[stor201 + 1].field_512 = 0
                                                lockedToken[stor201 + 1].field_768 = arg4
                                                lockedToken[stor201 + 1].field_1024 = 0
                                                lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                allDepositIds.length++
                                                stor42D7[stor202.length] = depositId + 1
                                                depositsByWithdrawal[address(arg2)].field_0++
                                                depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518] = depositId + 1
                                                return memory
                                                  from (32 * _57) + (4 * ceil32(return_data.size)) + 518
                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32
                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 385] = return_data.size
                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 417 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 390] = this.address
                                            require ext_code.size(arg1)
                                            staticcall arg1.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 390 len (5 * ceil32(return_data.size)) + 32]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 486] = arg3
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                revert with 0, 'SafeERC20: call to non-contract'
                                            if not ext_code.hash(arg1):
                                                revert with 0, 'SafeERC20: call to non-contract'
                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518 len floor32((5 * ceil32(return_data.size)) + 100)] = unknown_0x23b872dd(?????), msg.sender, address(this.address), mem[(32 * _57) + (4 * ceil32(return_data.size)) + 486 len floor32((5 * ceil32(return_data.size)) + 100) - 68]
                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + floor32((5 * ceil32(return_data.size)) + 100) + -((5 * ceil32(return_data.size)) + 100 % 32) + 550 len (5 * ceil32(return_data.size)) + 100 % 32] = mem[(32 * _57) + (4 * ceil32(return_data.size)) + -((5 * ceil32(return_data.size)) + 100 % 32) + floor32((5 * ceil32(return_data.size)) + 100) + 450 len (5 * ceil32(return_data.size)) + 100 % 32]
                                            call arg1.mem[(32 * _57) + (4 * ceil32(return_data.size)) + 518 len 4] with:
                                                 gas gas_remaining wei
                                                args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 522 len (5 * ceil32(return_data.size)) + 96]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                    require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                    if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                        revert with 0, 
                                                                    32,
                                                                    42,
                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 628 len 22]
                                            else:
                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 550 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    if not mem[(32 * _57) + (4 * ceil32(return_data.size)) + 550]:
                                                        revert with 0, 
                                                                    32,
                                                                    42,
                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 629 len 22]
                                        else:
                                            if not ((mem[ceil32(return_data.size) + 128] * sub_aa182aef) - (3 * mem[ceil32(return_data.size) + 128] / 1000 * sub_aa182aef) / 10^uint8(ext_call.return_data[0])) - msg.value:
                                                if not (mem[ceil32(return_data.size) + 128] * sub_aa182aef) - (3 * mem[ceil32(return_data.size) + 128] / 1000 * sub_aa182aef) / 10^uint8(ext_call.return_data[0]):
                                                    revert with 0, 'SafeMath: division by zero'
                                                if 0 / (mem[ceil32(return_data.size) + 128] * sub_aa182aef) - (3 * mem[ceil32(return_data.size) + 128] / 1000 * sub_aa182aef) / 10^uint8(ext_call.return_data[0]) > 5:
                                                    revert with 0, 'Fee Not Met'
                                                if (mem[ceil32(return_data.size) + 128] * sub_aa182aef) - (3 * mem[ceil32(return_data.size) + 128] / 1000 * sub_aa182aef) / 10^uint8(ext_call.return_data[0]) > msg.value:
                                                    call companyWalletAddress with:
                                                       value msg.value wei
                                                         gas gas_remaining wei
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'Fee transfer failed'
                                                        if (mem[ceil32(return_data.size) + 128] * sub_aa182aef) - (3 * mem[ceil32(return_data.size) + 128] / 1000 * sub_aa182aef) / 10^uint8(ext_call.return_data[0]) > msg.value:
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                                revert with 0, 'SafeERC20: call to non-contract'
                                                            if not ext_code.hash(arg1):
                                                                revert with 0, 'SafeERC20: call to non-contract'
                                                            mem[(32 * _57) + ceil32(return_data.size) + 580 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                            mem[(32 * _57) + ceil32(return_data.size) + 704 len 4] = uint32(arg3)
                                                            call arg1 with:
                                                                 gas gas_remaining wei
                                                                args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + 676 len 4]
                                                            if not return_data.size:
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                    require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                    if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + 690 len 14],
                                                                                    uint32(arg3),
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + 708 len 4]
                                                            else:
                                                                mem[(32 * _57) + ceil32(return_data.size) + 612 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if return_data.size:
                                                                    require return_data.size >= 32
                                                                    if not mem[(32 * _57) + ceil32(return_data.size) + 612]:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 22]
                                                        else:
                                                            if ((mem[ceil32(return_data.size) + 128] * sub_aa182aef) - (3 * mem[ceil32(return_data.size) + 128] / 1000 * sub_aa182aef) / 10^uint8(ext_call.return_data[0])) - msg.value <= 0:
                                                                require ext_code.size(arg1)
                                                                staticcall arg1.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args this.address
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                require return_data.size >= 32
                                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                                if not ext_code.hash(arg1):
                                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                                mem[(32 * _57) + ceil32(return_data.size) + 580 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                                mem[(32 * _57) + ceil32(return_data.size) + 704 len 4] = uint32(arg3)
                                                                call arg1 with:
                                                                     gas gas_remaining wei
                                                                    args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + 676 len 4]
                                                                if not return_data.size:
                                                                    if not ext_call.success:
                                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                                    if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                        require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                        if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                            revert with 0, 
                                                                                        32,
                                                                                        42,
                                                                                        0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                        mem[(32 * _57) + ceil32(return_data.size) + 690 len 14],
                                                                                        uint32(arg3),
                                                                                        mem[(32 * _57) + ceil32(return_data.size) + 708 len 4]
                                                                else:
                                                                    mem[(32 * _57) + ceil32(return_data.size) + 612 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    if not ext_call.success:
                                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                                    if return_data.size:
                                                                        require return_data.size >= 32
                                                                        if not mem[(32 * _57) + ceil32(return_data.size) + 612]:
                                                                            revert with 0, 
                                                                                        32,
                                                                                        42,
                                                                                        0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 22]
                                                            else:
                                                                call msg.sender with:
                                                                   value ((mem[ceil32(return_data.size) + 128] * sub_aa182aef) - (3 * mem[ceil32(return_data.size) + 128] / 1000 * sub_aa182aef) / 10^uint8(ext_call.return_data[0])) - msg.value wei
                                                                     gas gas_remaining wei
                                                                require ext_code.size(arg1)
                                                                staticcall arg1.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args this.address
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                require return_data.size >= 32
                                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                                if not ext_code.hash(arg1):
                                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                                if not return_data.size:
                                                                    mem[(32 * _57) + ceil32(return_data.size) + 580 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                                    mem[(32 * _57) + ceil32(return_data.size) + 704 len 4] = uint32(arg3)
                                                                    call arg1 with:
                                                                         gas gas_remaining wei
                                                                        args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + 676 len 4]
                                                                    if not return_data.size:
                                                                        if not ext_call.success:
                                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                                        if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                            require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                            if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                                revert with 0, 
                                                                                            32,
                                                                                            42,
                                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                            mem[(32 * _57) + ceil32(return_data.size) + 690 len 14],
                                                                                            uint32(arg3),
                                                                                            mem[(32 * _57) + ceil32(return_data.size) + 708 len 4]
                                                                    else:
                                                                        mem[(32 * _57) + ceil32(return_data.size) + 612 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                        if not ext_call.success:
                                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                                        if return_data.size:
                                                                            require return_data.size >= 32
                                                                            if not mem[(32 * _57) + ceil32(return_data.size) + 612]:
                                                                                revert with 0, 
                                                                                            32,
                                                                                            42,
                                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 22]
                                                                else:
                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 705 len 4] = uint32(arg3)
                                                                    call arg1 with:
                                                                         gas gas_remaining wei
                                                                        args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 677 len 4]
                                                                    if not return_data.size:
                                                                        if not ext_call.success:
                                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                                        if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                            require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                            if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                                revert with 0, 
                                                                                            32,
                                                                                            42,
                                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 14],
                                                                                            uint32(arg3),
                                                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 709 len 4]
                                                                    else:
                                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                        if not ext_call.success:
                                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                                        if return_data.size:
                                                                            require return_data.size >= 32
                                                                            if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613]:
                                                                                revert with 0, 
                                                                                            32,
                                                                                            42,
                                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 692 len 22]
                                                    else:
                                                        mem[(32 * _57) + ceil32(return_data.size) + 480 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'Fee transfer failed'
                                                        if (mem[ceil32(return_data.size) + 128] * sub_aa182aef) - (3 * mem[ceil32(return_data.size) + 128] / 1000 * sub_aa182aef) / 10^uint8(ext_call.return_data[0]) > msg.value:
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                                revert with 0, 'SafeERC20: call to non-contract'
                                                            if not ext_code.hash(arg1):
                                                                revert with 0, 'SafeERC20: call to non-contract'
                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 705 len 4] = uint32(arg3)
                                                            call arg1 with:
                                                                 gas gas_remaining wei
                                                                args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 677 len 4]
                                                            if not return_data.size:
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                    require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                    if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 14],
                                                                                    uint32(arg3),
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 709 len 4]
                                                                require ext_code.size(arg1)
                                                                staticcall arg1.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args this.address
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                require return_data.size >= 32
                                                                if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                depositId++
                                                                lockedToken[stor201 + 1].field_0 = arg1
                                                                lockedToken[stor201 + 1].field_256 = arg2
                                                                lockedToken[stor201 + 1].field_512 = 0
                                                                lockedToken[stor201 + 1].field_768 = arg4
                                                                lockedToken[stor201 + 1].field_1024 = 0
                                                                lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                                allDepositIds.length++
                                                                stor42D7[stor202.length] = depositId + 1
                                                                depositsByWithdrawal[address(arg2)].field_0++
                                                                depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                                return (depositId + 1)
                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581] = return_data.size
                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            if not ext_call.success:
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 32
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650] = 'SafeERC20: low-level call failed'
                                                                revert with memory
                                                                  from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                            if return_data.size:
                                                                require return_data.size >= 32
                                                                if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613]:
                                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 42
                                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650 len 42] = 0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565
                                                                    revert with memory
                                                                      from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                                       len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = this.address
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586 len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 27
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650] = 'SafeMath: addition overflow'
                                                                revert with memory
                                                                  from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                            depositId++
                                                            lockedToken[stor201 + 1].field_0 = arg1
                                                            lockedToken[stor201 + 1].field_256 = arg2
                                                            lockedToken[stor201 + 1].field_512 = 0
                                                            lockedToken[stor201 + 1].field_768 = arg4
                                                            lockedToken[stor201 + 1].field_1024 = 0
                                                            lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                            allDepositIds.length++
                                                            stor42D7[stor202.length] = depositId + 1
                                                            depositsByWithdrawal[address(arg2)].field_0++
                                                            depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = depositId + 1
                                                            return memory
                                                              from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32
                                                        if ((mem[ceil32(return_data.size) + 128] * sub_aa182aef) - (3 * mem[ceil32(return_data.size) + 128] / 1000 * sub_aa182aef) / 10^uint8(ext_call.return_data[0])) - msg.value <= 0:
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                                revert with 0, 'SafeERC20: call to non-contract'
                                                            if not ext_code.hash(arg1):
                                                                revert with 0, 'SafeERC20: call to non-contract'
                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 705 len 4] = uint32(arg3)
                                                            call arg1 with:
                                                                 gas gas_remaining wei
                                                                args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 677 len 4]
                                                            if not return_data.size:
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                    require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                    if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 14],
                                                                                    uint32(arg3),
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 709 len 4]
                                                                require ext_code.size(arg1)
                                                                staticcall arg1.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args this.address
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                require return_data.size >= 32
                                                                if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                depositId++
                                                                lockedToken[stor201 + 1].field_0 = arg1
                                                                lockedToken[stor201 + 1].field_256 = arg2
                                                                lockedToken[stor201 + 1].field_512 = 0
                                                                lockedToken[stor201 + 1].field_768 = arg4
                                                                lockedToken[stor201 + 1].field_1024 = 0
                                                                lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                                allDepositIds.length++
                                                                stor42D7[stor202.length] = depositId + 1
                                                                depositsByWithdrawal[address(arg2)].field_0++
                                                                depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                                return (depositId + 1)
                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581] = return_data.size
                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            if not ext_call.success:
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 32
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650] = 'SafeERC20: low-level call failed'
                                                                revert with memory
                                                                  from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                            if return_data.size:
                                                                require return_data.size >= 32
                                                                if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613]:
                                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 42
                                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650 len 42] = 0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565
                                                                    revert with memory
                                                                      from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                                       len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = this.address
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586 len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 27
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650] = 'SafeMath: addition overflow'
                                                                revert with memory
                                                                  from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                            depositId++
                                                            lockedToken[stor201 + 1].field_0 = arg1
                                                            lockedToken[stor201 + 1].field_256 = arg2
                                                            lockedToken[stor201 + 1].field_512 = 0
                                                            lockedToken[stor201 + 1].field_768 = arg4
                                                            lockedToken[stor201 + 1].field_1024 = 0
                                                            lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                            allDepositIds.length++
                                                            stor42D7[stor202.length] = depositId + 1
                                                            depositsByWithdrawal[address(arg2)].field_0++
                                                            depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = depositId + 1
                                                            return memory
                                                              from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32
                                                        call msg.sender with:
                                                           value ((mem[ceil32(return_data.size) + 128] * sub_aa182aef) - (3 * mem[ceil32(return_data.size) + 128] / 1000 * sub_aa182aef) / 10^uint8(ext_call.return_data[0])) - msg.value wei
                                                             gas gas_remaining wei
                                                        if not return_data.size:
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                                revert with 0, 'SafeERC20: call to non-contract'
                                                            if not ext_code.hash(arg1):
                                                                revert with 0, 'SafeERC20: call to non-contract'
                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 705 len 4] = uint32(arg3)
                                                            call arg1 with:
                                                                 gas gas_remaining wei
                                                                args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 677 len 4]
                                                            if not return_data.size:
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                    require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                    if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 14],
                                                                                    uint32(arg3),
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 709 len 4]
                                                                require ext_code.size(arg1)
                                                                staticcall arg1.0x70a08231 with:
                                                                        gas gas_remaining wei
                                                                       args this.address
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                require return_data.size >= 32
                                                                if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                depositId++
                                                                lockedToken[stor201 + 1].field_0 = arg1
                                                                lockedToken[stor201 + 1].field_256 = arg2
                                                                lockedToken[stor201 + 1].field_512 = 0
                                                                lockedToken[stor201 + 1].field_768 = arg4
                                                                lockedToken[stor201 + 1].field_1024 = 0
                                                                lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                                allDepositIds.length++
                                                                stor42D7[stor202.length] = depositId + 1
                                                                depositsByWithdrawal[address(arg2)].field_0++
                                                                depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                                return (depositId + 1)
                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581] = return_data.size
                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            if not ext_call.success:
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 32
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650] = 'SafeERC20: low-level call failed'
                                                                revert with memory
                                                                  from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                            if return_data.size:
                                                                require return_data.size >= 32
                                                                if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613]:
                                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 42
                                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650 len 42] = 0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565
                                                                    revert with memory
                                                                      from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                                       len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = this.address
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586 len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 27
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650] = 'SafeMath: addition overflow'
                                                                revert with memory
                                                                  from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                            depositId++
                                                            lockedToken[stor201 + 1].field_0 = arg1
                                                            lockedToken[stor201 + 1].field_256 = arg2
                                                            lockedToken[stor201 + 1].field_512 = 0
                                                            lockedToken[stor201 + 1].field_768 = arg4
                                                            lockedToken[stor201 + 1].field_1024 = 0
                                                            lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                            allDepositIds.length++
                                                            stor42D7[stor202.length] = depositId + 1
                                                            depositsByWithdrawal[address(arg2)].field_0++
                                                            depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = depositId + 1
                                                            return memory
                                                              from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 449] = return_data.size
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 481 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 454] = this.address
                                                        require ext_code.size(arg1)
                                                        staticcall arg1.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 454 len (5 * ceil32(return_data.size)) + 32]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 550] = arg3
                                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        if not ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582 len floor32((5 * ceil32(return_data.size)) + 100)] = unknown_0x23b872dd(?????), msg.sender, address(this.address), mem[(32 * _57) + (4 * ceil32(return_data.size)) + 550 len floor32((5 * ceil32(return_data.size)) + 100) - 68]
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + floor32((5 * ceil32(return_data.size)) + 100) + -((5 * ceil32(return_data.size)) + 100 % 32) + 614 len (5 * ceil32(return_data.size)) + 100 % 32] = mem[(32 * _57) + (4 * ceil32(return_data.size)) + -((5 * ceil32(return_data.size)) + 100 % 32) + floor32((5 * ceil32(return_data.size)) + 100) + 514 len (5 * ceil32(return_data.size)) + 100 % 32]
                                                        call arg1.mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582 len 4] with:
                                                             gas gas_remaining wei
                                                            args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586 len (5 * ceil32(return_data.size)) + 96]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                revert with 0, 'SafeERC20: low-level call failed'
                                                            if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 692 len 22]
                                                        else:
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 614 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            if not ext_call.success:
                                                                revert with 0, 'SafeERC20: low-level call failed'
                                                            if return_data.size:
                                                                require return_data.size >= 32
                                                                if not mem[(32 * _57) + (4 * ceil32(return_data.size)) + 614]:
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 693 len 22]
                                                else:
                                                    call companyWalletAddress with:
                                                       value (mem[ceil32(return_data.size) + 128] * sub_aa182aef) - (3 * mem[ceil32(return_data.size) + 128] / 1000 * sub_aa182aef) / 10^uint8(ext_call.return_data[0]) wei
                                                         gas gas_remaining wei
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'Fee transfer failed'
                                                        if (mem[ceil32(return_data.size) + 128] * sub_aa182aef) - (3 * mem[ceil32(return_data.size) + 128] / 1000 * sub_aa182aef) / 10^uint8(ext_call.return_data[0]) > msg.value:
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                                revert with 0, 'SafeERC20: call to non-contract'
                                                            if not ext_code.hash(arg1):
                                                                revert with 0, 'SafeERC20: call to non-contract'
                                                            mem[(32 * _57) + ceil32(return_data.size) + 580 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                            mem[(32 * _57) + ceil32(return_data.size) + 704 len 4] = uint32(arg3)
                                                            call arg1 with:
                                                                 gas gas_remaining wei
                                                                args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + 676 len 4]
                                                            if not return_data.size:
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                    require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                    if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + 690 len 14],
                                                                                    uint32(arg3),
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + 708 len 4]
                                                            else:
                                                                mem[(32 * _57) + ceil32(return_data.size) + 612 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if return_data.size:
                                                                    require return_data.size >= 32
                                                                    if not mem[(32 * _57) + ceil32(return_data.size) + 612]:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 22]
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            depositId++
                                                            lockedToken[stor201 + 1].field_0 = arg1
                                                            lockedToken[stor201 + 1].field_256 = arg2
                                                            lockedToken[stor201 + 1].field_512 = 0
                                                            lockedToken[stor201 + 1].field_768 = arg4
                                                            lockedToken[stor201 + 1].field_1024 = 0
                                                            lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                            allDepositIds.length++
                                                            stor42D7[stor202.length] = depositId + 1
                                                            depositsByWithdrawal[address(arg2)].field_0++
                                                            depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                            return (depositId + 1)
                                                        if ((mem[ceil32(return_data.size) + 128] * sub_aa182aef) - (3 * mem[ceil32(return_data.size) + 128] / 1000 * sub_aa182aef) / 10^uint8(ext_call.return_data[0])) - msg.value <= 0:
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                                revert with 0, 'SafeERC20: call to non-contract'
                                                            if not ext_code.hash(arg1):
                                                                revert with 0, 'SafeERC20: call to non-contract'
                                                            mem[(32 * _57) + ceil32(return_data.size) + 580 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                            mem[(32 * _57) + ceil32(return_data.size) + 704 len 4] = uint32(arg3)
                                                            call arg1 with:
                                                                 gas gas_remaining wei
                                                                args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + 676 len 4]
                                                            if not return_data.size:
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                    require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                    if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + 690 len 14],
                                                                                    uint32(arg3),
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + 708 len 4]
                                                            else:
                                                                mem[(32 * _57) + ceil32(return_data.size) + 612 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if return_data.size:
                                                                    require return_data.size >= 32
                                                                    if not mem[(32 * _57) + ceil32(return_data.size) + 612]:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 22]
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            depositId++
                                                            lockedToken[stor201 + 1].field_0 = arg1
                                                            lockedToken[stor201 + 1].field_256 = arg2
                                                            lockedToken[stor201 + 1].field_512 = 0
                                                            lockedToken[stor201 + 1].field_768 = arg4
                                                            lockedToken[stor201 + 1].field_1024 = 0
                                                            lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                            allDepositIds.length++
                                                            stor42D7[stor202.length] = depositId + 1
                                                            depositsByWithdrawal[address(arg2)].field_0++
                                                            depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                            return (depositId + 1)
                                                        call msg.sender with:
                                                           value ((mem[ceil32(return_data.size) + 128] * sub_aa182aef) - (3 * mem[ceil32(return_data.size) + 128] / 1000 * sub_aa182aef) / 10^uint8(ext_call.return_data[0])) - msg.value wei
                                                             gas gas_remaining wei
                                                        require ext_code.size(arg1)
                                                        staticcall arg1.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        if not ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        if not return_data.size:
                                                            mem[(32 * _57) + ceil32(return_data.size) + 580 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                            mem[(32 * _57) + ceil32(return_data.size) + 704 len 4] = uint32(arg3)
                                                            call arg1 with:
                                                                 gas gas_remaining wei
                                                                args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + 676 len 4]
                                                            if not return_data.size:
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                    require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                    if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + 690 len 14],
                                                                                    uint32(arg3),
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + 708 len 4]
                                                            else:
                                                                mem[(32 * _57) + ceil32(return_data.size) + 612 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if return_data.size:
                                                                    require return_data.size >= 32
                                                                    if not mem[(32 * _57) + ceil32(return_data.size) + 612]:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 22]
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            depositId++
                                                            lockedToken[stor201 + 1].field_0 = arg1
                                                            lockedToken[stor201 + 1].field_256 = arg2
                                                            lockedToken[stor201 + 1].field_512 = 0
                                                            lockedToken[stor201 + 1].field_768 = arg4
                                                            lockedToken[stor201 + 1].field_1024 = 0
                                                            lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                            allDepositIds.length++
                                                            stor42D7[stor202.length] = depositId + 1
                                                            depositsByWithdrawal[address(arg2)].field_0++
                                                            depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                            return (depositId + 1)
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 705 len 4] = uint32(arg3)
                                                        call arg1 with:
                                                             gas gas_remaining wei
                                                            args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 677 len 4]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                revert with 0, 'SafeERC20: low-level call failed'
                                                            if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 14],
                                                                                uint32(arg3),
                                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 709 len 4]
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            depositId++
                                                            lockedToken[stor201 + 1].field_0 = arg1
                                                            lockedToken[stor201 + 1].field_256 = arg2
                                                            lockedToken[stor201 + 1].field_512 = 0
                                                            lockedToken[stor201 + 1].field_768 = arg4
                                                            lockedToken[stor201 + 1].field_1024 = 0
                                                            lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                            allDepositIds.length++
                                                            stor42D7[stor202.length] = depositId + 1
                                                            depositsByWithdrawal[address(arg2)].field_0++
                                                            depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                            return (depositId + 1)
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581] = return_data.size
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650] = 'SafeERC20: low-level call failed'
                                                            revert with memory
                                                              from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613]:
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 42
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650 len 42] = 0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565
                                                                revert with memory
                                                                  from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = this.address
                                                        require ext_code.size(arg1)
                                                        staticcall arg1.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586 len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 27
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650] = 'SafeMath: addition overflow'
                                                            revert with memory
                                                              from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                        depositId++
                                                        lockedToken[stor201 + 1].field_0 = arg1
                                                        lockedToken[stor201 + 1].field_256 = arg2
                                                        lockedToken[stor201 + 1].field_512 = 0
                                                        lockedToken[stor201 + 1].field_768 = arg4
                                                        lockedToken[stor201 + 1].field_1024 = 0
                                                        lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                        allDepositIds.length++
                                                        stor42D7[stor202.length] = depositId + 1
                                                        depositsByWithdrawal[address(arg2)].field_0++
                                                        depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = depositId + 1
                                                        return memory
                                                          from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32
                                                    mem[(32 * _57) + ceil32(return_data.size) + 480 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'Fee transfer failed'
                                                    if (mem[ceil32(return_data.size) + 128] * sub_aa182aef) - (3 * mem[ceil32(return_data.size) + 128] / 1000 * sub_aa182aef) / 10^uint8(ext_call.return_data[0]) > msg.value:
                                                        require ext_code.size(arg1)
                                                        staticcall arg1.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        if not ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 705 len 4] = uint32(arg3)
                                                        call arg1 with:
                                                             gas gas_remaining wei
                                                            args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 677 len 4]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                revert with 0, 'SafeERC20: low-level call failed'
                                                            if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 14],
                                                                                uint32(arg3),
                                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 709 len 4]
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            depositId++
                                                            lockedToken[stor201 + 1].field_0 = arg1
                                                            lockedToken[stor201 + 1].field_256 = arg2
                                                            lockedToken[stor201 + 1].field_512 = 0
                                                            lockedToken[stor201 + 1].field_768 = arg4
                                                            lockedToken[stor201 + 1].field_1024 = 0
                                                            lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                            allDepositIds.length++
                                                            stor42D7[stor202.length] = depositId + 1
                                                            depositsByWithdrawal[address(arg2)].field_0++
                                                            depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                            return (depositId + 1)
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581] = return_data.size
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650] = 'SafeERC20: low-level call failed'
                                                            revert with memory
                                                              from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613]:
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 42
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650 len 42] = 0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565
                                                                revert with memory
                                                                  from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = this.address
                                                        require ext_code.size(arg1)
                                                        staticcall arg1.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586 len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 27
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650] = 'SafeMath: addition overflow'
                                                            revert with memory
                                                              from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                        depositId++
                                                        lockedToken[stor201 + 1].field_0 = arg1
                                                        lockedToken[stor201 + 1].field_256 = arg2
                                                        lockedToken[stor201 + 1].field_512 = 0
                                                        lockedToken[stor201 + 1].field_768 = arg4
                                                        lockedToken[stor201 + 1].field_1024 = 0
                                                        lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                        allDepositIds.length++
                                                        stor42D7[stor202.length] = depositId + 1
                                                        depositsByWithdrawal[address(arg2)].field_0++
                                                        depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = depositId + 1
                                                        return memory
                                                          from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32
                                                    if ((mem[ceil32(return_data.size) + 128] * sub_aa182aef) - (3 * mem[ceil32(return_data.size) + 128] / 1000 * sub_aa182aef) / 10^uint8(ext_call.return_data[0])) - msg.value <= 0:
                                                        require ext_code.size(arg1)
                                                        staticcall arg1.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        if not ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 705 len 4] = uint32(arg3)
                                                        call arg1 with:
                                                             gas gas_remaining wei
                                                            args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 677 len 4]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                revert with 0, 'SafeERC20: low-level call failed'
                                                            if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 14],
                                                                                uint32(arg3),
                                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 709 len 4]
                                                        else:
                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            if not ext_call.success:
                                                                revert with 0, 'SafeERC20: low-level call failed'
                                                            if return_data.size:
                                                                require return_data.size >= 32
                                                                if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613]:
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 692 len 22]
                                                    else:
                                                        call msg.sender with:
                                                           value ((mem[ceil32(return_data.size) + 128] * sub_aa182aef) - (3 * mem[ceil32(return_data.size) + 128] / 1000 * sub_aa182aef) / 10^uint8(ext_call.return_data[0])) - msg.value wei
                                                             gas gas_remaining wei
                                                        if not return_data.size:
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                                revert with 0, 'SafeERC20: call to non-contract'
                                                            if not ext_code.hash(arg1):
                                                                revert with 0, 'SafeERC20: call to non-contract'
                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 705 len 4] = uint32(arg3)
                                                            call arg1 with:
                                                                 gas gas_remaining wei
                                                                args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 677 len 4]
                                                            if not return_data.size:
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                    require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                    if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 14],
                                                                                    uint32(arg3),
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 709 len 4]
                                                            else:
                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if return_data.size:
                                                                    require return_data.size >= 32
                                                                    if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613]:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 692 len 22]
                                                        else:
                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 449] = return_data.size
                                                            mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 481 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 454] = this.address
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 454 len (5 * ceil32(return_data.size)) + 32]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 550] = arg3
                                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                                revert with 0, 'SafeERC20: call to non-contract'
                                                            if not ext_code.hash(arg1):
                                                                revert with 0, 'SafeERC20: call to non-contract'
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582 len floor32((5 * ceil32(return_data.size)) + 100)] = unknown_0x23b872dd(?????), msg.sender, address(this.address), mem[(32 * _57) + (4 * ceil32(return_data.size)) + 550 len floor32((5 * ceil32(return_data.size)) + 100) - 68]
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + floor32((5 * ceil32(return_data.size)) + 100) + -((5 * ceil32(return_data.size)) + 100 % 32) + 614 len (5 * ceil32(return_data.size)) + 100 % 32] = mem[(32 * _57) + (4 * ceil32(return_data.size)) + -((5 * ceil32(return_data.size)) + 100 % 32) + floor32((5 * ceil32(return_data.size)) + 100) + 514 len (5 * ceil32(return_data.size)) + 100 % 32]
                                                            call arg1.mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582 len 4] with:
                                                                 gas gas_remaining wei
                                                                args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586 len (5 * ceil32(return_data.size)) + 96]
                                                            if not return_data.size:
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                    require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                    if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 692 len 22]
                                                            else:
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 614 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if return_data.size:
                                                                    require return_data.size >= 32
                                                                    if not mem[(32 * _57) + (4 * ceil32(return_data.size)) + 614]:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 693 len 22]
                                            else:
                                                if (100 * (mem[ceil32(return_data.size) + 128] * sub_aa182aef) - (3 * mem[ceil32(return_data.size) + 128] / 1000 * sub_aa182aef) / 10^uint8(ext_call.return_data[0])) - (100 * msg.value) / ((mem[ceil32(return_data.size) + 128] * sub_aa182aef) - (3 * mem[ceil32(return_data.size) + 128] / 1000 * sub_aa182aef) / 10^uint8(ext_call.return_data[0])) - msg.value != 100:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _57) + ceil32(return_data.size) + 485 len 31]
                                                if not (mem[ceil32(return_data.size) + 128] * sub_aa182aef) - (3 * mem[ceil32(return_data.size) + 128] / 1000 * sub_aa182aef) / 10^uint8(ext_call.return_data[0]):
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (100 * (mem[ceil32(return_data.size) + 128] * sub_aa182aef) - (3 * mem[ceil32(return_data.size) + 128] / 1000 * sub_aa182aef) / 10^uint8(ext_call.return_data[0])) - (100 * msg.value) / (mem[ceil32(return_data.size) + 128] * sub_aa182aef) - (3 * mem[ceil32(return_data.size) + 128] / 1000 * sub_aa182aef) / 10^uint8(ext_call.return_data[0]) > 5:
                                                    revert with 0, 'Fee Not Met'
                                                if (mem[ceil32(return_data.size) + 128] * sub_aa182aef) - (3 * mem[ceil32(return_data.size) + 128] / 1000 * sub_aa182aef) / 10^uint8(ext_call.return_data[0]) > msg.value:
                                                    call companyWalletAddress with:
                                                       value msg.value wei
                                                         gas gas_remaining wei
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'Fee transfer failed'
                                                        if (mem[ceil32(return_data.size) + 128] * sub_aa182aef) - (3 * mem[ceil32(return_data.size) + 128] / 1000 * sub_aa182aef) / 10^uint8(ext_call.return_data[0]) > msg.value:
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                                revert with 0, 'SafeERC20: call to non-contract'
                                                            if not ext_code.hash(arg1):
                                                                revert with 0, 'SafeERC20: call to non-contract'
                                                            mem[(32 * _57) + ceil32(return_data.size) + 580 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                            mem[(32 * _57) + ceil32(return_data.size) + 704 len 4] = uint32(arg3)
                                                            call arg1 with:
                                                                 gas gas_remaining wei
                                                                args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + 676 len 4]
                                                            if not return_data.size:
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                    require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                    if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + 690 len 14],
                                                                                    uint32(arg3),
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + 708 len 4]
                                                            else:
                                                                mem[(32 * _57) + ceil32(return_data.size) + 612 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if return_data.size:
                                                                    require return_data.size >= 32
                                                                    if not mem[(32 * _57) + ceil32(return_data.size) + 612]:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 22]
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            depositId++
                                                            lockedToken[stor201 + 1].field_0 = arg1
                                                            lockedToken[stor201 + 1].field_256 = arg2
                                                            lockedToken[stor201 + 1].field_512 = 0
                                                            lockedToken[stor201 + 1].field_768 = arg4
                                                            lockedToken[stor201 + 1].field_1024 = 0
                                                            lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                            allDepositIds.length++
                                                            stor42D7[stor202.length] = depositId + 1
                                                            depositsByWithdrawal[address(arg2)].field_0++
                                                            depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                            return (depositId + 1)
                                                        if ((mem[ceil32(return_data.size) + 128] * sub_aa182aef) - (3 * mem[ceil32(return_data.size) + 128] / 1000 * sub_aa182aef) / 10^uint8(ext_call.return_data[0])) - msg.value <= 0:
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                                revert with 0, 'SafeERC20: call to non-contract'
                                                            if not ext_code.hash(arg1):
                                                                revert with 0, 'SafeERC20: call to non-contract'
                                                            mem[(32 * _57) + ceil32(return_data.size) + 580 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                            mem[(32 * _57) + ceil32(return_data.size) + 704 len 4] = uint32(arg3)
                                                            call arg1 with:
                                                                 gas gas_remaining wei
                                                                args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + 676 len 4]
                                                            if not return_data.size:
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                    require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                    if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + 690 len 14],
                                                                                    uint32(arg3),
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + 708 len 4]
                                                            else:
                                                                mem[(32 * _57) + ceil32(return_data.size) + 612 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if return_data.size:
                                                                    require return_data.size >= 32
                                                                    if not mem[(32 * _57) + ceil32(return_data.size) + 612]:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 22]
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            depositId++
                                                            lockedToken[stor201 + 1].field_0 = arg1
                                                            lockedToken[stor201 + 1].field_256 = arg2
                                                            lockedToken[stor201 + 1].field_512 = 0
                                                            lockedToken[stor201 + 1].field_768 = arg4
                                                            lockedToken[stor201 + 1].field_1024 = 0
                                                            lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                            allDepositIds.length++
                                                            stor42D7[stor202.length] = depositId + 1
                                                            depositsByWithdrawal[address(arg2)].field_0++
                                                            depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                            return (depositId + 1)
                                                        call msg.sender with:
                                                           value ((mem[ceil32(return_data.size) + 128] * sub_aa182aef) - (3 * mem[ceil32(return_data.size) + 128] / 1000 * sub_aa182aef) / 10^uint8(ext_call.return_data[0])) - msg.value wei
                                                             gas gas_remaining wei
                                                        require ext_code.size(arg1)
                                                        staticcall arg1.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        if not ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        if not return_data.size:
                                                            mem[(32 * _57) + ceil32(return_data.size) + 580 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                            mem[(32 * _57) + ceil32(return_data.size) + 704 len 4] = uint32(arg3)
                                                            call arg1 with:
                                                                 gas gas_remaining wei
                                                                args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + 676 len 4]
                                                            if not return_data.size:
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                    require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                    if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + 690 len 14],
                                                                                    uint32(arg3),
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + 708 len 4]
                                                            else:
                                                                mem[(32 * _57) + ceil32(return_data.size) + 612 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if return_data.size:
                                                                    require return_data.size >= 32
                                                                    if not mem[(32 * _57) + ceil32(return_data.size) + 612]:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 22]
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            depositId++
                                                            lockedToken[stor201 + 1].field_0 = arg1
                                                            lockedToken[stor201 + 1].field_256 = arg2
                                                            lockedToken[stor201 + 1].field_512 = 0
                                                            lockedToken[stor201 + 1].field_768 = arg4
                                                            lockedToken[stor201 + 1].field_1024 = 0
                                                            lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                            allDepositIds.length++
                                                            stor42D7[stor202.length] = depositId + 1
                                                            depositsByWithdrawal[address(arg2)].field_0++
                                                            depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                            return (depositId + 1)
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 705 len 4] = uint32(arg3)
                                                        call arg1 with:
                                                             gas gas_remaining wei
                                                            args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 677 len 4]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                revert with 0, 'SafeERC20: low-level call failed'
                                                            if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 14],
                                                                                uint32(arg3),
                                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 709 len 4]
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            depositId++
                                                            lockedToken[stor201 + 1].field_0 = arg1
                                                            lockedToken[stor201 + 1].field_256 = arg2
                                                            lockedToken[stor201 + 1].field_512 = 0
                                                            lockedToken[stor201 + 1].field_768 = arg4
                                                            lockedToken[stor201 + 1].field_1024 = 0
                                                            lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                            allDepositIds.length++
                                                            stor42D7[stor202.length] = depositId + 1
                                                            depositsByWithdrawal[address(arg2)].field_0++
                                                            depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                            return (depositId + 1)
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581] = return_data.size
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650] = 'SafeERC20: low-level call failed'
                                                            revert with memory
                                                              from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613]:
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 42
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650 len 42] = 0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565
                                                                revert with memory
                                                                  from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = this.address
                                                        require ext_code.size(arg1)
                                                        staticcall arg1.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586 len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 27
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650] = 'SafeMath: addition overflow'
                                                            revert with memory
                                                              from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                        depositId++
                                                        lockedToken[stor201 + 1].field_0 = arg1
                                                        lockedToken[stor201 + 1].field_256 = arg2
                                                        lockedToken[stor201 + 1].field_512 = 0
                                                        lockedToken[stor201 + 1].field_768 = arg4
                                                        lockedToken[stor201 + 1].field_1024 = 0
                                                        lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                        allDepositIds.length++
                                                        stor42D7[stor202.length] = depositId + 1
                                                        depositsByWithdrawal[address(arg2)].field_0++
                                                        depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = depositId + 1
                                                        return memory
                                                          from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32
                                                    mem[(32 * _57) + ceil32(return_data.size) + 480 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'Fee transfer failed'
                                                    if (mem[ceil32(return_data.size) + 128] * sub_aa182aef) - (3 * mem[ceil32(return_data.size) + 128] / 1000 * sub_aa182aef) / 10^uint8(ext_call.return_data[0]) > msg.value:
                                                        require ext_code.size(arg1)
                                                        staticcall arg1.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        if not ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 705 len 4] = uint32(arg3)
                                                        call arg1 with:
                                                             gas gas_remaining wei
                                                            args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 677 len 4]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                revert with 0, 'SafeERC20: low-level call failed'
                                                            if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 14],
                                                                                uint32(arg3),
                                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 709 len 4]
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            depositId++
                                                            lockedToken[stor201 + 1].field_0 = arg1
                                                            lockedToken[stor201 + 1].field_256 = arg2
                                                            lockedToken[stor201 + 1].field_512 = 0
                                                            lockedToken[stor201 + 1].field_768 = arg4
                                                            lockedToken[stor201 + 1].field_1024 = 0
                                                            lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                            allDepositIds.length++
                                                            stor42D7[stor202.length] = depositId + 1
                                                            depositsByWithdrawal[address(arg2)].field_0++
                                                            depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                            return (depositId + 1)
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581] = return_data.size
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650] = 'SafeERC20: low-level call failed'
                                                            revert with memory
                                                              from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613]:
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 42
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650 len 42] = 0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565
                                                                revert with memory
                                                                  from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = this.address
                                                        require ext_code.size(arg1)
                                                        staticcall arg1.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586 len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 27
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650] = 'SafeMath: addition overflow'
                                                            revert with memory
                                                              from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                        depositId++
                                                        lockedToken[stor201 + 1].field_0 = arg1
                                                        lockedToken[stor201 + 1].field_256 = arg2
                                                        lockedToken[stor201 + 1].field_512 = 0
                                                        lockedToken[stor201 + 1].field_768 = arg4
                                                        lockedToken[stor201 + 1].field_1024 = 0
                                                        lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                        allDepositIds.length++
                                                        stor42D7[stor202.length] = depositId + 1
                                                        depositsByWithdrawal[address(arg2)].field_0++
                                                        depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = depositId + 1
                                                        return memory
                                                          from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32
                                                    if ((mem[ceil32(return_data.size) + 128] * sub_aa182aef) - (3 * mem[ceil32(return_data.size) + 128] / 1000 * sub_aa182aef) / 10^uint8(ext_call.return_data[0])) - msg.value <= 0:
                                                        require ext_code.size(arg1)
                                                        staticcall arg1.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        if not ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 705 len 4] = uint32(arg3)
                                                        call arg1 with:
                                                             gas gas_remaining wei
                                                            args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 677 len 4]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                revert with 0, 'SafeERC20: low-level call failed'
                                                            if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 14],
                                                                                uint32(arg3),
                                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 709 len 4]
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            depositId++
                                                            lockedToken[stor201 + 1].field_0 = arg1
                                                            lockedToken[stor201 + 1].field_256 = arg2
                                                            lockedToken[stor201 + 1].field_512 = 0
                                                            lockedToken[stor201 + 1].field_768 = arg4
                                                            lockedToken[stor201 + 1].field_1024 = 0
                                                            lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                            allDepositIds.length++
                                                            stor42D7[stor202.length] = depositId + 1
                                                            depositsByWithdrawal[address(arg2)].field_0++
                                                            depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                            return (depositId + 1)
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581] = return_data.size
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650] = 'SafeERC20: low-level call failed'
                                                            revert with memory
                                                              from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613]:
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 42
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650 len 42] = 0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565
                                                                revert with memory
                                                                  from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = this.address
                                                        require ext_code.size(arg1)
                                                        staticcall arg1.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586 len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 27
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650] = 'SafeMath: addition overflow'
                                                            revert with memory
                                                              from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                        depositId++
                                                        lockedToken[stor201 + 1].field_0 = arg1
                                                        lockedToken[stor201 + 1].field_256 = arg2
                                                        lockedToken[stor201 + 1].field_512 = 0
                                                        lockedToken[stor201 + 1].field_768 = arg4
                                                        lockedToken[stor201 + 1].field_1024 = 0
                                                        lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                        allDepositIds.length++
                                                        stor42D7[stor202.length] = depositId + 1
                                                        depositsByWithdrawal[address(arg2)].field_0++
                                                        depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = depositId + 1
                                                        return memory
                                                          from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32
                                                    call msg.sender with:
                                                       value ((mem[ceil32(return_data.size) + 128] * sub_aa182aef) - (3 * mem[ceil32(return_data.size) + 128] / 1000 * sub_aa182aef) / 10^uint8(ext_call.return_data[0])) - msg.value wei
                                                         gas gas_remaining wei
                                                    if not return_data.size:
                                                        require ext_code.size(arg1)
                                                        staticcall arg1.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        if not ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 705 len 4] = uint32(arg3)
                                                        call arg1 with:
                                                             gas gas_remaining wei
                                                            args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 677 len 4]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                revert with 0, 'SafeERC20: low-level call failed'
                                                            if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 14],
                                                                                uint32(arg3),
                                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 709 len 4]
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            depositId++
                                                            lockedToken[stor201 + 1].field_0 = arg1
                                                            lockedToken[stor201 + 1].field_256 = arg2
                                                            lockedToken[stor201 + 1].field_512 = 0
                                                            lockedToken[stor201 + 1].field_768 = arg4
                                                            lockedToken[stor201 + 1].field_1024 = 0
                                                            lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                            allDepositIds.length++
                                                            stor42D7[stor202.length] = depositId + 1
                                                            depositsByWithdrawal[address(arg2)].field_0++
                                                            depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                            return (depositId + 1)
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581] = return_data.size
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650] = 'SafeERC20: low-level call failed'
                                                            revert with memory
                                                              from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613]:
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 42
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650 len 42] = 0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565
                                                                revert with memory
                                                                  from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = this.address
                                                        require ext_code.size(arg1)
                                                        staticcall arg1.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586 len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 27
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650] = 'SafeMath: addition overflow'
                                                            revert with memory
                                                              from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                        depositId++
                                                        lockedToken[stor201 + 1].field_0 = arg1
                                                        lockedToken[stor201 + 1].field_256 = arg2
                                                        lockedToken[stor201 + 1].field_512 = 0
                                                        lockedToken[stor201 + 1].field_768 = arg4
                                                        lockedToken[stor201 + 1].field_1024 = 0
                                                        lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                        allDepositIds.length++
                                                        stor42D7[stor202.length] = depositId + 1
                                                        depositsByWithdrawal[address(arg2)].field_0++
                                                        depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = depositId + 1
                                                        return memory
                                                          from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32
                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 449] = return_data.size
                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 481 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 454] = this.address
                                                    require ext_code.size(arg1)
                                                    staticcall arg1.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 454 len (5 * ceil32(return_data.size)) + 32]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 550] = arg3
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(arg1):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582 len floor32((5 * ceil32(return_data.size)) + 100)] = unknown_0x23b872dd(?????), msg.sender, address(this.address), mem[(32 * _57) + (4 * ceil32(return_data.size)) + 550 len floor32((5 * ceil32(return_data.size)) + 100) - 68]
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + floor32((5 * ceil32(return_data.size)) + 100) + -((5 * ceil32(return_data.size)) + 100 % 32) + 614 len (5 * ceil32(return_data.size)) + 100 % 32] = mem[(32 * _57) + (4 * ceil32(return_data.size)) + -((5 * ceil32(return_data.size)) + 100 % 32) + floor32((5 * ceil32(return_data.size)) + 100) + 514 len (5 * ceil32(return_data.size)) + 100 % 32]
                                                else:
                                                    call companyWalletAddress with:
                                                       value (mem[ceil32(return_data.size) + 128] * sub_aa182aef) - (3 * mem[ceil32(return_data.size) + 128] / 1000 * sub_aa182aef) / 10^uint8(ext_call.return_data[0]) wei
                                                         gas gas_remaining wei
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'Fee transfer failed'
                                                        if (mem[ceil32(return_data.size) + 128] * sub_aa182aef) - (3 * mem[ceil32(return_data.size) + 128] / 1000 * sub_aa182aef) / 10^uint8(ext_call.return_data[0]) > msg.value:
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                                revert with 0, 'SafeERC20: call to non-contract'
                                                            if not ext_code.hash(arg1):
                                                                revert with 0, 'SafeERC20: call to non-contract'
                                                            mem[(32 * _57) + ceil32(return_data.size) + 580 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                            mem[(32 * _57) + ceil32(return_data.size) + 704 len 4] = uint32(arg3)
                                                            call arg1 with:
                                                                 gas gas_remaining wei
                                                                args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + 676 len 4]
                                                            if not return_data.size:
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                    require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                    if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + 690 len 14],
                                                                                    uint32(arg3),
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + 708 len 4]
                                                            else:
                                                                mem[(32 * _57) + ceil32(return_data.size) + 612 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if return_data.size:
                                                                    require return_data.size >= 32
                                                                    if not mem[(32 * _57) + ceil32(return_data.size) + 612]:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 22]
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            depositId++
                                                            lockedToken[stor201 + 1].field_0 = arg1
                                                            lockedToken[stor201 + 1].field_256 = arg2
                                                            lockedToken[stor201 + 1].field_512 = 0
                                                            lockedToken[stor201 + 1].field_768 = arg4
                                                            lockedToken[stor201 + 1].field_1024 = 0
                                                            lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                            allDepositIds.length++
                                                            stor42D7[stor202.length] = depositId + 1
                                                            depositsByWithdrawal[address(arg2)].field_0++
                                                            depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                            return (depositId + 1)
                                                        if ((mem[ceil32(return_data.size) + 128] * sub_aa182aef) - (3 * mem[ceil32(return_data.size) + 128] / 1000 * sub_aa182aef) / 10^uint8(ext_call.return_data[0])) - msg.value <= 0:
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                                revert with 0, 'SafeERC20: call to non-contract'
                                                            if not ext_code.hash(arg1):
                                                                revert with 0, 'SafeERC20: call to non-contract'
                                                            mem[(32 * _57) + ceil32(return_data.size) + 580 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                            mem[(32 * _57) + ceil32(return_data.size) + 704 len 4] = uint32(arg3)
                                                            call arg1 with:
                                                                 gas gas_remaining wei
                                                                args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + 676 len 4]
                                                            if not return_data.size:
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                    require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                    if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + 690 len 14],
                                                                                    uint32(arg3),
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + 708 len 4]
                                                            else:
                                                                mem[(32 * _57) + ceil32(return_data.size) + 612 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if return_data.size:
                                                                    require return_data.size >= 32
                                                                    if not mem[(32 * _57) + ceil32(return_data.size) + 612]:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 22]
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            depositId++
                                                            lockedToken[stor201 + 1].field_0 = arg1
                                                            lockedToken[stor201 + 1].field_256 = arg2
                                                            lockedToken[stor201 + 1].field_512 = 0
                                                            lockedToken[stor201 + 1].field_768 = arg4
                                                            lockedToken[stor201 + 1].field_1024 = 0
                                                            lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                            allDepositIds.length++
                                                            stor42D7[stor202.length] = depositId + 1
                                                            depositsByWithdrawal[address(arg2)].field_0++
                                                            depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                            return (depositId + 1)
                                                        call msg.sender with:
                                                           value ((mem[ceil32(return_data.size) + 128] * sub_aa182aef) - (3 * mem[ceil32(return_data.size) + 128] / 1000 * sub_aa182aef) / 10^uint8(ext_call.return_data[0])) - msg.value wei
                                                             gas gas_remaining wei
                                                        require ext_code.size(arg1)
                                                        staticcall arg1.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        if not ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        if not return_data.size:
                                                            mem[(32 * _57) + ceil32(return_data.size) + 580 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                            mem[(32 * _57) + ceil32(return_data.size) + 704 len 4] = uint32(arg3)
                                                            call arg1 with:
                                                                 gas gas_remaining wei
                                                                args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + 676 len 4]
                                                            if not return_data.size:
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                    require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                    if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + 690 len 14],
                                                                                    uint32(arg3),
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + 708 len 4]
                                                            else:
                                                                mem[(32 * _57) + ceil32(return_data.size) + 612 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                if not ext_call.success:
                                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                                if return_data.size:
                                                                    require return_data.size >= 32
                                                                    if not mem[(32 * _57) + ceil32(return_data.size) + 612]:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    42,
                                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 22]
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            depositId++
                                                            lockedToken[stor201 + 1].field_0 = arg1
                                                            lockedToken[stor201 + 1].field_256 = arg2
                                                            lockedToken[stor201 + 1].field_512 = 0
                                                            lockedToken[stor201 + 1].field_768 = arg4
                                                            lockedToken[stor201 + 1].field_1024 = 0
                                                            lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                            allDepositIds.length++
                                                            stor42D7[stor202.length] = depositId + 1
                                                            depositsByWithdrawal[address(arg2)].field_0++
                                                            depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                            return (depositId + 1)
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 705 len 4] = uint32(arg3)
                                                        call arg1 with:
                                                             gas gas_remaining wei
                                                            args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 677 len 4]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                revert with 0, 'SafeERC20: low-level call failed'
                                                            if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 14],
                                                                                uint32(arg3),
                                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 709 len 4]
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            depositId++
                                                            lockedToken[stor201 + 1].field_0 = arg1
                                                            lockedToken[stor201 + 1].field_256 = arg2
                                                            lockedToken[stor201 + 1].field_512 = 0
                                                            lockedToken[stor201 + 1].field_768 = arg4
                                                            lockedToken[stor201 + 1].field_1024 = 0
                                                            lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                            allDepositIds.length++
                                                            stor42D7[stor202.length] = depositId + 1
                                                            depositsByWithdrawal[address(arg2)].field_0++
                                                            depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                            return (depositId + 1)
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581] = return_data.size
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650] = 'SafeERC20: low-level call failed'
                                                            revert with memory
                                                              from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613]:
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 42
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650 len 42] = 0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565
                                                                revert with memory
                                                                  from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = this.address
                                                        require ext_code.size(arg1)
                                                        staticcall arg1.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586 len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 27
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650] = 'SafeMath: addition overflow'
                                                            revert with memory
                                                              from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                        depositId++
                                                        lockedToken[stor201 + 1].field_0 = arg1
                                                        lockedToken[stor201 + 1].field_256 = arg2
                                                        lockedToken[stor201 + 1].field_512 = 0
                                                        lockedToken[stor201 + 1].field_768 = arg4
                                                        lockedToken[stor201 + 1].field_1024 = 0
                                                        lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                        allDepositIds.length++
                                                        stor42D7[stor202.length] = depositId + 1
                                                        depositsByWithdrawal[address(arg2)].field_0++
                                                        depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = depositId + 1
                                                        return memory
                                                          from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32
                                                    mem[(32 * _57) + ceil32(return_data.size) + 480 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'Fee transfer failed'
                                                    if (mem[ceil32(return_data.size) + 128] * sub_aa182aef) - (3 * mem[ceil32(return_data.size) + 128] / 1000 * sub_aa182aef) / 10^uint8(ext_call.return_data[0]) > msg.value:
                                                        require ext_code.size(arg1)
                                                        staticcall arg1.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        if not ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 705 len 4] = uint32(arg3)
                                                        call arg1 with:
                                                             gas gas_remaining wei
                                                            args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 677 len 4]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                revert with 0, 'SafeERC20: low-level call failed'
                                                            if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 14],
                                                                                uint32(arg3),
                                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 709 len 4]
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            depositId++
                                                            lockedToken[stor201 + 1].field_0 = arg1
                                                            lockedToken[stor201 + 1].field_256 = arg2
                                                            lockedToken[stor201 + 1].field_512 = 0
                                                            lockedToken[stor201 + 1].field_768 = arg4
                                                            lockedToken[stor201 + 1].field_1024 = 0
                                                            lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                            allDepositIds.length++
                                                            stor42D7[stor202.length] = depositId + 1
                                                            depositsByWithdrawal[address(arg2)].field_0++
                                                            depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                            return (depositId + 1)
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581] = return_data.size
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650] = 'SafeERC20: low-level call failed'
                                                            revert with memory
                                                              from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613]:
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 42
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650 len 42] = 0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565
                                                                revert with memory
                                                                  from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = this.address
                                                        require ext_code.size(arg1)
                                                        staticcall arg1.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586 len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 27
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650] = 'SafeMath: addition overflow'
                                                            revert with memory
                                                              from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                        depositId++
                                                        lockedToken[stor201 + 1].field_0 = arg1
                                                        lockedToken[stor201 + 1].field_256 = arg2
                                                        lockedToken[stor201 + 1].field_512 = 0
                                                        lockedToken[stor201 + 1].field_768 = arg4
                                                        lockedToken[stor201 + 1].field_1024 = 0
                                                        lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                        allDepositIds.length++
                                                        stor42D7[stor202.length] = depositId + 1
                                                        depositsByWithdrawal[address(arg2)].field_0++
                                                        depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = depositId + 1
                                                        return memory
                                                          from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32
                                                    if ((mem[ceil32(return_data.size) + 128] * sub_aa182aef) - (3 * mem[ceil32(return_data.size) + 128] / 1000 * sub_aa182aef) / 10^uint8(ext_call.return_data[0])) - msg.value <= 0:
                                                        require ext_code.size(arg1)
                                                        staticcall arg1.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        if not ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 705 len 4] = uint32(arg3)
                                                        call arg1 with:
                                                             gas gas_remaining wei
                                                            args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 677 len 4]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                revert with 0, 'SafeERC20: low-level call failed'
                                                            if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 14],
                                                                                uint32(arg3),
                                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 709 len 4]
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            depositId++
                                                            lockedToken[stor201 + 1].field_0 = arg1
                                                            lockedToken[stor201 + 1].field_256 = arg2
                                                            lockedToken[stor201 + 1].field_512 = 0
                                                            lockedToken[stor201 + 1].field_768 = arg4
                                                            lockedToken[stor201 + 1].field_1024 = 0
                                                            lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                            allDepositIds.length++
                                                            stor42D7[stor202.length] = depositId + 1
                                                            depositsByWithdrawal[address(arg2)].field_0++
                                                            depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                            return (depositId + 1)
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581] = return_data.size
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650] = 'SafeERC20: low-level call failed'
                                                            revert with memory
                                                              from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613]:
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 42
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650 len 42] = 0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565
                                                                revert with memory
                                                                  from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = this.address
                                                        require ext_code.size(arg1)
                                                        staticcall arg1.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586 len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 27
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650] = 'SafeMath: addition overflow'
                                                            revert with memory
                                                              from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                        depositId++
                                                        lockedToken[stor201 + 1].field_0 = arg1
                                                        lockedToken[stor201 + 1].field_256 = arg2
                                                        lockedToken[stor201 + 1].field_512 = 0
                                                        lockedToken[stor201 + 1].field_768 = arg4
                                                        lockedToken[stor201 + 1].field_1024 = 0
                                                        lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                        allDepositIds.length++
                                                        stor42D7[stor202.length] = depositId + 1
                                                        depositsByWithdrawal[address(arg2)].field_0++
                                                        depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = depositId + 1
                                                        return memory
                                                          from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32
                                                    call msg.sender with:
                                                       value ((mem[ceil32(return_data.size) + 128] * sub_aa182aef) - (3 * mem[ceil32(return_data.size) + 128] / 1000 * sub_aa182aef) / 10^uint8(ext_call.return_data[0])) - msg.value wei
                                                         gas gas_remaining wei
                                                    if not return_data.size:
                                                        require ext_code.size(arg1)
                                                        staticcall arg1.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        if not ext_code.hash(arg1):
                                                            revert with 0, 'SafeERC20: call to non-contract'
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg3) >> 32
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 705 len 4] = uint32(arg3)
                                                        call arg1 with:
                                                             gas gas_remaining wei
                                                            args Mask(224, 32, arg3) << 480, mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 677 len 4]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                revert with 0, 'SafeERC20: low-level call failed'
                                                            if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                                require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                                if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 691 len 14],
                                                                                uint32(arg3),
                                                                                mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 709 len 4]
                                                            require ext_code.size(arg1)
                                                            staticcall arg1.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            depositId++
                                                            lockedToken[stor201 + 1].field_0 = arg1
                                                            lockedToken[stor201 + 1].field_256 = arg2
                                                            lockedToken[stor201 + 1].field_512 = 0
                                                            lockedToken[stor201 + 1].field_768 = arg4
                                                            lockedToken[stor201 + 1].field_1024 = 0
                                                            lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                            allDepositIds.length++
                                                            stor42D7[stor202.length] = depositId + 1
                                                            depositsByWithdrawal[address(arg2)].field_0++
                                                            depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                            return (depositId + 1)
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 581] = return_data.size
                                                        mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650] = 'SafeERC20: low-level call failed'
                                                            revert with memory
                                                              from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 613]:
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 42
                                                                mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650 len 42] = 0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565
                                                                revert with memory
                                                                  from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = this.address
                                                        require ext_code.size(arg1)
                                                        staticcall arg1.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586 len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586] = 32
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 618] = 27
                                                            mem[(32 * _57) + (4 * ceil32(return_data.size)) + 650] = 'SafeMath: addition overflow'
                                                            revert with memory
                                                              from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                        depositId++
                                                        lockedToken[stor201 + 1].field_0 = arg1
                                                        lockedToken[stor201 + 1].field_256 = arg2
                                                        lockedToken[stor201 + 1].field_512 = 0
                                                        lockedToken[stor201 + 1].field_768 = arg4
                                                        lockedToken[stor201 + 1].field_1024 = 0
                                                        lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
                                                        allDepositIds.length++
                                                        stor42D7[stor202.length] = depositId + 1
                                                        depositsByWithdrawal[address(arg2)].field_0++
                                                        depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582] = depositId + 1
                                                        return memory
                                                          from (32 * _57) + (4 * ceil32(return_data.size)) + 582
                                                           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32
                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 449] = return_data.size
                                                    mem[(32 * _57) + ceil32(return_data.size) + ceil32(return_data.size) + 481 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 454] = this.address
                                                    require ext_code.size(arg1)
                                                    staticcall arg1.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 454 len (5 * ceil32(return_data.size)) + 32]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 550] = arg3
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(arg1):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582 len floor32((5 * ceil32(return_data.size)) + 100)] = unknown_0x23b872dd(?????), msg.sender, address(this.address), mem[(32 * _57) + (4 * ceil32(return_data.size)) + 550 len floor32((5 * ceil32(return_data.size)) + 100) - 68]
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + floor32((5 * ceil32(return_data.size)) + 100) + -((5 * ceil32(return_data.size)) + 100 % 32) + 614 len (5 * ceil32(return_data.size)) + 100 % 32] = mem[(32 * _57) + (4 * ceil32(return_data.size)) + floor32((5 * ceil32(return_data.size)) + 100) + -((5 * ceil32(return_data.size)) + 100 % 32) + 514 len (5 * ceil32(return_data.size)) + 100 % 32]
                                                call arg1.mem[(32 * _57) + (4 * ceil32(return_data.size)) + 582 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[(32 * _57) + (4 * ceil32(return_data.size)) + 586 len (5 * ceil32(return_data.size)) + 96]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32:
                                                        require mem[96 len 4], Mask(224, 32, 10^uint8(ext_call.return_data[0])) >> 32 >= 32
                                                        if not uint32(10^uint8(ext_call.return_data[0])), Mask(224, 0, stor206):
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + 692 len 22]
                                                else:
                                                    mem[(32 * _57) + (4 * ceil32(return_data.size)) + 614 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[(32 * _57) + (4 * ceil32(return_data.size)) + 614]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[(32 * _57) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 693 len 22]
        require ext_code.size(arg1)
        staticcall arg1.0x70a08231 with:
                gas gas_remaining wei
               args this.address
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if tokenBalanceBy[address(arg1)][address(arg2)] < tokenBalanceBy[address(arg1)][address(arg2)]:
            revert with 0, 'SafeMath: addition overflow'
        depositId++
        lockedToken[stor201 + 1].field_0 = arg1
        lockedToken[stor201 + 1].field_256 = arg2
        lockedToken[stor201 + 1].field_512 = 0
    lockedToken[stor201 + 1].field_768 = arg4
    lockedToken[stor201 + 1].field_1024 = 0
    lockedToken[stor201 + 1].field_1032 = Mask(248, 0, arg5)
    allDepositIds.length++
    stor42D7[stor202.length] = depositId + 1
    depositsByWithdrawal[address(arg2)].field_0++
    depositsByWithdrawal[address(arg2)][depositsByWithdrawal[address(arg2)].field_0].field_0 = depositId + 1
    return (depositId + 1)
}



}
